{
  "_filename": "util.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/luarocks/src/luarocks/util.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 3,
    "label": "calls",
    "to": 106
  }, {
    "from": 3,
    "label": "calls",
    "to": 256
  }, {
    "from": 2,
    "label": "calls",
    "to": 227
  }, {
    "from": 2,
    "label": "calls",
    "to": 227
  }, {
    "from": 2,
    "label": "calls",
    "to": 227
  }, {
    "from": 2,
    "label": "calls",
    "to": 227
  }, {
    "from": 2,
    "label": "calls",
    "to": 231
  }, {
    "from": 2,
    "label": "calls",
    "to": 220
  }, {
    "from": 5,
    "label": "calls",
    "to": 106
  }, {
    "from": 5,
    "label": "calls",
    "to": 256
  }, {
    "from": 4,
    "label": "calls",
    "to": 227
  }, {
    "from": 4,
    "label": "calls",
    "to": 227
  }, {
    "from": 4,
    "label": "calls",
    "to": 227
  }, {
    "from": 4,
    "label": "calls",
    "to": 227
  }, {
    "from": 4,
    "label": "calls",
    "to": 231
  }, {
    "from": 7,
    "label": "calls",
    "to": 175
  }, {
    "from": 6,
    "label": "calls",
    "to": 104
  }, {
    "from": 8,
    "label": "calls",
    "to": 175
  }, {
    "from": 9,
    "label": "calls",
    "to": 227
  }, {
    "from": 9,
    "label": "calls",
    "to": 227
  }, {
    "from": 9,
    "label": "calls",
    "to": 175
  }, {
    "from": 10,
    "label": "calls",
    "to": 160
  }, {
    "from": 10,
    "label": "calls",
    "to": 175
  }, {
    "from": 10,
    "label": "calls",
    "to": 175
  }, {
    "from": 11,
    "label": "calls",
    "to": 217
  }, {
    "from": 12,
    "label": "calls",
    "to": 86
  }, {
    "from": 12,
    "label": "calls",
    "to": 86
  }, {
    "from": 13,
    "label": "calls",
    "to": 106
  }, {
    "from": 12,
    "label": "calls",
    "to": 231
  }, {
    "from": 13,
    "label": "calls",
    "to": 231
  }, {
    "from": 11,
    "label": "calls",
    "to": 227
  }, {
    "from": 12,
    "label": "calls",
    "to": 227
  }, {
    "from": 12,
    "label": "calls",
    "to": 227
  }, {
    "from": 12,
    "label": "calls",
    "to": 227
  }, {
    "from": 13,
    "label": "calls",
    "to": 256
  }, {
    "from": 12,
    "label": "calls",
    "to": 92
  }, {
    "from": 12,
    "label": "calls",
    "to": 92
  }, {
    "from": 12,
    "label": "calls",
    "to": 323
  }, {
    "from": 14,
    "label": "calls",
    "to": 254
  }, {
    "from": 15,
    "label": "calls",
    "to": 227
  }, {
    "from": 16,
    "label": "calls",
    "to": 135
  }, {
    "from": 19,
    "label": "calls",
    "to": 244
  }, {
    "from": 17,
    "label": "calls",
    "to": 231
  }, {
    "from": 17,
    "label": "calls",
    "to": 231
  }, {
    "from": 18,
    "label": "calls",
    "to": 106
  }, {
    "from": 18,
    "label": "calls",
    "to": 97
  }, {
    "from": 18,
    "label": "calls",
    "to": 227
  }, {
    "from": 18,
    "label": "calls",
    "to": 227
  }, {
    "from": 18,
    "label": "calls",
    "to": 227
  }, {
    "from": 20,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 21,
    "label": "calls",
    "to": 231
  }, {
    "from": 22,
    "label": "calls",
    "to": 106
  }, {
    "from": 22,
    "label": "calls",
    "to": 238
  }, {
    "from": 22,
    "label": "calls",
    "to": 256
  }, {
    "from": 22,
    "label": "calls",
    "to": 227
  }, {
    "from": 22,
    "label": "calls",
    "to": 227
  }, {
    "from": 22,
    "label": "calls",
    "to": 227
  }, {
    "from": 22,
    "label": "calls",
    "to": 227
  }, {
    "from": 22,
    "label": "calls",
    "to": 227
  }, {
    "from": 22,
    "label": "calls",
    "to": 227
  }, {
    "from": 22,
    "label": "calls",
    "to": 227
  }, {
    "from": 22,
    "label": "calls",
    "to": 227
  }, {
    "from": 22,
    "label": "calls",
    "to": 227
  }, {
    "from": 24,
    "label": "calls",
    "to": 106
  }, {
    "from": 23,
    "label": "calls",
    "to": 238
  }, {
    "from": 23,
    "label": "calls",
    "to": 231
  }, {
    "from": 25,
    "label": "calls",
    "to": 86
  }, {
    "from": 26,
    "label": "calls",
    "to": 86
  }, {
    "from": 27,
    "label": "calls",
    "to": 86
  }, {
    "from": 28,
    "label": "calls",
    "to": 86
  }, {
    "from": 29,
    "label": "calls",
    "to": 86
  }, {
    "from": 30,
    "label": "calls",
    "to": 86
  }, {
    "from": 31,
    "label": "calls",
    "to": 144
  }, {
    "from": 31,
    "label": "calls",
    "to": 144
  }, {
    "from": 31,
    "label": "calls",
    "to": 144
  }, {
    "from": 31,
    "label": "calls",
    "to": 144
  }, {
    "from": 31,
    "label": "calls",
    "to": 144
  }, {
    "from": 33,
    "label": "calls",
    "to": 225
  }, {
    "from": 33,
    "label": "calls",
    "to": 225
  }, {
    "from": 33,
    "label": "calls",
    "to": 225
  }, {
    "from": 35,
    "label": "calls",
    "to": 231
  }, {
    "from": 34,
    "label": "calls",
    "to": 327
  }, {
    "from": 34,
    "label": "calls",
    "to": 327
  }, {
    "from": 34,
    "label": "calls",
    "to": 327
  }, {
    "from": 34,
    "label": "calls",
    "to": 327
  }, {
    "from": 34,
    "label": "calls",
    "to": 327
  }, {
    "from": 36,
    "label": "calls",
    "to": 327
  }, {
    "from": 36,
    "label": "calls",
    "to": 327
  }, {
    "from": 36,
    "label": "calls",
    "to": 327
  }, {
    "from": 36,
    "label": "calls",
    "to": 327
  }, {
    "from": 36,
    "label": "calls",
    "to": 327
  }, {
    "from": 37,
    "label": "calls",
    "to": 227
  }, {
    "from": 38,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 227
  }, {
    "from": 39,
    "label": "calls",
    "to": 106
  }, {
    "from": 39,
    "label": "calls",
    "to": 217
  }, {
    "from": 40,
    "label": "calls",
    "to": 244
  }, {
    "from": 41,
    "label": "calls",
    "to": 217
  }, {
    "from": 41,
    "label": "calls",
    "to": 217
  }, {
    "from": 41,
    "label": "calls",
    "to": 217
  }, {
    "from": 42,
    "label": "calls",
    "to": 217
  }, {
    "from": 42,
    "label": "calls",
    "to": 217
  }, {
    "from": 42,
    "label": "calls",
    "to": 220
  }, {
    "from": 43,
    "label": "calls",
    "to": 231
  }, {
    "from": 44,
    "label": "calls",
    "to": 231
  }, {
    "from": 44,
    "label": "calls",
    "to": 231
  }, {
    "from": 43,
    "label": "calls",
    "to": 86
  }, {
    "from": 43,
    "label": "calls",
    "to": 86
  }, {
    "from": 44,
    "label": "calls",
    "to": 106
  }, {
    "from": 44,
    "label": "calls",
    "to": 118
  }, {
    "from": 44,
    "label": "calls",
    "to": 118
  }, {
    "from": 43,
    "label": "calls",
    "to": 92
  }, {
    "from": 43,
    "label": "calls",
    "to": 92
  }, {
    "from": 44,
    "label": "calls",
    "to": 238
  }, {
    "from": 44,
    "label": "calls",
    "to": 256
  }, {
    "from": 43,
    "label": "calls",
    "to": 227
  }, {
    "from": 43,
    "label": "calls",
    "to": 227
  }, {
    "from": 44,
    "label": "calls",
    "to": 227
  }, {
    "from": 44,
    "label": "calls",
    "to": 227
  }, {
    "from": 44,
    "label": "calls",
    "to": 227
  }, {
    "from": 45,
    "label": "calls",
    "to": 254
  }, {
    "from": 46,
    "label": "calls",
    "to": 256
  }, {
    "from": 46,
    "label": "calls",
    "to": 106
  }, {
    "from": 46,
    "label": "calls",
    "to": 231
  }, {
    "from": 47,
    "label": "calls",
    "to": 106
  }, {
    "from": 47,
    "label": "calls",
    "to": 238
  }, {
    "from": 48,
    "label": "calls",
    "to": 256
  }, {
    "from": 48,
    "label": "calls",
    "to": 106
  }, {
    "from": 48,
    "label": "calls",
    "to": 231
  }, {
    "from": 49,
    "label": "calls",
    "to": 235
  }, {
    "from": 49,
    "label": "calls",
    "to": 227
  }, {
    "from": 49,
    "label": "calls",
    "to": 227
  }, {
    "from": 49,
    "label": "calls",
    "to": 106
  }, {
    "from": 49,
    "label": "calls",
    "to": 220
  }, {
    "from": 50,
    "label": "calls",
    "to": 231
  }, {
    "from": 50,
    "label": "calls",
    "to": 231
  }, {
    "from": 51,
    "label": "calls",
    "to": 231
  }, {
    "from": 53,
    "label": "calls",
    "to": 231
  }, {
    "from": 53,
    "label": "calls",
    "to": 227
  }, {
    "from": 52,
    "label": "calls",
    "to": 220
  }, {
    "from": 54,
    "label": "calls",
    "to": 220
  }, {
    "from": 55,
    "label": "calls",
    "to": 225
  }, {
    "from": 55,
    "label": "calls",
    "to": 225
  }, {
    "from": 55,
    "label": "calls",
    "to": 225
  }, {
    "from": 56,
    "label": "calls",
    "to": 187
  }, {
    "from": 56,
    "label": "calls",
    "to": 135
  }, {
    "from": 60,
    "label": "calls",
    "to": 106
  }, {
    "from": 57,
    "label": "calls",
    "to": 227
  }, {
    "from": 58,
    "label": "calls",
    "to": 227
  }, {
    "from": 60,
    "label": "calls",
    "to": 227
  }, {
    "from": 60,
    "label": "calls",
    "to": 256
  }, {
    "from": 58,
    "label": "calls",
    "to": 231
  }, {
    "from": 58,
    "label": "calls",
    "to": 231
  }, {
    "from": 58,
    "label": "calls",
    "to": 231
  }, {
    "from": 59,
    "label": "calls",
    "to": 231
  }, {
    "from": 61,
    "label": "calls",
    "to": 86
  }, {
    "from": 62,
    "label": "calls",
    "to": 106
  }, {
    "from": 62,
    "label": "calls",
    "to": 227
  }, {
    "from": 62,
    "label": "calls",
    "to": 256
  }, {
    "from": 63,
    "label": "calls",
    "to": 104
  }, {
    "from": 64,
    "label": "calls",
    "to": 227
  }, {
    "from": 64,
    "label": "calls",
    "to": 227
  }, {
    "from": 64,
    "label": "calls",
    "to": 227
  }, {
    "from": 64,
    "label": "calls",
    "to": 227
  }, {
    "from": 64,
    "label": "calls",
    "to": 227
  }, {
    "from": 64,
    "label": "calls",
    "to": 227
  }, {
    "from": 64,
    "label": "calls",
    "to": 106
  }, {
    "from": 64,
    "label": "calls",
    "to": 274
  }, {
    "from": 64,
    "label": "calls",
    "to": 274
  }, {
    "from": 64,
    "label": "calls",
    "to": 274
  }, {
    "from": 64,
    "label": "calls",
    "to": 274
  }, {
    "from": 64,
    "label": "calls",
    "to": 274
  }, {
    "from": 64,
    "label": "calls",
    "to": 274
  }, {
    "from": 64,
    "label": "calls",
    "to": 274
  }, {
    "from": 66,
    "label": "calls",
    "to": 217
  }, {
    "from": 65,
    "label": "calls",
    "to": 217
  }, {
    "from": 67,
    "label": "calls",
    "to": 106
  }, {
    "from": 67,
    "label": "calls",
    "to": 256
  }, {
    "from": 67,
    "label": "calls",
    "to": 227
  }, {
    "from": 67,
    "label": "calls",
    "to": 227
  }, {
    "from": 67,
    "label": "calls",
    "to": 231
  }, {
    "from": 67,
    "label": "calls",
    "to": 231
  }, {
    "from": 67,
    "label": "calls",
    "to": 217
  }, {
    "from": 67,
    "label": "calls",
    "to": 217
  }, {
    "from": 68,
    "label": "calls",
    "to": 106
  }, {
    "from": 71,
    "label": "calls",
    "to": 106
  }, {
    "from": 70,
    "label": "calls",
    "to": 187
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 70,
    "label": "calls",
    "to": 231
  }, {
    "from": 72,
    "label": "calls",
    "to": 254
  }, {
    "from": 69,
    "label": "calls",
    "to": 227
  }, {
    "from": 70,
    "label": "calls",
    "to": 227
  }, {
    "from": 70,
    "label": "calls",
    "to": 227
  }, {
    "from": 70,
    "label": "calls",
    "to": 227
  }, {
    "from": 70,
    "label": "calls",
    "to": 227
  }, {
    "from": 73,
    "label": "calls",
    "to": 175
  }, {
    "from": 74,
    "label": "calls",
    "to": 231
  }, {
    "from": 73,
    "label": "calls",
    "to": 227
  }, {
    "from": 76,
    "label": "calls",
    "to": 217
  }, {
    "from": 76,
    "label": "calls",
    "to": 217
  }, {
    "from": 77,
    "label": "calls",
    "to": 256
  }, {
    "from": 76,
    "label": "calls",
    "to": 227
  }, {
    "from": 76,
    "label": "calls",
    "to": 227
  }, {
    "from": 76,
    "label": "calls",
    "to": 227
  }, {
    "from": 76,
    "label": "calls",
    "to": 227
  }, {
    "from": 77,
    "label": "calls",
    "to": 238
  }, {
    "from": 77,
    "label": "calls",
    "to": 238
  }, {
    "from": 77,
    "label": "calls",
    "to": 238
  }, {
    "from": 75,
    "label": "calls",
    "to": 235
  }, {
    "from": 77,
    "label": "calls",
    "to": 106
  }, {
    "from": 78,
    "label": "calls",
    "to": 187
  }, {
    "from": 79,
    "label": "calls",
    "to": 258
  }, {
    "from": 81,
    "label": "calls",
    "to": 256
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 81,
    "label": "calls",
    "to": 227
  }, {
    "from": 80,
    "label": "calls",
    "to": 217
  }, {
    "from": 80,
    "label": "calls",
    "to": 217
  }, {
    "from": 81,
    "label": "calls",
    "to": 217
  }, {
    "from": 81,
    "label": "calls",
    "to": 106
  }, {
    "from": 82,
    "label": "calls",
    "to": 323
  }, {
    "from": 82,
    "label": "calls",
    "to": 323
  }, {
    "from": 82,
    "label": "calls",
    "to": 323
  }, {
    "from": 82,
    "label": "calls",
    "to": 323
  }, {
    "from": 83,
    "label": "calls",
    "to": 231
  }, {
    "from": 84,
    "label": "calls",
    "to": 92
  }, {
    "from": 84,
    "label": "calls",
    "to": 86
  }, {
    "from": 85,
    "label": "calls",
    "to": 256
  }, {
    "from": 84,
    "label": "calls",
    "to": 227
  }, {
    "from": 84,
    "label": "calls",
    "to": 227
  }, {
    "from": 84,
    "label": "calls",
    "to": 227
  }, {
    "from": 84,
    "label": "calls",
    "to": 227
  }, {
    "from": 85,
    "label": "calls",
    "to": 106
  }, {
    "from": 86,
    "label": "has",
    "to": 87
  }, {
    "from": 86,
    "label": "has",
    "to": 88
  }, {
    "from": 86,
    "label": "has",
    "to": 89
  }, {
    "from": 86,
    "label": "has",
    "to": 90
  }, {
    "from": 86,
    "label": "has",
    "to": 91
  }, {
    "from": 92,
    "label": "has",
    "to": 93
  }, {
    "from": 93,
    "label": "has",
    "to": 94
  }, {
    "from": 94,
    "label": "has",
    "to": 95
  }, {
    "from": 92,
    "label": "has",
    "to": 90
  }, {
    "from": 92,
    "label": "has",
    "to": 96
  }, {
    "from": 97,
    "label": "has",
    "to": 98
  }, {
    "from": 97,
    "label": "has",
    "to": 99
  }, {
    "from": 97,
    "label": "has",
    "to": 100
  }, {
    "from": 100,
    "label": "has",
    "to": 101
  }, {
    "from": 100,
    "label": "has",
    "to": 102
  }, {
    "from": 97,
    "label": "has",
    "to": 103
  }, {
    "from": 104,
    "label": "has",
    "to": 90
  }, {
    "from": 104,
    "label": "has",
    "to": 105
  }, {
    "from": 106,
    "label": "has",
    "to": 107
  }, {
    "from": 106,
    "label": "has",
    "to": 108
  }, {
    "from": 106,
    "label": "has",
    "to": 109
  }, {
    "from": 109,
    "label": "has",
    "to": 110
  }, {
    "from": 109,
    "label": "has",
    "to": 111
  }, {
    "from": 111,
    "label": "has",
    "to": 112
  }, {
    "from": 111,
    "label": "has",
    "to": 113
  }, {
    "from": 113,
    "label": "has",
    "to": 114
  }, {
    "from": 113,
    "label": "has",
    "to": 115
  }, {
    "from": 111,
    "label": "has",
    "to": 116
  }, {
    "from": 106,
    "label": "has",
    "to": 90
  }, {
    "from": 106,
    "label": "has",
    "to": 117
  }, {
    "from": 118,
    "label": "has",
    "to": 119
  }, {
    "from": 118,
    "label": "has",
    "to": 120
  }, {
    "from": 118,
    "label": "has",
    "to": 121
  }, {
    "from": 118,
    "label": "has",
    "to": 122
  }, {
    "from": 122,
    "label": "has",
    "to": 123
  }, {
    "from": 123,
    "label": "has",
    "to": 124
  }, {
    "from": 124,
    "label": "has",
    "to": 125
  }, {
    "from": 124,
    "label": "has",
    "to": 126
  }, {
    "from": 118,
    "label": "has",
    "to": 127
  }, {
    "from": 127,
    "label": "has",
    "to": 128
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 127,
    "label": "has",
    "to": 130
  }, {
    "from": 130,
    "label": "has",
    "to": 131
  }, {
    "from": 118,
    "label": "has",
    "to": 90
  }, {
    "from": 118,
    "label": "has",
    "to": 132
  }, {
    "from": 133,
    "label": "has",
    "to": 123
  }, {
    "from": 123,
    "label": "has",
    "to": 124
  }, {
    "from": 124,
    "label": "has",
    "to": 125
  }, {
    "from": 124,
    "label": "has",
    "to": 126
  }, {
    "from": 133,
    "label": "has",
    "to": 134
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 136,
    "label": "has",
    "to": 137
  }, {
    "from": 137,
    "label": "has",
    "to": 138
  }, {
    "from": 138,
    "label": "has",
    "to": 139
  }, {
    "from": 137,
    "label": "has",
    "to": 140
  }, {
    "from": 140,
    "label": "has",
    "to": 141
  }, {
    "from": 140,
    "label": "has",
    "to": 142
  }, {
    "from": 137,
    "label": "has",
    "to": 142
  }, {
    "from": 135,
    "label": "has",
    "to": 143
  }, {
    "from": 144,
    "label": "has",
    "to": 145
  }, {
    "from": 144,
    "label": "has",
    "to": 146
  }, {
    "from": 144,
    "label": "has",
    "to": 147
  }, {
    "from": 144,
    "label": "has",
    "to": 90
  }, {
    "from": 144,
    "label": "has",
    "to": 148
  }, {
    "from": 148,
    "label": "has",
    "to": 149
  }, {
    "from": 149,
    "label": "has",
    "to": 150
  }, {
    "from": 149,
    "label": "has",
    "to": 151
  }, {
    "from": 151,
    "label": "has",
    "to": 152
  }, {
    "from": 144,
    "label": "has",
    "to": 153
  }, {
    "from": 144,
    "label": "has",
    "to": 154
  }, {
    "from": 155,
    "label": "has",
    "to": 156
  }, {
    "from": 155,
    "label": "has",
    "to": 157
  }, {
    "from": 157,
    "label": "has",
    "to": 158
  }, {
    "from": 155,
    "label": "has",
    "to": 90
  }, {
    "from": 155,
    "label": "has",
    "to": 159
  }, {
    "from": 160,
    "label": "has",
    "to": 161
  }, {
    "from": 160,
    "label": "has",
    "to": 162
  }, {
    "from": 162,
    "label": "has",
    "to": 163
  }, {
    "from": 163,
    "label": "has",
    "to": 164
  }, {
    "from": 160,
    "label": "has",
    "to": 165
  }, {
    "from": 165,
    "label": "has",
    "to": 166
  }, {
    "from": 160,
    "label": "has",
    "to": 167
  }, {
    "from": 168,
    "label": "has",
    "to": 169
  }, {
    "from": 168,
    "label": "has",
    "to": 170
  }, {
    "from": 170,
    "label": "has",
    "to": 171
  }, {
    "from": 171,
    "label": "has",
    "to": 172
  }, {
    "from": 171,
    "label": "has",
    "to": 173
  }, {
    "from": 168,
    "label": "has",
    "to": 90
  }, {
    "from": 168,
    "label": "has",
    "to": 174
  }, {
    "from": 175,
    "label": "has",
    "to": 176
  }, {
    "from": 175,
    "label": "has",
    "to": 177
  }, {
    "from": 175,
    "label": "has",
    "to": 178
  }, {
    "from": 175,
    "label": "has",
    "to": 179
  }, {
    "from": 179,
    "label": "has",
    "to": 180
  }, {
    "from": 180,
    "label": "has",
    "to": 181
  }, {
    "from": 180,
    "label": "has",
    "to": 182
  }, {
    "from": 182,
    "label": "has",
    "to": 183
  }, {
    "from": 175,
    "label": "has",
    "to": 184
  }, {
    "from": 184,
    "label": "has",
    "to": 185
  }, {
    "from": 175,
    "label": "has",
    "to": 186
  }, {
    "from": 187,
    "label": "has",
    "to": 188
  }, {
    "from": 187,
    "label": "has",
    "to": 189
  }, {
    "from": 189,
    "label": "has",
    "to": 190
  }, {
    "from": 187,
    "label": "has",
    "to": 90
  }, {
    "from": 187,
    "label": "has",
    "to": 191
  }, {
    "from": 192,
    "label": "has",
    "to": 193
  }, {
    "from": 192,
    "label": "has",
    "to": 194
  }, {
    "from": 192,
    "label": "has",
    "to": 195
  }, {
    "from": 192,
    "label": "has",
    "to": 90
  }, {
    "from": 192,
    "label": "has",
    "to": 90
  }, {
    "from": 192,
    "label": "has",
    "to": 90
  }, {
    "from": 192,
    "label": "has",
    "to": 90
  }, {
    "from": 192,
    "label": "has",
    "to": 196
  }, {
    "from": 197,
    "label": "has",
    "to": 198
  }, {
    "from": 197,
    "label": "has",
    "to": 199
  }, {
    "from": 199,
    "label": "has",
    "to": 200
  }, {
    "from": 199,
    "label": "has",
    "to": 201
  }, {
    "from": 201,
    "label": "has",
    "to": 202
  }, {
    "from": 199,
    "label": "has",
    "to": 203
  }, {
    "from": 199,
    "label": "has",
    "to": 204
  }, {
    "from": 199,
    "label": "has",
    "to": 205
  }, {
    "from": 205,
    "label": "has",
    "to": 206
  }, {
    "from": 205,
    "label": "has",
    "to": 207
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 207,
    "label": "has",
    "to": 209
  }, {
    "from": 205,
    "label": "has",
    "to": 210
  }, {
    "from": 210,
    "label": "has",
    "to": 211
  }, {
    "from": 210,
    "label": "has",
    "to": 212
  }, {
    "from": 199,
    "label": "has",
    "to": 213
  }, {
    "from": 199,
    "label": "has",
    "to": 214
  }, {
    "from": 214,
    "label": "has",
    "to": 215
  }, {
    "from": 215,
    "label": "has",
    "to": 202
  }, {
    "from": 197,
    "label": "has",
    "to": 216
  }, {
    "from": 217,
    "label": "has",
    "to": 90
  }, {
    "from": 217,
    "label": "has",
    "to": 218
  }, {
    "from": 217,
    "label": "has",
    "to": 219
  }, {
    "from": 220,
    "label": "has",
    "to": 221
  }, {
    "from": 220,
    "label": "has",
    "to": 222
  }, {
    "from": 220,
    "label": "has",
    "to": 90
  }, {
    "from": 220,
    "label": "has",
    "to": 223
  }, {
    "from": 220,
    "label": "has",
    "to": 90
  }, {
    "from": 220,
    "label": "has",
    "to": 224
  }, {
    "from": 225,
    "label": "has",
    "to": 90
  }, {
    "from": 225,
    "label": "has",
    "to": 226
  }, {
    "from": 227,
    "label": "has",
    "to": 228
  }, {
    "from": 227,
    "label": "has",
    "to": 229
  }, {
    "from": 227,
    "label": "has",
    "to": 230
  }, {
    "from": 231,
    "label": "has",
    "to": 232
  }, {
    "from": 231,
    "label": "has",
    "to": 233
  }, {
    "from": 231,
    "label": "has",
    "to": 234
  }, {
    "from": 235,
    "label": "has",
    "to": 236
  }, {
    "from": 235,
    "label": "has",
    "to": 237
  }, {
    "from": 238,
    "label": "has",
    "to": 239
  }, {
    "from": 238,
    "label": "has",
    "to": 90
  }, {
    "from": 238,
    "label": "has",
    "to": 240
  }, {
    "from": 238,
    "label": "has",
    "to": 241
  }, {
    "from": 238,
    "label": "has",
    "to": 242
  }, {
    "from": 238,
    "label": "has",
    "to": 240
  }, {
    "from": 238,
    "label": "has",
    "to": 243
  }, {
    "from": 244,
    "label": "has",
    "to": 245
  }, {
    "from": 244,
    "label": "has",
    "to": 246
  }, {
    "from": 244,
    "label": "has",
    "to": 247
  }, {
    "from": 247,
    "label": "has",
    "to": 248
  }, {
    "from": 247,
    "label": "has",
    "to": 249
  }, {
    "from": 247,
    "label": "has",
    "to": 250
  }, {
    "from": 247,
    "label": "has",
    "to": 251
  }, {
    "from": 247,
    "label": "has",
    "to": 252
  }, {
    "from": 244,
    "label": "has",
    "to": 90
  }, {
    "from": 244,
    "label": "has",
    "to": 253
  }, {
    "from": 254,
    "label": "has",
    "to": 90
  }, {
    "from": 254,
    "label": "has",
    "to": 255
  }, {
    "from": 256,
    "label": "has",
    "to": 90
  }, {
    "from": 256,
    "label": "has",
    "to": 257
  }, {
    "from": 258,
    "label": "has",
    "to": 259
  }, {
    "from": 258,
    "label": "has",
    "to": 90
  }, {
    "from": 258,
    "label": "has",
    "to": 260
  }, {
    "from": 260,
    "label": "has",
    "to": 261
  }, {
    "from": 258,
    "label": "has",
    "to": 262
  }, {
    "from": 258,
    "label": "has",
    "to": 263
  }, {
    "from": 258,
    "label": "has",
    "to": 264
  }, {
    "from": 258,
    "label": "has",
    "to": 265
  }, {
    "from": 258,
    "label": "has",
    "to": 266
  }, {
    "from": 266,
    "label": "has",
    "to": 267
  }, {
    "from": 266,
    "label": "has",
    "to": 268
  }, {
    "from": 266,
    "label": "has",
    "to": 269
  }, {
    "from": 266,
    "label": "has",
    "to": 270
  }, {
    "from": 258,
    "label": "has",
    "to": 271
  }, {
    "from": 271,
    "label": "has",
    "to": 272
  }, {
    "from": 258,
    "label": "has",
    "to": 90
  }, {
    "from": 258,
    "label": "has",
    "to": 273
  }, {
    "from": 274,
    "label": "has",
    "to": 275
  }, {
    "from": 274,
    "label": "has",
    "to": 276
  }, {
    "from": 274,
    "label": "has",
    "to": 277
  }, {
    "from": 274,
    "label": "has",
    "to": 278
  }, {
    "from": 274,
    "label": "has",
    "to": 279
  }, {
    "from": 279,
    "label": "has",
    "to": 280
  }, {
    "from": 280,
    "label": "has",
    "to": 281
  }, {
    "from": 280,
    "label": "has",
    "to": 282
  }, {
    "from": 274,
    "label": "has",
    "to": 90
  }, {
    "from": 274,
    "label": "has",
    "to": 283
  }, {
    "from": 284,
    "label": "has",
    "to": 285
  }, {
    "from": 284,
    "label": "has",
    "to": 286
  }, {
    "from": 284,
    "label": "has",
    "to": 287
  }, {
    "from": 287,
    "label": "has",
    "to": 90
  }, {
    "from": 284,
    "label": "has",
    "to": 288
  }, {
    "from": 288,
    "label": "has",
    "to": 289
  }, {
    "from": 288,
    "label": "has",
    "to": 290
  }, {
    "from": 290,
    "label": "has",
    "to": 291
  }, {
    "from": 290,
    "label": "has",
    "to": 292
  }, {
    "from": 288,
    "label": "has",
    "to": 90
  }, {
    "from": 288,
    "label": "has",
    "to": 90
  }, {
    "from": 288,
    "label": "has",
    "to": 90
  }, {
    "from": 288,
    "label": "has",
    "to": 90
  }, {
    "from": 284,
    "label": "has",
    "to": 293
  }, {
    "from": 293,
    "label": "has",
    "to": 294
  }, {
    "from": 293,
    "label": "has",
    "to": 295
  }, {
    "from": 293,
    "label": "has",
    "to": 296
  }, {
    "from": 293,
    "label": "has",
    "to": 297
  }, {
    "from": 293,
    "label": "has",
    "to": 298
  }, {
    "from": 298,
    "label": "has",
    "to": 299
  }, {
    "from": 298,
    "label": "has",
    "to": 300
  }, {
    "from": 300,
    "label": "has",
    "to": 301
  }, {
    "from": 300,
    "label": "has",
    "to": 302
  }, {
    "from": 300,
    "label": "has",
    "to": 303
  }, {
    "from": 300,
    "label": "has",
    "to": 304
  }, {
    "from": 304,
    "label": "has",
    "to": 305
  }, {
    "from": 304,
    "label": "has",
    "to": 306
  }, {
    "from": 304,
    "label": "has",
    "to": 307
  }, {
    "from": 307,
    "label": "has",
    "to": 308
  }, {
    "from": 307,
    "label": "has",
    "to": 309
  }, {
    "from": 307,
    "label": "has",
    "to": 310
  }, {
    "from": 307,
    "label": "has",
    "to": 311
  }, {
    "from": 304,
    "label": "has",
    "to": 312
  }, {
    "from": 284,
    "label": "has",
    "to": 313
  }, {
    "from": 284,
    "label": "has",
    "to": 314
  }, {
    "from": 284,
    "label": "has",
    "to": 90
  }, {
    "from": 284,
    "label": "has",
    "to": 315
  }, {
    "from": 284,
    "label": "has",
    "to": 316
  }, {
    "from": 284,
    "label": "has",
    "to": 90
  }, {
    "from": 284,
    "label": "has",
    "to": 317
  }, {
    "from": 318,
    "label": "has",
    "to": 90
  }, {
    "from": 319,
    "label": "has",
    "to": 289
  }, {
    "from": 319,
    "label": "has",
    "to": 290
  }, {
    "from": 290,
    "label": "has",
    "to": 291
  }, {
    "from": 290,
    "label": "has",
    "to": 292
  }, {
    "from": 319,
    "label": "has",
    "to": 90
  }, {
    "from": 319,
    "label": "has",
    "to": 90
  }, {
    "from": 319,
    "label": "has",
    "to": 90
  }, {
    "from": 319,
    "label": "has",
    "to": 90
  }, {
    "from": 319,
    "label": "has",
    "to": 320
  }, {
    "from": 321,
    "label": "has",
    "to": 294
  }, {
    "from": 321,
    "label": "has",
    "to": 295
  }, {
    "from": 321,
    "label": "has",
    "to": 296
  }, {
    "from": 321,
    "label": "has",
    "to": 297
  }, {
    "from": 321,
    "label": "has",
    "to": 298
  }, {
    "from": 298,
    "label": "has",
    "to": 299
  }, {
    "from": 298,
    "label": "has",
    "to": 300
  }, {
    "from": 300,
    "label": "has",
    "to": 301
  }, {
    "from": 300,
    "label": "has",
    "to": 302
  }, {
    "from": 300,
    "label": "has",
    "to": 303
  }, {
    "from": 300,
    "label": "has",
    "to": 304
  }, {
    "from": 304,
    "label": "has",
    "to": 305
  }, {
    "from": 304,
    "label": "has",
    "to": 306
  }, {
    "from": 304,
    "label": "has",
    "to": 307
  }, {
    "from": 307,
    "label": "has",
    "to": 308
  }, {
    "from": 307,
    "label": "has",
    "to": 309
  }, {
    "from": 307,
    "label": "has",
    "to": 310
  }, {
    "from": 307,
    "label": "has",
    "to": 311
  }, {
    "from": 304,
    "label": "has",
    "to": 312
  }, {
    "from": 321,
    "label": "has",
    "to": 322
  }, {
    "from": 323,
    "label": "has",
    "to": 324
  }, {
    "from": 324,
    "label": "has",
    "to": 325
  }, {
    "from": 323,
    "label": "has",
    "to": 90
  }, {
    "from": 323,
    "label": "has",
    "to": 90
  }, {
    "from": 323,
    "label": "has",
    "to": 326
  }, {
    "from": 327,
    "label": "has",
    "to": 90
  }, {
    "from": 327,
    "label": "has",
    "to": 328
  }, {
    "from": 329,
    "label": "has",
    "to": 218
  }, {
    "from": 330,
    "label": "has",
    "to": 223
  }, {
    "from": 330,
    "label": "has",
    "to": 90
  }, {
    "from": 330,
    "label": "has",
    "to": 331
  }, {
    "from": 227,
    "label": "calls",
    "to": 351
  }, {
    "from": 231,
    "label": "calls",
    "to": 351
  }, {
    "from": 274,
    "label": "calls",
    "to": 351
  }, {
    "from": 86,
    "label": "calls",
    "to": 343
  }, {
    "from": 118,
    "label": "calls",
    "to": 343
  }, {
    "from": 144,
    "label": "calls",
    "to": 343
  }, {
    "from": 175,
    "label": "calls",
    "to": 343
  }, {
    "from": 175,
    "label": "calls",
    "to": 343
  }, {
    "from": 274,
    "label": "calls",
    "to": 343
  }, {
    "from": 274,
    "label": "calls",
    "to": 343
  }, {
    "from": 192,
    "label": "calls",
    "to": 344
  }, {
    "from": 192,
    "label": "calls",
    "to": 344
  }, {
    "from": 319,
    "label": "calls",
    "to": 344
  }, {
    "from": 258,
    "label": "calls",
    "to": 345
  }, {
    "from": 160,
    "label": "calls",
    "to": 155
  }, {
    "from": 144,
    "label": "calls",
    "to": 346
  }, {
    "from": 197,
    "label": "calls",
    "to": 346
  }, {
    "from": 197,
    "label": "calls",
    "to": 346
  }, {
    "from": 197,
    "label": "calls",
    "to": 346
  }, {
    "from": 274,
    "label": "calls",
    "to": 346
  }, {
    "from": 323,
    "label": "calls",
    "to": 346
  }, {
    "from": 97,
    "label": "calls",
    "to": 32
  }, {
    "from": 160,
    "label": "calls",
    "to": 235
  }, {
    "from": 168,
    "label": "calls",
    "to": 235
  }, {
    "from": 332,
    "label": "calls",
    "to": 347
  }, {
    "from": 258,
    "label": "calls",
    "to": 355
  }, {
    "from": 235,
    "label": "calls",
    "to": 231
  }, {
    "from": 97,
    "label": "calls",
    "to": 354
  }, {
    "from": 175,
    "label": "calls",
    "to": 168
  }, {
    "from": 92,
    "label": "calls",
    "to": 356
  }, {
    "from": 118,
    "label": "calls",
    "to": 356
  }, {
    "from": 135,
    "label": "calls",
    "to": 356
  }, {
    "from": 155,
    "label": "calls",
    "to": 356
  }, {
    "from": 160,
    "label": "calls",
    "to": 356
  }, {
    "from": 160,
    "label": "calls",
    "to": 356
  }, {
    "from": 175,
    "label": "calls",
    "to": 356
  }, {
    "from": 175,
    "label": "calls",
    "to": 356
  }, {
    "from": 187,
    "label": "calls",
    "to": 356
  }, {
    "from": 321,
    "label": "calls",
    "to": 356
  }, {
    "from": 197,
    "label": "calls",
    "to": 353
  }, {
    "from": 197,
    "label": "calls",
    "to": 353
  }, {
    "from": 197,
    "label": "calls",
    "to": 353
  }, {
    "from": 118,
    "label": "calls",
    "to": 133
  }, {
    "from": 118,
    "label": "calls",
    "to": 133
  }, {
    "from": 321,
    "label": "calls",
    "to": 318
  }, {
    "from": 197,
    "label": "calls",
    "to": 357
  }, {
    "from": 197,
    "label": "calls",
    "to": 357
  }, {
    "from": 258,
    "label": "calls",
    "to": 348
  }, {
    "from": 321,
    "label": "calls",
    "to": 319
  }, {
    "from": 321,
    "label": "calls",
    "to": 319
  }, {
    "from": 284,
    "label": "calls",
    "to": 319
  }, {
    "from": 254,
    "label": "calls",
    "to": 244
  }, {
    "from": 256,
    "label": "calls",
    "to": 244
  }, {
    "from": 217,
    "label": "calls",
    "to": 197
  }, {
    "from": 197,
    "label": "calls",
    "to": 187
  }, {
    "from": 238,
    "label": "calls",
    "to": 227
  }, {
    "from": 238,
    "label": "calls",
    "to": 227
  }, {
    "from": 238,
    "label": "calls",
    "to": 227
  }, {
    "from": 238,
    "label": "calls",
    "to": 227
  }, {
    "from": 86,
    "label": "calls",
    "to": 349
  }, {
    "from": 133,
    "label": "calls",
    "to": 349
  }, {
    "from": 133,
    "label": "calls",
    "to": 349
  }, {
    "from": 187,
    "label": "calls",
    "to": 349
  }, {
    "from": 274,
    "label": "calls",
    "to": 349
  }, {
    "from": 321,
    "label": "calls",
    "to": 321
  }, {
    "from": 284,
    "label": "calls",
    "to": 321
  }, {
    "from": 135,
    "label": "calls",
    "to": 135
  }, {
    "from": 144,
    "label": "calls",
    "to": 135
  }, {
    "from": 318,
    "label": "calls",
    "to": 360
  }, {
    "from": 274,
    "label": "calls",
    "to": 258
  }, {
    "from": 97,
    "label": "calls",
    "to": 358
  }, {
    "from": 106,
    "label": "calls",
    "to": 358
  }, {
    "from": 118,
    "label": "calls",
    "to": 358
  }, {
    "from": 118,
    "label": "calls",
    "to": 361
  }, {
    "from": 118,
    "label": "calls",
    "to": 361
  }, {
    "from": 92,
    "label": "calls",
    "to": 350
  }, {
    "from": 106,
    "label": "calls",
    "to": 350
  }, {
    "from": 86,
    "label": "calls",
    "to": 359
  }, {
    "from": 118,
    "label": "calls",
    "to": 359
  }, {
    "from": 135,
    "label": "calls",
    "to": 359
  }, {
    "from": 135,
    "label": "calls",
    "to": 359
  }, {
    "from": 144,
    "label": "calls",
    "to": 359
  }, {
    "from": 175,
    "label": "calls",
    "to": 359
  }, {
    "from": 175,
    "label": "calls",
    "to": 359
  }, {
    "from": 175,
    "label": "calls",
    "to": 359
  }, {
    "from": 192,
    "label": "calls",
    "to": 359
  }, {
    "from": 192,
    "label": "calls",
    "to": 359
  }, {
    "from": 197,
    "label": "calls",
    "to": 359
  }, {
    "from": 197,
    "label": "calls",
    "to": 359
  }, {
    "from": 274,
    "label": "calls",
    "to": 359
  }, {
    "from": 274,
    "label": "calls",
    "to": 359
  }, {
    "from": 319,
    "label": "calls",
    "to": 359
  }, {
    "from": 319,
    "label": "calls",
    "to": 359
  }, {
    "from": 321,
    "label": "calls",
    "to": 359
  }, {
    "from": 284,
    "label": "calls",
    "to": 359
  }, {
    "from": 332,
    "label": "calls",
    "to": 362
  }, {
    "from": 332,
    "label": "calls",
    "to": 362
  }, {
    "from": 97,
    "label": "calls",
    "to": 362
  }, {
    "from": 144,
    "label": "calls",
    "to": 362
  }, {
    "from": 217,
    "label": "calls",
    "to": 352
  }, {
    "from": 244,
    "label": "calls",
    "to": 342
  }, {
    "from": 319,
    "label": "calls",
    "to": 342
  }, {
    "from": 1,
    "label": "contains",
    "to": 332
  }, {
    "from": 332,
    "label": "declares",
    "to": 86
  }, {
    "from": 332,
    "label": "declares",
    "to": 92
  }, {
    "from": 332,
    "label": "declares",
    "to": 97
  }, {
    "from": 332,
    "label": "declares",
    "to": 104
  }, {
    "from": 332,
    "label": "declares",
    "to": 106
  }, {
    "from": 332,
    "label": "declares",
    "to": 118
  }, {
    "from": 332,
    "label": "declares",
    "to": 133
  }, {
    "from": 332,
    "label": "declares",
    "to": 135
  }, {
    "from": 332,
    "label": "declares",
    "to": 144
  }, {
    "from": 332,
    "label": "declares",
    "to": 155
  }, {
    "from": 332,
    "label": "declares",
    "to": 160
  }, {
    "from": 332,
    "label": "declares",
    "to": 168
  }, {
    "from": 332,
    "label": "declares",
    "to": 175
  }, {
    "from": 332,
    "label": "declares",
    "to": 187
  }, {
    "from": 332,
    "label": "declares",
    "to": 192
  }, {
    "from": 332,
    "label": "declares",
    "to": 197
  }, {
    "from": 332,
    "label": "declares",
    "to": 217
  }, {
    "from": 332,
    "label": "declares",
    "to": 220
  }, {
    "from": 332,
    "label": "declares",
    "to": 225
  }, {
    "from": 332,
    "label": "declares",
    "to": 227
  }, {
    "from": 332,
    "label": "declares",
    "to": 231
  }, {
    "from": 332,
    "label": "declares",
    "to": 235
  }, {
    "from": 332,
    "label": "declares",
    "to": 238
  }, {
    "from": 332,
    "label": "declares",
    "to": 244
  }, {
    "from": 332,
    "label": "declares",
    "to": 254
  }, {
    "from": 332,
    "label": "declares",
    "to": 256
  }, {
    "from": 332,
    "label": "declares",
    "to": 258
  }, {
    "from": 332,
    "label": "declares",
    "to": 274
  }, {
    "from": 332,
    "label": "declares",
    "to": 284
  }, {
    "from": 332,
    "label": "declares",
    "to": 318
  }, {
    "from": 332,
    "label": "declares",
    "to": 319
  }, {
    "from": 332,
    "label": "declares",
    "to": 321
  }, {
    "from": 332,
    "label": "declares",
    "to": 323
  }, {
    "from": 332,
    "label": "declares",
    "to": 327
  }, {
    "from": 332,
    "label": "declares",
    "to": 329
  }, {
    "from": 332,
    "label": "declares",
    "to": 330
  }, {
    "from": 336,
    "label": "calls",
    "to": 227
  }, {
    "from": 336,
    "label": "calls",
    "to": 227
  }, {
    "from": 336,
    "label": "calls",
    "to": 227
  }, {
    "from": 336,
    "label": "calls",
    "to": 227
  }, {
    "from": 336,
    "label": "calls",
    "to": 227
  }, {
    "from": 336,
    "label": "calls",
    "to": 227
  }, {
    "from": 336,
    "label": "calls",
    "to": 227
  }, {
    "from": 336,
    "label": "calls",
    "to": 227
  }, {
    "from": 336,
    "label": "calls",
    "to": 227
  }, {
    "from": 337,
    "label": "calls",
    "to": 227
  }, {
    "from": 337,
    "label": "calls",
    "to": 106
  }, {
    "from": 336,
    "label": "calls",
    "to": 238
  }, {
    "from": 336,
    "label": "calls",
    "to": 238
  }, {
    "from": 333,
    "label": "calls",
    "to": 231
  }, {
    "from": 334,
    "label": "calls",
    "to": 231
  }, {
    "from": 335,
    "label": "calls",
    "to": 231
  }, {
    "from": 336,
    "label": "calls",
    "to": 97
  }, {
    "from": 341,
    "label": "calls",
    "to": 106
  }, {
    "from": 340,
    "label": "calls",
    "to": 238
  }, {
    "from": 338,
    "label": "calls",
    "to": 235
  }, {
    "from": 339,
    "label": "calls",
    "to": 235
  }, {
    "from": 339,
    "label": "calls",
    "to": 256
  }, {
    "from": 341,
    "label": "calls",
    "to": 256
  }, {
    "from": 341,
    "label": "calls",
    "to": 256
  }, {
    "from": 341,
    "label": "calls",
    "to": 256
  }, {
    "from": 341,
    "label": "calls",
    "to": 256
  }, {
    "from": 338,
    "label": "calls",
    "to": 231
  }, {
    "from": 338,
    "label": "calls",
    "to": 231
  }, {
    "from": 338,
    "label": "calls",
    "to": 227
  }, {
    "from": 340,
    "label": "calls",
    "to": 227
  }, {
    "from": 340,
    "label": "calls",
    "to": 227
  }, {
    "from": 341,
    "label": "calls",
    "to": 227
  }, {
    "from": 341,
    "label": "calls",
    "to": 227
  }, {
    "from": 341,
    "label": "calls",
    "to": 227
  }, {
    "from": 1,
    "label": "contains",
    "to": 365
  }, {
    "from": 1,
    "label": "contains",
    "to": 366
  }, {
    "from": 365,
    "label": "initializes",
    "to": 367
  }, {
    "from": 367,
    "label": "assigns",
    "to": 368
  }, {
    "from": 365,
    "label": "initializes",
    "to": 369
  }, {
    "from": 369,
    "label": "assigns",
    "to": 370
  }, {
    "from": 365,
    "label": "initializes",
    "to": 371
  }, {
    "from": 371,
    "label": "assigns",
    "to": 372
  }, {
    "from": 366,
    "label": "initializes",
    "to": 373
  }, {
    "from": 373,
    "label": "requires",
    "to": 363
  }, {
    "from": 366,
    "label": "initializes",
    "to": 374
  }, {
    "from": 374,
    "label": "requires",
    "to": 375
  }, {
    "from": 366,
    "label": "initializes",
    "to": 376
  }, {
    "from": 376,
    "label": "requires",
    "to": 364
  }, {
    "from": 366,
    "label": "initializes",
    "to": 377
  }, {
    "from": 377,
    "label": "requires",
    "to": 363
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "util",
    "type": "module"
  }, {
    "id": 2,
    "text": "local function add_files_to_server(refresh, rockfiles, server, upload_server)\r\n   assert(type(refresh) == \"boolean\" or not refresh)\r\n   assert(type(rockfiles) == \"table\")\r\n   assert(type(server) == \"string\")\r\n   assert(type(upload_server) == \"table\" or not upload_server)\r\n   \r\n   local download_url, login_url = cache.get_server_urls(server, upload_server)\r\n   local at = fs.current_dir()\r\n   local refresh_fn = refresh and cache.refresh_local_cache or cache.split_server_url\r\n   \r\n   local local_cache, protocol, server_path, user, password = refresh_fn(server, download_url, cfg.upload_user, cfg.upload_password)\r\n   if not local_cache then\r\n      return nil, protocol\r\n   end\r\n   if protocol == \"file\" then\r\n      return nil, \"Server \"..server..\" is not recognized, check your configuration.\"\r\n   end\r\n   \r\n   if not login_url then\r\n      login_url = protocol..\"://\"..server_path\r\n   end\r\n   \r\n   local ok, err = fs.change_dir(at)\r\n   if not ok then return nil, err end\r\n   \r\n   local files = {}\r\n   for i, rockfile in ipairs(rockfiles) do\r\n      if fs.exists(rockfile) then\r\n         util.printout(\"Copying file \"..rockfile..\" to \"..local_cache..\"...\")\r\n         local absolute = fs.absolute_name(rockfile)\r\n         fs.copy(absolute, local_cache)\r\n         table.insert(files, dir.base_name(absolute))\r\n      else\r\n         util.printerr(\"File \"..rockfile..\" not found\")\r\n      end\r\n   end\r\n   if #files == 0 then\r\n      return nil, \"No files found\"\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_cache)\r\n   if not ok then return nil, err end\r\n\r\n   util.printout(\"Updating manifest...\")\r\n   manif.make_manifest(local_cache, \"one\", true)\r\n   \r\n   manif.zip_manifests()\r\n   \r\n   util.printout(\"Updating index.html...\")\r\n   index.make_index(local_cache)\r\n\r\n   local login_info = \"\"\r\n   if user then login_info = \" -u \"..user end\r\n   if password then login_info = login_info..\":\"..password end\r\n   if not login_url:match(\"/$\") then\r\n      login_url = login_url .. \"/\"\r\n   end\r\n\r\n   table.insert(files, \"index.html\")\r\n   table.insert(files, \"manifest\")\r\n   for ver in util.lua_versions() do\r\n      table.insert(files, \"manifest-\"..ver)\r\n      table.insert(files, \"manifest-\"..ver..\".zip\")\r\n   end\r\n\r\n   -- TODO abstract away explicit 'curl' call\r\n\r\n   local cmd\r\n   if protocol == \"rsync\" then\r\n      local srv, path = server_path:match(\"([^/]+)(/.+)\")\r\n      cmd = cfg.variables.RSYNC..\" \"..cfg.variables.RSYNCFLAGS..\" -e ssh \"..local_cache..\"/ \"..user..\"@\"..srv..\":\"..path..\"/\"\r\n   elseif upload_server and upload_server.sftp then\r\n      local part1, part2 = upload_server.sftp:match(\"^([^/]*)/(.*)$\")\r\n      cmd = cfg.variables.SCP..\" \"..table.concat(files, \" \")..\" \"..user..\"@\"..part1..\":/\"..part2\r\n   else\r\n      cmd = cfg.variables.CURL..\" \"..login_info..\" -T '{\"..table.concat(files, \",\")..\"}' \"..login_url\r\n   end\r\n\r\n   util.printout(cmd)\r\n   fs.execute(cmd)\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "function run(...)\r\n   local files = { util.parse_flags(...) }\r\n   local flags = table.remove(files, 1)\r\n   if #files < 1 then\r\n      return nil, \"Argument missing. \"..util.see_help(\"add\", \"luarocks-admin\")\r\n   end\r\n   local server, server_table = cache.get_upload_server(flags[\"server\"])\r\n   if not server then return nil, server_table end\r\n   return add_files_to_server(not flags[\"no-refresh\"], files, server, server_table)\r\nend",
    "type": "function"
  }, {
    "id": 4,
    "text": "local function remove_files_from_server(refresh, rockfiles, server, upload_server)\r\n   assert(type(refresh) == \"boolean\" or not refresh)\r\n   assert(type(rockfiles) == \"table\")\r\n   assert(type(server) == \"string\")\r\n   assert(type(upload_server) == \"table\" or not upload_server)\r\n\r\n   local download_url, login_url = cache.get_server_urls(server, upload_server)\r\n   local at = fs.current_dir()\r\n   local refresh_fn = refresh and cache.refresh_local_cache or cache.split_server_url\r\n   \r\n   local local_cache, protocol, server_path, user, password = refresh_fn(server, download_url, cfg.upload_user, cfg.upload_password)\r\n   if not local_cache then\r\n      return nil, protocol\r\n   end\r\n   if protocol ~= \"rsync\" then\r\n      return nil, \"This command requires 'rsync', check your configuration.\"\r\n   end\r\n   \r\n   local ok, err = fs.change_dir(at)\r\n   if not ok then return nil, err end\r\n   \r\n   local nr_files = 0\r\n   for i, rockfile in ipairs(rockfiles) do\r\n      local basename = dir.base_name(rockfile)\r\n      local file = dir.path(local_cache, basename)\r\n      util.printout(\"Removing file \"..file..\"...\")\r\n      fs.delete(file)\r\n      if not fs.exists(file) then\r\n         nr_files = nr_files + 1\r\n      else\r\n         util.printerr(\"Failed removing \"..file)\r\n      end\r\n   end\r\n   if nr_files == 0 then\r\n      return nil, \"No files removed.\"\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_cache)\r\n   if not ok then return nil, err end\r\n\r\n   util.printout(\"Updating manifest...\")\r\n   manif.make_manifest(local_cache, \"one\", true)\r\n   util.printout(\"Updating index.html...\")\r\n   index.make_index(local_cache)\r\n\r\n   local srv, path = server_path:match(\"([^/]+)(/.+)\")\r\n   local cmd = cfg.variables.RSYNC..\" \"..cfg.variables.RSYNCFLAGS..\" --delete -e ssh \"..local_cache..\"/ \"..user..\"@\"..srv..\":\"..path..\"/\"\r\n\r\n   util.printout(cmd)\r\n   fs.execute(cmd)\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 5,
    "text": "function run(...)\r\n   local files = { util.parse_flags(...) }\r\n   local flags = table.remove(files, 1)\r\n   if #files < 1 then\r\n      return nil, \"Argument missing. \"..util.see_help(\"remove\", \"luarocks-admin\")\r\n   end\r\n   local server, server_table = cache.get_upload_server(flags[\"server\"])\r\n   if not server then return nil, server_table end\r\n   return remove_files_from_server(not flags[\"no-refresh\"], files, server, server_table)\r\nend",
    "type": "function"
  }, {
    "id": 6,
    "text": "function run(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n   local compile_object, compile_library, compile_wrapper_binary\r\n\r\n   local build = rockspec.build\r\n   local variables = rockspec.variables\r\n\r\n   local function add_flags(extras, flag, flags)\r\n      if flags then\r\n         if type(flags) ~= \"table\" then\r\n            flags = { tostring(flags) }\r\n         end\r\n         util.variable_substitutions(flags, variables)\r\n         for _, v in ipairs(flags) do\r\n            table.insert(extras, flag:format(v))\r\n         end\r\n      end\r\n   end\r\n\r\n   -- MinGW basically behaves the same as Unix\r\n   if cfg.is_platform(\"mingw32\") then\r\n         compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR, \"-c\", source, \"-o\", object, unpack(extras))\r\n      end\r\n      compile_library = function (library, objects, libraries, libdirs)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-L%s\", libdirs)\r\n         add_flags(extras, \"-l%s\", libraries)\r\n         extras[#extras+1] = dir.path(variables.LUA_LIBDIR, variables.LUALIB)\r\n         extras[#extras+1] = \"-l\" .. (variables.MSVCRT or \"m\")\r\n         local ok = execute(variables.LD..\" \"..variables.LIBFLAG, \"-o\", library, unpack(extras))\r\n         return ok\r\n      end\r\n      compile_wrapper_binary = function(fullname, name)\r\n         local fullbasename = fullname:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local basename = name:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local rcname = basename..\".rc\"\r\n         local resname = basename..\".o\"\r\n         local wrapname = basename..\".exe\"\r\n         make_rc(fullname, fullbasename..\".rc\")\r\n         local ok = execute(variables.RC, \"-o\", resname, rcname)\r\n         if not ok then return ok end\r\n         ok = execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR,\r\n                      \"-o\", wrapname, resname, variables.WRAPPER,\r\n                      dir.path(variables.LUA_LIBDIR, variables.LUALIB),\r\n                      \"-l\" .. (variables.MSVCRT or \"m\"), \"-luser32\")\r\n         return ok, wrapname\r\n      end\r\n      compile_wrapper_binary = function(fullname, name) return true, name end\r\n\t-- MSVC specific commands\r\n\telseif cfg.is_platform(\"win32\") then\r\n      compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-c\", \"-Fo\"..object, \"-I\"..variables.LUA_INCDIR, source, unpack(extras))\r\n      end\r\n      compile_library = function(library, objects, libraries, libdirs, name)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-libpath:%s\", libdirs)\r\n         add_flags(extras, \"%s.lib\", libraries)\r\n         local basename = dir.base_name(library):gsub(\".[^.]*$\", \"\")\r\n         local deffile = basename .. \".def\"\r\n         local def = io.open(dir.path(fs.current_dir(), deffile), \"w+\")\r\n         def:write(\"EXPORTS\\n\")\r\n         def:write(\"luaopen_\"..name:gsub(\"%.\", \"_\")..\"\\n\")\r\n         def:close()\r\n         local ok = execute(variables.LD, \"-dll\", \"-def:\"..deffile, \"-out:\"..library, dir.path(variables.LUA_LIBDIR, variables.LUALIB), unpack(extras))\r\n         local basedir = \"\"\r\n         if name:find(\"%.\") ~= nil then\r\n            basedir = name:gsub(\"%.%w+$\", \"\\\\\")\r\n            basedir = basedir:gsub(\"%.\", \"\\\\\")\r\n         end\r\n         local manifestfile = basedir .. basename..\".dll.manifest\"\r\n\r\n         if ok and fs.exists(manifestfile) then\r\n            ok = execute(variables.MT, \"-manifest\", manifestfile, \"-outputresource:\"..basedir..basename..\".dll;2\")\r\n         end\r\n         return ok\r\n      end\r\n      compile_wrapper_binary = function(fullname, name)\r\n         local fullbasename = fullname:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local basename = name:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local object = basename..\".obj\"\r\n         local rcname = basename..\".rc\"\r\n         local resname = basename..\".res\"\r\n         local wrapname = basename..\".exe\"\r\n         make_rc(fullname, fullbasename..\".rc\")\r\n         local ok = execute(variables.RC, \"-r\", \"-fo\"..resname, rcname)\r\n         if not ok then return ok end\r\n         ok = execute(variables.CC..\" \"..variables.CFLAGS, \"-c\", \"-Fo\"..object,\r\n                      \"-I\"..variables.LUA_INCDIR, variables.WRAPPER)\r\n         if not ok then return ok end\r\n         ok = execute(variables.LD, \"-out:\"..wrapname, resname, object,\r\n                      dir.path(variables.LUA_LIBDIR, variables.LUALIB), \"user32.lib\")\r\n         local manifestfile = wrapname..\".manifest\"\r\n         if ok and fs.exists(manifestfile) then\r\n            ok = execute(variables.MT, \"-manifest\", manifestfile, \"-outputresource:\"..wrapname..\";1\")\r\n         end\r\n         return ok, wrapname\r\n      end\r\n   else\r\n\t-- Unix, Linux, Cygwin\r\n      compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR, \"-c\", source, \"-o\", object, unpack(extras))\r\n      end\r\n      compile_library = function (library, objects, libraries, libdirs)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-L%s\", libdirs)\r\n         if cfg.gcc_rpath then\r\n            add_flags(extras, \"-Wl,-rpath,%s:\", libdirs)\r\n         end\r\n         add_flags(extras, \"-l%s\", libraries)\r\n\t\t -- Link to Lua\r\n         add_flags(extras, \"-l%s\", variables.LUA_LIB)\r\n         return execute(variables.LD..\" \"..variables.LIBFLAG, \"-o\", library, \"-L\"..variables.LUA_LIBDIR, unpack(extras))\r\n      end\r\n      compile_wrapper_binary = function(fullname, name) return true, name end\r\n   end\r\n\r\n   local ok = true\r\n   local err = \"Build error\"\r\n   local built_modules = {}\r\n   local luadir = path.lua_dir(rockspec.name, rockspec.version)\r\n   local libdir = path.lib_dir(rockspec.name, rockspec.version)\r\n   local docdir = path.doc_dir(rockspec.name, rockspec.version)\r\n   -- On Windows, compiles an .exe for each Lua file in build.install.bin, and\r\n   -- replaces the filename with the .exe name. Strips the .lua extension if it exists,\r\n   -- otherwise just appends .exe to the name\r\n   if build.install and build.install.bin then\r\n     for i, name in ipairs(build.install.bin) do\r\n       local fullname = dir.path(fs.current_dir(), name)\r\n       local match = name:match(\"%.lua$\")\r\n       local basename = name:gsub(\"%.lua$\", \"\")\r\n       local file\r\n       if not match then\r\n          file = io.open(fullname)\r\n       end\r\n       if match or (file and file:read():match(\"#!.*lua.*\")) then\r\n          ok, name = compile_wrapper_binary(fullname, name)\r\n          if ok then\r\n             build.install.bin[i] = name\r\n          else\r\n             if file then file:close() end\r\n             return nil, \"Build error in wrapper binaries\"\r\n          end\r\n       end\r\n       if file then file:close() end\r\n     end\r\n   end\r\n   for name, info in pairs(build.modules) do\r\n      local moddir = path.module_to_path(name)\r\n      if type(info) == \"string\" then\r\n         local ext = info:match(\".([^.]+)$\")\r\n         if ext == \"lua\" then\r\n            local filename = dir.base_name(info)\r\n            if info:match(\"init%.lua$\") and not name:match(\"%.init$\") then\r\n               moddir = path.module_to_path(name..\".init\")\r\n            else\r\n               local basename = name:match(\"([^.]+)$\")\r\n               local baseinfo = filename:gsub(\"%.lua$\", \"\")\r\n               if basename ~= baseinfo then\r\n                  filename = basename..\".lua\"\r\n               end\r\n            end\r\n            local dest = dir.path(luadir, moddir, filename)\r\n            built_modules[info] = dest\r\n         else\r\n            info = {info}\r\n         end\r\n      end\r\n      if type(info) == \"table\" then\r\n         local objects = {}\r\n         local sources = info.sources\r\n         if info[1] then sources = info end\r\n         if type(sources) == \"string\" then sources = {sources} end\r\n         for _, source in ipairs(sources) do\r\n            local object = source:gsub(\".[^.]*$\", \".\"..cfg.obj_extension)\r\n            if not object then\r\n               object = source..\".\"..cfg.obj_extension\r\n            end\r\n            ok = compile_object(object, source, info.defines, info.incdirs)\r\n            if not ok then\r\n               return nil, \"Failed compiling object \"..object\r\n            end\r\n            table.insert(objects, object)\r\n         end\r\n         if not ok then break end\r\n         local module_name = name:match(\"([^.]*)$\")..\".\"..util.matchquote(cfg.lib_extension)\r\n         if moddir ~= \"\" then\r\n            module_name = dir.path(moddir, module_name)\r\n            local ok, err = fs.make_dir(moddir)\r\n            if not ok then return nil, err end\r\n         end\r\n         built_modules[module_name] = dir.path(libdir, module_name)\r\n         ok = compile_library(module_name, objects, info.libraries, info.libdirs, name)\r\n         if not ok then\r\n            return nil, \"Failed compiling module \"..module_name\r\n         end\r\n      end\r\n   end\r\n   for name, dest in pairs(built_modules) do\r\n      fs.make_dir(dir.dir_name(dest))\r\n      ok = fs.copy(name, dest)\r\n      if not ok then\r\n         return nil, \"Failed installing \"..name..\" in \"..dest\r\n      end\r\n   end\r\n   if fs.is_dir(\"lua\") then\r\n      local ok, err = fs.copy_contents(\"lua\", luadir)\r\n      if not ok then\r\n         return nil, \"Failed copying contents of 'lua' directory: \"..err\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 7,
    "text": "local function add_flags(extras, flag, flags)\r\n      if flags then\r\n         if type(flags) ~= \"table\" then\r\n            flags = { tostring(flags) }\r\n         end\r\n         util.variable_substitutions(flags, variables)\r\n         for _, v in ipairs(flags) do\r\n            table.insert(extras, flag:format(v))\r\n         end\r\n      end\r\n   end",
    "type": "function"
  }, {
    "id": 8,
    "text": "function run(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n   local build = rockspec.build\r\n   local variables = build.variables or {}\r\n   \r\n   -- Pass Env variables\r\n   variables.CMAKE_MODULE_PATH=os.getenv(\"CMAKE_MODULE_PATH\")\r\n   variables.CMAKE_LIBRARY_PATH=os.getenv(\"CMAKE_LIBRARY_PATH\")\r\n   variables.CMAKE_INCLUDE_PATH=os.getenv(\"CMAKE_INCLUDE_PATH\")\r\n\r\n   util.variable_substitutions(variables, rockspec.variables)\r\n\r\n   if not fs.execute_quiet(rockspec.variables.CMAKE, \"--help\") then\r\n      return nil, \"'\"..rockspec.variables.CMAKE..\"' program not found. Is cmake installed? You may want to edit variables.CMAKE\"\r\n   end\r\n   \r\n   -- If inline cmake is present create CMakeLists.txt from it.\r\n   if type(build.cmake) == \"string\" then\r\n      local cmake = assert(io.open(fs.current_dir()..\"/CMakeLists.txt\", \"w\"))\r\n      cmake:write(build.cmake)\r\n      cmake:close()\r\n   end\r\n\r\n\r\n   -- Execute cmake with variables.\r\n   local args = \"\"\r\n   if cfg.cmake_generator then\r\n      args = args .. ' -G\"'..cfg.cmake_generator.. '\"'\r\n   end\r\n   for k,v in pairs(variables) do\r\n      args = args .. ' -D' ..k.. '=\"' ..v.. '\"'\r\n   end\r\n\r\n   if not fs.execute_string(rockspec.variables.CMAKE..\" . \" ..args) then\r\n      return nil, \"Failed cmake.\"\r\n   end\r\n   \r\n   if not fs.execute_string(rockspec.variables.MAKE..\" -fMakefile\") then\r\n      return nil, \"Failed building.\"\r\n   end\r\n\r\n   if not fs.execute_string(rockspec.variables.MAKE..\" -fMakefile install\") then\r\n      return nil, \"Failed installing.\"\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 9,
    "text": "function run(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   local build = rockspec.build\r\n   \r\n   util.variable_substitutions(build, rockspec.variables)\r\n   \r\n   if build.build_command then\r\n      util.printout(build.build_command)\r\n      if not fs.execute(build.build_command) then\r\n         return nil, \"Failed building.\"\r\n      end\r\n   end\r\n   if build.install_command then\r\n      util.printout(build.install_command)\r\n      if not fs.execute(build.install_command) then\r\n         return nil, \"Failed installing.\"\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 10,
    "text": "function run(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   local build = rockspec.build\r\n   \r\n   if build.build_pass == nil then build.build_pass = true end\r\n   if build.install_pass == nil then build.install_pass = true end\r\n   build.build_variables = build.build_variables or {}\r\n   build.install_variables = build.install_variables or {}\r\n   build.build_target = build.build_target or \"\"\r\n   build.install_target = build.install_target or \"install\"\r\n   local makefile = build.makefile or cfg.makefile\r\n   if makefile then\r\n      -- Assumes all make's accept -f. True for POSIX make, GNU make and Microsoft nmake.\r\n      build.build_target = \"-f \"..makefile..\" \"..build.build_target\r\n      build.install_target = \"-f \"..makefile..\" \"..build.install_target\r\n   end\r\n\r\n   if build.variables then   \r\n      for var, val in pairs(build.variables) do\r\n         build.build_variables[var] = val \r\n         build.install_variables[var] = val\r\n      end\r\n   end\r\n\r\n   util.warn_if_not_used(build.build_variables, { CFLAGS=true }, \"variable %s was not passed in build_variables\")\r\n\r\n   util.variable_substitutions(build.build_variables, rockspec.variables)\r\n   util.variable_substitutions(build.install_variables, rockspec.variables)\r\n   \r\n   local auto_variables = { \"CC\" }\r\n   \r\n   for _, variable in pairs(auto_variables) do\r\n      if not build.build_variables[variable] then\r\n         build.build_variables[variable] = rockspec.variables[variable]\r\n      end\r\n      if not build.install_variables[variable] then\r\n         build.install_variables[variable] = rockspec.variables[variable]\r\n      end\r\n   end\r\n\r\n   -- backwards compatibility \r\n   local make_cmd = cfg.make or rockspec.variables.MAKE\r\n\r\n   local ok = make_pass(make_cmd, build.build_pass, build.build_target, build.build_variables)\r\n   if not ok then\r\n      return nil, \"Failed building.\"\r\n   end\r\n   ok = make_pass(make_cmd, build.install_pass, build.install_target, build.install_variables)\r\n   if not ok then\r\n      return nil, \"Failed installing.\"\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 11,
    "text": "function apply_patches(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   local build = rockspec.build\r\n   if build.extra_files then\r\n      extract_from_rockspec(build.extra_files)\r\n   end\r\n   if build.patches then\r\n      extract_from_rockspec(build.patches)\r\n      for patch, patchdata in util.sortedpairs(build.patches) do\r\n         util.printout(\"Applying patch \"..patch..\"...\")\r\n         local ok, err = fs.apply_patch(tostring(patch), patchdata)\r\n         if not ok then\r\n            return nil, \"Failed applying patch \"..patch\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 12,
    "text": "function build_rockspec(rockspec_file, need_to_fetch, minimal_mode, deps_mode)\r\n   assert(type(rockspec_file) == \"string\")\r\n   assert(type(need_to_fetch) == \"boolean\")\r\n\r\n   local rockspec, err, errcode = fetch.load_rockspec(rockspec_file)\r\n   if err then\r\n      return nil, err, errcode\r\n   elseif not rockspec.build then\r\n      return nil, \"Rockspec error: build table not specified\"\r\n   elseif not rockspec.build.type then\r\n      return nil, \"Rockspec error: build type not specified\"\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      local ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then\r\n         return nil, err, errcode\r\n      end\r\n   end\r\n\r\n   local ok, err, errcode = deps.check_external_deps(rockspec, \"build\")\r\n   if err then\r\n      return nil, err, errcode\r\n   end\r\n\r\n   local name, version = rockspec.name, rockspec.version\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n\r\n   if not minimal_mode then\r\n      local _, source_dir\r\n      if need_to_fetch then\r\n         ok, source_dir, errcode = fetch.fetch_sources(rockspec, true)\r\n         if not ok then\r\n            return nil, source_dir, errcode\r\n         end\r\n         local ok, err = fs.change_dir(source_dir)\r\n         if not ok then return nil, err end\r\n      elseif rockspec.source.file then\r\n         local ok, err = fs.unpack_archive(rockspec.source.file)\r\n         if not ok then\r\n            return nil, err\r\n         end\r\n      end\r\n      fs.change_dir(rockspec.source.dir)\r\n   end\r\n   \r\n   local dirs = {\r\n      lua = { name = path.lua_dir(name, version), is_module_path = true },\r\n      lib = { name = path.lib_dir(name, version), is_module_path = true },\r\n      conf = { name = path.conf_dir(name, version), is_module_path = false },\r\n      bin = { name = path.bin_dir(name, version), is_module_path = false },\r\n   }\r\n   \r\n   for _, d in pairs(dirs) do\r\n      local ok, err = fs.make_dir(d.name)\r\n      if not ok then return nil, err end\r\n   end\r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n\r\n   local build = rockspec.build\r\n   \r\n   if not minimal_mode then\r\n      ok, err = apply_patches(rockspec)\r\n      if err then\r\n         return nil, err\r\n      end\r\n   end\r\n   \r\n   if build.type ~= \"none\" then\r\n\r\n      -- Temporary compatibility\r\n      if build.type == \"module\" then\r\n         util.printout(\"Do not use 'module' as a build type. Use 'builtin' instead.\")\r\n         build.type = \"builtin\"\r\n      end\r\n\r\n      if cfg.accepted_build_types and util.array_contains(cfg.accepted_build_types, build.type) then\r\n         return nil, \"This rockspec uses the '\"..build.type..\"' build type, which is blocked by the 'accepted_build_types' setting in your LuaRocks configuration.\"\r\n      end\r\n\r\n      local build_type\r\n      ok, build_type = pcall(require, \"luarocks.build.\" .. build.type)\r\n      if not ok or not type(build_type) == \"table\" then\r\n         return nil, \"Failed initializing build back-end for build type '\"..build.type..\"': \"..build_type\r\n      end\r\n  \r\n      ok, err = build_type.run(rockspec)\r\n      if not ok then\r\n         return nil, \"Build error: \" .. err\r\n      end\r\n   end\r\n\r\n   if build.install then\r\n      for id, install_dir in pairs(dirs) do\r\n         ok, err = install_files(build.install[id], install_dir.name, install_dir.is_module_path)\r\n         if not ok then \r\n            return nil, err\r\n         end\r\n      end\r\n   end\r\n   \r\n   local copy_directories = build.copy_directories\r\n   local copying_default = false\r\n   if not copy_directories then\r\n      copy_directories = {\"doc\"}\r\n      copying_default = true\r\n   end\r\n\r\n   for _, copy_dir in pairs(copy_directories) do\r\n      if fs.is_dir(copy_dir) then\r\n         local dest = dir.path(path.install_dir(name, version), copy_dir)\r\n         fs.make_dir(dest)\r\n         fs.copy_contents(copy_dir, dest)\r\n      else\r\n         if not copying_default then\r\n            return nil, \"Directory '\"..copy_dir..\"' not found\"\r\n         end\r\n      end\r\n   end\r\n\r\n   for _, d in pairs(dirs) do\r\n      fs.remove_dir_if_empty(d.name)\r\n   end\r\n\r\n   fs.pop_dir()\r\n   \r\n   fs.copy(rockspec.local_filename, path.rockspec_file(name, version))\r\n   if need_to_fetch then\r\n      fs.pop_dir()\r\n   end\r\n\r\n   ok, err = manif.make_rock_manifest(name, version)\r\n   if err then return nil, err end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n\r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n\r\n   local license = \"\"\r\n   if rockspec.description and rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now built and installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 13,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"build\")\r\n   end\r\n   assert(type(version) == \"string\" or not version)\r\n\r\n   if flags[\"pack-binary-rock\"] then\r\n      return pack.pack_binary_rock(name, version, do_build, name, version, deps.get_deps_mode(flags))\r\n   else\r\n      local ok, err = fs.check_command_permissions(flags)\r\n      if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n      ok, err = do_build(name, version, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 14,
    "text": "",
    "type": "function container"
  }, {
    "id": 15,
    "text": "function refresh_local_cache(server, url, user, password)\r\n   local local_cache, protocol, server_path, user, password = split_server_url(server, url, user, password)\r\n\r\n   local ok, err = fs.make_dir(cfg.local_cache)\r\n   if not ok then return nil, err end\r\n\r\n   local tmp_cache = false\r\n   if not local_cache then\r\n      local err\r\n      local_cache, err = fs.make_temp_dir(\"local_cache\")\r\n      tmp_cache = true\r\n   end\r\n   local ok, err = fs.make_dir(local_cache)\r\n   if not ok then\r\n      return nil, \"Failed creating local cache dir: \"..err\r\n   end\r\n   fs.change_dir(local_cache)\r\n   if not ok then return nil, err end\r\n   util.printout(\"Refreshing cache \"..local_cache..\"...\")\r\n\r\n   -- TODO abstract away explicit 'wget' call\r\n   local ok = false\r\n   if protocol == \"rsync\" then\r\n      local srv, path = server_path:match(\"([^/]+)(/.+)\")\r\n      ok = fs.execute(cfg.variables.RSYNC..\" \"..cfg.variables.RSYNCFLAGS..\" -e ssh \"..user..\"@\"..srv..\":\"..path..\"/ \"..local_cache..\"/\")\r\n   else \r\n      local login_info = \"\"\r\n      if user then login_info = \" --user=\"..user end\r\n      if password then login_info = login_info .. \" --password=\"..password end\r\n      ok = fs.execute(cfg.variables.WGET..\" --no-cache -q -m -np -nd \"..protocol..\"://\"..server_path..login_info)\r\n   end\r\n   if not ok then\r\n      return nil, \"Failed downloading cache.\"\r\n   end\r\n   return local_cache, protocol, server_path, user, password\r\nend",
    "type": "function"
  }, {
    "id": 16,
    "text": "",
    "type": "function container"
  }, {
    "id": 17,
    "text": "local function die(message, exitcode)\r\n   assert(type(message) == \"string\")\r\n\r\n   local ok, err = pcall(util.run_scheduled_functions)\r\n   if not ok then\r\n      util.printerr(\"\\nLuaRocks \"..cfg.program_version..\" internal bug (please report at luarocks-developers@lists.sourceforge.net):\\n\"..err)\r\n   end\r\n   util.printerr(\"\\nError: \"..message)\r\n   os.exit(exitcode or cfg.errorcodes.UNSPECIFIED)\r\nend",
    "type": "function"
  }, {
    "id": 18,
    "text": "function run_command(...)\r\n   local args = {...}\r\n   local cmdline_vars = {}\r\n   for i = #args, 1, -1 do\r\n      local arg = args[i]\r\n      if arg:match(\"^[^-][^=]*=\") then\r\n         local var, val = arg:match(\"^([A-Z_][A-Z0-9_]*)=(.*)\")\r\n         if val then\r\n            cmdline_vars[var] = val\r\n            table.remove(args, i)\r\n         else\r\n            die(\"Invalid assignment: \"..arg)\r\n         end\r\n      end\r\n   end\r\n   local nonflags = { util.parse_flags(unpack(args)) }\r\n   local flags = table.remove(nonflags, 1)\r\n   \r\n   if flags[\"from\"] then flags[\"server\"] = flags[\"from\"] end\r\n   if flags[\"only-from\"] then flags[\"only-server\"] = flags[\"only-from\"] end\r\n   if flags[\"only-sources-from\"] then flags[\"only-sources\"] = flags[\"only-sources-from\"] end\r\n   if flags[\"to\"] then flags[\"tree\"] = flags[\"to\"] end\r\n   if flags[\"nodeps\"] then\r\n      flags[\"deps-mode\"] = \"none\"\r\n      table.insert(args, \"--deps-mode=none\")\r\n   end\r\n   \r\n   cfg.flags = flags\r\n\r\n   local command\r\n   \r\n   if flags[\"verbose\"] then   -- setting it in the config file will kick-in earlier in the process\r\n      cfg.verbose = true\r\n      local fs = require(\"luarocks.fs\")\r\n      fs.verbose()\r\n   end\r\n\r\n   if flags[\"version\"] then\r\n      util.printout(program..\" \"..cfg.program_version)\r\n      util.printout(program_description)\r\n      util.printout()\r\n      os.exit(cfg.errorcodes.OK)\r\n   elseif flags[\"help\"] or #nonflags == 0 then\r\n      command = \"help\"\r\n      args = nonflags\r\n   else\r\n      command = nonflags[1]\r\n      for i, arg in ipairs(args) do\r\n         if arg == command then\r\n            table.remove(args, i)\r\n            break\r\n         end\r\n      end\r\n   end\r\n   command = command:gsub(\"-\", \"_\")\r\n\r\n   if flags[\"extensions\"] then\r\n      cfg.use_extensions = true\r\n      local type_check = require(\"luarocks.type_check\")\r\n      type_check.load_extensions()\r\n   end\r\n   \r\n   if cfg.local_by_default then\r\n      flags[\"local\"] = true\r\n   end\r\n\r\n   if flags[\"deps-mode\"] and not deps.check_deps_mode_flag(flags[\"deps-mode\"]) then\r\n      die(\"Invalid entry for --deps-mode.\")\r\n   end\r\n   \r\n   if flags[\"tree\"] then\r\n      if flags[\"tree\"] == true or flags[\"tree\"] == \"\" then\r\n         die(\"Argument error: use --tree=<path>\")\r\n      end\r\n      local named = false\r\n      for _, tree in ipairs(cfg.rocks_trees) do\r\n         if type(tree) == \"table\" and flags[\"tree\"] == tree.name then\r\n            if not tree.root then\r\n               die(\"Configuration error: tree '\"..tree.name..\"' has no 'root' field.\")\r\n            end\r\n            replace_tree(flags, args, tree.root)\r\n            named = true\r\n            break\r\n         end\r\n      end\r\n      if not named then\r\n         local fs = require(\"luarocks.fs\")\r\n         local root_dir = fs.absolute_name(flags[\"tree\"])\r\n         replace_tree(flags, args, root_dir)\r\n      end\r\n   elseif flags[\"local\"] then\r\n      replace_tree(flags, args, cfg.home_tree)\r\n   else\r\n      local trees = cfg.rocks_trees\r\n      path.use_tree(trees[#trees])\r\n   end\r\n\r\n   if type(cfg.root_dir) == \"string\" then\r\n     cfg.root_dir = cfg.root_dir:gsub(\"/+$\", \"\")\r\n   else\r\n     cfg.root_dir.root = cfg.root_dir.root:gsub(\"/+$\", \"\")\r\n   end\r\n   cfg.rocks_dir = cfg.rocks_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_bin_dir = cfg.deploy_bin_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_lua_dir = cfg.deploy_lua_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_lib_dir = cfg.deploy_lib_dir:gsub(\"/+$\", \"\")\r\n   \r\n   cfg.variables.ROCKS_TREE = cfg.rocks_dir\r\n   cfg.variables.SCRIPTS_DIR = cfg.deploy_bin_dir\r\n\r\n   if flags[\"server\"] then\r\n      if flags[\"server\"] == true then\r\n         die(\"Argument error: use --server=<url>\")\r\n      end\r\n      local protocol, path = dir.split_url(flags[\"server\"])\r\n      table.insert(cfg.rocks_servers, 1, protocol..\"://\"..path)\r\n   end\r\n   \r\n   if flags[\"only-server\"] then\r\n      if flags[\"only-server\"] == true then\r\n         die(\"Argument error: use --only-server=<url>\")\r\n      end\r\n      cfg.rocks_servers = { flags[\"only-server\"] }\r\n   end\r\n\r\n   if flags[\"only-sources\"] then\r\n      cfg.only_sources_from = flags[\"only-sources\"]\r\n   end\r\n  \r\n   if command ~= \"help\" then\r\n      for k, v in pairs(cmdline_vars) do\r\n         cfg.variables[k] = v\r\n      end\r\n   end\r\n   \r\n   if commands[command] then\r\n      -- TODO the interface of run should be modified, to receive the\r\n      -- flags table and the (possibly unpacked) nonflags arguments.\r\n      -- This would remove redundant parsing of arguments.\r\n      -- I'm not changing this now to avoid messing with the run()\r\n      -- interface, which I know some people use (even though\r\n      -- I never published it as a public API...)\r\n      local cmd = require(commands[command])\r\n      local xp, ok, err, exitcode = xpcall(function() return cmd.run(unpack(args)) end, function(err)\r\n         die(debug.traceback(\"LuaRocks \"..cfg.program_version\r\n            ..\" bug (please report at luarocks-developers@lists.sourceforge.net).\\n\"\r\n            ..err, 2))\r\n      end)\r\n      if xp and (not ok) then\r\n         die(err, exitcode)\r\n      end\r\n   else\r\n      die(\"Unknown command: \"..command)\r\n   end\r\n   util.run_scheduled_functions()\r\nend",
    "type": "function"
  }, {
    "id": 19,
    "text": "",
    "type": "function container"
  }, {
    "id": 20,
    "text": "function parse_version(vstring)\r\n   if not vstring then return nil end\r\n   assert(type(vstring) == \"string\")\r\n\r\n   local cached = version_cache[vstring]\r\n   if cached then\r\n      return cached\r\n   end\r\n\r\n   local version = {}\r\n   local i = 1\r\n\r\n   local function add_token(number)\r\n      version[i] = version[i] and version[i] + number/100000 or number\r\n      i = i + 1\r\n   end\r\n   \r\n   -- trim leading and trailing spaces\r\n   vstring = vstring:match(\"^%s*(.*)%s*$\")\r\n   version.string = vstring\r\n   -- store revision separately if any\r\n   local main, revision = vstring:match(\"(.*)%-(%d+)$\")\r\n   if revision then\r\n      vstring = main\r\n      version.revision = tonumber(revision)\r\n   end\r\n   while #vstring > 0 do\r\n      -- extract a number\r\n      local token, rest = vstring:match(\"^(%d+)[%.%-%_]*(.*)\")\r\n      if token then\r\n         add_token(tonumber(token))\r\n      else\r\n         -- extract a word\r\n         token, rest = vstring:match(\"^(%a+)[%.%-%_]*(.*)\")\r\n         if not token then\r\n            util.printerr(\"Warning: version number '\"..vstring..\"' could not be parsed.\")\r\n            version[i] = 0\r\n            break\r\n         end\r\n         local last = #version\r\n         version[i] = deltas[token] or (token:byte() / 1000)\r\n      end\r\n      vstring = rest\r\n   end\r\n   setmetatable(version, version_mt)\r\n   version_cache[vstring] = version\r\n   return version\r\nend",
    "type": "function"
  }, {
    "id": 21,
    "text": "function fulfill_dependencies(rockspec, deps_mode)\r\n\r\n   local search = require(\"luarocks.search\")\r\n   local install = require(\"luarocks.install\")\r\n\r\n   if rockspec.supported_platforms then\r\n      if not platforms_set then\r\n         platforms_set = values_set(cfg.platforms)\r\n      end\r\n      local supported = nil\r\n      for _, plat in pairs(rockspec.supported_platforms) do\r\n         local neg, plat = plat:match(\"^(!?)(.*)\")\r\n         if neg == \"!\" then\r\n            if platforms_set[plat] then\r\n               return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plat..\" platforms.\"\r\n            end\r\n         else\r\n            if platforms_set[plat] then\r\n               supported = true\r\n            else\r\n               if supported == nil then\r\n                  supported = false\r\n               end\r\n            end\r\n         end\r\n      end\r\n      if supported == false then\r\n         local plats = table.concat(cfg.platforms, \", \")\r\n         return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plats..\" platforms.\"\r\n      end\r\n   end\r\n\r\n   local _, missing, no_upgrade = match_deps(rockspec, nil, deps_mode)\r\n\r\n   if next(no_upgrade) then\r\n      util.printerr(\"Missing dependencies for \"..rockspec.name..\" \"..rockspec.version..\":\")\r\n      for _, dep in pairs(no_upgrade) do\r\n         util.printerr(show_dep(dep))\r\n      end\r\n      if next(missing) then\r\n         for _, dep in pairs(missing) do\r\n            util.printerr(show_dep(dep))\r\n         end\r\n      end\r\n      util.printerr()\r\n      for _, dep in pairs(no_upgrade) do\r\n         util.printerr(\"This version of \"..rockspec.name..\" is designed for use with\")\r\n         util.printerr(show_dep(dep)..\", but is configured to avoid upgrading it\")\r\n         util.printerr(\"automatically. Please upgrade \"..dep.name..\" with\")\r\n         util.printerr(\"   luarocks install \"..dep.name)\r\n         util.printerr(\"or choose an older version of \"..rockspec.name..\" with\")\r\n         util.printerr(\"   luarocks search \"..rockspec.name)\r\n      end\r\n      return nil, \"Failed matching dependencies.\"\r\n   end\r\n\r\n   if next(missing) then\r\n      util.printerr()\r\n      util.printerr(\"Missing dependencies for \"..rockspec.name..\":\")\r\n      for _, dep in pairs(missing) do\r\n         util.printerr(show_dep(dep))\r\n      end\r\n      util.printerr()\r\n\r\n      for _, dep in pairs(missing) do\r\n         -- Double-check in case dependency was filled during recursion.\r\n         if not match_dep(dep, nil, deps_mode) then\r\n            local rock = search.find_suitable_rock(dep)\r\n            if not rock then\r\n               return nil, \"Could not satisfy dependency: \"..show_dep(dep)\r\n            end\r\n            local ok, err, errcode = install.run(rock)\r\n            if not ok then\r\n               return nil, \"Failed installing dependency: \"..rock..\" - \"..err, errcode\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 22,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if not name then\r\n      return nil, \"Argument missing. \"..util.see_help(\"doc\")\r\n   end\r\n\r\n   local repo\r\n   name, version, repo = show.pick_installed_rock(name, version, flags[\"tree\"])\r\n   if not name then\r\n      return nil, version\r\n   end\r\n   \r\n   local rockspec, err = fetch.load_local_rockspec(path.rockspec_file(name, version, repo))\r\n   if not rockspec then return nil,err end\r\n   local descript = rockspec.description or {}\r\n\r\n   if flags[\"homepage\"] then\r\n      if not descript.homepage then\r\n         return nil, \"No 'homepage' field in rockspec for \"..name..\" \"..version\r\n      end\r\n      util.printout(\"Opening \"..descript.homepage..\" ...\")\r\n      fs.browser(descript.homepage)\r\n      return true\r\n   end\r\n\r\n   local directory = path.install_dir(name,version,repo)\r\n   \r\n   local docdir\r\n   local directories = { \"doc\", \"docs\" }\r\n   for _, d in ipairs(directories) do\r\n      local dirname = dir.path(directory, d)\r\n      if fs.is_dir(dirname) then\r\n         docdir = dirname\r\n         break\r\n      end\r\n   end\r\n   if not docdir then\r\n      if descript.homepage and not flags[\"list\"] then\r\n         util.printout(\"Local documentation directory not found -- opening \"..descript.homepage..\" ...\")\r\n         fs.browser(descript.homepage)\r\n         return true\r\n      end\r\n      return nil, \"Documentation directory not found for \"..name..\" \"..version\r\n   end\r\n\r\n   docdir = dir.normalize(docdir):gsub(\"/+\", \"/\")\r\n   local files = fs.find(docdir)\r\n   local htmlpatt = \"%.html?$\"\r\n   local extensions = { htmlpatt, \"%.md$\", \"%.txt$\",  \"%.textile$\", \"\" }\r\n   local basenames = { \"index\", \"readme\", \"manual\" }\r\n   \r\n   local porcelain = flags[\"porcelain\"]\r\n   if #files > 0 then\r\n      util.title(\"Documentation files for \"..name..\" \"..version, porcelain)\r\n      if porcelain then\r\n         for _, file in ipairs(files) do\r\n            util.printout(docdir..\"/\"..file)\r\n         end\r\n      else\r\n         util.printout(docdir..\"/\")\r\n         for _, file in ipairs(files) do\r\n            util.printout(\"\\t\"..file)\r\n         end\r\n      end\r\n   end\r\n   \r\n   if flags[\"list\"] then\r\n      return true\r\n   end\r\n   \r\n   for _, extension in ipairs(extensions) do\r\n      for _, basename in ipairs(basenames) do\r\n         local filename = basename..extension\r\n         local found\r\n         for _, file in ipairs(files) do\r\n            if file:lower():match(filename) and ((not found) or #file < #found) then\r\n               found = file\r\n            end\r\n         end\r\n         if found then\r\n            local pathname = dir.path(docdir, found)\r\n            util.printout()\r\n            util.printout(\"Opening \"..pathname..\" ...\")\r\n            util.printout()\r\n            local ok = fs.browser(pathname)\r\n            if not ok and not pathname:match(htmlpatt) then\r\n               local fd = io.open(pathname, \"r\")\r\n               util.printout(fd:read(\"*a\"))\r\n               fd:close()\r\n            end\r\n            return true\r\n         end\r\n      end\r\n   end\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 23,
    "text": "function download(arch, name, version, all)\r\n   local results, err\r\n   local query = search.make_query(name, version)\r\n   if arch then query.arch = arch end\r\n   if all then\r\n      if name == \"\" then query.exact_name = false end\r\n      results = search.search_repos(query)\r\n   else\r\n      results, err = search.find_suitable_rock(query)\r\n   end\r\n   if type(results) == \"string\" then\r\n      return get_file(results)\r\n   elseif type(results) == \"table\" and next(results) then\r\n      if all then\r\n         local all_ok = true\r\n         local any_err = \"\"\r\n         for name, result in pairs(results) do\r\n            for version, versions in pairs(result) do\r\n               for _,items in pairs(versions) do\r\n                  local filename = path.make_url(items.repo, name, version, items.arch)\r\n                  local ok, err = get_file(filename)\r\n                  if not ok then\r\n                     all_ok = false\r\n                     any_err = any_err .. \"\\n\" .. err\r\n                  end\r\n               end\r\n            end\r\n         end\r\n         return all_ok, any_err\r\n      else\r\n         util.printerr(\"Multiple search results were returned.\")\r\n         util.title(\"Search results:\")\r\n         search.print_results(results)\r\n         return nil, \"Please narrow your query or use --all.\"\r\n      end\r\n   end\r\n   return nil, \"Could not find a result named \"..name..(version and \" \"..version or \"\")..\".\"\r\nend",
    "type": "function"
  }, {
    "id": 24,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   \r\n   assert(type(version) == \"string\" or not version)\r\n   if type(name) ~= \"string\" and not flags[\"all\"] then\r\n      return nil, \"Argument missing, see help.\"\r\n   end\r\n   if not name then name, version = \"\", \"\" end\r\n\r\n   local arch\r\n\r\n   if flags[\"source\"] then\r\n      arch = \"src\"\r\n   elseif flags[\"rockspec\"] then\r\n      arch = \"rockspec\"\r\n   elseif flags[\"arch\"] then\r\n      arch = flags[\"arch\"]\r\n   end\r\n   \r\n   local dl, err = download(arch, name, version, flags[\"all\"])\r\n   return dl and true, err\r\nend",
    "type": "function"
  }, {
    "id": 25,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local module = rockspec.source.module or dir.base_name(rockspec.source.url)\r\n   local command = {rockspec.variables.CVS, \"-d\"..rockspec.source.pathname, \"export\", module}\r\n   if rockspec.source.tag then\r\n      table.insert(command, 4, \"-r\")\r\n      table.insert(command, 5, rockspec.source.tag)\r\n   end\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed fetching files from CVS.\"\r\n   end\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 26,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local git_cmd = rockspec.variables.GIT\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local module = dir.base_name(rockspec.source.url)\r\n   -- Strip off .git from base name if present\r\n   module = module:gsub(\"%.git$\", \"\")\r\n\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   store_dir = fs.absolute_name(store_dir)\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n\r\n   local command = {git_cmd, \"clone\", \"--depth=1\", rockspec.source.url, module}\r\n   local tag_or_branch = rockspec.source.tag or rockspec.source.branch\r\n   -- If the tag or branch is explicitly set to \"master\" in the rockspec, then\r\n   -- we can avoid passing it to Git since it's the default.\r\n   if tag_or_branch == \"master\" then tag_or_branch = nil end\r\n   if tag_or_branch then\r\n      if git_can_clone_by_tag(git_cmd) then\r\n         -- The argument to `--branch` can actually be a branch or a tag as of\r\n         -- Git 1.7.10.\r\n         table.insert(command, 4, \"--branch=\" .. tag_or_branch)\r\n      end\r\n   end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed cloning git repository.\"\r\n   end\r\n   local ok, err = fs.change_dir(module)\r\n   if not ok then return nil, err end\r\n   if tag_or_branch and not git_can_clone_by_tag() then\r\n      local checkout_command = {git_cmd, \"checkout\", tag_or_branch}\r\n      if not fs.execute(unpack(checkout_command)) then\r\n         return nil, 'Failed to check out the \"' .. tag_or_branch ..'\" tag or branch.'\r\n      end\r\n   end\r\n\r\n   fs.delete(dir.path(store_dir, module, \".git\"))\r\n   fs.delete(dir.path(store_dir, module, \".gitignore\"))\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 27,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local hg_cmd = rockspec.variables.HG\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   -- Strip off special hg:// protocol type\r\n   local url = rockspec.source.url:gsub(\"^hg://\", \"\") \r\n\r\n   local module = dir.base_name(url)\r\n\r\n   local command = {hg_cmd, \"clone\", url, module}\r\n   local tag_or_branch = rockspec.source.tag or rockspec.source.branch\r\n   if tag_or_branch then\r\n      command = {hg_cmd, \"clone\", \"--rev\", url, module}\r\n   end\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed cloning hg repository.\"\r\n   end\r\n   local ok, err = fs.change_dir(module)\r\n   if not ok then return nil, err end\r\n\r\n   fs.delete(dir.path(store_dir, module, \".hg\"))\r\n   fs.delete(dir.path(store_dir, module, \".hgignore\"))\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 28,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local svn_cmd = rockspec.variables.SVN\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local module = rockspec.source.module or dir.base_name(rockspec.source.url)\r\n   local url = rockspec.source.url:gsub(\"^svn://\", \"\")\r\n   local command = {svn_cmd, \"checkout\", url, module}\r\n   if rockspec.source.tag then\r\n      table.insert(command, 5, \"-r\")\r\n      table.insert(command, 6, rockspec.source.tag)\r\n   end\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed fetching files from Subversion.\"\r\n   end\r\n   ok, err = fs.change_dir(module)\r\n   if not ok then return nil, err end\r\n   for _, d in ipairs(fs.find(\".\")) do\r\n      if dir.base_name(d) == \".svn\" then\r\n         fs.delete(dir.path(store_dir, module, d))\r\n      end\r\n   end\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 29,
    "text": "function fetch_url_at_temp_dir(url, tmpname, filename)\r\n   assert(type(url) == \"string\")\r\n   assert(type(tmpname) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n   filename = filename or dir.base_name(url)\r\n\r\n   local protocol, pathname = dir.split_url(url)\r\n   if protocol == \"file\" then\r\n      if fs.exists(pathname) then\r\n         return pathname, dir.dir_name(fs.absolute_name(pathname))\r\n      else\r\n         return nil, \"File not found: \"..pathname\r\n      end\r\n   else\r\n      local temp_dir, err = fs.make_temp_dir(tmpname)\r\n      if not temp_dir then\r\n         return nil, \"Failed creating temporary directory \"..tmpname..\": \"..err\r\n      end\r\n      util.schedule_function(fs.delete, temp_dir)\r\n      local ok, err = fs.change_dir(temp_dir)\r\n      if not ok then return nil, err end\r\n      local file, err, errcode = fetch_url(url, filename)\r\n      fs.pop_dir()\r\n      if not file then\r\n         return nil, \"Error fetching file: \"..err, errcode\r\n      end\r\n      return file, temp_dir\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 30,
    "text": "function fetch_and_unpack_rock(rock_file, dest)\r\n   assert(type(rock_file) == \"string\")\r\n   assert(type(dest) == \"string\" or not dest)\r\n\r\n   local name = dir.base_name(rock_file):match(\"(.*)%.[^.]*%.rock\")\r\n   \r\n   local rock_file, err, errcode = fetch_url_at_temp_dir(rock_file,\"luarocks-rock-\"..name)\r\n   if not rock_file then\r\n      return nil, \"Could not fetch rock file: \" .. err, errcode\r\n   end\r\n\r\n   rock_file = fs.absolute_name(rock_file)\r\n   local unpack_dir\r\n   if dest then\r\n      unpack_dir = dest\r\n      local ok, err = fs.make_dir(unpack_dir)\r\n      if not ok then\r\n         return nil, \"Failed unpacking rock file: \" .. err\r\n      end\r\n   else\r\n      unpack_dir = fs.make_temp_dir(name)\r\n   end\r\n   if not dest then\r\n      util.schedule_function(fs.delete, unpack_dir)\r\n   end\r\n   local ok, err = fs.change_dir(unpack_dir)\r\n   if not ok then return nil, err end\r\n   ok = fs.unzip(rock_file)\r\n   if not ok then\r\n      return nil, \"Failed unpacking rock file: \" .. rock_file\r\n   end\r\n   fs.pop_dir()\r\n   return unpack_dir\r\nend",
    "type": "function"
  }, {
    "id": 31,
    "text": "function load_local_rockspec(filename, quick)\r\n   assert(type(filename) == \"string\")\r\n   filename = fs.absolute_name(filename)\r\n   local rockspec, err = persist.load_into_table(filename)\r\n   if not rockspec then\r\n      return nil, \"Could not load rockspec file \"..filename..\" (\"..err..\")\"\r\n   end\r\n\r\n   local ok, err = true, nil\r\n   if not quick then\r\n      ok, err = type_check.type_check_rockspec(rockspec)\r\n      if not ok then\r\n         return nil, filename..\": \"..err\r\n      end\r\n   end\r\n   \r\n   if rockspec.rockspec_format then\r\n      if deps.compare_versions(rockspec.rockspec_format, type_check.rockspec_format) then\r\n         return nil, \"Rockspec format \"..rockspec.rockspec_format..\" is not supported, please upgrade LuaRocks.\"\r\n      end\r\n   end\r\n\r\n   util.platform_overrides(rockspec.build)\r\n   util.platform_overrides(rockspec.dependencies)\r\n   util.platform_overrides(rockspec.external_dependencies)\r\n   util.platform_overrides(rockspec.source)\r\n   util.platform_overrides(rockspec.hooks)\r\n\r\n   local basename = dir.base_name(filename)\r\n   if basename == \"rockspec\" then\r\n      rockspec.name = rockspec.package:lower()\r\n   else\r\n      rockspec.name = basename:match(\"(.*)-[^-]*-[0-9]*\")\r\n      if not rockspec.name then\r\n         return nil, \"Expected filename in format 'name-version-revision.rockspec'.\"\r\n      end\r\n   end\r\n\r\n   local protocol, pathname = dir.split_url(rockspec.source.url)\r\n   if is_basic_protocol(protocol) then\r\n      rockspec.source.file = rockspec.source.file or dir.base_name(rockspec.source.url)\r\n   end\r\n   rockspec.source.protocol, rockspec.source.pathname = protocol, pathname\r\n\r\n   -- Temporary compatibility\r\n   if rockspec.source.cvs_module then rockspec.source.module = rockspec.source.cvs_module end\r\n   if rockspec.source.cvs_tag then rockspec.source.tag = rockspec.source.cvs_tag end\r\n\r\n   local name_version = rockspec.package:lower() .. \"-\" .. rockspec.version\r\n   if basename ~= \"rockspec\" and basename ~= name_version .. \".rockspec\" then\r\n      return nil, \"Inconsistency between rockspec filename (\"..basename..\") and its contents (\"..name_version..\".rockspec).\"\r\n   end\r\n\r\n   rockspec.local_filename = filename\r\n   local filebase = rockspec.source.file or rockspec.source.url\r\n   local base = url_to_base_dir(filebase)\r\n   rockspec.source.dir = rockspec.source.dir\r\n                      or rockspec.source.module\r\n                      or ((filebase:match(\".lua$\") or filebase:match(\".c$\")) and \".\")\r\n                      or base\r\n   if rockspec.dependencies then\r\n      for i = 1, #rockspec.dependencies do\r\n         local parsed, err = deps.parse_dep(rockspec.dependencies[i])\r\n         if not parsed then\r\n            return nil, \"Parse error processing dependency '\"..rockspec.dependencies[i]..\"': \"..tostring(err)\r\n         end\r\n         rockspec.dependencies[i] = parsed\r\n      end\r\n   else\r\n      rockspec.dependencies = {}\r\n   end\r\n   if not quick then\r\n      path.configure_paths(rockspec)\r\n   end\r\n\r\n   return rockspec\r\nend",
    "type": "function"
  }, {
    "id": 32,
    "text": "function change_dir_to_root()\r\n   table.insert(dir_stack, lfs.currentdir())\r\n   lfs.chdir(\"/\") -- works on Windows too\r\nend",
    "type": "function"
  }, {
    "id": 33,
    "text": "function download(url, filename, cache)\r\n   assert(type(url) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n\r\n   filename = fs.absolute_name(filename or dir.base_name(url))\r\n   \r\n   local content, err\r\n   if util.starts_with(url, \"http:\") then\r\n      content, err = http_request(url, http, cache and filename)\r\n   elseif util.starts_with(url, \"ftp:\") then\r\n      content, err = ftp.get(url)\r\n   elseif util.starts_with(url, \"https:\") then\r\n      if luasec_ok then\r\n         content, err = http_request(url, https, cache and filename)\r\n      else\r\n         err = \"Unsupported protocol - install luasec to get HTTPS support.\"\r\n      end\r\n   else\r\n      err = \"Unsupported protocol\"\r\n   end\r\n   if cache and content == true then\r\n      return true, filename\r\n   end\r\n   if not content then\r\n      return false, tostring(err)\r\n   end\r\n   local file = io.open(filename, \"wb\")\r\n   if not file then return false end\r\n   file:write(content)\r\n   file:close()\r\n   return true, filename\r\nend",
    "type": "function"
  }, {
    "id": 34,
    "text": "function wrap_script(file, dest, name, version)\r\n   assert(type(file) == \"string\")\r\n   assert(type(dest) == \"string\")\r\n   \r\n   local base = dir.base_name(file)\r\n   local wrapname = fs.is_dir(dest) and dest..\"/\"..base or dest\r\n   local lpath, lcpath = cfg.package_paths()\r\n   local wrapper = io.open(wrapname, \"w\")\r\n   if not wrapper then\r\n      return nil, \"Could not open \"..wrapname..\" for writing.\"\r\n   end\r\n   wrapper:write(\"#!/bin/sh\\n\\n\")\r\n   local lua = dir.path(cfg.variables[\"LUA_BINDIR\"], cfg.lua_interpreter)\r\n   local ppaths = \"package.path=\"..util.LQ(lpath..\";\")..\"..package.path; package.cpath=\"..util.LQ(lcpath..\";\")..\"..package.cpath\"\r\n   local addctx = \"local k,l,_=pcall(require,\"..util.LQ(\"luarocks.loader\")..\") _=k and l.add_context(\"..util.LQ(name)..\",\"..util.LQ(version)..\")\"\r\n   wrapper:write('exec '..fs.Q(lua)..' -e '..fs.Q(ppaths)..' -e '..fs.Q(addctx)..' '..fs.Q(file)..' \"$@\"\\n')\r\n   wrapper:close()\r\n   if fs.chmod(wrapname, \"0755\") then\r\n      return true\r\n   else\r\n      return nil, \"Could not make \"..wrapname..\" executable.\"\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 35,
    "text": "function is_actual_binary(filename)\r\n   if filename:match(\"%.lua$\") then\r\n      return false\r\n   end\r\n   local file = io.open(filename)\r\n   if not file then\r\n      return true\r\n   end\r\n   local first = file:read(2)\r\n   file:close()\r\n   if not first then\r\n      util.printerr(\"Warning: could not read \"..filename)\r\n      return true\r\n   end\r\n   return first ~= \"#!\"\r\nend",
    "type": "function"
  }, {
    "id": 36,
    "text": "function wrap_script(file, dest, name, version)\r\n   assert(type(file) == \"string\")\r\n   assert(type(dest) == \"string\")\r\n\r\n   local base = dir.base_name(file)\r\n   local wrapname = fs.is_dir(dest) and dest..\"/\"..base or dest\r\n   wrapname = wrapname..\".bat\"\r\n   local lpath, lcpath = cfg.package_paths()\r\n   local wrapper = io.open(wrapname, \"w\")\r\n   if not wrapper then\r\n      return nil, \"Could not open \"..wrapname..\" for writing.\"\r\n   end\r\n   wrapper:write(\"@echo off\\n\")\r\n   local lua = dir.path(cfg.variables[\"LUA_BINDIR\"], cfg.lua_interpreter)\r\n   local ppaths = \"package.path=\"..util.LQ(lpath..\";\")..\"..package.path; package.cpath=\"..util.LQ(lcpath..\";\")..\"..package.cpath\"\r\n   local addctx = \"local k,l,_=pcall(require,\"..util.LQ(\"luarocks.loader\")..\") _=k and l.add_context(\"..util.LQ(name)..\",\"..util.LQ(version)..\")\"\r\n   wrapper:write(fs.Qb(lua)..' -e '..fs.Qb(ppaths)..' -e '..fs.Qb(addctx)..' '..fs.Qb(file)..' %*\\n')\r\n   wrapper:close()\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 37,
    "text": "local function print_banner()\r\n   util.printout(\"\\nLuaRocks \"..cfg.program_version..\", a module deployment system for Lua\")\r\nend",
    "type": "function"
  }, {
    "id": 38,
    "text": "local function print_section(section)\r\n   util.printout(\"\\n\"..section)\r\nend",
    "type": "function"
  }, {
    "id": 39,
    "text": "function run(...)\r\n   local flags, command = util.parse_flags(...)\r\n\r\n   if not command then\r\n      local sys_file, sys_ok, home_file, home_ok = cfg.which_config()\r\n      print_banner()\r\n      print_section(\"NAME\")\r\n      util.printout(\"\\t\"..program..[[ - ]]..program_description)\r\n      print_section(\"SYNOPSIS\")\r\n      util.printout(\"\\t\"..program..[[ [--from=<server> | --only-from=<server>] [--to=<tree>] [VAR=VALUE]... <command> [<argument>] ]])\r\n      print_section(\"GENERAL OPTIONS\")\r\n      util.printout([[\r\n\tThese apply to all commands, as appropriate:\r\n\r\n\t--server=<server>      Fetch rocks/rockspecs from this server\r\n\t                       (takes priority over config file)\r\n\t--only-server=<server> Fetch rocks/rockspecs from this server only\r\n\t                       (overrides any entries in the config file)\r\n\t--only-sources=<url>   Restrict downloads to paths matching the\r\n\t                       given URL.\r\n\t--tree=<tree>          Which tree to operate on.\r\n\t--local                Use the tree in the user's home directory.\r\n\t                       To enable it, see ']]..program..[[ help path'.]])\r\n      print_section(\"VARIABLES\")\r\n      util.printout([[\r\n\tVariables from the \"variables\" table of the configuration file\r\n\tcan be overriden with VAR=VALUE assignments.]])\r\n      print_section(\"COMMANDS\")\r\n      local names = {}\r\n      for name, command in util.sortedpairs(commands) do\r\n         local cmd = require(command)\r\n         util.printout(\"\", name)\r\n         util.printout(\"\\t\", cmd.help_summary)\r\n      end\r\n      print_section(\"CONFIGURATION\")\r\n      util.printout(\"\\tLua version: \" .. cfg.lua_version)\r\n      util.printout(\"\\tConfiguration files:\")\r\n      util.printout(\"\\t\\tSystem: \".. dir.normalize(sys_file) .. \" (\" .. get_status(sys_ok) ..\")\")\r\n      if home_file then\r\n         util.printout(\"\\t\\tUser  : \".. dir.normalize(home_file) .. \" (\" .. get_status(home_ok) ..\")\\n\")\r\n      else\r\n         util.printout(\"\\t\\tUser  : disabled in this LuaRocks installation.\\n\")\r\n      end\r\n      util.printout(\"\\tRocks trees in use: \")\r\n      for _, tree in ipairs(cfg.rocks_trees) do\r\n      \tif type(tree) == \"string\" then\r\n      \t   util.printout(\"\\t\\t\"..dir.normalize(tree))\r\n      \telse\r\n      \t   local name = tree.name and \" (\\\"\"..tree.name..\"\\\")\" or \"\"\r\n      \t   util.printout(\"\\t\\t\"..dir.normalize(tree.root)..name)\r\n      \tend\r\n      end\r\n   else\r\n      command = command:gsub(\"-\", \"_\")\r\n      local cmd = require(commands[command])\r\n      if cmd then\r\n         local arguments = cmd.help_arguments or \"<argument>\"\r\n         print_banner()\r\n         print_section(\"NAME\")\r\n         util.printout(\"\\t\"..program..\" \"..command..\" - \"..cmd.help_summary)\r\n         print_section(\"SYNOPSIS\")\r\n         util.printout(\"\\t\"..program..\" \"..command..\" \"..arguments)\r\n         print_section(\"DESCRIPTION\")\r\n         util.printout(\"\",(cmd.help:gsub(\"\\n\",\"\\n\\t\"):gsub(\"\\n\\t$\",\"\")))\r\n         print_section(\"SEE ALSO\")\r\n         util.printout(\"\",\"'\"..program..\" help' for general options and configuration.\\n\")\r\n      else\r\n         return nil, \"Unknown command '\"..command..\"'\"\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 40,
    "text": "",
    "type": "function container"
  }, {
    "id": 41,
    "text": "function format_external_dependencies(rockspec)\r\n   if rockspec.external_dependencies then\r\n      local deplist = {}\r\n      local listed_set = {}\r\n      local plats = nil\r\n      for name, desc in util.sortedpairs(rockspec.external_dependencies) do\r\n         if name ~= \"platforms\" then\r\n            table.insert(deplist, name:lower())\r\n            listed_set[name] = true\r\n         else\r\n            plats = desc\r\n         end\r\n      end\r\n      if plats then\r\n         for plat, entries in util.sortedpairs(plats) do\r\n            for name, desc in util.sortedpairs(entries) do\r\n               if not listed_set[name] then\r\n                  table.insert(deplist, name:lower() .. \" (on \"..plat..\")\")\r\n               end\r\n            end\r\n         end\r\n      end\r\n      return '<p><b>External dependencies:</b> ' .. table.concat(deplist, ',&nbsp;').. '</p>'\r\n   else\r\n      return \"\"\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 42,
    "text": "function make_index(repo)\r\n   if not fs.is_dir(repo) then\r\n      return nil, \"Cannot access repository at \"..repo\r\n   end\r\n   local manifest = manif.load_manifest(repo)\r\n   local out = io.open(dir.path(repo, \"index.html\"), \"w\")\r\n   \r\n   out:write(index_header)\r\n   for package, version_list in util.sortedpairs(manifest.repository) do\r\n      local latest_rockspec = nil\r\n      local output = index_package_begin\r\n      for version, data in util.sortedpairs(version_list, deps.compare_versions) do\r\n         local versions = {}\r\n         output = output..version..':&nbsp;'\r\n         table.sort(data, function(a,b) return a.arch < b.arch end)\r\n         for _, item in ipairs(data) do\r\n            local file\r\n            if item.arch == 'rockspec' then\r\n               file = (\"%s-%s.rockspec\"):format(package, version)\r\n               if not latest_rockspec then latest_rockspec = file end\r\n            else\r\n               file = (\"%s-%s.%s.rock\"):format(package, version, item.arch)\r\n            end\r\n            table.insert(versions, '<a href=\"'..file..'\">'..item.arch..'</a>')\r\n         end\r\n         output = output .. table.concat(versions, ',&nbsp;') .. '<br/>'\r\n      end\r\n      output = output .. index_package_end\r\n      if latest_rockspec then\r\n         local rockspec = persist.load_into_table(dir.path(repo, latest_rockspec))\r\n         local descript = rockspec.description or {}\r\n         local vars = {\r\n            anchor = package,\r\n            package = rockspec.package,\r\n            original = rockspec.source.url,\r\n            summary = descript.summary or \"\",\r\n            detailed = descript.detailed or \"\",\r\n            license = descript.license or \"N/A\",\r\n            homepage = descript.homepage and ('| <a href=\"'..descript.homepage..'\"'..ext_url_target..'>project homepage</a>') or \"\",\r\n            externaldependencies = format_external_dependencies(rockspec)\r\n         }\r\n         vars.detailed = vars.detailed:gsub(\"\\n\\n\", \"</p><p>\"):gsub(\"%s+\", \" \")\r\n         vars.detailed = vars.detailed:gsub(\"(https?://[a-zA-Z0-9%.%%-_%+%[%]=%?&/$@;:]+)\", '<a href=\"%1\"'..ext_url_target..'>%1</a>')\r\n         output = output:gsub(\"$(%w+)\", vars)\r\n      else\r\n         output = output:gsub(\"$anchor\", package)\r\n         output = output:gsub(\"$package\", package)\r\n         output = output:gsub(\"$(%w+)\", \"\")\r\n      end\r\n      out:write(output)\r\n   end\r\n   out:write(index_footer_begin)\r\n   for ver in util.lua_versions() do\r\n      out:write((index_manifest_ver:gsub(\"$VER\", ver)))\r\n   end\r\n   out:write(index_footer_end)\r\n   out:close()\r\nend",
    "type": "function"
  }, {
    "id": 43,
    "text": "function install_binary_rock(rock_file, deps_mode)\r\n   assert(type(rock_file) == \"string\")\r\n\r\n   local name, version, arch = path.parse_name(rock_file)\r\n   if not name then\r\n      return nil, \"Filename \"..rock_file..\" does not match format 'name-version-revision.arch.rock'.\"\r\n   end\r\n   \r\n   if arch ~= \"all\" and arch ~= cfg.arch then\r\n      return nil, \"Incompatible architecture \"..arch, \"arch\"\r\n   end\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n   \r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n   \r\n   local ok, err, errcode = fetch.fetch_and_unpack_rock(rock_file, path.install_dir(name, version))\r\n   if not ok then return nil, err, errcode end\r\n   \r\n   local rockspec, err, errcode = fetch.load_rockspec(path.rockspec_file(name, version))\r\n   if err then\r\n      return nil, \"Failed loading rockspec for installed package: \"..err, errcode\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      ok, err, errcode = deps.check_external_deps(rockspec, \"install\")\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   -- For compatibility with .rock files built with LuaRocks 1\r\n   if not fs.exists(path.rock_manifest_file(name, version)) then\r\n      ok, err = manif.make_rock_manifest(name, version)\r\n      if err then return nil, err end\r\n   end\r\n\r\n   if deps_mode ~= \"none\" then\r\n      ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   local wrap_bin_scripts = true\r\n   if rockspec.deploy and rockspec.deploy.wrap_bin_scripts == false then\r\n      wrap_bin_scripts = false\r\n   end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n\r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n   \r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n   \r\n   local license = \"\"\r\n   if rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 44,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"install\")\r\n   end\r\n\r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n\r\n   if name:match(\"%.rockspec$\") or name:match(\"%.src%.rock$\") then\r\n      util.printout(\"Using \"..name..\"... switching to 'build' mode\")\r\n      local build = require(\"luarocks.build\")\r\n      return build.run(name, util.forward_flags(flags, \"local\", \"keep\", \"deps-mode\"))\r\n   elseif name:match(\"%.rock$\") then\r\n      ok, err = install_binary_rock(name, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   else\r\n      local search = require(\"luarocks.search\")\r\n      local results, err = search.find_suitable_rock(search.make_query(name:lower(), version))\r\n      if err then\r\n         return nil, err\r\n      elseif type(results) == \"string\" then\r\n         local url = results\r\n         util.printout(\"Installing \"..url..\"...\")\r\n         return run(url, util.forward_flags(flags))\r\n      else\r\n         util.printout()\r\n         util.printerr(\"Could not determine which rock to install.\")\r\n         util.title(\"Search results:\")\r\n         search.print_results(results)\r\n         return nil, (next(results) and \"Please narrow your query.\" or \"No results found.\")\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 45,
    "text": "",
    "type": "function container"
  }, {
    "id": 46,
    "text": "function run(...)\r\n   local flags, input = util.parse_flags(...)\r\n   \r\n   if not input then\r\n      return nil, \"Argument missing. \"..util.see_help(\"lint\")\r\n   end\r\n   \r\n   local filename = input\r\n   if not input:match(\".rockspec$\") then\r\n      local err\r\n      filename, err = download.download(\"rockspec\", input)\r\n      if not filename then\r\n         return nil, err\r\n      end\r\n   end\r\n\r\n   local rs, err = fetch.load_local_rockspec(filename)\r\n   if not rs then\r\n      return nil, \"Failed loading rockspec: \"..err\r\n   end\r\n\r\n   local ok = true\r\n   \r\n   -- This should have been done in the type checker, \r\n   -- but it would break compatibility of other commands.\r\n   -- Making 'lint' alone be stricter shouldn't be a problem,\r\n   -- because extra-strict checks is what lint-type commands\r\n   -- are all about.\r\n   if not rs.description.license then\r\n      util.printerr(\"Rockspec has no license field.\")\r\n      ok = false\r\n   end\r\n\r\n   return ok, ok or filename..\" failed consistency checks.\"\r\nend",
    "type": "function"
  }, {
    "id": 47,
    "text": "function run(...)\r\n   local flags, filter, version = util.parse_flags(...)\r\n   local results = {}\r\n   local query = search.make_query(filter and filter:lower() or \"\", version)\r\n   query.exact_name = false\r\n   local trees = cfg.rocks_trees\r\n   if flags[\"tree\"] then\r\n      trees = { flags[\"tree\"] }\r\n   end\r\n   for _, tree in ipairs(trees) do\r\n      search.manifest_search(results, path.rocks_dir(tree), query)\r\n   end\r\n   util.title(\"Installed rocks:\", flags[\"porcelain\"])\r\n   search.print_results(results, flags[\"porcelain\"])\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 48,
    "text": "function run(...)\r\n   local flags, rockspec = util.parse_flags(...)\r\n   assert(type(rockspec) == \"string\" or not rockspec)\r\n   \r\n   if not rockspec then\r\n      local files = fs.list_dir(fs.current_dir())\r\n      for _, file in pairs(files) do\r\n         if file:match(\"rockspec$\") then\r\n            if rockspec then\r\n               return nil, \"Please specify which rockspec file to use.\"\r\n            else\r\n               rockspec = file\r\n            end\r\n         end\r\n      end\r\n      if not rockspec then\r\n         return nil, \"Argument missing: please specify a rockspec to use on current directory.\"\r\n      end\r\n   end\r\n   if not rockspec:match(\"rockspec$\") then\r\n      return nil, \"Invalid argument: 'make' takes a rockspec as a parameter. \"..util.see_help(\"make\")\r\n   end\r\n\r\n   if flags[\"pack-binary-rock\"] then\r\n      local rspec, err, errcode = fetch.load_rockspec(rockspec)\r\n      if not rspec then\r\n         return nil, err\r\n      end\r\n      return pack.pack_binary_rock(rspec.name, rspec.version, build.build_rockspec, rockspec, false, true, deps.get_deps_mode(flags))\r\n   else\r\n      local ok, err = fs.check_command_permissions(flags)\r\n      if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n      ok, err = build.build_rockspec(rockspec, false, true, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 49,
    "text": "function run(...)\r\n   local flags, repo = util.parse_flags(...)\r\n\r\n   assert(type(repo) == \"string\" or not repo)\r\n   repo = repo or cfg.rocks_dir\r\n  \r\n   util.printout(\"Making manifest for \"..repo)\r\n   \r\n   if repo:match(\"/lib/luarocks\") and not flags[\"local-tree\"] then\r\n      util.warning(\"This looks like a local rocks tree, but you did not pass --local-tree.\")\r\n   end\r\n   \r\n   local ok, err = manif.make_manifest(repo, deps.get_deps_mode(flags), not flags[\"local-tree\"])\r\n   if ok and not flags[\"local-tree\"] then\r\n      util.printout(\"Generating index.html for \"..repo)\r\n      index.make_index(repo)\r\n   end\r\n   if flags[\"local-tree\"] then\r\n      for luaver in util.lua_versions() do\r\n         fs.delete(dir.path(repo, \"manifest-\"..luaver))\r\n      end\r\n   end\r\n   return ok, err\r\nend",
    "type": "function"
  }, {
    "id": 50,
    "text": "local function update_dependencies(manifest, deps_mode)\r\n   assert(type(manifest) == \"table\")\r\n   assert(type(deps_mode) == \"string\")\r\n   \r\n   for pkg, versions in pairs(manifest.repository) do\r\n      for version, repositories in pairs(versions) do\r\n         local current = pkg..\" \"..version\r\n         for _, repo in ipairs(repositories) do\r\n            if repo.arch == \"installed\" then\r\n               local missing\r\n               repo.dependencies, missing = deps.scan_deps({}, {}, manifest, pkg, version, deps_mode)\r\n               repo.dependencies[pkg] = nil\r\n               if missing then\r\n                  for miss, err in pairs(missing) do\r\n                     if miss == current then\r\n                        util.printerr(\"Tree inconsistency detected: \"..current..\" has no rockspec. \"..err)\r\n                     else\r\n                        util.printerr(\"Missing dependency for \"..pkg..\" \"..version..\": \"..miss)\r\n                     end\r\n                  end\r\n               end\r\n            end\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 51,
    "text": "local function filter_by_lua_version(manifest, lua_version, repodir, cache)\r\n   assert(type(manifest) == \"table\")\r\n   assert(type(repodir) == \"string\")\r\n   assert((not cache) or type(cache) == \"table\")\r\n   \r\n   cache = cache or {}\r\n   lua_version = deps.parse_version(lua_version)\r\n   for pkg, versions in pairs(manifest.repository) do\r\n      local to_remove = {}\r\n      for version, repositories in pairs(versions) do\r\n         for _, repo in ipairs(repositories) do\r\n            if repo.arch == \"rockspec\" then\r\n               local pathname = dir.path(repodir, pkg..\"-\"..version..\".rockspec\")\r\n               local rockspec, err = cache[pathname]\r\n               if not rockspec then\r\n                  rockspec, err = fetch.load_local_rockspec(pathname, true)\r\n               end\r\n               if rockspec then\r\n                  cache[pathname] = rockspec\r\n                  for _, dep in ipairs(rockspec.dependencies) do\r\n                     if dep.name == \"lua\" then \r\n                        if not deps.match_constraints(lua_version, dep.constraints) then\r\n                           table.insert(to_remove, version)\r\n                        end\r\n                        break\r\n                     end\r\n                  end\r\n               else\r\n                  util.printerr(\"Error loading rockspec for \"..pkg..\" \"..version..\": \"..err)\r\n               end\r\n            end\r\n         end\r\n      end\r\n      if next(to_remove) then\r\n         for _, incompat in ipairs(to_remove) do\r\n            versions[incompat] = nil\r\n         end\r\n         if not next(versions) then\r\n            manifest.repository[pkg] = nil\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 52,
    "text": "function make_manifest(repo, deps_mode, remote)\r\n   assert(type(repo) == \"string\")\r\n   assert(type(deps_mode) == \"string\")\r\n\r\n   if deps_mode == \"none\" then deps_mode = cfg.deps_mode end\r\n\r\n   if not fs.is_dir(repo) then\r\n      return nil, \"Cannot access repository at \"..repo\r\n   end\r\n\r\n   local query = search.make_query(\"\")\r\n   query.exact_name = false\r\n   query.arch = \"any\"\r\n   local results = search.disk_search(repo, query)\r\n   local manifest = { repository = {}, modules = {}, commands = {} }\r\n\r\n   manif_core.manifest_cache[repo] = manifest\r\n\r\n   local dep_handler = nil\r\n   if not remote then\r\n      dep_handler = function(manifest)\r\n         update_dependencies(manifest, deps_mode)\r\n      end\r\n   end\r\n   local ok, err = store_results(results, manifest, dep_handler)\r\n   if not ok then return nil, err end\r\n\r\n   if remote then\r\n      local cache = {}\r\n      for luaver in util.lua_versions() do\r\n         local vmanifest = { repository = {}, modules = {}, commands = {} }\r\n         local dep_handler = function(manifest)\r\n            filter_by_lua_version(manifest, luaver, repo, cache)\r\n         end\r\n         local ok, err = store_results(results, vmanifest, dep_handler)\r\n         save_table(repo, \"manifest-\"..luaver, vmanifest)\r\n      end\r\n   end\r\n\r\n   return save_table(repo, \"manifest\", manifest)\r\nend",
    "type": "function"
  }, {
    "id": 53,
    "text": "function update_manifest(name, version, repo, deps_mode)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   repo = path.rocks_dir(repo or cfg.root_dir)\r\n   assert(type(deps_mode) == \"string\")\r\n   \r\n   if deps_mode == \"none\" then deps_mode = cfg.deps_mode end\r\n\r\n   util.printout(\"Updating manifest for \"..repo)\r\n\r\n   local manifest, err = load_manifest(repo)\r\n   if not manifest then\r\n      util.printerr(\"No existing manifest. Attempting to rebuild...\")\r\n      local ok, err = make_manifest(repo, deps_mode)\r\n      if not ok then\r\n         return nil, err\r\n      end\r\n      manifest, err = load_manifest(repo)\r\n      if not manifest then\r\n         return nil, err\r\n      end\r\n   end\r\n\r\n   local results = {[name] = {[version] = {{arch = \"installed\", repo = repo}}}}\r\n\r\n   local dep_handler = function(manifest)\r\n      update_dependencies(manifest, deps_mode)\r\n   end\r\n   local ok, err = store_results(results, manifest, dep_handler)\r\n   if not ok then return nil, err end\r\n\r\n   return save_table(repo, \"manifest\", manifest)\r\nend",
    "type": "function"
  }, {
    "id": 54,
    "text": "function zip_manifests()\r\n   for ver in util.lua_versions() do\r\n      local file = \"manifest-\"..ver\r\n      local zip = file..\".zip\"\r\n      fs.delete(dir.path(fs.current_dir(), zip))\r\n      fs.zip(zip, file)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 55,
    "text": "local function find_providers(file, root)\r\n   assert(type(file) == \"string\")\r\n   root = root or cfg.root_dir\r\n\r\n   local manifest, err = manif_core.load_local_manifest(path.rocks_dir(root))\r\n   if not manifest then\r\n      return nil, \"untracked\"\r\n   end\r\n   local deploy_bin = path.deploy_bin_dir(root)\r\n   local deploy_lua = path.deploy_lua_dir(root)\r\n   local deploy_lib = path.deploy_lib_dir(root)\r\n   local key, manifest_tbl\r\n\r\n   if util.starts_with(file, deploy_lua) then\r\n      manifest_tbl = manifest.modules\r\n      key = path.path_to_module(file:sub(#deploy_lua+1):gsub(\"\\\\\", \"/\"))\r\n   elseif util.starts_with(file, deploy_lib) then\r\n      manifest_tbl = manifest.modules\r\n      key = path.path_to_module(file:sub(#deploy_lib+1):gsub(\"\\\\\", \"/\"))\r\n   elseif util.starts_with(file, deploy_bin) then\r\n      manifest_tbl = manifest.commands\r\n      key = file:sub(#deploy_bin+1):gsub(\"^[\\\\/]*\", \"\")\r\n   else\r\n      assert(false, \"Assertion failed: '\"..file..\"' is not a deployed file.\")\r\n   end\r\n\r\n   local providers = manifest_tbl[key]\r\n   if not providers then\r\n      return nil, \"untracked\"\r\n   end\r\n   return providers\r\nend",
    "type": "function"
  }, {
    "id": 56,
    "text": "function get_versions(name, deps_mode)\r\n   assert(type(name) == \"string\")\r\n   assert(type(deps_mode) == \"string\")\r\n   \r\n   local manifest = {}\r\n   path.map_trees(deps_mode, function(tree)\r\n      local loaded = load_local_manifest(path.rocks_dir(tree))\r\n      if loaded then\r\n         util.deep_merge(manifest, loaded)\r\n      end\r\n   end)\r\n   \r\n   local item = next(manifest) and manifest.repository[name]\r\n   if item then\r\n      return util.keys(item)\r\n   end\r\n   return {}\r\nend",
    "type": "function"
  }, {
    "id": 57,
    "text": "local function try_replace(tbl, field, old, new)\r\n   if not tbl[field] then\r\n      return false\r\n   end\r\n   local old_field = tbl[field]\r\n   local new_field = tbl[field]:gsub(old, new)\r\n   if new_field ~= old_field then\r\n      util.printout(\"Guessing new '\"..field..\"' field as \"..new_field)\r\n      tbl[field] = new_field\r\n      return true      \r\n   end\r\n   return false\r\nend",
    "type": "function"
  }, {
    "id": 58,
    "text": "local function check_url_and_update_md5(out_rs, out_name)\r\n   local old_md5 = out_rs.source.md5\r\n   out_rs.source.md5 = nil\r\n   local file, temp_dir = fetch.fetch_url_at_temp_dir(out_rs.source.url, \"luarocks-new-version-\"..out_name)\r\n   if not file then\r\n      util.printerr(\"Warning: invalid URL - \"..temp_dir)\r\n      return true\r\n   end\r\n   util.printout(\"File successfully downloaded. Updating MD5 checksum...\")\r\n   out_rs.source.md5 = fs.get_md5(file)\r\n   local ok, err = fs.change_dir(temp_dir)\r\n   if not ok then return nil, err end\r\n   fs.unpack_archive(file)\r\n   local base_dir = out_rs.source.dir or fetch.url_to_base_dir(out_rs.source.url)\r\n   if not fs.exists(base_dir) then\r\n      util.printerr(\"Directory \"..base_dir..\" not found\")\r\n      local files = fs.list_dir()\r\n      if files[1] and fs.is_dir(files[1]) then\r\n         util.printerr(\"Found \"..files[1])\r\n         out_rs.source.dir = files[1]\r\n      end\r\n   end\r\n   fs.pop_dir()\r\n   return out_rs.source.md5 ~= old_md5\r\nend",
    "type": "function"
  }, {
    "id": 59,
    "text": "local function update_source_section(out_rs, out_name, url, old_ver, new_ver)\r\n   if url then\r\n      out_rs.source.url = url\r\n      check_url_and_update_md5(out_rs, out_name)\r\n      return true\r\n   end\r\n   if new_ver == old_ver then\r\n      return true\r\n   end\r\n   if not out_rs.source then\r\n      return nil, \"'source' table is missing. Invalid rockspec?\"\r\n   end\r\n   if out_rs.source.dir then\r\n      try_replace(out_rs.source, \"dir\", old_ver, new_ver)\r\n   end\r\n   if out_rs.source.file then\r\n      try_replace(out_rs.source, \"file\", old_ver, new_ver)\r\n   end\r\n   local ok = try_replace(out_rs.source, \"url\", old_ver, new_ver)\r\n   if ok then\r\n      check_url_and_update_md5(out_rs, out_name)\r\n      return true\r\n   end\r\n   ok = try_replace(out_rs.source, \"tag\", old_ver, new_ver)\r\n   if not ok then\r\n      ok = check_url_and_update_md5(out_rs, out_name)\r\n      if ok then\r\n         util.printerr(\"Warning: URL is the same, but MD5 has changed. Old rockspec is broken.\")\r\n      end\r\n   end\r\n   if not ok then\r\n      return nil, \"Failed to determine the location of the new version.\"\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 60,
    "text": "function run(...)\r\n   local flags, input, version, url = util.parse_flags(...)\r\n   if not input then\r\n      return nil, \"Missing arguments: expected program or rockspec. \"..util.see_help(\"new_version\")\r\n   end\r\n   assert(type(input) == \"string\")\r\n   \r\n   local filename = input\r\n   if not input:match(\".rockspec$\") then\r\n      local err\r\n      filename, err = download.download(\"rockspec\", input)\r\n      if not filename then\r\n         return nil, err\r\n      end\r\n   end\r\n   \r\n   local valid_rs, err = fetch.load_rockspec(filename)\r\n   if not valid_rs then\r\n      return nil, err\r\n   end\r\n\r\n   local old_ver, old_rev = valid_rs.version:match(\"(.*)%-(%d+)$\")\r\n   local new_ver, new_rev\r\n   \r\n   if version then\r\n      new_ver, new_rev = version:match(\"(.*)%-(%d+)$\")\r\n      new_rev = tonumber(new_rev)\r\n      if not new_rev then\r\n         new_ver = version\r\n         new_rev = 1\r\n      end\r\n   else\r\n      new_ver = old_ver\r\n      new_rev = tonumber(old_rev) + 1\r\n   end\r\n   local new_rockver = new_ver:gsub(\"-\", \"\")\r\n   \r\n   local out_rs = persist.load_into_table(filename)\r\n   local out_name = out_rs.package:lower()\r\n   out_rs.version = new_rockver..\"-\"..new_rev\r\n\r\n   local ok, err = update_source_section(out_rs, out_name, url, old_ver, new_ver)\r\n   if not ok then return nil, err end\r\n\r\n   if out_rs.build and out_rs.build.type == \"module\" then\r\n      out_rs.build.type = \"builtin\"\r\n   end\r\n   \r\n   local out_filename = out_name..\"-\"..new_rockver..\"-\"..new_rev..\".rockspec\"\r\n   \r\n   persist.save_from_table(out_filename, out_rs, type_check.rockspec_order)\r\n   \r\n   util.printout(\"Wrote \"..out_filename)\r\n\r\n   local valid_out_rs, err = fetch.load_local_rockspec(out_filename)\r\n   if not valid_out_rs then\r\n      return nil, \"Failed loading generated rockspec: \"..err\r\n   end\r\n   \r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 61,
    "text": "function pack_binary_rock(name, version, cmd, ...)\r\n\r\n   -- The --pack-binary-rock option for \"luarocks build\" basically performs\r\n   -- \"luarocks build\" on a temporary tree and then \"luarocks pack\". The\r\n   -- alternative would require refactoring parts of luarocks.build and\r\n   -- luarocks.pack, which would save a few file operations: the idea would be\r\n   -- to shave off the final deploy steps from the build phase and the initial\r\n   -- collect steps from the pack phase.\r\n\r\n   local temp_dir, err = fs.make_temp_dir(\"luarocks-build-pack-\"..dir.base_name(name))\r\n   if not temp_dir then\r\n      return nil, \"Failed creating temporary directory: \"..err\r\n   end\r\n   util.schedule_function(fs.delete, temp_dir)\r\n\r\n   path.use_tree(temp_dir)\r\n   local ok, err = cmd(...)\r\n   if not ok then\r\n      return nil, err\r\n   end\r\n   local rname, rversion = path.parse_name(name)\r\n   if not rname then\r\n      rname, rversion = name, version\r\n   end\r\n   return do_pack_binary_rock(rname, rversion)\r\nend",
    "type": "function"
  }, {
    "id": 62,
    "text": "function run(...)\r\n   local flags, arg, version = util.parse_flags(...)\r\n   assert(type(version) == \"string\" or not version)\r\n   if type(arg) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"pack\")\r\n   end\r\n\r\n   local file, err\r\n   if arg:match(\".*%.rockspec\") then\r\n      file, err = pack_source_rock(arg)\r\n   else\r\n      file, err = do_pack_binary_rock(arg, version)\r\n   end\r\n   if err then\r\n      return nil, err\r\n   else\r\n      util.printout(\"Packed: \"..file)\r\n      return true\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 63,
    "text": "function root_dir(rocks_dir)\r\n   assert(type(rocks_dir) == \"string\")\r\n   return rocks_dir:match(\"(.*)\" .. util.matchquote(cfg.rocks_subdir) .. \".*$\")\r\nend",
    "type": "function"
  }, {
    "id": 64,
    "text": "function run(...)\r\n   local flags = util.parse_flags(...)\r\n   local deps_mode = deps.get_deps_mode(flags)\r\n   \r\n   local lr_path, lr_cpath = cfg.package_paths()\r\n   local bin_dirs = map_trees(deps_mode, deploy_bin_dir)\r\n\r\n   if flags[\"lr-path\"] then\r\n      util.printout(util.remove_path_dupes(lr_path, ';'))\r\n      return true\r\n   elseif flags[\"lr-cpath\"] then\r\n      util.printout(util.remove_path_dupes(lr_cpath, ';'))\r\n      return true\r\n   elseif flags[\"lr-bin\"] then\r\n      local lr_bin = util.remove_path_dupes(table.concat(bin_dirs, cfg.export_path_separator), cfg.export_path_separator)\r\n      util.printout(util.remove_path_dupes(lr_bin, ';'))\r\n      return true\r\n   end\r\n   \r\n   if flags[\"append\"] then\r\n      lr_path = package.path .. \";\" .. lr_path\r\n      lr_cpath = package.cpath .. \";\" .. lr_cpath\r\n   else\r\n      lr_path =  lr_path.. \";\" .. package.path\r\n      lr_cpath = lr_cpath .. \";\" .. package.cpath\r\n   end\r\n\r\n   util.printout(cfg.export_lua_path:format(util.remove_path_dupes(lr_path, ';')))\r\n   util.printout(cfg.export_lua_cpath:format(util.remove_path_dupes(lr_cpath, ';')))\r\n   if flags[\"bin\"] then\r\n      table.insert(bin_dirs, 1, os.getenv(\"PATH\"))\r\n      local lr_bin = util.remove_path_dupes(table.concat(bin_dirs, cfg.export_path_separator), cfg.export_path_separator)\r\n      util.printout(cfg.export_path:format(lr_bin))\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 65,
    "text": "function(out, tbl, level, field_order)\r\n   out:write(\"{\")\r\n   local sep = \"\\n\"\r\n   local indentation = \"   \"\r\n   local indent = true\r\n   local i = 1\r\n   for k, v, sub_order in util.sortedpairs(tbl, field_order) do\r\n      out:write(sep)\r\n      if indent then\r\n         for n = 1,level do out:write(indentation) end\r\n      end\r\n      sep = \",\\n\"\r\n      indent = true\r\n      if type(k) == \"number\" then\r\n         if k ~= i then\r\n            out:write(\"[\"..tostring(k)..\"]=\")\r\n         else\r\n            i = i + 1\r\n         end\r\n         indent = false\r\n         sep = \", \"\r\n      elseif type(k) == \"table\" then\r\n         out:write(\"[\")\r\n         write_table(out, k, level + 1)\r\n         out:write(\"] = \")\r\n      else\r\n         if k:match(\"^[a-zA-Z_][a-zA-Z0-9_]*$\") then\r\n            out:write(k..\" = \")\r\n         else\r\n            out:write(\"['\"..k:gsub(\"'\", \"\\\\'\")..\"'] = \") \r\n         end\r\n      end\r\n      write_value(out, v, level, sub_order)\r\n   end\r\n   if sep ~= \"\\n\" then\r\n      out:write(\"\\n\")\r\n      for n = 1,level-1 do out:write(indentation) end\r\n   end\r\n   out:write(\"}\")\r\nend",
    "type": "function"
  }, {
    "id": 66,
    "text": "",
    "type": "function container"
  }, {
    "id": 67,
    "text": "function run(...)\r\n   local flags = util.parse_flags(...)\r\n   \r\n   local tree = flags[\"tree\"]\r\n\r\n   if type(tree) ~= \"string\" then\r\n      return nil, \"The --tree argument is mandatory. \"..util.see_help(\"purge\")\r\n   end\r\n   \r\n   local results = {}\r\n   local query = search.make_query(\"\")\r\n   query.exact_name = false\r\n   if not fs.is_dir(tree) then\r\n      return nil, \"Directory not found: \"..tree\r\n   end\r\n\r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n\r\n   search.manifest_search(results, path.rocks_dir(tree), query)\r\n\r\n   local sort = function(a,b) return deps.compare_versions(b,a) end\r\n   if flags[\"old-versions\"] then\r\n      sort = deps.compare_versions\r\n   end\r\n\r\n   for package, versions in util.sortedpairs(results) do\r\n      for version, repositories in util.sortedpairs(versions, sort) do\r\n         if flags[\"old-versions\"] then\r\n            util.printout(\"Keeping \"..package..\" \"..version..\"...\")\r\n            local ok, err = remove.remove_other_versions(package, version, flags[\"force\"])\r\n            if not ok then\r\n               util.printerr(err)\r\n            end\r\n            break\r\n         else\r\n            util.printout(\"Removing \"..package..\" \"..version..\"...\")\r\n            local ok, err = repos.delete_version(package, version, true)\r\n            if not ok then\r\n               util.printerr(err)\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return manif.make_manifest(cfg.rocks_dir, \"one\")\r\nend",
    "type": "function"
  }, {
    "id": 68,
    "text": "function run(...)\r\n   local flags = util.parse_flags(...)\r\n   local server, upload_server = cache.get_upload_server(flags[\"server\"])\r\n   if not server then return nil, upload_server end\r\n   local download_url = cache.get_server_urls(server, upload_server)\r\n   \r\n   local ok, err = cache.refresh_local_cache(server, download_url, cfg.upload_user, cfg.upload_password)\r\n   if not ok then\r\n      return nil, err\r\n   else\r\n      return true\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 69,
    "text": "local function delete_versions(name, versions) \r\n\r\n   for version, _ in pairs(versions) do\r\n      util.printout(\"Removing \"..name..\" \"..version..\"...\")\r\n      local ok, err = repos.delete_version(name, version)\r\n      if not ok then return nil, err end\r\n   end\r\n   \r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 70,
    "text": "function remove_search_results(results, name, deps_mode, force) \r\n   local versions = results[name]\r\n\r\n   local version = next(versions)\r\n   local second = next(versions, version)\r\n   \r\n   local dependents = {}\r\n   if force ~= \"fast\" then\r\n      util.printout(\"Checking stability of dependencies on the absence of\")\r\n      util.printout(name..\" \"..table.concat(util.keys(versions), \", \")..\"...\")\r\n      util.printout()\r\n      dependents = check_dependents(name, versions, deps_mode)\r\n   end\r\n   \r\n   if #dependents > 0 then\r\n      if force then\r\n         util.printerr(\"The following packages may be broken by this forced removal:\")\r\n         for _, dependent in ipairs(dependents) do\r\n            util.printerr(dependent.name..\" \"..dependent.version)\r\n         end\r\n         util.printerr()\r\n      else\r\n         if not second then\r\n            util.printerr(\"Will not remove \"..name..\" \"..version..\".\")\r\n            util.printerr(\"Removing it would break dependencies for: \")\r\n         else\r\n            util.printerr(\"Will not remove installed versions of \"..name..\".\")\r\n            util.printerr(\"Removing them would break dependencies for: \")\r\n         end\r\n         for _, dependent in ipairs(dependents) do\r\n            util.printerr(dependent.name..\" \"..dependent.version)\r\n         end\r\n         util.printerr()\r\n         util.printerr(\"Use --force to force removal (warning: this may break modules).\")\r\n         return nil, \"Failed removing.\"\r\n      end\r\n   end\r\n   \r\n   local ok, err = delete_versions(name, versions)\r\n   if not ok then return nil, err end\r\n   ok, err = manif.make_manifest(cfg.rocks_dir, deps_mode)\r\n   if not ok then return nil, err end\r\n\r\n   util.printout(\"Removal successful.\")\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 71,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   \r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing, see help.\"\r\n   end\r\n   \r\n   local deps_mode = flags[\"deps-mode\"] or cfg.deps_mode\r\n   \r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n   \r\n   local rock_type = name:match(\"%.(rock)$\") or name:match(\"%.(rockspec)$\")\r\n   local filename = name\r\n   if rock_type then\r\n      name, version = path.parse_name(filename)\r\n      if not name then return nil, \"Invalid \"..rock_type..\" filename: \"..filename end\r\n   end\r\n\r\n   local results = {}\r\n   search.manifest_search(results, cfg.rocks_dir, search.make_query(name, version))\r\n   if not results[name] then\r\n      return nil, \"Could not find rock '\"..name..(version and \" \"..version or \"\")..\"' in local tree.\"\r\n   end\r\n\r\n   return remove_search_results(results, name, deps_mode, flags[\"force\"])\r\nend",
    "type": "function"
  }, {
    "id": 72,
    "text": "",
    "type": "function container"
  }, {
    "id": 73,
    "text": "function run_hook(rockspec, hook_name)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(hook_name) == \"string\")\r\n\r\n   local hooks = rockspec.hooks\r\n   if not hooks then\r\n      return true\r\n   end\r\n   \r\n   if cfg.hooks_enabled == false then\r\n      return nil, \"This rockspec contains hooks, which are blocked by the 'hooks_enabled' setting in your LuaRocks configuration.\"\r\n   end\r\n   \r\n   if not hooks.substituted_variables then\r\n      util.variable_substitutions(hooks, rockspec.variables)\r\n      hooks.substituted_variables = true\r\n   end\r\n   local hook = hooks[hook_name]\r\n   if hook then\r\n      util.printout(hook)\r\n      if not fs.execute(hook) then\r\n         return nil, \"Failed running \"..hook_name..\" hook.\"\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 74,
    "text": "local function deploy_file_tree(file_tree, path_fn, deploy_dir, move_fn)\r\n      local source_dir = path_fn(name, version)\r\n      if not move_fn then\r\n         move_fn = fs.move\r\n      end\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local source = dir.path(source_dir, parent_path, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local ok, err\r\n            if fs.exists(target) then\r\n               local new_target, err = resolve_conflict(target, deploy_dir, name, version)\r\n               if err == \"untracked\" then\r\n                  local backup = target\r\n                  repeat\r\n                     backup = backup..\"~\"\r\n                  until not fs.exists(backup) -- slight race condition here, but shouldn't be a problem.\r\n                  util.printerr(\"Warning: \"..target..\" is not tracked by this installation of LuaRocks. Moving it to \"..backup)\r\n                  fs.move(target, backup)\r\n               elseif err then\r\n                  return nil, err..\" Cannot install new version.\"\r\n               else\r\n                  target = new_target\r\n               end\r\n            end\r\n            ok, err = fs.make_dir(dir.dir_name(target))\r\n            if not ok then return nil, err end\r\n            ok, err = move_fn(source, target, name, version)\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(source))\r\n            if not ok then return nil, err end\r\n            return true\r\n         end\r\n      )\r\n   end",
    "type": "function"
  }, {
    "id": 75,
    "text": "function search_repos(query)\r\n   assert(type(query) == \"table\")\r\n\r\n   local results = {}\r\n   for _, repo in ipairs(cfg.rocks_servers) do\r\n      if type(repo) == \"string\" then\r\n         repo = { repo }\r\n      end\r\n      for _, mirror in ipairs(repo) do\r\n         local protocol, pathname = dir.split_url(mirror)\r\n         if protocol == \"file\" then\r\n            mirror = pathname\r\n         end\r\n         local ok, err = manifest_search(results, mirror, query)\r\n         if ok then\r\n            break\r\n         else\r\n            util.warning(\"Failed searching manifest: \"..err)\r\n         end\r\n      end\r\n   end\r\n   -- search through rocks in cfg.rocks_provided\r\n   local provided_repo = \"provided by VM or rocks_provided\"\r\n   local name, versions\r\n   for name, versions in pairs(cfg.rocks_provided) do\r\n      store_if_match(results, provided_repo, name, versions, \"installed\", query)\r\n   end\r\n   return results\r\nend",
    "type": "function"
  }, {
    "id": 76,
    "text": "function print_results(results, porcelain)\r\n   assert(type(results) == \"table\")\r\n   assert(type(porcelain) == \"boolean\" or not porcelain)\r\n   \r\n   for package, versions in util.sortedpairs(results) do\r\n      if not porcelain then\r\n         util.printout(package)\r\n      end\r\n      for version, repos in util.sortedpairs(versions, deps.compare_versions) do\r\n         for _, repo in ipairs(repos) do\r\n            repo.repo = dir.normalize(repo.repo)\r\n            if porcelain then\r\n               util.printout(package, version, repo.arch, repo.repo)\r\n            else\r\n               util.printout(\"   \"..version..\" (\"..repo.arch..\") - \"..repo.repo)\r\n            end\r\n         end\r\n      end\r\n      if not porcelain then\r\n         util.printout()\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 77,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   \r\n   if flags[\"all\"] then\r\n      name, version = \"\", nil\r\n   end\r\n\r\n   if type(name) ~= \"string\" and not flags[\"all\"] then\r\n      return nil, \"Enter name and version or use --all. \"..util.see_help(\"search\")\r\n   end\r\n   \r\n   local query = make_query(name:lower(), version)\r\n   query.exact_name = false\r\n   local results, err = search_repos(query)\r\n   local porcelain = flags[\"porcelain\"]\r\n   util.title(\"Search results:\", porcelain, \"=\")\r\n   local sources, binaries = split_source_and_binary_results(results)\r\n   if next(sources) and not flags[\"binary\"] then\r\n      util.title(\"Rockspecs and source rocks:\", porcelain)\r\n      print_results(sources, porcelain)\r\n   end\r\n   if next(binaries) and not flags[\"source\"] then    \r\n      util.title(\"Binary and pure-Lua rocks:\", porcelain)\r\n      print_results(binaries, porcelain)\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 78,
    "text": "local function keys_as_string(t, sep)\r\n    return table.concat(util.keys(t), sep or \" \")\r\nend",
    "type": "function"
  }, {
    "id": 79,
    "text": "local function format_text(text)\r\n   text = text:gsub(\"^%s*\",\"\"):gsub(\"%s$\", \"\"):gsub(\"\\n[ \\t]+\",\"\\n\"):gsub(\"([^\\n])\\n([^\\n])\",\"%1 %2\")\r\n   local paragraphs = util.split_string(text, \"\\n\\n\")\r\n   for n, line in ipairs(paragraphs) do\r\n      paragraphs[n] = word_wrap(line)\r\n   end\r\n   return (table.concat(paragraphs, \"\\n\\n\"):gsub(\"%s$\", \"\"))\r\nend",
    "type": "function"
  }, {
    "id": 80,
    "text": "function pick_installed_rock(name, version, tree)\r\n   local results = {}\r\n   local query = search.make_query(name, version)\r\n   query.exact_name = true\r\n   local tree_map = {}\r\n   local trees = cfg.rocks_trees\r\n   if tree then\r\n      trees = { tree }\r\n   end\r\n   for _, tree in ipairs(trees) do\r\n      local rocks_dir = path.rocks_dir(tree)\r\n      tree_map[rocks_dir] = tree\r\n      search.manifest_search(results, rocks_dir, query)\r\n   end\r\n\r\n   if not next(results) then --\r\n      return nil,\"cannot find package \"..name..\" \"..(version or \"\")..\"\\nUse 'list' to find installed rocks.\"\r\n   end\r\n\r\n   version = nil\r\n   local repo_url\r\n   local package, versions = util.sortedpairs(results)()\r\n   --question: what do we do about multiple versions? This should\r\n   --give us the latest version on the last repo (which is usually the global one)\r\n   for vs, repositories in util.sortedpairs(versions, deps.compare_versions) do\r\n      if not version then version = vs end\r\n      for _, rp in ipairs(repositories) do repo_url = rp.repo end\r\n   end\r\n\r\n   local repo = tree_map[repo_url]\r\n   return name, version, repo, repo_url\r\nend",
    "type": "function"
  }, {
    "id": 81,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if not name then\r\n      return nil, \"Argument missing. \"..util.see_help(\"show\")\r\n   end\r\n   \r\n   local repo, repo_url\r\n   name, version, repo, repo_url = pick_installed_rock(name, version, flags[\"tree\"])\r\n   if not name then\r\n      return nil, version\r\n   end\r\n\r\n   local directory = path.install_dir(name,version,repo)\r\n   local rockspec_file = path.rockspec_file(name, version, repo)\r\n   local rockspec, err = fetch.load_local_rockspec(rockspec_file)\r\n   if not rockspec then return nil,err end\r\n\r\n   local descript = rockspec.description or {}\r\n   local manifest, err = manif.load_manifest(repo_url)\r\n   if not manifest then return nil,err end\r\n   local minfo = manifest.repository[name][version][1]\r\n\r\n   if flags[\"rock-tree\"] then util.printout(path.rocks_tree_to_string(repo))\r\n   elseif flags[\"rock-dir\"] then util.printout(directory)\r\n   elseif flags[\"home\"] then util.printout(descript.homepage)\r\n   elseif flags[\"modules\"] then util.printout(keys_as_string(minfo.modules))\r\n   elseif flags[\"deps\"] then util.printout(keys_as_string(minfo.dependencies))\r\n   elseif flags[\"rockspec\"] then util.printout(rockspec_file)\r\n   elseif flags[\"mversion\"] then util.printout(version)\r\n   else\r\n      util.printout()\r\n      util.printout(rockspec.package..\" \"..rockspec.version..\" - \"..(descript.summary or \"\"))\r\n      util.printout()\r\n      if descript.detailed then\r\n         util.printout(format_text(descript.detailed))\r\n         util.printout()\r\n      end\r\n      if descript.license then\r\n         util.printout(\"License: \", descript.license)\r\n      end\r\n      if descript.homepage then\r\n         util.printout(\"Homepage: \", descript.homepage)\r\n      end\r\n      util.printout(\"Installed in: \", path.rocks_tree_to_string(repo))\r\n      if next(minfo.modules) then\r\n         util.printout()\r\n         util.printout(\"Modules:\")\r\n         for mod, filename in util.sortedpairs(minfo.modules) do\r\n            util.printout(\"\\t\"..mod..\" (\"..path.which(mod, filename, name, version, repo, manifest)..\")\")\r\n         end\r\n      end\r\n      if next(minfo.dependencies) then\r\n         util.printout()\r\n         util.printout(\"Depends on:\")\r\n         util.printout(\"\\t\"..keys_as_string(minfo.dependencies, \"\\n\\t\"))\r\n      end\r\n      util.printout()\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 82,
    "text": "function read_patch(filename, data)\r\n  -- define possible file regions that will direct the parser flow\r\n  local state = 'header'\r\n    -- 'header'    - comments before the patch body\r\n    -- 'filenames' - lines starting with --- and +++\r\n    -- 'hunkhead'  - @@ -R +R @@ sequence\r\n    -- 'hunkbody'\r\n    -- 'hunkskip'  - skipping invalid hunk mode\r\n\r\n  local all_ok = true\r\n  local lineends = {lf=0, crlf=0, cr=0}\r\n  local files = {source={}, target={}, hunks={}, fileends={}, hunkends={}}\r\n  local nextfileno = 0\r\n  local nexthunkno = 0    --: even if index starts with 0 user messages\r\n                          --  number hunks from 1\r\n\r\n  -- hunkinfo holds parsed values, hunkactual - calculated\r\n  local hunkinfo = {\r\n    startsrc=nil, linessrc=nil, starttgt=nil, linestgt=nil,\r\n    invalid=false, text={}\r\n  }\r\n  local hunkactual = {linessrc=nil, linestgt=nil}\r\n\r\n  info(format(\"reading patch %s\", filename))\r\n\r\n  local fp\r\n  if data then\r\n    fp = string_as_file(data)\r\n  else\r\n    fp = filename == '-' and io.stdin or assert(io.open(filename, \"rb\"))\r\n  end\r\n  local lineno = 0\r\n\r\n  for line in file_lines(fp) do\r\n    lineno = lineno + 1\r\n    if state == 'header' then\r\n      if startswith(line, \"--- \") then\r\n        state = 'filenames'\r\n      end\r\n      -- state is 'header' or 'filenames'\r\n    end\r\n    if state == 'hunkbody' then\r\n      -- skip hunkskip and hunkbody code until definition of hunkhead read\r\n\r\n      -- process line first\r\n      if line:match\"^[- +\\\\]\" or line:match\"^[\\r\\n]*$\" then\r\n          -- gather stats about line endings\r\n          local he = files.hunkends[nextfileno]\r\n          if endswith(line, \"\\r\\n\") then\r\n            he.crlf = he.crlf + 1\r\n          elseif endswith(line, \"\\n\") then\r\n            he.lf = he.lf + 1\r\n          elseif endswith(line, \"\\r\") then\r\n            he.cr = he.cr + 1\r\n          end\r\n          if startswith(line, \"-\") then\r\n            hunkactual.linessrc = hunkactual.linessrc + 1\r\n          elseif startswith(line, \"+\") then\r\n            hunkactual.linestgt = hunkactual.linestgt + 1\r\n          elseif startswith(line, \"\\\\\") then\r\n            -- nothing\r\n          else\r\n            hunkactual.linessrc = hunkactual.linessrc + 1\r\n            hunkactual.linestgt = hunkactual.linestgt + 1\r\n          end\r\n          table.insert(hunkinfo.text, line)\r\n          -- todo: handle \\ No newline cases\r\n      else\r\n          warning(format(\"invalid hunk no.%d at %d for target file %s\",\r\n                         nexthunkno, lineno, files.target[nextfileno]))\r\n          -- add hunk status node\r\n          table.insert(files.hunks[nextfileno], table_copy(hunkinfo))\r\n          files.hunks[nextfileno][nexthunkno].invalid = true\r\n          all_ok = false\r\n          state = 'hunkskip'\r\n      end\r\n\r\n      -- check exit conditions\r\n      if hunkactual.linessrc > hunkinfo.linessrc or\r\n         hunkactual.linestgt > hunkinfo.linestgt\r\n      then\r\n          warning(format(\"extra hunk no.%d lines at %d for target %s\",\r\n                         nexthunkno, lineno, files.target[nextfileno]))\r\n          -- add hunk status node\r\n          table.insert(files.hunks[nextfileno], table_copy(hunkinfo))\r\n          files.hunks[nextfileno][nexthunkno].invalid = true\r\n          state = 'hunkskip'\r\n      elseif hunkinfo.linessrc == hunkactual.linessrc and\r\n             hunkinfo.linestgt == hunkactual.linestgt\r\n      then\r\n          table.insert(files.hunks[nextfileno], table_copy(hunkinfo))\r\n          state = 'hunkskip'\r\n\r\n          -- detect mixed window/unix line ends\r\n          local ends = files.hunkends[nextfileno]\r\n          if (ends.cr~=0 and 1 or 0) + (ends.crlf~=0 and 1 or 0) +\r\n             (ends.lf~=0 and 1 or 0) > 1\r\n          then\r\n            warning(format(\"inconsistent line ends in patch hunks for %s\",\r\n                    files.source[nextfileno]))\r\n          end\r\n          if debugmode then\r\n            local debuglines = {crlf=ends.crlf, lf=ends.lf, cr=ends.cr,\r\n                  file=files.target[nextfileno], hunk=nexthunkno}\r\n            debug(format(\"crlf: %(crlf)d  lf: %(lf)d  cr: %(cr)d\\t \" ..\r\n                         \"- file: %(file)s hunk: %(hunk)d\", debuglines))\r\n          end\r\n      end\r\n      -- state is 'hunkbody' or 'hunkskip'\r\n    end\r\n\r\n    if state == 'hunkskip' then\r\n      if match_linerange(line) then\r\n        state = 'hunkhead'\r\n      elseif startswith(line, \"--- \") then\r\n        state = 'filenames'\r\n        if debugmode and #files.source > 0 then\r\n            debug(format(\"- %2d hunks for %s\", #files.hunks[nextfileno],\r\n                         files.source[nextfileno]))\r\n        end\r\n      end\r\n      -- state is 'hunkskip', 'hunkhead', or 'filenames'\r\n    end\r\n    local advance\r\n    if state == 'filenames' then\r\n      if startswith(line, \"--- \") then\r\n        if util.array_contains(files.source, nextfileno) then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid patch for %s\",\r\n                         files.source[nextfileno+1]))\r\n          table.remove(files.source, nextfileno+1)\r\n          -- double source filename line is encountered\r\n          -- attempt to restart from this second line\r\n        end\r\n        -- Accept a space as a terminator, like GNU patch does.\r\n        -- Breaks patches containing filenames with spaces...\r\n        -- FIXME Figure out what does GNU patch do in those cases.\r\n        local match = line:match(\"^%-%-%- ([^ \\t\\r\\n]+)\")\r\n        if not match then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid filename at line %d\", lineno+1))\r\n          state = 'header'\r\n        else\r\n          table.insert(files.source, match)\r\n        end\r\n      elseif not startswith(line, \"+++ \") then\r\n        if util.array_contains(files.source, nextfileno) then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid patch with no target for %s\",\r\n                         files.source[nextfileno+1]))\r\n          table.remove(files.source, nextfileno+1)\r\n        else\r\n          -- this should be unreachable\r\n          warning(\"skipping invalid target patch\")\r\n        end\r\n        state = 'header'\r\n      else\r\n        if util.array_contains(files.target, nextfileno) then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid patch - double target at line %d\",\r\n                         lineno+1))\r\n          table.remove(files.source, nextfileno+1)\r\n          table.remove(files.target, nextfileno+1)\r\n          nextfileno = nextfileno - 1\r\n          -- double target filename line is encountered\r\n          -- switch back to header state\r\n          state = 'header'\r\n        else\r\n          -- Accept a space as a terminator, like GNU patch does.\r\n          -- Breaks patches containing filenames with spaces...\r\n          -- FIXME Figure out what does GNU patch do in those cases.\r\n          local re_filename = \"^%+%+%+ ([^ \\t\\r\\n]+)\"\r\n          local match = line:match(re_filename)\r\n          if not match then\r\n            all_ok = false\r\n            warning(format(\r\n              \"skipping invalid patch - no target filename at line %d\",\r\n              lineno+1))\r\n            state = 'header'\r\n          else\r\n            table.insert(files.target, match)\r\n            nextfileno = nextfileno + 1\r\n            nexthunkno = 0\r\n            table.insert(files.hunks, {})\r\n            table.insert(files.hunkends, table_copy(lineends))\r\n            table.insert(files.fileends, table_copy(lineends))\r\n            state = 'hunkhead'\r\n            advance = true\r\n          end\r\n        end\r\n      end\r\n      -- state is 'filenames', 'header', or ('hunkhead' with advance)\r\n    end\r\n    if not advance and state == 'hunkhead' then\r\n      local m1, m2, m3, m4 = match_linerange(line)\r\n      if not m1 then\r\n        if not util.array_contains(files.hunks, nextfileno-1) then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid patch with no hunks for file %s\",\r\n                         files.target[nextfileno]))\r\n        end\r\n        state = 'header'\r\n      else\r\n        hunkinfo.startsrc = tonumber(m1)\r\n        hunkinfo.linessrc = tonumber(m2 or 1)\r\n        hunkinfo.starttgt = tonumber(m3)\r\n        hunkinfo.linestgt = tonumber(m4 or 1)\r\n        hunkinfo.invalid = false\r\n        hunkinfo.text = {}\r\n\r\n        hunkactual.linessrc = 0\r\n        hunkactual.linestgt = 0\r\n\r\n        state = 'hunkbody'\r\n        nexthunkno = nexthunkno + 1\r\n      end\r\n      -- state is 'header' or 'hunkbody'\r\n    end\r\n  end\r\n  if state ~= 'hunkskip' then\r\n    warning(format(\"patch file incomplete - %s\", filename))\r\n    all_ok = false\r\n    -- os.exit(?)\r\n  else\r\n    -- duplicated message when an eof is reached\r\n    if debugmode and #files.source > 0 then\r\n      debug(format(\"- %2d hunks for %s\", #files.hunks[nextfileno],\r\n                   files.source[nextfileno]))\r\n    end\r\n  end\r\n\r\n  local sum = 0; for _,hset in ipairs(files.hunks) do sum = sum + #hset end\r\n  info(format(\"total files: %d  total hunks: %d\", #files.source, sum))\r\n  fp:close()\r\n  return files, all_ok\r\nend",
    "type": "function"
  }, {
    "id": 83,
    "text": "function untar(filename, destdir)\r\n   assert(type(filename) == \"string\")\r\n   assert(type(destdir) == \"string\")\r\n\r\n   local tar_handle = io.open(filename, \"r\")\r\n   if not tar_handle then return nil, \"Error opening file \"..filename end\r\n   \r\n   local long_name, long_link_name\r\n   while true do\r\n      local block\r\n      repeat \r\n         block = tar_handle:read(blocksize)\r\n      until (not block) or checksum_header(block) > 256\r\n      if not block then break end\r\n      local header, err = read_header_block(block)\r\n      if not header then\r\n         util.printerr(err)\r\n      end\r\n\r\n      local file_data = tar_handle:read(math.ceil(header.size / blocksize) * blocksize):sub(1,header.size)\r\n\r\n      if header.typeflag == \"long name\" then\r\n         long_name = nullterm(file_data)\r\n      elseif header.typeflag == \"long link name\" then\r\n         long_link_name = nullterm(file_data)\r\n      else\r\n         if long_name then\r\n            header.name = long_name\r\n            long_name = nil\r\n         end\r\n         if long_link_name then\r\n            header.name = long_link_name\r\n            long_link_name = nil\r\n         end\r\n      end\r\n      local pathname = dir.path(destdir, header.name)\r\n      if header.typeflag == \"directory\" then\r\n         local ok, err = fs.make_dir(pathname)\r\n         if not ok then return nil, err end\r\n      elseif header.typeflag == \"file\" then\r\n         local dirname = dir.dir_name(pathname)\r\n         if dirname ~= \"\" then\r\n            local ok, err = fs.make_dir(dirname)\r\n            if not ok then return nil, err end\r\n         end\r\n         local file_handle = io.open(pathname, \"wb\")\r\n         file_handle:write(file_data)\r\n         file_handle:close()\r\n         fs.set_time(pathname, header.mtime)\r\n         if fs.chmod then\r\n            fs.chmod(pathname, header.mode)\r\n         end\r\n      end\r\n      --[[\r\n      for k,v in pairs(header) do\r\n         util.printout(\"[\\\"\"..tostring(k)..\"\\\"] = \"..(type(v)==\"number\" and v or \"\\\"\"..v:gsub(\"%z\", \"\\\\0\")..\"\\\"\"))\r\n      end\r\n      util.printout()\r\n      --]]\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 84,
    "text": "local function run_unpacker(file, force)\r\n   assert(type(file) == \"string\")\r\n   \r\n   local base_name = dir.base_name(file)\r\n   local dir_name, kind, extension = base_name:match(\"(.*)%.([^.]+)%.(rock)$\")\r\n   if not extension then\r\n      dir_name, extension = base_name:match(\"(.*)%.(rockspec)$\")\r\n      kind = \"rockspec\"\r\n   end\r\n   if not extension then\r\n      return nil, file..\" does not seem to be a valid filename.\"\r\n   end\r\n\r\n   local exists = fs.exists(dir_name)\r\n   if exists and not force then\r\n      return nil, \"Directory \"..dir_name..\" already exists.\"\r\n   end\r\n   if not exists then\r\n      local ok, err = fs.make_dir(dir_name)\r\n      if not ok then return nil, err end\r\n   end\r\n   local rollback = util.schedule_function(fs.delete, fs.absolute_name(dir_name))\r\n\r\n   local rockspec, err\r\n   if extension == \"rock\" then\r\n      rockspec, err = unpack_rock(file, dir_name, kind)\r\n   elseif extension == \"rockspec\" then\r\n      rockspec, err = unpack_rockspec(file, dir_name)\r\n   end\r\n   if not rockspec then\r\n      return nil, err\r\n   end\r\n   if kind == \"src\" or kind == \"rockspec\" then\r\n      if rockspec.source.dir ~= \".\" then\r\n         local ok = fs.copy(rockspec.local_filename, rockspec.source.dir)\r\n         if not ok then\r\n            return nil, \"Failed copying unpacked rockspec into unpacked source directory.\"\r\n         end\r\n      end\r\n      util.printout()   \r\n      util.printout(\"Done. You may now enter directory \")\r\n      util.printout(dir.path(dir_name, rockspec.source.dir))\r\n      util.printout(\"and type 'luarocks make' to build.\")\r\n   end\r\n   util.remove_scheduled_function(rollback)\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 85,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n\r\n   assert(type(version) == \"string\" or not version)\r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"unpack\")\r\n   end\r\n\r\n   if name:match(\".*%.rock\") or name:match(\".*%.rockspec\") then\r\n      return run_unpacker(name, flags[\"force\"])\r\n   else\r\n      local search = require(\"luarocks.search\")\r\n      return search.act_on_src_or_rockspec(run_unpacker, name, version)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 86,
    "text": "function schedule_function(f, ...)\r\n   assert(type(f) == \"function\")\r\n   \r\n   local item = { fn = f, args = {...} }\r\n   table.insert(scheduled_functions, item)\r\n   return item\r\nend",
    "type": "function"
  }, {
    "id": 87,
    "text": "assert(type(f) == \"function\")",
    "type": "statement:functioncall"
  }, {
    "id": 88,
    "text": "local item = { fn = f, args = {...} }",
    "type": "statement:localassign"
  }, {
    "id": 89,
    "text": "table.insert(scheduled_functions, item)",
    "type": "statement:functioncall"
  }, {
    "id": 90,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 91,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 92,
    "text": "function remove_scheduled_function(item)\r\n   for k, v in pairs(scheduled_functions) do\r\n      if v == item then\r\n         table.remove(scheduled_functions, k)\r\n         return\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 93,
    "text": "for k, v in pairs(scheduled_functions) do\r\n      if v == item then\r\n         table.remove(scheduled_functions, k)\r\n         return\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 94,
    "text": "if v == item then\r\n         table.remove(scheduled_functions, k)\r\n         return\r\n      end",
    "type": "statement:if"
  }, {
    "id": 95,
    "text": "table.remove(scheduled_functions, k)",
    "type": "statement:functioncall"
  }, {
    "id": 96,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 97,
    "text": "function run_scheduled_functions()\r\n   local fs = require(\"luarocks.fs\")\r\n   fs.change_dir_to_root()\r\n   for i = #scheduled_functions, 1, -1 do\r\n      local item = scheduled_functions[i]\r\n      item.fn(unpack(item.args))\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 98,
    "text": "local fs = require(\"luarocks.fs\")",
    "type": "statement:localassign"
  }, {
    "id": 99,
    "text": "fs.change_dir_to_root()",
    "type": "statement:functioncall"
  }, {
    "id": 100,
    "text": "for i = #scheduled_functions, 1, -1 do\r\n      local item = scheduled_functions[i]\r\n      item.fn(unpack(item.args))\r\n   end",
    "type": "statement:numericfor"
  }, {
    "id": 101,
    "text": "local item = scheduled_functions[i]",
    "type": "statement:localassign"
  }, {
    "id": 102,
    "text": "item.fn(unpack(item.args))",
    "type": "statement:functioncall"
  }, {
    "id": 103,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 104,
    "text": "function matchquote(s)\r\n   return (s:gsub(\"[?%-+*%[%].%%()$^]\",\"%%%1\"))\r\nend",
    "type": "function"
  }, {
    "id": 105,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 106,
    "text": "function parse_flags(...)\r\n   local args = {...}\r\n   local flags = {}\r\n   for i = #args, 1, -1 do\r\n      local flag = args[i]:match(\"^%-%-(.*)\")\r\n      if flag then\r\n         local var,val = flag:match(\"([a-z_%-]*)=(.*)\")\r\n         if val then\r\n            flags[var] = val\r\n         else\r\n            flags[flag] = true\r\n         end\r\n         table.remove(args, i)\r\n      end\r\n   end\r\n   return flags, unpack(args)\r\nend",
    "type": "function"
  }, {
    "id": 107,
    "text": "local args = {...}",
    "type": "statement:localassign"
  }, {
    "id": 108,
    "text": "local flags = {}",
    "type": "statement:localassign"
  }, {
    "id": 109,
    "text": "for i = #args, 1, -1 do\r\n      local flag = args[i]:match(\"^%-%-(.*)\")\r\n      if flag then\r\n         local var,val = flag:match(\"([a-z_%-]*)=(.*)\")\r\n         if val then\r\n            flags[var] = val\r\n         else\r\n            flags[flag] = true\r\n         end\r\n         table.remove(args, i)\r\n      end\r\n   end",
    "type": "statement:numericfor"
  }, {
    "id": 110,
    "text": "local flag = args[i]:match(\"^%-%-(.*)\")",
    "type": "statement:localassign"
  }, {
    "id": 111,
    "text": "if flag then\r\n         local var,val = flag:match(\"([a-z_%-]*)=(.*)\")\r\n         if val then\r\n            flags[var] = val\r\n         else\r\n            flags[flag] = true\r\n         end\r\n         table.remove(args, i)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 112,
    "text": "local var,val = flag:match(\"([a-z_%-]*)=(.*)\")",
    "type": "statement:localassign"
  }, {
    "id": 113,
    "text": "if val then\r\n            flags[var] = val\r\n         else\r\n            flags[flag] = true\r\n         end",
    "type": "statement:if"
  }, {
    "id": 114,
    "text": "flags[var] = val",
    "type": "statement:assign"
  }, {
    "id": 115,
    "text": "flags[flag] = true",
    "type": "statement:assign"
  }, {
    "id": 116,
    "text": "table.remove(args, i)",
    "type": "statement:functioncall"
  }, {
    "id": 117,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 118,
    "text": "function forward_flags(flags, ...)\r\n   assert(type(flags) == \"table\")\r\n   local out = {}\r\n   local filter = select('#', ...)\r\n   local function add_flag(flagname)\r\n      if flags[flagname] then\r\n         if flags[flagname] == true then\r\n            table.insert(out, \"--\"..flagname)\r\n         else\r\n            table.insert(out, \"--\"..flagname..\"=\"..flags[flagname])\r\n         end\r\n      end\r\n   end\r\n   if filter > 0 then\r\n      for i = 1, filter do\r\n         add_flag(select(i, ...))\r\n      end\r\n   else\r\n      for flagname, _ in pairs(flags) do\r\n         add_flag(flagname)\r\n      end\r\n   end\r\n   return unpack(out)\r\nend",
    "type": "function"
  }, {
    "id": 119,
    "text": "assert(type(flags) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 120,
    "text": "local out = {}",
    "type": "statement:localassign"
  }, {
    "id": 121,
    "text": "local filter = select('#', ...)",
    "type": "statement:localassign"
  }, {
    "id": 122,
    "text": "local function add_flag(flagname)\r\n      if flags[flagname] then\r\n         if flags[flagname] == true then\r\n            table.insert(out, \"--\"..flagname)\r\n         else\r\n            table.insert(out, \"--\"..flagname..\"=\"..flags[flagname])\r\n         end\r\n      end\r\n   end",
    "type": "statement:localfunction"
  }, {
    "id": 123,
    "text": "if flags[flagname] then\r\n         if flags[flagname] == true then\r\n            table.insert(out, \"--\"..flagname)\r\n         else\r\n            table.insert(out, \"--\"..flagname..\"=\"..flags[flagname])\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 124,
    "text": "if flags[flagname] == true then\r\n            table.insert(out, \"--\"..flagname)\r\n         else\r\n            table.insert(out, \"--\"..flagname..\"=\"..flags[flagname])\r\n         end",
    "type": "statement:if"
  }, {
    "id": 125,
    "text": "table.insert(out, \"--\"..flagname)",
    "type": "statement:functioncall"
  }, {
    "id": 126,
    "text": "table.insert(out, \"--\"..flagname..\"=\"..flags[flagname])",
    "type": "statement:functioncall"
  }, {
    "id": 127,
    "text": "if filter > 0 then\r\n      for i = 1, filter do\r\n         add_flag(select(i, ...))\r\n      end\r\n   else\r\n      for flagname, _ in pairs(flags) do\r\n         add_flag(flagname)\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 128,
    "text": "for i = 1, filter do\r\n         add_flag(select(i, ...))\r\n      end",
    "type": "statement:numericfor"
  }, {
    "id": 129,
    "text": "add_flag(select(i, ...))",
    "type": "statement:functioncall"
  }, {
    "id": 130,
    "text": "for flagname, _ in pairs(flags) do\r\n         add_flag(flagname)\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 131,
    "text": "add_flag(flagname)",
    "type": "statement:functioncall"
  }, {
    "id": 132,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 133,
    "text": "local function add_flag(flagname)\r\n      if flags[flagname] then\r\n         if flags[flagname] == true then\r\n            table.insert(out, \"--\"..flagname)\r\n         else\r\n            table.insert(out, \"--\"..flagname..\"=\"..flags[flagname])\r\n         end\r\n      end\r\n   end",
    "type": "function"
  }, {
    "id": 134,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 135,
    "text": "function deep_merge(dst, src)\r\n   for k, v in pairs(src) do\r\n      if type(v) == \"table\" then\r\n         if not dst[k] then\r\n            dst[k] = {}\r\n         end\r\n         if type(dst[k]) == \"table\" then\r\n            deep_merge(dst[k], v)\r\n         else\r\n            dst[k] = v\r\n         end\r\n      else\r\n         dst[k] = v\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 136,
    "text": "for k, v in pairs(src) do\r\n      if type(v) == \"table\" then\r\n         if not dst[k] then\r\n            dst[k] = {}\r\n         end\r\n         if type(dst[k]) == \"table\" then\r\n            deep_merge(dst[k], v)\r\n         else\r\n            dst[k] = v\r\n         end\r\n      else\r\n         dst[k] = v\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 137,
    "text": "if type(v) == \"table\" then\r\n         if not dst[k] then\r\n            dst[k] = {}\r\n         end\r\n         if type(dst[k]) == \"table\" then\r\n            deep_merge(dst[k], v)\r\n         else\r\n            dst[k] = v\r\n         end\r\n      else\r\n         dst[k] = v\r\n      end",
    "type": "statement:if"
  }, {
    "id": 138,
    "text": "if not dst[k] then\r\n            dst[k] = {}\r\n         end",
    "type": "statement:if"
  }, {
    "id": 139,
    "text": "dst[k] = {}",
    "type": "statement:assign"
  }, {
    "id": 140,
    "text": "if type(dst[k]) == \"table\" then\r\n            deep_merge(dst[k], v)\r\n         else\r\n            dst[k] = v\r\n         end",
    "type": "statement:if"
  }, {
    "id": 141,
    "text": "deep_merge(dst[k], v)",
    "type": "statement:functioncall"
  }, {
    "id": 142,
    "text": "dst[k] = v",
    "type": "statement:assign"
  }, {
    "id": 143,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 144,
    "text": "function platform_overrides(tbl)\r\n   assert(type(tbl) == \"table\" or not tbl)\r\n   \r\n   local cfg = require(\"luarocks.cfg\")\r\n   \r\n   if not tbl then return end\r\n   \r\n   if tbl.platforms then\r\n      for _, platform in ipairs(cfg.platforms) do\r\n         local platform_tbl = tbl.platforms[platform]\r\n         if platform_tbl then\r\n            deep_merge(tbl, platform_tbl)\r\n         end\r\n      end\r\n   end\r\n   tbl.platforms = nil\r\nend",
    "type": "function"
  }, {
    "id": 145,
    "text": "assert(type(tbl) == \"table\" or not tbl)",
    "type": "statement:functioncall"
  }, {
    "id": 146,
    "text": "local cfg = require(\"luarocks.cfg\")",
    "type": "statement:localassign"
  }, {
    "id": 147,
    "text": "if not tbl then return end",
    "type": "statement:if"
  }, {
    "id": 148,
    "text": "if tbl.platforms then\r\n      for _, platform in ipairs(cfg.platforms) do\r\n         local platform_tbl = tbl.platforms[platform]\r\n         if platform_tbl then\r\n            deep_merge(tbl, platform_tbl)\r\n         end\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 149,
    "text": "for _, platform in ipairs(cfg.platforms) do\r\n         local platform_tbl = tbl.platforms[platform]\r\n         if platform_tbl then\r\n            deep_merge(tbl, platform_tbl)\r\n         end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 150,
    "text": "local platform_tbl = tbl.platforms[platform]",
    "type": "statement:localassign"
  }, {
    "id": 151,
    "text": "if platform_tbl then\r\n            deep_merge(tbl, platform_tbl)\r\n         end",
    "type": "statement:if"
  }, {
    "id": 152,
    "text": "deep_merge(tbl, platform_tbl)",
    "type": "statement:functioncall"
  }, {
    "id": 153,
    "text": "tbl.platforms = nil",
    "type": "statement:assign"
  }, {
    "id": 154,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 155,
    "text": "local function make_shallow_copy(tbl)\r\n   local copy = {}\r\n   for k,v in pairs(tbl) do\r\n      copy[k] = v\r\n   end\r\n   return copy\r\nend",
    "type": "function"
  }, {
    "id": 156,
    "text": "local copy = {}",
    "type": "statement:localassign"
  }, {
    "id": 157,
    "text": "for k,v in pairs(tbl) do\r\n      copy[k] = v\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 158,
    "text": "copy[k] = v",
    "type": "statement:assign"
  }, {
    "id": 159,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 160,
    "text": "function warn_if_not_used(var_defs, needed_set, msg)\r\n   needed_set = make_shallow_copy(needed_set)\r\n   for var,val in pairs(var_defs) do\r\n      for used in val:gmatch(var_format_pattern) do\r\n         needed_set[used] = nil\r\n      end\r\n   end\r\n   for var,_ in pairs(needed_set) do\r\n      warning(msg:format(var))\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 161,
    "text": "needed_set = make_shallow_copy(needed_set)",
    "type": "statement:assign"
  }, {
    "id": 162,
    "text": "for var,val in pairs(var_defs) do\r\n      for used in val:gmatch(var_format_pattern) do\r\n         needed_set[used] = nil\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 163,
    "text": "for used in val:gmatch(var_format_pattern) do\r\n         needed_set[used] = nil\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 164,
    "text": "needed_set[used] = nil",
    "type": "statement:assign"
  }, {
    "id": 165,
    "text": "for var,_ in pairs(needed_set) do\r\n      warning(msg:format(var))\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 166,
    "text": "warning(msg:format(var))",
    "type": "statement:functioncall"
  }, {
    "id": 167,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 168,
    "text": "local function warn_failed_matches(line)\r\n   local any_failed = false\r\n   if line:match(var_format_pattern) then\r\n      for unmatched in line:gmatch(var_format_pattern) do\r\n         warning(\"unmatched variable \" .. unmatched)\r\n         any_failed = true\r\n      end\r\n   end\r\n   return any_failed\r\nend",
    "type": "function"
  }, {
    "id": 169,
    "text": "local any_failed = false",
    "type": "statement:localassign"
  }, {
    "id": 170,
    "text": "if line:match(var_format_pattern) then\r\n      for unmatched in line:gmatch(var_format_pattern) do\r\n         warning(\"unmatched variable \" .. unmatched)\r\n         any_failed = true\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 171,
    "text": "for unmatched in line:gmatch(var_format_pattern) do\r\n         warning(\"unmatched variable \" .. unmatched)\r\n         any_failed = true\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 172,
    "text": "warning(\"unmatched variable \" .. unmatched)",
    "type": "statement:functioncall"
  }, {
    "id": 173,
    "text": "any_failed = true",
    "type": "statement:assign"
  }, {
    "id": 174,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 175,
    "text": "function variable_substitutions(tbl, vars)\r\n   assert(type(tbl) == \"table\")\r\n   assert(type(vars) == \"table\")\r\n   \r\n   local updated = {}\r\n   for k, v in pairs(tbl) do\r\n      if type(v) == \"string\" then\r\n         updated[k] = v:gsub(var_format_pattern, vars)\r\n         if warn_failed_matches(updated[k]) then\r\n            updated[k] = updated[k]:gsub(var_format_pattern, \"\")\r\n         end\r\n      end\r\n   end\r\n   for k, v in pairs(updated) do\r\n      tbl[k] = v\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 176,
    "text": "assert(type(tbl) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 177,
    "text": "assert(type(vars) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 178,
    "text": "local updated = {}",
    "type": "statement:localassign"
  }, {
    "id": 179,
    "text": "for k, v in pairs(tbl) do\r\n      if type(v) == \"string\" then\r\n         updated[k] = v:gsub(var_format_pattern, vars)\r\n         if warn_failed_matches(updated[k]) then\r\n            updated[k] = updated[k]:gsub(var_format_pattern, \"\")\r\n         end\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 180,
    "text": "if type(v) == \"string\" then\r\n         updated[k] = v:gsub(var_format_pattern, vars)\r\n         if warn_failed_matches(updated[k]) then\r\n            updated[k] = updated[k]:gsub(var_format_pattern, \"\")\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 181,
    "text": "updated[k] = v:gsub(var_format_pattern, vars)",
    "type": "statement:assign"
  }, {
    "id": 182,
    "text": "if warn_failed_matches(updated[k]) then\r\n            updated[k] = updated[k]:gsub(var_format_pattern, \"\")\r\n         end",
    "type": "statement:if"
  }, {
    "id": 183,
    "text": "updated[k] = updated[k]:gsub(var_format_pattern, \"\")",
    "type": "statement:assign"
  }, {
    "id": 184,
    "text": "for k, v in pairs(updated) do\r\n      tbl[k] = v\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 185,
    "text": "tbl[k] = v",
    "type": "statement:assign"
  }, {
    "id": 186,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 187,
    "text": "function keys(tbl)\r\n   local ks = {}\r\n   for k,_ in pairs(tbl) do\r\n      table.insert(ks, k)\r\n   end\r\n   return ks\r\nend",
    "type": "function"
  }, {
    "id": 188,
    "text": "local ks = {}",
    "type": "statement:localassign"
  }, {
    "id": 189,
    "text": "for k,_ in pairs(tbl) do\r\n      table.insert(ks, k)\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 190,
    "text": "table.insert(ks, k)",
    "type": "statement:functioncall"
  }, {
    "id": 191,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 192,
    "text": "local function default_sort(a, b)\r\n   local ta = type(a)\r\n   local tb = type(b)\r\n   if ta == \"number\" and tb == \"number\" then\r\n      return a < b\r\n   elseif ta == \"number\" then\r\n      return true\r\n   elseif tb == \"number\" then\r\n      return false\r\n   else\r\n      return tostring(a) < tostring(b)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 193,
    "text": "local ta = type(a)",
    "type": "statement:localassign"
  }, {
    "id": 194,
    "text": "local tb = type(b)",
    "type": "statement:localassign"
  }, {
    "id": 195,
    "text": "if ta == \"number\" and tb == \"number\" then\r\n      return a < b\r\n   elseif ta == \"number\" then\r\n      return true\r\n   elseif tb == \"number\" then\r\n      return false\r\n   else\r\n      return tostring(a) < tostring(b)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 196,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 197,
    "text": "local function sortedpairs_iterator(tbl, sort_function)\r\n   local ks = keys(tbl)\r\n   if not sort_function or type(sort_function) == \"function\" then\r\n      table.sort(ks, sort_function or default_sort)\r\n      for _, k in ipairs(ks) do\r\n         coroutine.yield(k, tbl[k])\r\n      end\r\n   else\r\n      local order = sort_function\r\n      local done = {}\r\n      for _, k in ipairs(order) do\r\n         local sub_order\r\n         if type(k) == \"table\" then\r\n            sub_order = k[2]\r\n            k = k[1]\r\n         end\r\n         if tbl[k] then\r\n            done[k] = true\r\n            coroutine.yield(k, tbl[k], sub_order)\r\n         end\r\n      end\r\n      table.sort(ks, default_sort)\r\n      for _, k in ipairs(ks) do\r\n         if not done[k] then\r\n            coroutine.yield(k, tbl[k])\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 198,
    "text": "local ks = keys(tbl)",
    "type": "statement:localassign"
  }, {
    "id": 199,
    "text": "if not sort_function or type(sort_function) == \"function\" then\r\n      table.sort(ks, sort_function or default_sort)\r\n      for _, k in ipairs(ks) do\r\n         coroutine.yield(k, tbl[k])\r\n      end\r\n   else\r\n      local order = sort_function\r\n      local done = {}\r\n      for _, k in ipairs(order) do\r\n         local sub_order\r\n         if type(k) == \"table\" then\r\n            sub_order = k[2]\r\n            k = k[1]\r\n         end\r\n         if tbl[k] then\r\n            done[k] = true\r\n            coroutine.yield(k, tbl[k], sub_order)\r\n         end\r\n      end\r\n      table.sort(ks, default_sort)\r\n      for _, k in ipairs(ks) do\r\n         if not done[k] then\r\n            coroutine.yield(k, tbl[k])\r\n         end\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 200,
    "text": "table.sort(ks, sort_function or default_sort)",
    "type": "statement:functioncall"
  }, {
    "id": 201,
    "text": "for _, k in ipairs(ks) do\r\n         coroutine.yield(k, tbl[k])\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 202,
    "text": "coroutine.yield(k, tbl[k])",
    "type": "statement:functioncall"
  }, {
    "id": 203,
    "text": "local order = sort_function",
    "type": "statement:localassign"
  }, {
    "id": 204,
    "text": "local done = {}",
    "type": "statement:localassign"
  }, {
    "id": 205,
    "text": "for _, k in ipairs(order) do\r\n         local sub_order\r\n         if type(k) == \"table\" then\r\n            sub_order = k[2]\r\n            k = k[1]\r\n         end\r\n         if tbl[k] then\r\n            done[k] = true\r\n            coroutine.yield(k, tbl[k], sub_order)\r\n         end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 206,
    "text": "local sub_order",
    "type": "statement:localassign"
  }, {
    "id": 207,
    "text": "if type(k) == \"table\" then\r\n            sub_order = k[2]\r\n            k = k[1]\r\n         end",
    "type": "statement:if"
  }, {
    "id": 208,
    "text": "sub_order = k[2]",
    "type": "statement:assign"
  }, {
    "id": 209,
    "text": "k = k[1]",
    "type": "statement:assign"
  }, {
    "id": 210,
    "text": "if tbl[k] then\r\n            done[k] = true\r\n            coroutine.yield(k, tbl[k], sub_order)\r\n         end",
    "type": "statement:if"
  }, {
    "id": 211,
    "text": "done[k] = true",
    "type": "statement:assign"
  }, {
    "id": 212,
    "text": "coroutine.yield(k, tbl[k], sub_order)",
    "type": "statement:functioncall"
  }, {
    "id": 213,
    "text": "table.sort(ks, default_sort)",
    "type": "statement:functioncall"
  }, {
    "id": 214,
    "text": "for _, k in ipairs(ks) do\r\n         if not done[k] then\r\n            coroutine.yield(k, tbl[k])\r\n         end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 215,
    "text": "if not done[k] then\r\n            coroutine.yield(k, tbl[k])\r\n         end",
    "type": "statement:if"
  }, {
    "id": 216,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 217,
    "text": "function sortedpairs(tbl, sort_function)\r\n   return coroutine.wrap(function() sortedpairs_iterator(tbl, sort_function) end)\r\nend",
    "type": "function"
  }, {
    "id": 218,
    "text": "sortedpairs_iterator(tbl, sort_function)",
    "type": "statement:functioncall"
  }, {
    "id": 219,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 220,
    "text": "function lua_versions()\r\n   local versions = { \"5.1\", \"5.2\" }\r\n   local i = 0\r\n   return function()\r\n      i = i + 1\r\n      return versions[i]\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 221,
    "text": "local versions = { \"5.1\", \"5.2\" }",
    "type": "statement:localassign"
  }, {
    "id": 222,
    "text": "local i = 0",
    "type": "statement:localassign"
  }, {
    "id": 223,
    "text": "i = i + 1",
    "type": "statement:assign"
  }, {
    "id": 224,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 225,
    "text": "function starts_with(s, prefix)\r\n   return s:sub(1,#prefix) == prefix\r\nend",
    "type": "function"
  }, {
    "id": 226,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 227,
    "text": "function printout(...)\r\n   io.stdout:write(table.concat({...},\"\\t\"))\r\n   io.stdout:write(\"\\n\")\r\nend",
    "type": "function"
  }, {
    "id": 228,
    "text": "io.stdout:write(table.concat({...},\"\\t\"))",
    "type": "statement:functioncall"
  }, {
    "id": 229,
    "text": "io.stdout:write(\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 230,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 231,
    "text": "function printerr(...)\r\n   io.stderr:write(table.concat({...},\"\\t\"))\r\n   io.stderr:write(\"\\n\")\r\nend",
    "type": "function"
  }, {
    "id": 232,
    "text": "io.stderr:write(table.concat({...},\"\\t\"))",
    "type": "statement:functioncall"
  }, {
    "id": 233,
    "text": "io.stderr:write(\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 234,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 235,
    "text": "function warning(msg)\r\n   printerr(\"Warning: \"..msg)\r\nend",
    "type": "function"
  }, {
    "id": 236,
    "text": "printerr(\"Warning: \"..msg)",
    "type": "statement:functioncall"
  }, {
    "id": 237,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 238,
    "text": "function title(msg, porcelain, underline)\r\n   if porcelain then return end\r\n   printout()\r\n   printout(msg)\r\n   printout((underline or \"-\"):rep(#msg))\r\n   printout()\r\nend",
    "type": "function"
  }, {
    "id": 239,
    "text": "if porcelain then return end",
    "type": "statement:if"
  }, {
    "id": 240,
    "text": "printout()",
    "type": "statement:functioncall"
  }, {
    "id": 241,
    "text": "printout(msg)",
    "type": "statement:functioncall"
  }, {
    "id": 242,
    "text": "printout((underline or \"-\"):rep(#msg))",
    "type": "statement:functioncall"
  }, {
    "id": 243,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 244,
    "text": "function this_program(default)\r\n   local i = 1\r\n   local last, cur = default, default\r\n   while i do\r\n      local dbg = debug.getinfo(i,\"S\")\r\n      if not dbg then break end\r\n      last = cur\r\n      cur = dbg.source\r\n      i=i+1\r\n   end\r\n   return last:sub(2)\r\nend",
    "type": "function"
  }, {
    "id": 245,
    "text": "local i = 1",
    "type": "statement:localassign"
  }, {
    "id": 246,
    "text": "local last, cur = default, default",
    "type": "statement:localassign"
  }, {
    "id": 247,
    "text": "while i do\r\n      local dbg = debug.getinfo(i,\"S\")\r\n      if not dbg then break end\r\n      last = cur\r\n      cur = dbg.source\r\n      i=i+1\r\n   end",
    "type": "statement:while"
  }, {
    "id": 248,
    "text": "local dbg = debug.getinfo(i,\"S\")",
    "type": "statement:localassign"
  }, {
    "id": 249,
    "text": "if not dbg then break end",
    "type": "statement:if"
  }, {
    "id": 250,
    "text": "last = cur",
    "type": "statement:assign"
  }, {
    "id": 251,
    "text": "cur = dbg.source",
    "type": "statement:assign"
  }, {
    "id": 252,
    "text": "i=i+1",
    "type": "statement:assign"
  }, {
    "id": 253,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 254,
    "text": "function deps_mode_help(program)\r\n   return [[\r\n--deps-mode=<mode>  How to handle dependencies. Four modes are supported:\r\n                    * all - use all trees from the rocks_trees list\r\n                      for finding dependencies\r\n                    * one - use only the current tree (possibly set\r\n                      with --tree)\r\n                    * order - use trees based on order (use the current\r\n                      tree and all trees below it on the rocks_trees list)\r\n                    * none - ignore dependencies altogether.\r\n                    The default mode may be set with the deps_mode entry\r\n                    in the configuration file.\r\n                    The current default is \"]]..cfg.deps_mode..[[\".\r\n                    Type ']]..this_program(program or \"luarocks\")..[[' with no arguments to see\r\n                    your list of rocks trees.\r\n]]\r\nend",
    "type": "function"
  }, {
    "id": 255,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 256,
    "text": "function see_help(command, program)\r\n   return \"See '\"..this_program(program or \"luarocks\")..' help '..command..\"'.\"\r\nend",
    "type": "function"
  }, {
    "id": 257,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 258,
    "text": "function split_string(str, delim, maxNb)\r\n   -- Eliminate bad cases...\r\n   if string.find(str, delim) == nil then\r\n      return { str }\r\n   end\r\n   if maxNb == nil or maxNb < 1 then\r\n      maxNb = 0    -- No limit\r\n   end\r\n   local result = {}\r\n   local pat = \"(.-)\" .. delim .. \"()\"\r\n   local nb = 0\r\n   local lastPos\r\n   for part, pos in string.gmatch(str, pat) do\r\n      nb = nb + 1\r\n      result[nb] = part\r\n      lastPos = pos\r\n      if nb == maxNb then break end\r\n   end\r\n   -- Handle the last field\r\n   if nb ~= maxNb then\r\n      result[nb + 1] = string.sub(str, lastPos)\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 259,
    "text": "if string.find(str, delim) == nil then\r\n      return { str }\r\n   end",
    "type": "statement:if"
  }, {
    "id": 260,
    "text": "if maxNb == nil or maxNb < 1 then\r\n      maxNb = 0    -- No limit\r\n   end",
    "type": "statement:if"
  }, {
    "id": 261,
    "text": "maxNb = 0",
    "type": "statement:assign"
  }, {
    "id": 262,
    "text": "local result = {}",
    "type": "statement:localassign"
  }, {
    "id": 263,
    "text": "local pat = \"(.-)\" .. delim .. \"()\"",
    "type": "statement:localassign"
  }, {
    "id": 264,
    "text": "local nb = 0",
    "type": "statement:localassign"
  }, {
    "id": 265,
    "text": "local lastPos",
    "type": "statement:localassign"
  }, {
    "id": 266,
    "text": "for part, pos in string.gmatch(str, pat) do\r\n      nb = nb + 1\r\n      result[nb] = part\r\n      lastPos = pos\r\n      if nb == maxNb then break end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 267,
    "text": "nb = nb + 1",
    "type": "statement:assign"
  }, {
    "id": 268,
    "text": "result[nb] = part",
    "type": "statement:assign"
  }, {
    "id": 269,
    "text": "lastPos = pos",
    "type": "statement:assign"
  }, {
    "id": 270,
    "text": "if nb == maxNb then break end",
    "type": "statement:if"
  }, {
    "id": 271,
    "text": "if nb ~= maxNb then\r\n      result[nb + 1] = string.sub(str, lastPos)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 272,
    "text": "result[nb + 1] = string.sub(str, lastPos)",
    "type": "statement:assign"
  }, {
    "id": 273,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 274,
    "text": "function remove_path_dupes(list, sep)\r\n   assert(type(list) == \"string\")\r\n   assert(type(sep) == \"string\")\r\n   local parts = split_string(list, sep)\r\n   local final, entries = {}, {}\r\n   for _, part in ipairs(parts) do\r\n      if not entries[part] then\r\n         table.insert(final, part)\r\n         entries[part] = true\r\n      end\r\n   end\r\n   return table.concat(final, sep)\r\nend",
    "type": "function"
  }, {
    "id": 275,
    "text": "assert(type(list) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 276,
    "text": "assert(type(sep) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 277,
    "text": "local parts = split_string(list, sep)",
    "type": "statement:localassign"
  }, {
    "id": 278,
    "text": "local final, entries = {}, {}",
    "type": "statement:localassign"
  }, {
    "id": 279,
    "text": "for _, part in ipairs(parts) do\r\n      if not entries[part] then\r\n         table.insert(final, part)\r\n         entries[part] = true\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 280,
    "text": "if not entries[part] then\r\n         table.insert(final, part)\r\n         entries[part] = true\r\n      end",
    "type": "statement:if"
  }, {
    "id": 281,
    "text": "table.insert(final, part)",
    "type": "statement:functioncall"
  }, {
    "id": 282,
    "text": "entries[part] = true",
    "type": "statement:assign"
  }, {
    "id": 283,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 284,
    "text": "function show_table(t, name, indent)\r\n   local cart     -- a container\r\n   local autoref  -- for self references\r\n\r\n   local function isemptytable(t) return next(t) == nil end\r\n   \r\n   local function basicSerialize (o)\r\n      local so = tostring(o)\r\n      if type(o) == \"function\" then\r\n         local info = debug.getinfo(o, \"S\")\r\n         -- info.name is nil because o is not a calling level\r\n         if info.what == \"C\" then\r\n            return (\"%q\"):format(so .. \", C function\")\r\n         else \r\n            -- the information is defined through lines\r\n            return (\"%q\"):format(so .. \", defined in (\" .. info.linedefined .. \"-\" .. info.lastlinedefined .. \")\" .. info.source)\r\n         end\r\n      elseif type(o) == \"number\" then\r\n         return so\r\n      else\r\n         return (\"%q\"):format(so)\r\n      end\r\n   end\r\n   \r\n   local function addtocart (value, name, indent, saved, field)\r\n      indent = indent or \"\"\r\n      saved = saved or {}\r\n      field = field or name\r\n      \r\n      cart = cart .. indent .. field\r\n      \r\n      if type(value) ~= \"table\" then\r\n         cart = cart .. \" = \" .. basicSerialize(value) .. \";\\n\"\r\n      else\r\n         if saved[value] then\r\n            cart = cart .. \" = {}; -- \" .. saved[value] .. \" (self reference)\\n\"\r\n            autoref = autoref ..  name .. \" = \" .. saved[value] .. \";\\n\"\r\n         else\r\n            saved[value] = name\r\n            --if tablecount(value) == 0 then\r\n            if isemptytable(value) then\r\n               cart = cart .. \" = {};\\n\"\r\n            else\r\n               cart = cart .. \" = {\\n\"\r\n               for k, v in pairs(value) do\r\n                  k = basicSerialize(k)\r\n                  local fname = (\"%s[%s]\"):format(name, k)\r\n                  field = (\"[%s]\"):format(k)\r\n                  -- three spaces between levels\r\n                  addtocart(v, fname, indent .. \"   \", saved, field)\r\n               end\r\n               cart = cart .. indent .. \"};\\n\"\r\n            end\r\n         end\r\n      end\r\n   end\r\n   \r\n   name = name or \"__unnamed__\"\r\n   if type(t) ~= \"table\" then\r\n      return name .. \" = \" .. basicSerialize(t)\r\n   end\r\n   cart, autoref = \"\", \"\"\r\n   addtocart(t, name, indent)\r\n   return cart .. autoref\r\nend",
    "type": "function"
  }, {
    "id": 285,
    "text": "local cart",
    "type": "statement:localassign"
  }, {
    "id": 286,
    "text": "local autoref",
    "type": "statement:localassign"
  }, {
    "id": 287,
    "text": "local function isemptytable(t) return next(t) == nil end",
    "type": "statement:localfunction"
  }, {
    "id": 288,
    "text": "local function basicSerialize (o)\r\n      local so = tostring(o)\r\n      if type(o) == \"function\" then\r\n         local info = debug.getinfo(o, \"S\")\r\n         -- info.name is nil because o is not a calling level\r\n         if info.what == \"C\" then\r\n            return (\"%q\"):format(so .. \", C function\")\r\n         else \r\n            -- the information is defined through lines\r\n            return (\"%q\"):format(so .. \", defined in (\" .. info.linedefined .. \"-\" .. info.lastlinedefined .. \")\" .. info.source)\r\n         end\r\n      elseif type(o) == \"number\" then\r\n         return so\r\n      else\r\n         return (\"%q\"):format(so)\r\n      end\r\n   end",
    "type": "statement:localfunction"
  }, {
    "id": 289,
    "text": "local so = tostring(o)",
    "type": "statement:localassign"
  }, {
    "id": 290,
    "text": "if type(o) == \"function\" then\r\n         local info = debug.getinfo(o, \"S\")\r\n         -- info.name is nil because o is not a calling level\r\n         if info.what == \"C\" then\r\n            return (\"%q\"):format(so .. \", C function\")\r\n         else \r\n            -- the information is defined through lines\r\n            return (\"%q\"):format(so .. \", defined in (\" .. info.linedefined .. \"-\" .. info.lastlinedefined .. \")\" .. info.source)\r\n         end\r\n      elseif type(o) == \"number\" then\r\n         return so\r\n      else\r\n         return (\"%q\"):format(so)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 291,
    "text": "local info = debug.getinfo(o, \"S\")",
    "type": "statement:localassign"
  }, {
    "id": 292,
    "text": "if info.what == \"C\" then\r\n            return (\"%q\"):format(so .. \", C function\")\r\n         else \r\n            -- the information is defined through lines\r\n            return (\"%q\"):format(so .. \", defined in (\" .. info.linedefined .. \"-\" .. info.lastlinedefined .. \")\" .. info.source)\r\n         end",
    "type": "statement:if"
  }, {
    "id": 293,
    "text": "local function addtocart (value, name, indent, saved, field)\r\n      indent = indent or \"\"\r\n      saved = saved or {}\r\n      field = field or name\r\n      \r\n      cart = cart .. indent .. field\r\n      \r\n      if type(value) ~= \"table\" then\r\n         cart = cart .. \" = \" .. basicSerialize(value) .. \";\\n\"\r\n      else\r\n         if saved[value] then\r\n            cart = cart .. \" = {}; -- \" .. saved[value] .. \" (self reference)\\n\"\r\n            autoref = autoref ..  name .. \" = \" .. saved[value] .. \";\\n\"\r\n         else\r\n            saved[value] = name\r\n            --if tablecount(value) == 0 then\r\n            if isemptytable(value) then\r\n               cart = cart .. \" = {};\\n\"\r\n            else\r\n               cart = cart .. \" = {\\n\"\r\n               for k, v in pairs(value) do\r\n                  k = basicSerialize(k)\r\n                  local fname = (\"%s[%s]\"):format(name, k)\r\n                  field = (\"[%s]\"):format(k)\r\n                  -- three spaces between levels\r\n                  addtocart(v, fname, indent .. \"   \", saved, field)\r\n               end\r\n               cart = cart .. indent .. \"};\\n\"\r\n            end\r\n         end\r\n      end\r\n   end",
    "type": "statement:localfunction"
  }, {
    "id": 294,
    "text": "indent = indent or \"\"",
    "type": "statement:assign"
  }, {
    "id": 295,
    "text": "saved = saved or {}",
    "type": "statement:assign"
  }, {
    "id": 296,
    "text": "field = field or name",
    "type": "statement:assign"
  }, {
    "id": 297,
    "text": "cart = cart .. indent .. field",
    "type": "statement:assign"
  }, {
    "id": 298,
    "text": "if type(value) ~= \"table\" then\r\n         cart = cart .. \" = \" .. basicSerialize(value) .. \";\\n\"\r\n      else\r\n         if saved[value] then\r\n            cart = cart .. \" = {}; -- \" .. saved[value] .. \" (self reference)\\n\"\r\n            autoref = autoref ..  name .. \" = \" .. saved[value] .. \";\\n\"\r\n         else\r\n            saved[value] = name\r\n            --if tablecount(value) == 0 then\r\n            if isemptytable(value) then\r\n               cart = cart .. \" = {};\\n\"\r\n            else\r\n               cart = cart .. \" = {\\n\"\r\n               for k, v in pairs(value) do\r\n                  k = basicSerialize(k)\r\n                  local fname = (\"%s[%s]\"):format(name, k)\r\n                  field = (\"[%s]\"):format(k)\r\n                  -- three spaces between levels\r\n                  addtocart(v, fname, indent .. \"   \", saved, field)\r\n               end\r\n               cart = cart .. indent .. \"};\\n\"\r\n            end\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 299,
    "text": "cart = cart .. \" = \" .. basicSerialize(value) .. \";\\n\"",
    "type": "statement:assign"
  }, {
    "id": 300,
    "text": "if saved[value] then\r\n            cart = cart .. \" = {}; -- \" .. saved[value] .. \" (self reference)\\n\"\r\n            autoref = autoref ..  name .. \" = \" .. saved[value] .. \";\\n\"\r\n         else\r\n            saved[value] = name\r\n            --if tablecount(value) == 0 then\r\n            if isemptytable(value) then\r\n               cart = cart .. \" = {};\\n\"\r\n            else\r\n               cart = cart .. \" = {\\n\"\r\n               for k, v in pairs(value) do\r\n                  k = basicSerialize(k)\r\n                  local fname = (\"%s[%s]\"):format(name, k)\r\n                  field = (\"[%s]\"):format(k)\r\n                  -- three spaces between levels\r\n                  addtocart(v, fname, indent .. \"   \", saved, field)\r\n               end\r\n               cart = cart .. indent .. \"};\\n\"\r\n            end\r\n         end",
    "type": "statement:if"
  }, {
    "id": 301,
    "text": "cart = cart .. \" = {}; -- \" .. saved[value] .. \" (self reference)\\n\"",
    "type": "statement:assign"
  }, {
    "id": 302,
    "text": "autoref = autoref ..  name .. \" = \" .. saved[value] .. \";\\n\"",
    "type": "statement:assign"
  }, {
    "id": 303,
    "text": "saved[value] = name",
    "type": "statement:assign"
  }, {
    "id": 304,
    "text": "if isemptytable(value) then\r\n               cart = cart .. \" = {};\\n\"\r\n            else\r\n               cart = cart .. \" = {\\n\"\r\n               for k, v in pairs(value) do\r\n                  k = basicSerialize(k)\r\n                  local fname = (\"%s[%s]\"):format(name, k)\r\n                  field = (\"[%s]\"):format(k)\r\n                  -- three spaces between levels\r\n                  addtocart(v, fname, indent .. \"   \", saved, field)\r\n               end\r\n               cart = cart .. indent .. \"};\\n\"\r\n            end",
    "type": "statement:if"
  }, {
    "id": 305,
    "text": "cart = cart .. \" = {};\\n\"",
    "type": "statement:assign"
  }, {
    "id": 306,
    "text": "cart = cart .. \" = {\\n\"",
    "type": "statement:assign"
  }, {
    "id": 307,
    "text": "for k, v in pairs(value) do\r\n                  k = basicSerialize(k)\r\n                  local fname = (\"%s[%s]\"):format(name, k)\r\n                  field = (\"[%s]\"):format(k)\r\n                  -- three spaces between levels\r\n                  addtocart(v, fname, indent .. \"   \", saved, field)\r\n               end",
    "type": "statement:genericfor"
  }, {
    "id": 308,
    "text": "k = basicSerialize(k)",
    "type": "statement:assign"
  }, {
    "id": 309,
    "text": "local fname = (\"%s[%s]\"):format(name, k)",
    "type": "statement:localassign"
  }, {
    "id": 310,
    "text": "field = (\"[%s]\"):format(k)",
    "type": "statement:assign"
  }, {
    "id": 311,
    "text": "addtocart(v, fname, indent .. \"   \", saved, field)",
    "type": "statement:functioncall"
  }, {
    "id": 312,
    "text": "cart = cart .. indent .. \"};\\n\"",
    "type": "statement:assign"
  }, {
    "id": 313,
    "text": "name = name or \"__unnamed__\"",
    "type": "statement:assign"
  }, {
    "id": 314,
    "text": "if type(t) ~= \"table\" then\r\n      return name .. \" = \" .. basicSerialize(t)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 315,
    "text": "cart, autoref = \"\", \"\"",
    "type": "statement:assign"
  }, {
    "id": 316,
    "text": "addtocart(t, name, indent)",
    "type": "statement:functioncall"
  }, {
    "id": 317,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 318,
    "text": "local function isemptytable(t) return next(t) == nil end",
    "type": "function"
  }, {
    "id": 319,
    "text": "local function basicSerialize (o)\r\n      local so = tostring(o)\r\n      if type(o) == \"function\" then\r\n         local info = debug.getinfo(o, \"S\")\r\n         -- info.name is nil because o is not a calling level\r\n         if info.what == \"C\" then\r\n            return (\"%q\"):format(so .. \", C function\")\r\n         else \r\n            -- the information is defined through lines\r\n            return (\"%q\"):format(so .. \", defined in (\" .. info.linedefined .. \"-\" .. info.lastlinedefined .. \")\" .. info.source)\r\n         end\r\n      elseif type(o) == \"number\" then\r\n         return so\r\n      else\r\n         return (\"%q\"):format(so)\r\n      end\r\n   end",
    "type": "function"
  }, {
    "id": 320,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 321,
    "text": "local function addtocart (value, name, indent, saved, field)\r\n      indent = indent or \"\"\r\n      saved = saved or {}\r\n      field = field or name\r\n      \r\n      cart = cart .. indent .. field\r\n      \r\n      if type(value) ~= \"table\" then\r\n         cart = cart .. \" = \" .. basicSerialize(value) .. \";\\n\"\r\n      else\r\n         if saved[value] then\r\n            cart = cart .. \" = {}; -- \" .. saved[value] .. \" (self reference)\\n\"\r\n            autoref = autoref ..  name .. \" = \" .. saved[value] .. \";\\n\"\r\n         else\r\n            saved[value] = name\r\n            --if tablecount(value) == 0 then\r\n            if isemptytable(value) then\r\n               cart = cart .. \" = {};\\n\"\r\n            else\r\n               cart = cart .. \" = {\\n\"\r\n               for k, v in pairs(value) do\r\n                  k = basicSerialize(k)\r\n                  local fname = (\"%s[%s]\"):format(name, k)\r\n                  field = (\"[%s]\"):format(k)\r\n                  -- three spaces between levels\r\n                  addtocart(v, fname, indent .. \"   \", saved, field)\r\n               end\r\n               cart = cart .. indent .. \"};\\n\"\r\n            end\r\n         end\r\n      end\r\n   end",
    "type": "function"
  }, {
    "id": 322,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 323,
    "text": "function array_contains(tbl, value)\r\n   for _, v in ipairs(tbl) do\r\n      if v == value then\r\n         return true\r\n      end\r\n   end\r\n   return false\r\nend",
    "type": "function"
  }, {
    "id": 324,
    "text": "for _, v in ipairs(tbl) do\r\n      if v == value then\r\n         return true\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 325,
    "text": "if v == value then\r\n         return true\r\n      end",
    "type": "statement:if"
  }, {
    "id": 326,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 327,
    "text": "function LQ(s)\r\n   return (\"%q\"):format(s)\r\nend",
    "type": "function"
  }, {
    "id": 328,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 329,
    "text": "function() sortedpairs_iterator(tbl, sort_function) end",
    "type": "function"
  }, {
    "id": 330,
    "text": "function()\r\n      i = i + 1\r\n      return versions[i]\r\n   end",
    "type": "function"
  }, {
    "id": 331,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 332,
    "text": "",
    "type": "function container"
  }, {
    "id": 333,
    "text": "local function validate_rockspec(file)\r\n   local ok, err, errcode = build.build_rockspec(file, true, \"one\")\r\n   if not ok then\r\n      util.printerr(err)\r\n   end\r\n   return ok, err, errcode\r\nend",
    "type": "function"
  }, {
    "id": 334,
    "text": "local function validate_src_rock(file)\r\n   local ok, err, errcode = build.build_rock(file, false, \"one\")\r\n   if not ok then\r\n      util.printerr(err)\r\n   end\r\n   return ok, err, errcode\r\nend",
    "type": "function"
  }, {
    "id": 335,
    "text": "local function validate_rock(file)\r\n   local ok, err, errcode = install.install_binary_rock(file, \"one\")\r\n   if not ok then\r\n      util.printerr(err)\r\n   end\r\n   return ok, err, errcode\r\nend",
    "type": "function"
  }, {
    "id": 336,
    "text": "local function validate(repo, flags)\r\n   local results = {\r\n      ok = {}\r\n   }\r\n   local settings = save_settings(repo)\r\n   local sandbox\r\n   if flags[\"quick\"] then\r\n      sandbox = prepare_sandbox(\"luarocks_validate\")\r\n   end\r\n   if not fs.exists(repo) then\r\n      return nil, repo..\" is not a local repository.\"\r\n   end\r\n   for _, file in pairs(fs.list_dir(repo)) do for _=1,1 do\r\n      if file == \"manifest\" or file == \"index.html\" then\r\n         break -- continue for\r\n      end\r\n      local pathname = fs.absolute_name(dir.path(repo, file))\r\n      if not flags[\"quick\"] then\r\n         sandbox = prepare_sandbox(file)\r\n      end\r\n      local ok, err, errcode\r\n      util.printout()\r\n      util.printout(\"Verifying \"..pathname)\r\n      if file:match(\"%.rockspec$\") then\r\n         ok, err, errcode = validate_rockspec(pathname, \"one\")\r\n      elseif file:match(\"%.src%.rock$\") then\r\n         ok, err, errcode = validate_src_rock(pathname)\r\n      elseif file:match(\"%.rock$\") then\r\n         ok, err, errcode = validate_rock(pathname)\r\n      end\r\n      if ok then\r\n         table.insert(results.ok, {file=file} )\r\n      else\r\n         if not errcode then\r\n            errcode = \"misc\"\r\n         end\r\n         if not results[errcode] then\r\n            results[errcode] = {}\r\n         end\r\n         table.insert(results[errcode], {file=file, err=err} )\r\n      end\r\n      util.run_scheduled_functions()\r\n      if not flags[\"quick\"] then\r\n         fs.delete(sandbox)\r\n      end\r\n      repeat until not fs.pop_dir()\r\n   end end\r\n   if flags[\"quick\"] then\r\n      fs.delete(sandbox)\r\n   end\r\n   restore_settings(settings)\r\n   util.title(\"Results:\")\r\n   util.printout(\"OK: \"..tostring(#results.ok))\r\n   for _, entry in ipairs(results.ok) do\r\n      util.printout(entry.file)\r\n   end\r\n   for errcode, errors in pairs(results) do\r\n      if errcode ~= \"ok\" then\r\n         util.printout()\r\n         util.printout(errcode..\" errors: \"..tostring(#errors))\r\n         for _, entry in ipairs(errors) do\r\n            util.printout(entry.file, entry.err)\r\n         end\r\n      end\r\n   end\r\n\r\n   util.title(\"Summary:\")\r\n   local total = 0\r\n   for errcode, errors in pairs(results) do\r\n      util.printout(errcode..\": \"..tostring(#errors))\r\n      total = total + #errors\r\n   end\r\n   util.printout(\"Total: \"..total)\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 337,
    "text": "function run(...)\r\n   local flags, repo = util.parse_flags(...)\r\n   repo = repo or cfg.rocks_dir\r\n\r\n   util.printout(\"Verifying contents of \"..repo)\r\n\r\n   return validate(repo, flags)\r\nend",
    "type": "function"
  }, {
    "id": 338,
    "text": "local function get_url(rockspec)\r\n   local url = rockspec.source.url\r\n   local file, temp_dir, err_code, err_file, err_temp_dir = fetch.fetch_sources(rockspec, false)\r\n   if err_code == \"source.dir\" then\r\n      file, temp_dir = err_file, err_temp_dir\r\n   elseif not file then\r\n      util.warning(\"Could not fetch sources - \"..temp_dir)\r\n      return false\r\n   end\r\n   util.printout(\"File successfully downloaded. Making checksum and checking base dir...\")\r\n   local md5 = nil\r\n   if fetch.is_basic_protocol(rockspec.source.protocol) then\r\n      rockspec.source.md5 = fs.get_md5(file)\r\n   end\r\n   local ok, err = fs.change_dir(temp_dir)\r\n   if not ok then return false end\r\n   fs.unpack_archive(file)\r\n   local base_dir = fetch.url_to_base_dir(url)\r\n   if not fs.exists(base_dir) then\r\n      util.printerr(\"Directory \"..base_dir..\" not found\")\r\n      local files = fs.list_dir()\r\n      if files[1] and fs.is_dir(files[1]) then\r\n         util.printerr(\"Found \"..files[1])\r\n         base_dir = files[1]\r\n      end\r\n   end\r\n   fs.pop_dir()\r\n   return true, base_dir, temp_dir\r\nend",
    "type": "function"
  }, {
    "id": 339,
    "text": "local function configure_lua_version(rockspec, luaver)\r\n   if luaver == \"5.1\" then\r\n      table.insert(rockspec.dependencies, \"lua ~> 5.1\")\r\n   elseif luaver == \"5.2\" then\r\n      table.insert(rockspec.dependencies, \"lua ~> 5.2\")\r\n   elseif luaver == \"5.1,5.2\" then\r\n      table.insert(rockspec.dependencies, \"lua >= 5.1, < 5.3\")\r\n   else\r\n      util.warning(\"Please specify supported Lua version with --lua-version=<ver>. \"..util.see_help(\"write_rockspec\"))\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 340,
    "text": "local function show_license(rockspec)\r\n   local fd = open_file(\"COPYING\") or open_file(\"LICENSE\") or open_file(\"MIT-LICENSE.txt\")\r\n   if not fd then return nil end\r\n   local data = fd:read(\"*a\")\r\n   fd:close()\r\n   local is_mit = detect_mit_license(data)\r\n   util.title(\"License for \"..rockspec.package..\":\")\r\n   util.printout(data)\r\n   util.printout()\r\n   return is_mit\r\nend",
    "type": "function"
  }, {
    "id": 341,
    "text": "function run(...)\r\n   local flags, name, version, url_or_dir = util.parse_flags(...)\r\n   \r\n   if not name then\r\n      return nil, \"Missing arguments. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n\r\n   if name and not version then\r\n      url_or_dir = name\r\n      name = nil\r\n   elseif not url_or_dir then\r\n      url_or_dir = version\r\n   end\r\n\r\n   if flags[\"tag\"] == true then\r\n      return nil, \"Incorrect usage: --tag requires an argument. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n   \r\n   if flags[\"tag\"] then\r\n      if not version then\r\n         version = flags[\"tag\"]:gsub(\"^v\", \"\")\r\n      end\r\n   end\r\n   \r\n   local protocol, pathname = dir.split_url(url_or_dir)\r\n   if not fetch.is_basic_protocol(protocol) then\r\n      if not name then\r\n         name = dir.base_name(url_or_dir):gsub(\"%.[^.]+$\", \"\")\r\n      end\r\n      if not version then\r\n         version = \"scm\"\r\n      end\r\n   elseif protocol ~= \"file\" then\r\n      local filename = dir.base_name(url_or_dir)\r\n      local newname, newversion = filename:match(\"(.*)-([^-]+)\")\r\n      if (not name) and newname then\r\n         name = newname\r\n      end\r\n      if (not version) and newversion then\r\n         version = newversion:gsub(\".[a-z]+$\", \"\"):gsub(\".tar$\", \"\")\r\n      end\r\n      if not (name and version) then\r\n         return nil, \"Missing name and version arguments. \"..util.see_help(\"write_rockspec\")\r\n      end\r\n   elseif not version then\r\n      return nil, \"Missing name and version arguments. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n\r\n   local filename = flags[\"output\"] or dir.path(fs.current_dir(), name:lower()..\"-\"..version..\"-1.rockspec\")\r\n   \r\n   if not flags[\"homepage\"] and url_or_dir:match(\"^git://github.com\") then\r\n      flags[\"homepage\"] = \"http://\"..url_or_dir:match(\"^[^:]+://(.*)\")\r\n   end\r\n\r\n   local rockspec = {\r\n      package = name,\r\n      name = name:lower(),\r\n      version = version..\"-1\",\r\n      source = {\r\n         url = \"*** please add URL for source tarball, zip or repository here ***\",\r\n         tag = flags[\"tag\"],\r\n      },\r\n      description = {\r\n         summary = flags[\"summary\"] or \"*** please specify description summary ***\",\r\n         detailed = flags[\"detailed\"] or \"*** please enter a detailed description ***\",\r\n         homepage = flags[\"homepage\"] or \"*** please enter a project homepage ***\",\r\n         license = flags[\"license\"] or \"*** please specify a license ***\",\r\n      },\r\n      dependencies = {},\r\n      build = {},\r\n   }\r\n   path.configure_paths(rockspec)\r\n   rockspec.source.protocol = protocol\r\n   \r\n   configure_lua_version(rockspec, flags[\"lua-version\"])\r\n   \r\n   local local_dir = url_or_dir\r\n\r\n   if url_or_dir:match(\"://\") then\r\n      rockspec.source.url = url_or_dir\r\n      rockspec.source.file = dir.base_name(url_or_dir)\r\n      rockspec.source.dir = \"dummy\"\r\n      if not fetch.is_basic_protocol(rockspec.source.protocol) then\r\n         if version ~= \"scm\" then\r\n            rockspec.source.tag = flags[\"tag\"] or \"v\" .. version\r\n         end\r\n      end\r\n      rockspec.source.dir = nil\r\n      local ok, base_dir, temp_dir = get_url(rockspec)\r\n      if ok then\r\n         if base_dir ~= dir.base_name(url_or_dir) then\r\n            rockspec.source.dir = base_dir\r\n         end\r\n      end\r\n      if base_dir then\r\n         local_dir = dir.path(temp_dir, base_dir)\r\n      else\r\n         local_dir = nil\r\n      end\r\n   end\r\n   \r\n   if not local_dir then\r\n      local_dir = \".\"\r\n   end\r\n   \r\n   local libs = nil\r\n   if flags[\"lib\"] then\r\n      libs = {}\r\n      rockspec.external_dependencies = {}\r\n      for lib in flags[\"lib\"]:gmatch(\"([^,]+)\") do\r\n         table.insert(libs, lib)\r\n         rockspec.external_dependencies[lib:upper()] = {\r\n            library = lib\r\n         }\r\n      end\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_dir)\r\n   if not ok then return nil, \"Failed reaching files from project - error entering directory \"..local_dir end\r\n\r\n   detect_description(rockspec)\r\n\r\n   local is_mit = show_license(rockspec)\r\n   \r\n   if is_mit and not flags[\"license\"] then\r\n      rockspec.description.license = \"MIT\"\r\n   end\r\n   \r\n   fill_as_builtin(rockspec, libs)\r\n      \r\n   rockspec_cleanup(rockspec)\r\n   \r\n   persist.save_from_table(filename, rockspec, type_check.rockspec_order)\r\n\r\n   util.printout()   \r\n   util.printout(\"Wrote template at \"..filename..\" -- you should now edit and finish it.\")\r\n   util.printout()   \r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 342,
    "text": "getinfo",
    "type": "global function"
  }, {
    "id": 343,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 344,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 345,
    "text": "find",
    "type": "global function"
  }, {
    "id": 346,
    "text": "ipairs",
    "type": "global function"
  }, {
    "id": 347,
    "text": "module",
    "type": "global function"
  }, {
    "id": 348,
    "text": "sub",
    "type": "global function"
  }, {
    "id": 349,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 350,
    "text": "remove",
    "type": "global function"
  }, {
    "id": 351,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 352,
    "text": "wrap",
    "type": "global function"
  }, {
    "id": 353,
    "text": "yield",
    "type": "global function"
  }, {
    "id": 354,
    "text": "fn",
    "type": "global function"
  }, {
    "id": 355,
    "text": "gmatch",
    "type": "global function"
  }, {
    "id": 356,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 357,
    "text": "sort",
    "type": "global function"
  }, {
    "id": 358,
    "text": "unpack",
    "type": "global function"
  }, {
    "id": 359,
    "text": "type",
    "type": "global function"
  }, {
    "id": 360,
    "text": "next",
    "type": "global function"
  }, {
    "id": 361,
    "text": "select",
    "type": "global function"
  }, {
    "id": 362,
    "text": "require",
    "type": "global function"
  }, {
    "id": 363,
    "text": "cfg)",
    "type": "module"
  }, {
    "id": 364,
    "text": "fs)",
    "type": "module"
  }, {
    "id": 365,
    "text": "",
    "type": "variable container"
  }, {
    "id": 366,
    "text": "",
    "type": "require container"
  }, {
    "id": 367,
    "text": "",
    "type": "local variable"
  }, {
    "id": 368,
    "text": "",
    "type": "n/a"
  }, {
    "id": 369,
    "text": "",
    "type": "local variable"
  }, {
    "id": 370,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 371,
    "text": "",
    "type": "local variable"
  }, {
    "id": 372,
    "text": "",
    "type": "string"
  }, {
    "id": 373,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 374,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 375,
    "text": "(debug)",
    "type": "module"
  }, {
    "id": 376,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 377,
    "text": "",
    "type": "require local variable"
  } ]
}