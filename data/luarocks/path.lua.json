{
  "_filename": "path.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/luarocks/src/luarocks/path.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "calls",
    "to": 68
  }, {
    "from": 2,
    "label": "calls",
    "to": 72
  }, {
    "from": 2,
    "label": "calls",
    "to": 105
  }, {
    "from": 2,
    "label": "calls",
    "to": 105
  }, {
    "from": 2,
    "label": "calls",
    "to": 70
  }, {
    "from": 4,
    "label": "calls",
    "to": 70
  }, {
    "from": 4,
    "label": "calls",
    "to": 57
  }, {
    "from": 4,
    "label": "calls",
    "to": 76
  }, {
    "from": 4,
    "label": "calls",
    "to": 64
  }, {
    "from": 5,
    "label": "calls",
    "to": 30
  }, {
    "from": 4,
    "label": "calls",
    "to": 61
  }, {
    "from": 4,
    "label": "calls",
    "to": 61
  }, {
    "from": 4,
    "label": "calls",
    "to": 68
  }, {
    "from": 4,
    "label": "calls",
    "to": 74
  }, {
    "from": 4,
    "label": "calls",
    "to": 39
  }, {
    "from": 3,
    "label": "calls",
    "to": 105
  }, {
    "from": 7,
    "label": "calls",
    "to": 126
  }, {
    "from": 8,
    "label": "calls",
    "to": 126
  }, {
    "from": 9,
    "label": "calls",
    "to": 64
  }, {
    "from": 14,
    "label": "calls",
    "to": 64
  }, {
    "from": 14,
    "label": "calls",
    "to": 61
  }, {
    "from": 15,
    "label": "calls",
    "to": 82
  }, {
    "from": 16,
    "label": "calls",
    "to": 108
  }, {
    "from": 17,
    "label": "calls",
    "to": 39
  }, {
    "from": 18,
    "label": "calls",
    "to": 64
  }, {
    "from": 18,
    "label": "calls",
    "to": 61
  }, {
    "from": 18,
    "label": "calls",
    "to": 61
  }, {
    "from": 18,
    "label": "calls",
    "to": 39
  }, {
    "from": 18,
    "label": "calls",
    "to": 57
  }, {
    "from": 18,
    "label": "calls",
    "to": 78
  }, {
    "from": 18,
    "label": "calls",
    "to": 66
  }, {
    "from": 19,
    "label": "calls",
    "to": 35
  }, {
    "from": 21,
    "label": "calls",
    "to": 91
  }, {
    "from": 20,
    "label": "calls",
    "to": 35
  }, {
    "from": 21,
    "label": "calls",
    "to": 122
  }, {
    "from": 25,
    "label": "calls",
    "to": 45
  }, {
    "from": 22,
    "label": "calls",
    "to": 66
  }, {
    "from": 23,
    "label": "calls",
    "to": 66
  }, {
    "from": 25,
    "label": "calls",
    "to": 91
  }, {
    "from": 25,
    "label": "calls",
    "to": 91
  }, {
    "from": 23,
    "label": "calls",
    "to": 61
  }, {
    "from": 24,
    "label": "calls",
    "to": 35
  }, {
    "from": 25,
    "label": "calls",
    "to": 35
  }, {
    "from": 25,
    "label": "calls",
    "to": 51
  }, {
    "from": 25,
    "label": "calls",
    "to": 48
  }, {
    "from": 26,
    "label": "calls",
    "to": 35
  }, {
    "from": 26,
    "label": "calls",
    "to": 133
  }, {
    "from": 28,
    "label": "calls",
    "to": 51
  }, {
    "from": 27,
    "label": "calls",
    "to": 122
  }, {
    "from": 28,
    "label": "calls",
    "to": 61
  }, {
    "from": 28,
    "label": "calls",
    "to": 39
  }, {
    "from": 28,
    "label": "calls",
    "to": 48
  }, {
    "from": 29,
    "label": "calls",
    "to": 78
  }, {
    "from": 29,
    "label": "calls",
    "to": 126
  }, {
    "from": 30,
    "label": "has",
    "to": 31
  }, {
    "from": 30,
    "label": "has",
    "to": 32
  }, {
    "from": 30,
    "label": "has",
    "to": 33
  }, {
    "from": 30,
    "label": "has",
    "to": 34
  }, {
    "from": 35,
    "label": "has",
    "to": 36
  }, {
    "from": 36,
    "label": "has",
    "to": 37
  }, {
    "from": 35,
    "label": "has",
    "to": 33
  }, {
    "from": 35,
    "label": "has",
    "to": 33
  }, {
    "from": 35,
    "label": "has",
    "to": 38
  }, {
    "from": 39,
    "label": "has",
    "to": 40
  }, {
    "from": 39,
    "label": "has",
    "to": 33
  }, {
    "from": 39,
    "label": "has",
    "to": 41
  }, {
    "from": 42,
    "label": "has",
    "to": 43
  }, {
    "from": 43,
    "label": "has",
    "to": 37
  }, {
    "from": 42,
    "label": "has",
    "to": 33
  }, {
    "from": 42,
    "label": "has",
    "to": 33
  }, {
    "from": 42,
    "label": "has",
    "to": 44
  }, {
    "from": 45,
    "label": "has",
    "to": 46
  }, {
    "from": 46,
    "label": "has",
    "to": 37
  }, {
    "from": 45,
    "label": "has",
    "to": 33
  }, {
    "from": 45,
    "label": "has",
    "to": 33
  }, {
    "from": 45,
    "label": "has",
    "to": 47
  }, {
    "from": 48,
    "label": "has",
    "to": 49
  }, {
    "from": 49,
    "label": "has",
    "to": 37
  }, {
    "from": 48,
    "label": "has",
    "to": 33
  }, {
    "from": 48,
    "label": "has",
    "to": 33
  }, {
    "from": 48,
    "label": "has",
    "to": 50
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 52,
    "label": "has",
    "to": 37
  }, {
    "from": 51,
    "label": "has",
    "to": 33
  }, {
    "from": 51,
    "label": "has",
    "to": 33
  }, {
    "from": 51,
    "label": "has",
    "to": 53
  }, {
    "from": 54,
    "label": "has",
    "to": 55
  }, {
    "from": 55,
    "label": "has",
    "to": 37
  }, {
    "from": 54,
    "label": "has",
    "to": 33
  }, {
    "from": 54,
    "label": "has",
    "to": 33
  }, {
    "from": 54,
    "label": "has",
    "to": 56
  }, {
    "from": 57,
    "label": "has",
    "to": 58
  }, {
    "from": 57,
    "label": "has",
    "to": 59
  }, {
    "from": 57,
    "label": "has",
    "to": 33
  }, {
    "from": 57,
    "label": "has",
    "to": 60
  }, {
    "from": 61,
    "label": "has",
    "to": 58
  }, {
    "from": 61,
    "label": "has",
    "to": 62
  }, {
    "from": 61,
    "label": "has",
    "to": 59
  }, {
    "from": 61,
    "label": "has",
    "to": 33
  }, {
    "from": 61,
    "label": "has",
    "to": 63
  }, {
    "from": 64,
    "label": "has",
    "to": 58
  }, {
    "from": 64,
    "label": "has",
    "to": 62
  }, {
    "from": 64,
    "label": "has",
    "to": 59
  }, {
    "from": 64,
    "label": "has",
    "to": 33
  }, {
    "from": 64,
    "label": "has",
    "to": 65
  }, {
    "from": 66,
    "label": "has",
    "to": 58
  }, {
    "from": 66,
    "label": "has",
    "to": 62
  }, {
    "from": 66,
    "label": "has",
    "to": 59
  }, {
    "from": 66,
    "label": "has",
    "to": 33
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 68,
    "label": "has",
    "to": 58
  }, {
    "from": 68,
    "label": "has",
    "to": 62
  }, {
    "from": 68,
    "label": "has",
    "to": 59
  }, {
    "from": 68,
    "label": "has",
    "to": 33
  }, {
    "from": 68,
    "label": "has",
    "to": 69
  }, {
    "from": 70,
    "label": "has",
    "to": 58
  }, {
    "from": 70,
    "label": "has",
    "to": 62
  }, {
    "from": 70,
    "label": "has",
    "to": 59
  }, {
    "from": 70,
    "label": "has",
    "to": 33
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 72,
    "label": "has",
    "to": 58
  }, {
    "from": 72,
    "label": "has",
    "to": 62
  }, {
    "from": 72,
    "label": "has",
    "to": 59
  }, {
    "from": 72,
    "label": "has",
    "to": 33
  }, {
    "from": 72,
    "label": "has",
    "to": 73
  }, {
    "from": 74,
    "label": "has",
    "to": 58
  }, {
    "from": 74,
    "label": "has",
    "to": 62
  }, {
    "from": 74,
    "label": "has",
    "to": 59
  }, {
    "from": 74,
    "label": "has",
    "to": 33
  }, {
    "from": 74,
    "label": "has",
    "to": 75
  }, {
    "from": 76,
    "label": "has",
    "to": 58
  }, {
    "from": 76,
    "label": "has",
    "to": 62
  }, {
    "from": 76,
    "label": "has",
    "to": 59
  }, {
    "from": 76,
    "label": "has",
    "to": 33
  }, {
    "from": 76,
    "label": "has",
    "to": 77
  }, {
    "from": 78,
    "label": "has",
    "to": 79
  }, {
    "from": 78,
    "label": "has",
    "to": 80
  }, {
    "from": 78,
    "label": "has",
    "to": 33
  }, {
    "from": 78,
    "label": "has",
    "to": 33
  }, {
    "from": 78,
    "label": "has",
    "to": 81
  }, {
    "from": 82,
    "label": "has",
    "to": 83
  }, {
    "from": 82,
    "label": "has",
    "to": 58
  }, {
    "from": 82,
    "label": "has",
    "to": 62
  }, {
    "from": 82,
    "label": "has",
    "to": 84
  }, {
    "from": 82,
    "label": "has",
    "to": 85
  }, {
    "from": 82,
    "label": "has",
    "to": 86
  }, {
    "from": 86,
    "label": "has",
    "to": 87
  }, {
    "from": 86,
    "label": "has",
    "to": 88
  }, {
    "from": 86,
    "label": "has",
    "to": 89
  }, {
    "from": 82,
    "label": "has",
    "to": 33
  }, {
    "from": 82,
    "label": "has",
    "to": 90
  }, {
    "from": 91,
    "label": "has",
    "to": 92
  }, {
    "from": 91,
    "label": "has",
    "to": 93
  }, {
    "from": 91,
    "label": "has",
    "to": 94
  }, {
    "from": 94,
    "label": "has",
    "to": 95
  }, {
    "from": 94,
    "label": "has",
    "to": 96
  }, {
    "from": 94,
    "label": "has",
    "to": 97
  }, {
    "from": 97,
    "label": "has",
    "to": 98
  }, {
    "from": 94,
    "label": "has",
    "to": 99
  }, {
    "from": 94,
    "label": "has",
    "to": 100
  }, {
    "from": 100,
    "label": "has",
    "to": 95
  }, {
    "from": 91,
    "label": "has",
    "to": 101
  }, {
    "from": 101,
    "label": "has",
    "to": 102
  }, {
    "from": 91,
    "label": "has",
    "to": 103
  }, {
    "from": 91,
    "label": "has",
    "to": 33
  }, {
    "from": 91,
    "label": "has",
    "to": 104
  }, {
    "from": 105,
    "label": "has",
    "to": 106
  }, {
    "from": 105,
    "label": "has",
    "to": 33
  }, {
    "from": 105,
    "label": "has",
    "to": 107
  }, {
    "from": 108,
    "label": "has",
    "to": 109
  }, {
    "from": 108,
    "label": "has",
    "to": 110
  }, {
    "from": 108,
    "label": "has",
    "to": 111
  }, {
    "from": 111,
    "label": "has",
    "to": 112
  }, {
    "from": 108,
    "label": "has",
    "to": 113
  }, {
    "from": 108,
    "label": "has",
    "to": 114
  }, {
    "from": 108,
    "label": "has",
    "to": 115
  }, {
    "from": 108,
    "label": "has",
    "to": 116
  }, {
    "from": 108,
    "label": "has",
    "to": 117
  }, {
    "from": 108,
    "label": "has",
    "to": 118
  }, {
    "from": 108,
    "label": "has",
    "to": 119
  }, {
    "from": 108,
    "label": "has",
    "to": 120
  }, {
    "from": 108,
    "label": "has",
    "to": 121
  }, {
    "from": 122,
    "label": "has",
    "to": 92
  }, {
    "from": 122,
    "label": "has",
    "to": 58
  }, {
    "from": 122,
    "label": "has",
    "to": 62
  }, {
    "from": 122,
    "label": "has",
    "to": 123
  }, {
    "from": 122,
    "label": "has",
    "to": 124
  }, {
    "from": 122,
    "label": "has",
    "to": 33
  }, {
    "from": 122,
    "label": "has",
    "to": 125
  }, {
    "from": 126,
    "label": "has",
    "to": 127
  }, {
    "from": 126,
    "label": "has",
    "to": 128
  }, {
    "from": 126,
    "label": "has",
    "to": 129
  }, {
    "from": 126,
    "label": "has",
    "to": 130
  }, {
    "from": 126,
    "label": "has",
    "to": 131
  }, {
    "from": 126,
    "label": "has",
    "to": 132
  }, {
    "from": 133,
    "label": "has",
    "to": 134
  }, {
    "from": 133,
    "label": "has",
    "to": 135
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 135,
    "label": "has",
    "to": 137
  }, {
    "from": 135,
    "label": "has",
    "to": 138
  }, {
    "from": 138,
    "label": "has",
    "to": 139
  }, {
    "from": 135,
    "label": "has",
    "to": 140
  }, {
    "from": 140,
    "label": "has",
    "to": 141
  }, {
    "from": 141,
    "label": "has",
    "to": 139
  }, {
    "from": 140,
    "label": "has",
    "to": 142
  }, {
    "from": 142,
    "label": "has",
    "to": 143
  }, {
    "from": 133,
    "label": "has",
    "to": 33
  }, {
    "from": 133,
    "label": "has",
    "to": 144
  }, {
    "from": 145,
    "label": "has",
    "to": 146
  }, {
    "from": 145,
    "label": "has",
    "to": 147
  }, {
    "from": 147,
    "label": "has",
    "to": 148
  }, {
    "from": 147,
    "label": "has",
    "to": 149
  }, {
    "from": 147,
    "label": "has",
    "to": 150
  }, {
    "from": 147,
    "label": "has",
    "to": 149
  }, {
    "from": 145,
    "label": "has",
    "to": 151
  }, {
    "from": 151,
    "label": "has",
    "to": 152
  }, {
    "from": 145,
    "label": "has",
    "to": 33
  }, {
    "from": 145,
    "label": "has",
    "to": 153
  }, {
    "from": 154,
    "label": "has",
    "to": 155
  }, {
    "from": 154,
    "label": "has",
    "to": 156
  }, {
    "from": 154,
    "label": "has",
    "to": 157
  }, {
    "from": 157,
    "label": "has",
    "to": 158
  }, {
    "from": 154,
    "label": "has",
    "to": 33
  }, {
    "from": 154,
    "label": "has",
    "to": 159
  }, {
    "from": 154,
    "label": "has",
    "to": 160
  }, {
    "from": 161,
    "label": "has",
    "to": 162
  }, {
    "from": 161,
    "label": "has",
    "to": 163
  }, {
    "from": 161,
    "label": "has",
    "to": 164
  }, {
    "from": 161,
    "label": "has",
    "to": 165
  }, {
    "from": 161,
    "label": "has",
    "to": 166
  }, {
    "from": 166,
    "label": "has",
    "to": 167
  }, {
    "from": 166,
    "label": "has",
    "to": 168
  }, {
    "from": 166,
    "label": "has",
    "to": 169
  }, {
    "from": 166,
    "label": "has",
    "to": 170
  }, {
    "from": 161,
    "label": "has",
    "to": 33
  }, {
    "from": 161,
    "label": "has",
    "to": 33
  }, {
    "from": 161,
    "label": "has",
    "to": 33
  }, {
    "from": 161,
    "label": "has",
    "to": 171
  }, {
    "from": 171,
    "label": "has",
    "to": 172
  }, {
    "from": 171,
    "label": "has",
    "to": 173
  }, {
    "from": 171,
    "label": "has",
    "to": 174
  }, {
    "from": 171,
    "label": "has",
    "to": 175
  }, {
    "from": 161,
    "label": "has",
    "to": 176
  }, {
    "from": 161,
    "label": "has",
    "to": 177
  }, {
    "from": 161,
    "label": "has",
    "to": 178
  }, {
    "from": 178,
    "label": "has",
    "to": 179
  }, {
    "from": 178,
    "label": "has",
    "to": 169
  }, {
    "from": 178,
    "label": "has",
    "to": 180
  }, {
    "from": 161,
    "label": "has",
    "to": 33
  }, {
    "from": 161,
    "label": "has",
    "to": 181
  }, {
    "from": 161,
    "label": "calls",
    "to": 209
  }, {
    "from": 161,
    "label": "calls",
    "to": 209
  }, {
    "from": 108,
    "label": "calls",
    "to": 72
  }, {
    "from": 30,
    "label": "calls",
    "to": 204
  }, {
    "from": 35,
    "label": "calls",
    "to": 204
  }, {
    "from": 39,
    "label": "calls",
    "to": 204
  }, {
    "from": 42,
    "label": "calls",
    "to": 204
  }, {
    "from": 45,
    "label": "calls",
    "to": 204
  }, {
    "from": 48,
    "label": "calls",
    "to": 204
  }, {
    "from": 51,
    "label": "calls",
    "to": 204
  }, {
    "from": 54,
    "label": "calls",
    "to": 204
  }, {
    "from": 57,
    "label": "calls",
    "to": 204
  }, {
    "from": 61,
    "label": "calls",
    "to": 204
  }, {
    "from": 61,
    "label": "calls",
    "to": 204
  }, {
    "from": 64,
    "label": "calls",
    "to": 204
  }, {
    "from": 64,
    "label": "calls",
    "to": 204
  }, {
    "from": 66,
    "label": "calls",
    "to": 204
  }, {
    "from": 66,
    "label": "calls",
    "to": 204
  }, {
    "from": 68,
    "label": "calls",
    "to": 204
  }, {
    "from": 68,
    "label": "calls",
    "to": 204
  }, {
    "from": 70,
    "label": "calls",
    "to": 204
  }, {
    "from": 70,
    "label": "calls",
    "to": 204
  }, {
    "from": 72,
    "label": "calls",
    "to": 204
  }, {
    "from": 72,
    "label": "calls",
    "to": 204
  }, {
    "from": 74,
    "label": "calls",
    "to": 204
  }, {
    "from": 74,
    "label": "calls",
    "to": 204
  }, {
    "from": 76,
    "label": "calls",
    "to": 204
  }, {
    "from": 76,
    "label": "calls",
    "to": 204
  }, {
    "from": 78,
    "label": "calls",
    "to": 204
  }, {
    "from": 82,
    "label": "calls",
    "to": 204
  }, {
    "from": 82,
    "label": "calls",
    "to": 204
  }, {
    "from": 82,
    "label": "calls",
    "to": 204
  }, {
    "from": 82,
    "label": "calls",
    "to": 204
  }, {
    "from": 91,
    "label": "calls",
    "to": 204
  }, {
    "from": 105,
    "label": "calls",
    "to": 204
  }, {
    "from": 108,
    "label": "calls",
    "to": 204
  }, {
    "from": 122,
    "label": "calls",
    "to": 204
  }, {
    "from": 122,
    "label": "calls",
    "to": 204
  }, {
    "from": 122,
    "label": "calls",
    "to": 204
  }, {
    "from": 154,
    "label": "calls",
    "to": 204
  }, {
    "from": 154,
    "label": "calls",
    "to": 204
  }, {
    "from": 161,
    "label": "calls",
    "to": 205
  }, {
    "from": 35,
    "label": "calls",
    "to": 12
  }, {
    "from": 35,
    "label": "calls",
    "to": 12
  }, {
    "from": 45,
    "label": "calls",
    "to": 12
  }, {
    "from": 45,
    "label": "calls",
    "to": 12
  }, {
    "from": 48,
    "label": "calls",
    "to": 12
  }, {
    "from": 48,
    "label": "calls",
    "to": 12
  }, {
    "from": 51,
    "label": "calls",
    "to": 12
  }, {
    "from": 51,
    "label": "calls",
    "to": 12
  }, {
    "from": 54,
    "label": "calls",
    "to": 12
  }, {
    "from": 54,
    "label": "calls",
    "to": 12
  }, {
    "from": 54,
    "label": "calls",
    "to": 12
  }, {
    "from": 57,
    "label": "calls",
    "to": 12
  }, {
    "from": 61,
    "label": "calls",
    "to": 12
  }, {
    "from": 64,
    "label": "calls",
    "to": 12
  }, {
    "from": 66,
    "label": "calls",
    "to": 12
  }, {
    "from": 68,
    "label": "calls",
    "to": 12
  }, {
    "from": 70,
    "label": "calls",
    "to": 12
  }, {
    "from": 72,
    "label": "calls",
    "to": 12
  }, {
    "from": 74,
    "label": "calls",
    "to": 12
  }, {
    "from": 76,
    "label": "calls",
    "to": 12
  }, {
    "from": 82,
    "label": "calls",
    "to": 12
  }, {
    "from": 82,
    "label": "calls",
    "to": 12
  }, {
    "from": 122,
    "label": "calls",
    "to": 12
  }, {
    "from": 145,
    "label": "calls",
    "to": 12
  }, {
    "from": 145,
    "label": "calls",
    "to": 12
  }, {
    "from": 126,
    "label": "calls",
    "to": 45
  }, {
    "from": 133,
    "label": "calls",
    "to": 13
  }, {
    "from": 133,
    "label": "calls",
    "to": 13
  }, {
    "from": 133,
    "label": "calls",
    "to": 211
  }, {
    "from": 133,
    "label": "calls",
    "to": 211
  }, {
    "from": 57,
    "label": "calls",
    "to": 35
  }, {
    "from": 61,
    "label": "calls",
    "to": 35
  }, {
    "from": 64,
    "label": "calls",
    "to": 35
  }, {
    "from": 66,
    "label": "calls",
    "to": 35
  }, {
    "from": 68,
    "label": "calls",
    "to": 35
  }, {
    "from": 70,
    "label": "calls",
    "to": 35
  }, {
    "from": 72,
    "label": "calls",
    "to": 35
  }, {
    "from": 74,
    "label": "calls",
    "to": 35
  }, {
    "from": 76,
    "label": "calls",
    "to": 35
  }, {
    "from": 126,
    "label": "calls",
    "to": 35
  }, {
    "from": 145,
    "label": "calls",
    "to": 122
  }, {
    "from": 133,
    "label": "calls",
    "to": 206
  }, {
    "from": 154,
    "label": "calls",
    "to": 206
  }, {
    "from": 39,
    "label": "calls",
    "to": 197
  }, {
    "from": 126,
    "label": "calls",
    "to": 51
  }, {
    "from": 145,
    "label": "calls",
    "to": 51
  }, {
    "from": 108,
    "label": "calls",
    "to": 68
  }, {
    "from": 108,
    "label": "calls",
    "to": 74
  }, {
    "from": 161,
    "label": "calls",
    "to": 133
  }, {
    "from": 154,
    "label": "calls",
    "to": 145
  }, {
    "from": 133,
    "label": "calls",
    "to": 42
  }, {
    "from": 133,
    "label": "calls",
    "to": 42
  }, {
    "from": 161,
    "label": "calls",
    "to": 6
  }, {
    "from": 108,
    "label": "calls",
    "to": 210
  }, {
    "from": 108,
    "label": "calls",
    "to": 70
  }, {
    "from": 126,
    "label": "calls",
    "to": 48
  }, {
    "from": 145,
    "label": "calls",
    "to": 48
  }, {
    "from": 161,
    "label": "calls",
    "to": 199
  }, {
    "from": 161,
    "label": "calls",
    "to": 199
  }, {
    "from": 161,
    "label": "calls",
    "to": 199
  }, {
    "from": 161,
    "label": "calls",
    "to": 199
  }, {
    "from": 161,
    "label": "calls",
    "to": 199
  }, {
    "from": 161,
    "label": "calls",
    "to": 199
  }, {
    "from": 133,
    "label": "calls",
    "to": 208
  }, {
    "from": 133,
    "label": "calls",
    "to": 208
  }, {
    "from": 161,
    "label": "calls",
    "to": 208
  }, {
    "from": 161,
    "label": "calls",
    "to": 198
  }, {
    "from": 161,
    "label": "calls",
    "to": 200
  }, {
    "from": 161,
    "label": "calls",
    "to": 200
  }, {
    "from": 161,
    "label": "calls",
    "to": 200
  }, {
    "from": 161,
    "label": "calls",
    "to": 200
  }, {
    "from": 161,
    "label": "calls",
    "to": 200
  }, {
    "from": 161,
    "label": "calls",
    "to": 200
  }, {
    "from": 161,
    "label": "calls",
    "to": 200
  }, {
    "from": 108,
    "label": "calls",
    "to": 61
  }, {
    "from": 161,
    "label": "calls",
    "to": 10
  }, {
    "from": 182,
    "label": "calls",
    "to": 207
  }, {
    "from": 30,
    "label": "calls",
    "to": 212
  }, {
    "from": 35,
    "label": "calls",
    "to": 212
  }, {
    "from": 35,
    "label": "calls",
    "to": 212
  }, {
    "from": 39,
    "label": "calls",
    "to": 212
  }, {
    "from": 42,
    "label": "calls",
    "to": 212
  }, {
    "from": 42,
    "label": "calls",
    "to": 212
  }, {
    "from": 45,
    "label": "calls",
    "to": 212
  }, {
    "from": 45,
    "label": "calls",
    "to": 212
  }, {
    "from": 48,
    "label": "calls",
    "to": 212
  }, {
    "from": 48,
    "label": "calls",
    "to": 212
  }, {
    "from": 51,
    "label": "calls",
    "to": 212
  }, {
    "from": 51,
    "label": "calls",
    "to": 212
  }, {
    "from": 54,
    "label": "calls",
    "to": 212
  }, {
    "from": 54,
    "label": "calls",
    "to": 212
  }, {
    "from": 57,
    "label": "calls",
    "to": 212
  }, {
    "from": 61,
    "label": "calls",
    "to": 212
  }, {
    "from": 61,
    "label": "calls",
    "to": 212
  }, {
    "from": 64,
    "label": "calls",
    "to": 212
  }, {
    "from": 64,
    "label": "calls",
    "to": 212
  }, {
    "from": 66,
    "label": "calls",
    "to": 212
  }, {
    "from": 66,
    "label": "calls",
    "to": 212
  }, {
    "from": 68,
    "label": "calls",
    "to": 212
  }, {
    "from": 68,
    "label": "calls",
    "to": 212
  }, {
    "from": 70,
    "label": "calls",
    "to": 212
  }, {
    "from": 70,
    "label": "calls",
    "to": 212
  }, {
    "from": 72,
    "label": "calls",
    "to": 212
  }, {
    "from": 72,
    "label": "calls",
    "to": 212
  }, {
    "from": 74,
    "label": "calls",
    "to": 212
  }, {
    "from": 74,
    "label": "calls",
    "to": 212
  }, {
    "from": 76,
    "label": "calls",
    "to": 212
  }, {
    "from": 76,
    "label": "calls",
    "to": 212
  }, {
    "from": 78,
    "label": "calls",
    "to": 212
  }, {
    "from": 82,
    "label": "calls",
    "to": 212
  }, {
    "from": 82,
    "label": "calls",
    "to": 212
  }, {
    "from": 82,
    "label": "calls",
    "to": 212
  }, {
    "from": 82,
    "label": "calls",
    "to": 212
  }, {
    "from": 91,
    "label": "calls",
    "to": 212
  }, {
    "from": 105,
    "label": "calls",
    "to": 212
  }, {
    "from": 108,
    "label": "calls",
    "to": 212
  }, {
    "from": 122,
    "label": "calls",
    "to": 212
  }, {
    "from": 122,
    "label": "calls",
    "to": 212
  }, {
    "from": 122,
    "label": "calls",
    "to": 212
  }, {
    "from": 182,
    "label": "calls",
    "to": 213
  }, {
    "from": 182,
    "label": "calls",
    "to": 213
  }, {
    "from": 182,
    "label": "calls",
    "to": 213
  }, {
    "from": 182,
    "label": "calls",
    "to": 213
  }, {
    "from": 30,
    "label": "calls",
    "to": 11
  }, {
    "from": 78,
    "label": "calls",
    "to": 11
  }, {
    "from": 78,
    "label": "calls",
    "to": 11
  }, {
    "from": 108,
    "label": "calls",
    "to": 76
  }, {
    "from": 1,
    "label": "contains",
    "to": 182
  }, {
    "from": 182,
    "label": "declares",
    "to": 30
  }, {
    "from": 182,
    "label": "declares",
    "to": 35
  }, {
    "from": 182,
    "label": "declares",
    "to": 39
  }, {
    "from": 182,
    "label": "declares",
    "to": 42
  }, {
    "from": 182,
    "label": "declares",
    "to": 45
  }, {
    "from": 182,
    "label": "declares",
    "to": 48
  }, {
    "from": 182,
    "label": "declares",
    "to": 51
  }, {
    "from": 182,
    "label": "declares",
    "to": 54
  }, {
    "from": 182,
    "label": "declares",
    "to": 57
  }, {
    "from": 182,
    "label": "declares",
    "to": 61
  }, {
    "from": 182,
    "label": "declares",
    "to": 64
  }, {
    "from": 182,
    "label": "declares",
    "to": 66
  }, {
    "from": 182,
    "label": "declares",
    "to": 68
  }, {
    "from": 182,
    "label": "declares",
    "to": 70
  }, {
    "from": 182,
    "label": "declares",
    "to": 72
  }, {
    "from": 182,
    "label": "declares",
    "to": 74
  }, {
    "from": 182,
    "label": "declares",
    "to": 76
  }, {
    "from": 182,
    "label": "declares",
    "to": 78
  }, {
    "from": 182,
    "label": "declares",
    "to": 82
  }, {
    "from": 182,
    "label": "declares",
    "to": 91
  }, {
    "from": 182,
    "label": "declares",
    "to": 105
  }, {
    "from": 182,
    "label": "declares",
    "to": 108
  }, {
    "from": 182,
    "label": "declares",
    "to": 122
  }, {
    "from": 182,
    "label": "declares",
    "to": 126
  }, {
    "from": 182,
    "label": "declares",
    "to": 133
  }, {
    "from": 182,
    "label": "declares",
    "to": 145
  }, {
    "from": 182,
    "label": "declares",
    "to": 154
  }, {
    "from": 182,
    "label": "declares",
    "to": 161
  }, {
    "from": 183,
    "label": "calls",
    "to": 35
  }, {
    "from": 184,
    "label": "calls",
    "to": 64
  }, {
    "from": 185,
    "label": "calls",
    "to": 78
  }, {
    "from": 188,
    "label": "calls",
    "to": 91
  }, {
    "from": 189,
    "label": "calls",
    "to": 122
  }, {
    "from": 189,
    "label": "calls",
    "to": 122
  }, {
    "from": 191,
    "label": "calls",
    "to": 122
  }, {
    "from": 191,
    "label": "calls",
    "to": 122
  }, {
    "from": 187,
    "label": "calls",
    "to": 61
  }, {
    "from": 190,
    "label": "calls",
    "to": 61
  }, {
    "from": 186,
    "label": "calls",
    "to": 57
  }, {
    "from": 193,
    "label": "calls",
    "to": 82
  }, {
    "from": 192,
    "label": "calls",
    "to": 78
  }, {
    "from": 194,
    "label": "calls",
    "to": 48
  }, {
    "from": 196,
    "label": "calls",
    "to": 61
  }, {
    "from": 196,
    "label": "calls",
    "to": 64
  }, {
    "from": 195,
    "label": "calls",
    "to": 35
  }, {
    "from": 196,
    "label": "calls",
    "to": 42
  }, {
    "from": 196,
    "label": "calls",
    "to": 42
  }, {
    "from": 196,
    "label": "calls",
    "to": 154
  }, {
    "from": 194,
    "label": "calls",
    "to": 51
  }, {
    "from": 201,
    "label": "calls",
    "to": 45
  }, {
    "from": 201,
    "label": "calls",
    "to": 35
  }, {
    "from": 203,
    "label": "calls",
    "to": 108
  }, {
    "from": 202,
    "label": "calls",
    "to": 91
  }, {
    "from": 202,
    "label": "calls",
    "to": 91
  }, {
    "from": 1,
    "label": "contains",
    "to": 218
  }, {
    "from": 1,
    "label": "contains",
    "to": 219
  }, {
    "from": 218,
    "label": "initializes",
    "to": 220
  }, {
    "from": 218,
    "label": "initializes",
    "to": 221
  }, {
    "from": 218,
    "label": "initializes",
    "to": 222
  }, {
    "from": 219,
    "label": "initializes",
    "to": 223
  }, {
    "from": 223,
    "label": "requires",
    "to": 216
  }, {
    "from": 219,
    "label": "initializes",
    "to": 224
  }, {
    "from": 224,
    "label": "requires",
    "to": 214
  }, {
    "from": 219,
    "label": "initializes",
    "to": 225
  }, {
    "from": 225,
    "label": "requires",
    "to": 215
  }, {
    "from": 219,
    "label": "initializes",
    "to": 226
  }, {
    "from": 226,
    "label": "requires",
    "to": 217
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "path",
    "type": "module"
  }, {
    "id": 2,
    "text": "function run(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n   local compile_object, compile_library, compile_wrapper_binary\r\n\r\n   local build = rockspec.build\r\n   local variables = rockspec.variables\r\n\r\n   local function add_flags(extras, flag, flags)\r\n      if flags then\r\n         if type(flags) ~= \"table\" then\r\n            flags = { tostring(flags) }\r\n         end\r\n         util.variable_substitutions(flags, variables)\r\n         for _, v in ipairs(flags) do\r\n            table.insert(extras, flag:format(v))\r\n         end\r\n      end\r\n   end\r\n\r\n   -- MinGW basically behaves the same as Unix\r\n   if cfg.is_platform(\"mingw32\") then\r\n         compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR, \"-c\", source, \"-o\", object, unpack(extras))\r\n      end\r\n      compile_library = function (library, objects, libraries, libdirs)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-L%s\", libdirs)\r\n         add_flags(extras, \"-l%s\", libraries)\r\n         extras[#extras+1] = dir.path(variables.LUA_LIBDIR, variables.LUALIB)\r\n         extras[#extras+1] = \"-l\" .. (variables.MSVCRT or \"m\")\r\n         local ok = execute(variables.LD..\" \"..variables.LIBFLAG, \"-o\", library, unpack(extras))\r\n         return ok\r\n      end\r\n      compile_wrapper_binary = function(fullname, name)\r\n         local fullbasename = fullname:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local basename = name:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local rcname = basename..\".rc\"\r\n         local resname = basename..\".o\"\r\n         local wrapname = basename..\".exe\"\r\n         make_rc(fullname, fullbasename..\".rc\")\r\n         local ok = execute(variables.RC, \"-o\", resname, rcname)\r\n         if not ok then return ok end\r\n         ok = execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR,\r\n                      \"-o\", wrapname, resname, variables.WRAPPER,\r\n                      dir.path(variables.LUA_LIBDIR, variables.LUALIB),\r\n                      \"-l\" .. (variables.MSVCRT or \"m\"), \"-luser32\")\r\n         return ok, wrapname\r\n      end\r\n      compile_wrapper_binary = function(fullname, name) return true, name end\r\n\t-- MSVC specific commands\r\n\telseif cfg.is_platform(\"win32\") then\r\n      compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-c\", \"-Fo\"..object, \"-I\"..variables.LUA_INCDIR, source, unpack(extras))\r\n      end\r\n      compile_library = function(library, objects, libraries, libdirs, name)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-libpath:%s\", libdirs)\r\n         add_flags(extras, \"%s.lib\", libraries)\r\n         local basename = dir.base_name(library):gsub(\".[^.]*$\", \"\")\r\n         local deffile = basename .. \".def\"\r\n         local def = io.open(dir.path(fs.current_dir(), deffile), \"w+\")\r\n         def:write(\"EXPORTS\\n\")\r\n         def:write(\"luaopen_\"..name:gsub(\"%.\", \"_\")..\"\\n\")\r\n         def:close()\r\n         local ok = execute(variables.LD, \"-dll\", \"-def:\"..deffile, \"-out:\"..library, dir.path(variables.LUA_LIBDIR, variables.LUALIB), unpack(extras))\r\n         local basedir = \"\"\r\n         if name:find(\"%.\") ~= nil then\r\n            basedir = name:gsub(\"%.%w+$\", \"\\\\\")\r\n            basedir = basedir:gsub(\"%.\", \"\\\\\")\r\n         end\r\n         local manifestfile = basedir .. basename..\".dll.manifest\"\r\n\r\n         if ok and fs.exists(manifestfile) then\r\n            ok = execute(variables.MT, \"-manifest\", manifestfile, \"-outputresource:\"..basedir..basename..\".dll;2\")\r\n         end\r\n         return ok\r\n      end\r\n      compile_wrapper_binary = function(fullname, name)\r\n         local fullbasename = fullname:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local basename = name:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local object = basename..\".obj\"\r\n         local rcname = basename..\".rc\"\r\n         local resname = basename..\".res\"\r\n         local wrapname = basename..\".exe\"\r\n         make_rc(fullname, fullbasename..\".rc\")\r\n         local ok = execute(variables.RC, \"-r\", \"-fo\"..resname, rcname)\r\n         if not ok then return ok end\r\n         ok = execute(variables.CC..\" \"..variables.CFLAGS, \"-c\", \"-Fo\"..object,\r\n                      \"-I\"..variables.LUA_INCDIR, variables.WRAPPER)\r\n         if not ok then return ok end\r\n         ok = execute(variables.LD, \"-out:\"..wrapname, resname, object,\r\n                      dir.path(variables.LUA_LIBDIR, variables.LUALIB), \"user32.lib\")\r\n         local manifestfile = wrapname..\".manifest\"\r\n         if ok and fs.exists(manifestfile) then\r\n            ok = execute(variables.MT, \"-manifest\", manifestfile, \"-outputresource:\"..wrapname..\";1\")\r\n         end\r\n         return ok, wrapname\r\n      end\r\n   else\r\n\t-- Unix, Linux, Cygwin\r\n      compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR, \"-c\", source, \"-o\", object, unpack(extras))\r\n      end\r\n      compile_library = function (library, objects, libraries, libdirs)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-L%s\", libdirs)\r\n         if cfg.gcc_rpath then\r\n            add_flags(extras, \"-Wl,-rpath,%s:\", libdirs)\r\n         end\r\n         add_flags(extras, \"-l%s\", libraries)\r\n\t\t -- Link to Lua\r\n         add_flags(extras, \"-l%s\", variables.LUA_LIB)\r\n         return execute(variables.LD..\" \"..variables.LIBFLAG, \"-o\", library, \"-L\"..variables.LUA_LIBDIR, unpack(extras))\r\n      end\r\n      compile_wrapper_binary = function(fullname, name) return true, name end\r\n   end\r\n\r\n   local ok = true\r\n   local err = \"Build error\"\r\n   local built_modules = {}\r\n   local luadir = path.lua_dir(rockspec.name, rockspec.version)\r\n   local libdir = path.lib_dir(rockspec.name, rockspec.version)\r\n   local docdir = path.doc_dir(rockspec.name, rockspec.version)\r\n   -- On Windows, compiles an .exe for each Lua file in build.install.bin, and\r\n   -- replaces the filename with the .exe name. Strips the .lua extension if it exists,\r\n   -- otherwise just appends .exe to the name\r\n   if build.install and build.install.bin then\r\n     for i, name in ipairs(build.install.bin) do\r\n       local fullname = dir.path(fs.current_dir(), name)\r\n       local match = name:match(\"%.lua$\")\r\n       local basename = name:gsub(\"%.lua$\", \"\")\r\n       local file\r\n       if not match then\r\n          file = io.open(fullname)\r\n       end\r\n       if match or (file and file:read():match(\"#!.*lua.*\")) then\r\n          ok, name = compile_wrapper_binary(fullname, name)\r\n          if ok then\r\n             build.install.bin[i] = name\r\n          else\r\n             if file then file:close() end\r\n             return nil, \"Build error in wrapper binaries\"\r\n          end\r\n       end\r\n       if file then file:close() end\r\n     end\r\n   end\r\n   for name, info in pairs(build.modules) do\r\n      local moddir = path.module_to_path(name)\r\n      if type(info) == \"string\" then\r\n         local ext = info:match(\".([^.]+)$\")\r\n         if ext == \"lua\" then\r\n            local filename = dir.base_name(info)\r\n            if info:match(\"init%.lua$\") and not name:match(\"%.init$\") then\r\n               moddir = path.module_to_path(name..\".init\")\r\n            else\r\n               local basename = name:match(\"([^.]+)$\")\r\n               local baseinfo = filename:gsub(\"%.lua$\", \"\")\r\n               if basename ~= baseinfo then\r\n                  filename = basename..\".lua\"\r\n               end\r\n            end\r\n            local dest = dir.path(luadir, moddir, filename)\r\n            built_modules[info] = dest\r\n         else\r\n            info = {info}\r\n         end\r\n      end\r\n      if type(info) == \"table\" then\r\n         local objects = {}\r\n         local sources = info.sources\r\n         if info[1] then sources = info end\r\n         if type(sources) == \"string\" then sources = {sources} end\r\n         for _, source in ipairs(sources) do\r\n            local object = source:gsub(\".[^.]*$\", \".\"..cfg.obj_extension)\r\n            if not object then\r\n               object = source..\".\"..cfg.obj_extension\r\n            end\r\n            ok = compile_object(object, source, info.defines, info.incdirs)\r\n            if not ok then\r\n               return nil, \"Failed compiling object \"..object\r\n            end\r\n            table.insert(objects, object)\r\n         end\r\n         if not ok then break end\r\n         local module_name = name:match(\"([^.]*)$\")..\".\"..util.matchquote(cfg.lib_extension)\r\n         if moddir ~= \"\" then\r\n            module_name = dir.path(moddir, module_name)\r\n            local ok, err = fs.make_dir(moddir)\r\n            if not ok then return nil, err end\r\n         end\r\n         built_modules[module_name] = dir.path(libdir, module_name)\r\n         ok = compile_library(module_name, objects, info.libraries, info.libdirs, name)\r\n         if not ok then\r\n            return nil, \"Failed compiling module \"..module_name\r\n         end\r\n      end\r\n   end\r\n   for name, dest in pairs(built_modules) do\r\n      fs.make_dir(dir.dir_name(dest))\r\n      ok = fs.copy(name, dest)\r\n      if not ok then\r\n         return nil, \"Failed installing \"..name..\" in \"..dest\r\n      end\r\n   end\r\n   if fs.is_dir(\"lua\") then\r\n      local ok, err = fs.copy_contents(\"lua\", luadir)\r\n      if not ok then\r\n         return nil, \"Failed copying contents of 'lua' directory: \"..err\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "local function install_files(files, location, is_module_path)\r\n   assert(type(files) == \"table\" or not files)\r\n   assert(type(location) == \"string\")\r\n   if files then\r\n      for k, file in pairs(files) do\r\n         local dest = location\r\n         local filename = dir.base_name(file)\r\n         if type(k) == \"string\" then\r\n            local modname = k\r\n            if is_module_path then\r\n               dest = dir.path(location, path.module_to_path(modname))\r\n               local ok, err = fs.make_dir(dest)\r\n               if not ok then return nil, err end\r\n               if filename:match(\"%.lua$\") then\r\n                  local basename = modname:match(\"([^.]+)$\")\r\n                  local baseinfo = filename:gsub(\"%.lua$\", \"\")\r\n                  if basename ~= baseinfo then\r\n                     filename = basename..\".lua\"\r\n                  end\r\n               end\r\n            else\r\n               dest = dir.path(location, dir.dir_name(modname))\r\n               local ok, err = fs.make_dir(dest)\r\n               if not ok then return nil, err end\r\n               filename = dir.base_name(modname)\r\n            end\r\n         else\r\n            local ok, err = fs.make_dir(dest)\r\n            if not ok then return nil, err end\r\n         end\r\n         local ok = fs.copy(dir.path(file), dir.path(dest, filename))\r\n         if not ok then\r\n            return nil, \"Failed copying \"..file\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 4,
    "text": "function build_rockspec(rockspec_file, need_to_fetch, minimal_mode, deps_mode)\r\n   assert(type(rockspec_file) == \"string\")\r\n   assert(type(need_to_fetch) == \"boolean\")\r\n\r\n   local rockspec, err, errcode = fetch.load_rockspec(rockspec_file)\r\n   if err then\r\n      return nil, err, errcode\r\n   elseif not rockspec.build then\r\n      return nil, \"Rockspec error: build table not specified\"\r\n   elseif not rockspec.build.type then\r\n      return nil, \"Rockspec error: build type not specified\"\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      local ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then\r\n         return nil, err, errcode\r\n      end\r\n   end\r\n\r\n   local ok, err, errcode = deps.check_external_deps(rockspec, \"build\")\r\n   if err then\r\n      return nil, err, errcode\r\n   end\r\n\r\n   local name, version = rockspec.name, rockspec.version\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n\r\n   if not minimal_mode then\r\n      local _, source_dir\r\n      if need_to_fetch then\r\n         ok, source_dir, errcode = fetch.fetch_sources(rockspec, true)\r\n         if not ok then\r\n            return nil, source_dir, errcode\r\n         end\r\n         local ok, err = fs.change_dir(source_dir)\r\n         if not ok then return nil, err end\r\n      elseif rockspec.source.file then\r\n         local ok, err = fs.unpack_archive(rockspec.source.file)\r\n         if not ok then\r\n            return nil, err\r\n         end\r\n      end\r\n      fs.change_dir(rockspec.source.dir)\r\n   end\r\n   \r\n   local dirs = {\r\n      lua = { name = path.lua_dir(name, version), is_module_path = true },\r\n      lib = { name = path.lib_dir(name, version), is_module_path = true },\r\n      conf = { name = path.conf_dir(name, version), is_module_path = false },\r\n      bin = { name = path.bin_dir(name, version), is_module_path = false },\r\n   }\r\n   \r\n   for _, d in pairs(dirs) do\r\n      local ok, err = fs.make_dir(d.name)\r\n      if not ok then return nil, err end\r\n   end\r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n\r\n   local build = rockspec.build\r\n   \r\n   if not minimal_mode then\r\n      ok, err = apply_patches(rockspec)\r\n      if err then\r\n         return nil, err\r\n      end\r\n   end\r\n   \r\n   if build.type ~= \"none\" then\r\n\r\n      -- Temporary compatibility\r\n      if build.type == \"module\" then\r\n         util.printout(\"Do not use 'module' as a build type. Use 'builtin' instead.\")\r\n         build.type = \"builtin\"\r\n      end\r\n\r\n      if cfg.accepted_build_types and util.array_contains(cfg.accepted_build_types, build.type) then\r\n         return nil, \"This rockspec uses the '\"..build.type..\"' build type, which is blocked by the 'accepted_build_types' setting in your LuaRocks configuration.\"\r\n      end\r\n\r\n      local build_type\r\n      ok, build_type = pcall(require, \"luarocks.build.\" .. build.type)\r\n      if not ok or not type(build_type) == \"table\" then\r\n         return nil, \"Failed initializing build back-end for build type '\"..build.type..\"': \"..build_type\r\n      end\r\n  \r\n      ok, err = build_type.run(rockspec)\r\n      if not ok then\r\n         return nil, \"Build error: \" .. err\r\n      end\r\n   end\r\n\r\n   if build.install then\r\n      for id, install_dir in pairs(dirs) do\r\n         ok, err = install_files(build.install[id], install_dir.name, install_dir.is_module_path)\r\n         if not ok then \r\n            return nil, err\r\n         end\r\n      end\r\n   end\r\n   \r\n   local copy_directories = build.copy_directories\r\n   local copying_default = false\r\n   if not copy_directories then\r\n      copy_directories = {\"doc\"}\r\n      copying_default = true\r\n   end\r\n\r\n   for _, copy_dir in pairs(copy_directories) do\r\n      if fs.is_dir(copy_dir) then\r\n         local dest = dir.path(path.install_dir(name, version), copy_dir)\r\n         fs.make_dir(dest)\r\n         fs.copy_contents(copy_dir, dest)\r\n      else\r\n         if not copying_default then\r\n            return nil, \"Directory '\"..copy_dir..\"' not found\"\r\n         end\r\n      end\r\n   end\r\n\r\n   for _, d in pairs(dirs) do\r\n      fs.remove_dir_if_empty(d.name)\r\n   end\r\n\r\n   fs.pop_dir()\r\n   \r\n   fs.copy(rockspec.local_filename, path.rockspec_file(name, version))\r\n   if need_to_fetch then\r\n      fs.pop_dir()\r\n   end\r\n\r\n   ok, err = manif.make_rock_manifest(name, version)\r\n   if err then return nil, err end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n\r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n\r\n   local license = \"\"\r\n   if rockspec.description and rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now built and installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 5,
    "text": "function build_rock(rock_file, need_to_fetch, deps_mode)\r\n   assert(type(rock_file) == \"string\")\r\n   assert(type(need_to_fetch) == \"boolean\")\r\n  \r\n   local unpack_dir, err, errcode = fetch.fetch_and_unpack_rock(rock_file)\r\n   if not unpack_dir then\r\n      return nil, err, errcode\r\n   end\r\n   local rockspec_file = path.rockspec_name_from_rock(rock_file)\r\n   local ok, err = fs.change_dir(unpack_dir)\r\n   if not ok then return nil, err end\r\n   local ok, err, errcode = build_rockspec(rockspec_file, need_to_fetch, false, deps_mode)\r\n   fs.pop_dir()\r\n   return ok, err, errcode\r\nend",
    "type": "function"
  }, {
    "id": 6,
    "text": "function package_paths()\r\n   local new_path, new_cpath = { extra_luarocks_module_dir }, {}\r\n   for _,tree in ipairs(rocks_trees) do\r\n     if type(tree) == \"string\" then\r\n        table.insert(new_path, 1, tree..lua_modules_path..\"/?.lua;\"..tree..lua_modules_path..\"/?/init.lua\")\r\n        table.insert(new_cpath, 1, tree..lib_modules_path..\"/?.\"..lib_extension)\r\n     else\r\n        table.insert(new_path, 1, (tree.lua_dir or tree.root..lua_modules_path)..\"/?.lua;\"..\r\n           (tree.lua_dir or tree.root..lua_modules_path)..\"/?/init.lua\")\r\n        table.insert(new_cpath, 1, (tree.lib_dir or tree.root..lib_modules_path)..\"/?.\"..lib_extension)\r\n     end\r\n   end\r\n   return table.concat(new_path, \";\"), table.concat(new_cpath, \";\")\r\nend",
    "type": "function"
  }, {
    "id": 7,
    "text": "local function replace_tree(flags, args, tree)\r\n   local tree = dir.normalize(tree)\r\n   flags[\"tree\"] = tree\r\n   for i = 1, #args do\r\n      if args[i]:match(\"%-%-tree=\") then\r\n         args[i] = \"--tree=\"..tree\r\n         break\r\n      end\r\n   end\r\n   path.use_tree(tree)\r\nend",
    "type": "function"
  }, {
    "id": 8,
    "text": "function run_command(...)\r\n   local args = {...}\r\n   local cmdline_vars = {}\r\n   for i = #args, 1, -1 do\r\n      local arg = args[i]\r\n      if arg:match(\"^[^-][^=]*=\") then\r\n         local var, val = arg:match(\"^([A-Z_][A-Z0-9_]*)=(.*)\")\r\n         if val then\r\n            cmdline_vars[var] = val\r\n            table.remove(args, i)\r\n         else\r\n            die(\"Invalid assignment: \"..arg)\r\n         end\r\n      end\r\n   end\r\n   local nonflags = { util.parse_flags(unpack(args)) }\r\n   local flags = table.remove(nonflags, 1)\r\n   \r\n   if flags[\"from\"] then flags[\"server\"] = flags[\"from\"] end\r\n   if flags[\"only-from\"] then flags[\"only-server\"] = flags[\"only-from\"] end\r\n   if flags[\"only-sources-from\"] then flags[\"only-sources\"] = flags[\"only-sources-from\"] end\r\n   if flags[\"to\"] then flags[\"tree\"] = flags[\"to\"] end\r\n   if flags[\"nodeps\"] then\r\n      flags[\"deps-mode\"] = \"none\"\r\n      table.insert(args, \"--deps-mode=none\")\r\n   end\r\n   \r\n   cfg.flags = flags\r\n\r\n   local command\r\n   \r\n   if flags[\"verbose\"] then   -- setting it in the config file will kick-in earlier in the process\r\n      cfg.verbose = true\r\n      local fs = require(\"luarocks.fs\")\r\n      fs.verbose()\r\n   end\r\n\r\n   if flags[\"version\"] then\r\n      util.printout(program..\" \"..cfg.program_version)\r\n      util.printout(program_description)\r\n      util.printout()\r\n      os.exit(cfg.errorcodes.OK)\r\n   elseif flags[\"help\"] or #nonflags == 0 then\r\n      command = \"help\"\r\n      args = nonflags\r\n   else\r\n      command = nonflags[1]\r\n      for i, arg in ipairs(args) do\r\n         if arg == command then\r\n            table.remove(args, i)\r\n            break\r\n         end\r\n      end\r\n   end\r\n   command = command:gsub(\"-\", \"_\")\r\n\r\n   if flags[\"extensions\"] then\r\n      cfg.use_extensions = true\r\n      local type_check = require(\"luarocks.type_check\")\r\n      type_check.load_extensions()\r\n   end\r\n   \r\n   if cfg.local_by_default then\r\n      flags[\"local\"] = true\r\n   end\r\n\r\n   if flags[\"deps-mode\"] and not deps.check_deps_mode_flag(flags[\"deps-mode\"]) then\r\n      die(\"Invalid entry for --deps-mode.\")\r\n   end\r\n   \r\n   if flags[\"tree\"] then\r\n      if flags[\"tree\"] == true or flags[\"tree\"] == \"\" then\r\n         die(\"Argument error: use --tree=<path>\")\r\n      end\r\n      local named = false\r\n      for _, tree in ipairs(cfg.rocks_trees) do\r\n         if type(tree) == \"table\" and flags[\"tree\"] == tree.name then\r\n            if not tree.root then\r\n               die(\"Configuration error: tree '\"..tree.name..\"' has no 'root' field.\")\r\n            end\r\n            replace_tree(flags, args, tree.root)\r\n            named = true\r\n            break\r\n         end\r\n      end\r\n      if not named then\r\n         local fs = require(\"luarocks.fs\")\r\n         local root_dir = fs.absolute_name(flags[\"tree\"])\r\n         replace_tree(flags, args, root_dir)\r\n      end\r\n   elseif flags[\"local\"] then\r\n      replace_tree(flags, args, cfg.home_tree)\r\n   else\r\n      local trees = cfg.rocks_trees\r\n      path.use_tree(trees[#trees])\r\n   end\r\n\r\n   if type(cfg.root_dir) == \"string\" then\r\n     cfg.root_dir = cfg.root_dir:gsub(\"/+$\", \"\")\r\n   else\r\n     cfg.root_dir.root = cfg.root_dir.root:gsub(\"/+$\", \"\")\r\n   end\r\n   cfg.rocks_dir = cfg.rocks_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_bin_dir = cfg.deploy_bin_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_lua_dir = cfg.deploy_lua_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_lib_dir = cfg.deploy_lib_dir:gsub(\"/+$\", \"\")\r\n   \r\n   cfg.variables.ROCKS_TREE = cfg.rocks_dir\r\n   cfg.variables.SCRIPTS_DIR = cfg.deploy_bin_dir\r\n\r\n   if flags[\"server\"] then\r\n      if flags[\"server\"] == true then\r\n         die(\"Argument error: use --server=<url>\")\r\n      end\r\n      local protocol, path = dir.split_url(flags[\"server\"])\r\n      table.insert(cfg.rocks_servers, 1, protocol..\"://\"..path)\r\n   end\r\n   \r\n   if flags[\"only-server\"] then\r\n      if flags[\"only-server\"] == true then\r\n         die(\"Argument error: use --only-server=<url>\")\r\n      end\r\n      cfg.rocks_servers = { flags[\"only-server\"] }\r\n   end\r\n\r\n   if flags[\"only-sources\"] then\r\n      cfg.only_sources_from = flags[\"only-sources\"]\r\n   end\r\n  \r\n   if command ~= \"help\" then\r\n      for k, v in pairs(cmdline_vars) do\r\n         cfg.variables[k] = v\r\n      end\r\n   end\r\n   \r\n   if commands[command] then\r\n      -- TODO the interface of run should be modified, to receive the\r\n      -- flags table and the (possibly unpacked) nonflags arguments.\r\n      -- This would remove redundant parsing of arguments.\r\n      -- I'm not changing this now to avoid messing with the run()\r\n      -- interface, which I know some people use (even though\r\n      -- I never published it as a public API...)\r\n      local cmd = require(commands[command])\r\n      local xp, ok, err, exitcode = xpcall(function() return cmd.run(unpack(args)) end, function(err)\r\n         die(debug.traceback(\"LuaRocks \"..cfg.program_version\r\n            ..\" bug (please report at luarocks-developers@lists.sourceforge.net).\\n\"\r\n            ..err, 2))\r\n      end)\r\n      if xp and (not ok) then\r\n         die(err, exitcode)\r\n      end\r\n   else\r\n      die(\"Unknown command: \"..command)\r\n   end\r\n   util.run_scheduled_functions()\r\nend",
    "type": "function"
  }, {
    "id": 9,
    "text": "function scan_deps(results, missing, manifest, name, version, deps_mode)\r\n   assert(type(results) == \"table\")\r\n   assert(type(missing) == \"table\")\r\n   assert(type(manifest) == \"table\")\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local fetch = require(\"luarocks.fetch\")\r\n\r\n   local err\r\n   if results[name] then\r\n      return results, missing\r\n   end\r\n   if not manifest.dependencies then manifest.dependencies = {} end\r\n   local dependencies = manifest.dependencies\r\n   if not dependencies[name] then dependencies[name] = {} end\r\n   local dependencies_name = dependencies[name]\r\n   local deplist = dependencies_name[version]\r\n   local rockspec, err\r\n   if not deplist then\r\n      rockspec, err = fetch.load_local_rockspec(path.rockspec_file(name, version), false)\r\n      if err then\r\n         missing[name..\" \"..version] = err\r\n         return results, missing\r\n      end\r\n      dependencies_name[version] = rockspec.dependencies\r\n   else\r\n      rockspec = { dependencies = deplist }\r\n   end\r\n   local matched, failures = match_deps(rockspec, nil, deps_mode)\r\n   results[name] = results\r\n   for _, match in pairs(matched) do\r\n      results, missing = scan_deps(results, missing, manifest, match.name, match.version, deps_mode)\r\n   end\r\n   if next(failures) then\r\n      for _, failure in pairs(failures) do\r\n         missing[show_dep(failure)] = \"failed\"\r\n      end\r\n   end\r\n   results[name] = version\r\n   return results, missing\r\nend",
    "type": "function"
  }, {
    "id": 10,
    "text": "function get_deps_mode(flags)\r\n   if flags[\"deps-mode\"] then\r\n      return flags[\"deps-mode\"]\r\n   else\r\n      return cfg.deps_mode\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 11,
    "text": "function base_name(pathname)\r\n   assert(type(pathname) == \"string\")\r\n\r\n   local base = pathname:gsub(\"[/\\\\]*$\", \"\"):match(\".*[/\\\\]([^/\\\\]*)\")\r\n   return base or pathname\r\nend",
    "type": "function"
  }, {
    "id": 12,
    "text": "function path(...)\r\n   local t = {...}\r\n   while t[1] == \"\" do\r\n      table.remove(t, 1)\r\n   end\r\n   return (table.concat(t, \"/\"):gsub(\"([^:])/+\", \"%1/\"):gsub(\"^/+\", \"/\"):gsub(\"/*$\", \"\"))\r\nend",
    "type": "function"
  }, {
    "id": 13,
    "text": "function normalize(name)\r\n   local protocol, pathname = split_url(name)\r\n   pathname = pathname:gsub(\"\\\\\", \"/\"):gsub(\"(.)/*$\", \"%1\"):gsub(\"//\", \"/\")\r\n   if protocol ~= \"file\" then pathname = protocol ..\"://\"..pathname end\r\n   return pathname\r\nend",
    "type": "function"
  }, {
    "id": 14,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if not name then\r\n      return nil, \"Argument missing. \"..util.see_help(\"doc\")\r\n   end\r\n\r\n   local repo\r\n   name, version, repo = show.pick_installed_rock(name, version, flags[\"tree\"])\r\n   if not name then\r\n      return nil, version\r\n   end\r\n   \r\n   local rockspec, err = fetch.load_local_rockspec(path.rockspec_file(name, version, repo))\r\n   if not rockspec then return nil,err end\r\n   local descript = rockspec.description or {}\r\n\r\n   if flags[\"homepage\"] then\r\n      if not descript.homepage then\r\n         return nil, \"No 'homepage' field in rockspec for \"..name..\" \"..version\r\n      end\r\n      util.printout(\"Opening \"..descript.homepage..\" ...\")\r\n      fs.browser(descript.homepage)\r\n      return true\r\n   end\r\n\r\n   local directory = path.install_dir(name,version,repo)\r\n   \r\n   local docdir\r\n   local directories = { \"doc\", \"docs\" }\r\n   for _, d in ipairs(directories) do\r\n      local dirname = dir.path(directory, d)\r\n      if fs.is_dir(dirname) then\r\n         docdir = dirname\r\n         break\r\n      end\r\n   end\r\n   if not docdir then\r\n      if descript.homepage and not flags[\"list\"] then\r\n         util.printout(\"Local documentation directory not found -- opening \"..descript.homepage..\" ...\")\r\n         fs.browser(descript.homepage)\r\n         return true\r\n      end\r\n      return nil, \"Documentation directory not found for \"..name..\" \"..version\r\n   end\r\n\r\n   docdir = dir.normalize(docdir):gsub(\"/+\", \"/\")\r\n   local files = fs.find(docdir)\r\n   local htmlpatt = \"%.html?$\"\r\n   local extensions = { htmlpatt, \"%.md$\", \"%.txt$\",  \"%.textile$\", \"\" }\r\n   local basenames = { \"index\", \"readme\", \"manual\" }\r\n   \r\n   local porcelain = flags[\"porcelain\"]\r\n   if #files > 0 then\r\n      util.title(\"Documentation files for \"..name..\" \"..version, porcelain)\r\n      if porcelain then\r\n         for _, file in ipairs(files) do\r\n            util.printout(docdir..\"/\"..file)\r\n         end\r\n      else\r\n         util.printout(docdir..\"/\")\r\n         for _, file in ipairs(files) do\r\n            util.printout(\"\\t\"..file)\r\n         end\r\n      end\r\n   end\r\n   \r\n   if flags[\"list\"] then\r\n      return true\r\n   end\r\n   \r\n   for _, extension in ipairs(extensions) do\r\n      for _, basename in ipairs(basenames) do\r\n         local filename = basename..extension\r\n         local found\r\n         for _, file in ipairs(files) do\r\n            if file:lower():match(filename) and ((not found) or #file < #found) then\r\n               found = file\r\n            end\r\n         end\r\n         if found then\r\n            local pathname = dir.path(docdir, found)\r\n            util.printout()\r\n            util.printout(\"Opening \"..pathname..\" ...\")\r\n            util.printout()\r\n            local ok = fs.browser(pathname)\r\n            if not ok and not pathname:match(htmlpatt) then\r\n               local fd = io.open(pathname, \"r\")\r\n               util.printout(fd:read(\"*a\"))\r\n               fd:close()\r\n            end\r\n            return true\r\n         end\r\n      end\r\n   end\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 15,
    "text": "function download(arch, name, version, all)\r\n   local results, err\r\n   local query = search.make_query(name, version)\r\n   if arch then query.arch = arch end\r\n   if all then\r\n      if name == \"\" then query.exact_name = false end\r\n      results = search.search_repos(query)\r\n   else\r\n      results, err = search.find_suitable_rock(query)\r\n   end\r\n   if type(results) == \"string\" then\r\n      return get_file(results)\r\n   elseif type(results) == \"table\" and next(results) then\r\n      if all then\r\n         local all_ok = true\r\n         local any_err = \"\"\r\n         for name, result in pairs(results) do\r\n            for version, versions in pairs(result) do\r\n               for _,items in pairs(versions) do\r\n                  local filename = path.make_url(items.repo, name, version, items.arch)\r\n                  local ok, err = get_file(filename)\r\n                  if not ok then\r\n                     all_ok = false\r\n                     any_err = any_err .. \"\\n\" .. err\r\n                  end\r\n               end\r\n            end\r\n         end\r\n         return all_ok, any_err\r\n      else\r\n         util.printerr(\"Multiple search results were returned.\")\r\n         util.title(\"Search results:\")\r\n         search.print_results(results)\r\n         return nil, \"Please narrow your query or use --all.\"\r\n      end\r\n   end\r\n   return nil, \"Could not find a result named \"..name..(version and \" \"..version or \"\")..\".\"\r\nend",
    "type": "function"
  }, {
    "id": 16,
    "text": "function load_local_rockspec(filename, quick)\r\n   assert(type(filename) == \"string\")\r\n   filename = fs.absolute_name(filename)\r\n   local rockspec, err = persist.load_into_table(filename)\r\n   if not rockspec then\r\n      return nil, \"Could not load rockspec file \"..filename..\" (\"..err..\")\"\r\n   end\r\n\r\n   local ok, err = true, nil\r\n   if not quick then\r\n      ok, err = type_check.type_check_rockspec(rockspec)\r\n      if not ok then\r\n         return nil, filename..\": \"..err\r\n      end\r\n   end\r\n   \r\n   if rockspec.rockspec_format then\r\n      if deps.compare_versions(rockspec.rockspec_format, type_check.rockspec_format) then\r\n         return nil, \"Rockspec format \"..rockspec.rockspec_format..\" is not supported, please upgrade LuaRocks.\"\r\n      end\r\n   end\r\n\r\n   util.platform_overrides(rockspec.build)\r\n   util.platform_overrides(rockspec.dependencies)\r\n   util.platform_overrides(rockspec.external_dependencies)\r\n   util.platform_overrides(rockspec.source)\r\n   util.platform_overrides(rockspec.hooks)\r\n\r\n   local basename = dir.base_name(filename)\r\n   if basename == \"rockspec\" then\r\n      rockspec.name = rockspec.package:lower()\r\n   else\r\n      rockspec.name = basename:match(\"(.*)-[^-]*-[0-9]*\")\r\n      if not rockspec.name then\r\n         return nil, \"Expected filename in format 'name-version-revision.rockspec'.\"\r\n      end\r\n   end\r\n\r\n   local protocol, pathname = dir.split_url(rockspec.source.url)\r\n   if is_basic_protocol(protocol) then\r\n      rockspec.source.file = rockspec.source.file or dir.base_name(rockspec.source.url)\r\n   end\r\n   rockspec.source.protocol, rockspec.source.pathname = protocol, pathname\r\n\r\n   -- Temporary compatibility\r\n   if rockspec.source.cvs_module then rockspec.source.module = rockspec.source.cvs_module end\r\n   if rockspec.source.cvs_tag then rockspec.source.tag = rockspec.source.cvs_tag end\r\n\r\n   local name_version = rockspec.package:lower() .. \"-\" .. rockspec.version\r\n   if basename ~= \"rockspec\" and basename ~= name_version .. \".rockspec\" then\r\n      return nil, \"Inconsistency between rockspec filename (\"..basename..\") and its contents (\"..name_version..\".rockspec).\"\r\n   end\r\n\r\n   rockspec.local_filename = filename\r\n   local filebase = rockspec.source.file or rockspec.source.url\r\n   local base = url_to_base_dir(filebase)\r\n   rockspec.source.dir = rockspec.source.dir\r\n                      or rockspec.source.module\r\n                      or ((filebase:match(\".lua$\") or filebase:match(\".c$\")) and \".\")\r\n                      or base\r\n   if rockspec.dependencies then\r\n      for i = 1, #rockspec.dependencies do\r\n         local parsed, err = deps.parse_dep(rockspec.dependencies[i])\r\n         if not parsed then\r\n            return nil, \"Parse error processing dependency '\"..rockspec.dependencies[i]..\"': \"..tostring(err)\r\n         end\r\n         rockspec.dependencies[i] = parsed\r\n      end\r\n   else\r\n      rockspec.dependencies = {}\r\n   end\r\n   if not quick then\r\n      path.configure_paths(rockspec)\r\n   end\r\n\r\n   return rockspec\r\nend",
    "type": "function"
  }, {
    "id": 17,
    "text": "function check_command_permissions(flags)\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   local ok = true\r\n   local err = \"\"\r\n   for _, dir in ipairs { cfg.rocks_dir, root_dir } do\r\n      if fs.exists(dir) and not fs.is_writable(dir) then\r\n         ok = false\r\n         err = \"Your user does not have write permissions in \" .. dir\r\n         break\r\n      end\r\n   end\r\n   local root_parent = dir.dir_name(root_dir)\r\n   if ok and not fs.exists(root_dir) and not fs.is_writable(root_parent) then\r\n      ok = false\r\n      err = root_dir..\" does not exist and your user does not have write permissions in \" .. root_parent\r\n   end\r\n   if ok then\r\n      return true\r\n   else\r\n      if flags[\"local\"] then\r\n         err = err .. \" \\n-- please check your permissions.\"\r\n      else\r\n         err = err .. \" \\n-- you may want to run as a privileged user or use your local tree with --local.\"\r\n      end\r\n      return nil, err\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 18,
    "text": "function install_binary_rock(rock_file, deps_mode)\r\n   assert(type(rock_file) == \"string\")\r\n\r\n   local name, version, arch = path.parse_name(rock_file)\r\n   if not name then\r\n      return nil, \"Filename \"..rock_file..\" does not match format 'name-version-revision.arch.rock'.\"\r\n   end\r\n   \r\n   if arch ~= \"all\" and arch ~= cfg.arch then\r\n      return nil, \"Incompatible architecture \"..arch, \"arch\"\r\n   end\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n   \r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n   \r\n   local ok, err, errcode = fetch.fetch_and_unpack_rock(rock_file, path.install_dir(name, version))\r\n   if not ok then return nil, err, errcode end\r\n   \r\n   local rockspec, err, errcode = fetch.load_rockspec(path.rockspec_file(name, version))\r\n   if err then\r\n      return nil, \"Failed loading rockspec for installed package: \"..err, errcode\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      ok, err, errcode = deps.check_external_deps(rockspec, \"install\")\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   -- For compatibility with .rock files built with LuaRocks 1\r\n   if not fs.exists(path.rock_manifest_file(name, version)) then\r\n      ok, err = manif.make_rock_manifest(name, version)\r\n      if err then return nil, err end\r\n   end\r\n\r\n   if deps_mode ~= \"none\" then\r\n      ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   local wrap_bin_scripts = true\r\n   if rockspec.deploy and rockspec.deploy.wrap_bin_scripts == false then\r\n      wrap_bin_scripts = false\r\n   end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n\r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n   \r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n   \r\n   local license = \"\"\r\n   if rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 19,
    "text": "function run(...)\r\n   local flags, filter, version = util.parse_flags(...)\r\n   local results = {}\r\n   local query = search.make_query(filter and filter:lower() or \"\", version)\r\n   query.exact_name = false\r\n   local trees = cfg.rocks_trees\r\n   if flags[\"tree\"] then\r\n      trees = { flags[\"tree\"] }\r\n   end\r\n   for _, tree in ipairs(trees) do\r\n      search.manifest_search(results, path.rocks_dir(tree), query)\r\n   end\r\n   util.title(\"Installed rocks:\", flags[\"porcelain\"])\r\n   search.print_results(results, flags[\"porcelain\"])\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 20,
    "text": "local function load_rocks_trees() \r\n   local any_ok = false\r\n   local trees = {}\r\n   for _, tree in ipairs(cfg.rocks_trees) do\r\n      local manifest, err = manif_core.load_local_manifest(path.rocks_dir(tree))\r\n      if manifest then\r\n         any_ok = true\r\n         table.insert(trees, {tree=tree, manifest=manifest})\r\n      end\r\n   end\r\n   if not any_ok then\r\n      rocks_trees = false\r\n      return false\r\n   end\r\n   rocks_trees = trees\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 21,
    "text": "local function pick_module(module)\r\n   return\r\n      select_module(module, function(module_name, name, version, tree, i)\r\n         if i > 1 then\r\n            module_name = path.versioned_name(module_name, \"\", name, version)\r\n         end\r\n         module_name = path.path_to_module(module_name)\r\n         return module_name\r\n      end)\r\nend",
    "type": "function"
  }, {
    "id": 22,
    "text": "function load_rock_manifest(name, version, root)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local name_version = name..\"/\"..version\r\n   if rock_manifest_cache[name_version] then\r\n      return rock_manifest_cache[name_version].rock_manifest\r\n   end\r\n   local pathname = path.rock_manifest_file(name, version, root)\r\n   local rock_manifest = persist.load_into_table(pathname)\r\n   if not rock_manifest then return nil end\r\n   rock_manifest_cache[name_version] = rock_manifest\r\n   return rock_manifest.rock_manifest\r\nend",
    "type": "function"
  }, {
    "id": 23,
    "text": "function make_rock_manifest(name, version)\r\n   local install_dir = path.install_dir(name, version)\r\n   local rock_manifest = path.rock_manifest_file(name, version)\r\n   local tree = {}\r\n   for _, file in ipairs(fs.find(install_dir)) do\r\n      local full_path = dir.path(install_dir, file)\r\n      local walk = tree\r\n      local last\r\n      local last_name\r\n      for name in file:gmatch(\"[^/]+\") do\r\n         local next = walk[name]\r\n         if not next then\r\n            next = {}\r\n            walk[name] = next\r\n         end\r\n         last = walk\r\n         last_name = name\r\n         walk = next\r\n      end\r\n      if fs.is_file(full_path) then\r\n         local sum, err = fs.get_md5(full_path)\r\n         if not sum then\r\n            return nil, \"Failed producing checksum: \"..tostring(err)\r\n         end\r\n         last[last_name] = sum\r\n      end\r\n   end\r\n   local rock_manifest = { rock_manifest=tree }\r\n   rock_manifest_cache[name..\"/\"..version] = rock_manifest\r\n   save_table(install_dir, \"rock_manifest\", rock_manifest )\r\nend",
    "type": "function"
  }, {
    "id": 24,
    "text": "function update_manifest(name, version, repo, deps_mode)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   repo = path.rocks_dir(repo or cfg.root_dir)\r\n   assert(type(deps_mode) == \"string\")\r\n   \r\n   if deps_mode == \"none\" then deps_mode = cfg.deps_mode end\r\n\r\n   util.printout(\"Updating manifest for \"..repo)\r\n\r\n   local manifest, err = load_manifest(repo)\r\n   if not manifest then\r\n      util.printerr(\"No existing manifest. Attempting to rebuild...\")\r\n      local ok, err = make_manifest(repo, deps_mode)\r\n      if not ok then\r\n         return nil, err\r\n      end\r\n      manifest, err = load_manifest(repo)\r\n      if not manifest then\r\n         return nil, err\r\n      end\r\n   end\r\n\r\n   local results = {[name] = {[version] = {{arch = \"installed\", repo = repo}}}}\r\n\r\n   local dep_handler = function(manifest)\r\n      update_dependencies(manifest, deps_mode)\r\n   end\r\n   local ok, err = store_results(results, manifest, dep_handler)\r\n   if not ok then return nil, err end\r\n\r\n   return save_table(repo, \"manifest\", manifest)\r\nend",
    "type": "function"
  }, {
    "id": 25,
    "text": "local function find_providers(file, root)\r\n   assert(type(file) == \"string\")\r\n   root = root or cfg.root_dir\r\n\r\n   local manifest, err = manif_core.load_local_manifest(path.rocks_dir(root))\r\n   if not manifest then\r\n      return nil, \"untracked\"\r\n   end\r\n   local deploy_bin = path.deploy_bin_dir(root)\r\n   local deploy_lua = path.deploy_lua_dir(root)\r\n   local deploy_lib = path.deploy_lib_dir(root)\r\n   local key, manifest_tbl\r\n\r\n   if util.starts_with(file, deploy_lua) then\r\n      manifest_tbl = manifest.modules\r\n      key = path.path_to_module(file:sub(#deploy_lua+1):gsub(\"\\\\\", \"/\"))\r\n   elseif util.starts_with(file, deploy_lib) then\r\n      manifest_tbl = manifest.modules\r\n      key = path.path_to_module(file:sub(#deploy_lib+1):gsub(\"\\\\\", \"/\"))\r\n   elseif util.starts_with(file, deploy_bin) then\r\n      manifest_tbl = manifest.commands\r\n      key = file:sub(#deploy_bin+1):gsub(\"^[\\\\/]*\", \"\")\r\n   else\r\n      assert(false, \"Assertion failed: '\"..file..\"' is not a deployed file.\")\r\n   end\r\n\r\n   local providers = manifest_tbl[key]\r\n   if not providers then\r\n      return nil, \"untracked\"\r\n   end\r\n   return providers\r\nend",
    "type": "function"
  }, {
    "id": 26,
    "text": "function get_versions(name, deps_mode)\r\n   assert(type(name) == \"string\")\r\n   assert(type(deps_mode) == \"string\")\r\n   \r\n   local manifest = {}\r\n   path.map_trees(deps_mode, function(tree)\r\n      local loaded = load_local_manifest(path.rocks_dir(tree))\r\n      if loaded then\r\n         util.deep_merge(manifest, loaded)\r\n      end\r\n   end)\r\n   \r\n   local item = next(manifest) and manifest.repository[name]\r\n   if item then\r\n      return util.keys(item)\r\n   end\r\n   return {}\r\nend",
    "type": "function"
  }, {
    "id": 27,
    "text": "local function copy_back_files(name, version, file_tree, deploy_dir, pack_dir)\r\n   local ok, err = fs.make_dir(pack_dir)\r\n   if not ok then return nil, err end\r\n   for file, sub in pairs(file_tree) do\r\n      local source = dir.path(deploy_dir, file)\r\n      local target = dir.path(pack_dir, file)\r\n      if type(sub) == \"table\" then\r\n         local ok, err = copy_back_files(name, version, sub, source, target)\r\n         if not ok then return nil, err end\r\n      else\r\n         local versioned = path.versioned_name(source, deploy_dir, name, version)\r\n         if fs.exists(versioned) then\r\n            fs.copy(versioned, target)\r\n         else\r\n            fs.copy(source, target)\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 28,
    "text": "local function do_pack_binary_rock(name, version)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\" or not version)\r\n\r\n   local query = search.make_query(name, version)\r\n   query.exact_name = true\r\n   local results = {}\r\n   \r\n   search.manifest_search(results, cfg.rocks_dir, query)\r\n   \r\n   if not next(results) then\r\n      return nil, \"'\"..name..\"' does not seem to be an installed rock.\"\r\n   end\r\n   \r\n   local versions = results[name]\r\n   \r\n   if not version then\r\n      local first = next(versions)\r\n      if next(versions, first) then\r\n         return nil, \"Please specify which version of '\"..name..\"' to pack.\"\r\n      end\r\n      version = first\r\n   end\r\n   if not version:match(\"[^-]+%-%d+\") then\r\n      return nil, \"Expected version \"..version..\" in version-revision format.\"\r\n   end\r\n   \r\n   local info = versions[version][1]\r\n   \r\n   local root = path.root_dir(info.repo)\r\n   local prefix = path.install_dir(name, version, root)\r\n   if not fs.exists(prefix) then\r\n      return nil, \"'\"..name..\" \"..version..\"' does not seem to be an installed rock.\"\r\n   end\r\n   \r\n   local rock_manifest = manif.load_rock_manifest(name, version, root)\r\n   if not rock_manifest then\r\n      return nil, \"rock_manifest file not found for \"..name..\" \"..version..\" - not a LuaRocks 2 tree?\"\r\n   end\r\n\r\n   local name_version = name .. \"-\" .. version\r\n   local rock_file = fs.absolute_name(name_version .. \".\"..cfg.arch..\".rock\")\r\n   \r\n   local temp_dir = fs.make_temp_dir(\"pack\")\r\n   fs.copy_contents(prefix, temp_dir)\r\n\r\n   local is_binary = false\r\n   if rock_manifest.lib then\r\n      local ok, err = copy_back_files(name, version, rock_manifest.lib, path.deploy_lib_dir(root), dir.path(temp_dir, \"lib\"))\r\n      if not ok then return nil, \"Failed copying back files: \" .. err end\r\n      is_binary = true\r\n   end\r\n   if rock_manifest.lua then\r\n      local ok, err = copy_back_files(name, version, rock_manifest.lua, path.deploy_lua_dir(root), dir.path(temp_dir, \"lua\"))\r\n      if not ok then return nil, \"Failed copying back files: \" .. err end\r\n   end\r\n   \r\n   local ok, err = fs.change_dir(temp_dir)\r\n   if not ok then return nil, err end\r\n   if not is_binary and not repos.has_binaries(name, version) then\r\n      rock_file = rock_file:gsub(\"%.\"..cfg.arch:gsub(\"%-\",\"%%-\")..\"%.\", \".all.\")\r\n   end\r\n   fs.delete(rock_file)\r\n   if not fs.zip(rock_file, unpack(fs.list_dir())) then\r\n      return nil, \"Failed packing \"..rock_file\r\n   end\r\n   fs.pop_dir()\r\n   fs.delete(temp_dir)\r\n   return rock_file\r\nend",
    "type": "function"
  }, {
    "id": 29,
    "text": "function pack_binary_rock(name, version, cmd, ...)\r\n\r\n   -- The --pack-binary-rock option for \"luarocks build\" basically performs\r\n   -- \"luarocks build\" on a temporary tree and then \"luarocks pack\". The\r\n   -- alternative would require refactoring parts of luarocks.build and\r\n   -- luarocks.pack, which would save a few file operations: the idea would be\r\n   -- to shave off the final deploy steps from the build phase and the initial\r\n   -- collect steps from the pack phase.\r\n\r\n   local temp_dir, err = fs.make_temp_dir(\"luarocks-build-pack-\"..dir.base_name(name))\r\n   if not temp_dir then\r\n      return nil, \"Failed creating temporary directory: \"..err\r\n   end\r\n   util.schedule_function(fs.delete, temp_dir)\r\n\r\n   path.use_tree(temp_dir)\r\n   local ok, err = cmd(...)\r\n   if not ok then\r\n      return nil, err\r\n   end\r\n   local rname, rversion = path.parse_name(name)\r\n   if not rname then\r\n      rname, rversion = name, version\r\n   end\r\n   return do_pack_binary_rock(rname, rversion)\r\nend",
    "type": "function"
  }, {
    "id": 30,
    "text": "function rockspec_name_from_rock(rock_name)\r\n   assert(type(rock_name) == \"string\")\r\n   local base_name = dir.base_name(rock_name)\r\n   return base_name:match(\"(.*)%.[^.]*.rock\") .. \".rockspec\"\r\nend",
    "type": "function"
  }, {
    "id": 31,
    "text": "assert(type(rock_name) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 32,
    "text": "local base_name = dir.base_name(rock_name)",
    "type": "statement:localassign"
  }, {
    "id": 33,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 34,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 35,
    "text": "function rocks_dir(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.rocks_subdir)\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.rocks_dir or dir.path(tree.root, cfg.rocks_subdir)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 36,
    "text": "if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.rocks_subdir)\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.rocks_dir or dir.path(tree.root, cfg.rocks_subdir)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 37,
    "text": "assert(type(tree) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 38,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 39,
    "text": "function root_dir(rocks_dir)\r\n   assert(type(rocks_dir) == \"string\")\r\n   return rocks_dir:match(\"(.*)\" .. util.matchquote(cfg.rocks_subdir) .. \".*$\")\r\nend",
    "type": "function"
  }, {
    "id": 40,
    "text": "assert(type(rocks_dir) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 41,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 42,
    "text": "function rocks_tree_to_string(tree)\r\n   if type(tree) == \"string\" then\r\n      return tree\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.root\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 43,
    "text": "if type(tree) == \"string\" then\r\n      return tree\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.root\r\n   end",
    "type": "statement:if"
  }, {
    "id": 44,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 45,
    "text": "function deploy_bin_dir(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, \"bin\")\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.bin_dir or dir.path(tree.root, \"bin\")\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 46,
    "text": "if type(tree) == \"string\" then\r\n      return dir.path(tree, \"bin\")\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.bin_dir or dir.path(tree.root, \"bin\")\r\n   end",
    "type": "statement:if"
  }, {
    "id": 47,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 48,
    "text": "function deploy_lua_dir(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.lua_modules_path)\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.lua_dir or dir.path(tree.root, cfg.lua_modules_path)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 49,
    "text": "if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.lua_modules_path)\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.lua_dir or dir.path(tree.root, cfg.lua_modules_path)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 50,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 51,
    "text": "function deploy_lib_dir(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.lib_modules_path)\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.lib_dir or dir.path(tree.root, cfg.lib_modules_path)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 52,
    "text": "if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.lib_modules_path)\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.lib_dir or dir.path(tree.root, cfg.lib_modules_path)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 53,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 54,
    "text": "function manifest_file(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.rocks_subdir, \"manifest\")\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return (tree.rocks_dir and dir.path(tree.rocks_dir, \"manifest\")) or dir.path(tree.root, cfg.rocks_subdir, \"manifest\")\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 55,
    "text": "if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.rocks_subdir, \"manifest\")\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return (tree.rocks_dir and dir.path(tree.rocks_dir, \"manifest\")) or dir.path(tree.root, cfg.rocks_subdir, \"manifest\")\r\n   end",
    "type": "statement:if"
  }, {
    "id": 56,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 57,
    "text": "function versions_dir(name, tree)\r\n   assert(type(name) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name)\r\nend",
    "type": "function"
  }, {
    "id": 58,
    "text": "assert(type(name) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 59,
    "text": "tree = tree or cfg.root_dir",
    "type": "statement:assign"
  }, {
    "id": 60,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 61,
    "text": "function install_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version)\r\nend",
    "type": "function"
  }, {
    "id": 62,
    "text": "assert(type(version) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 63,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 64,
    "text": "function rockspec_file(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, name..\"-\"..version..\".rockspec\")\r\nend",
    "type": "function"
  }, {
    "id": 65,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 66,
    "text": "function rock_manifest_file(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"rock_manifest\")\r\nend",
    "type": "function"
  }, {
    "id": 67,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 68,
    "text": "function lib_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"lib\")\r\nend",
    "type": "function"
  }, {
    "id": 69,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 70,
    "text": "function lua_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"lua\")\r\nend",
    "type": "function"
  }, {
    "id": 71,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 72,
    "text": "function doc_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"doc\")\r\nend",
    "type": "function"
  }, {
    "id": 73,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 74,
    "text": "function conf_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"conf\")\r\nend",
    "type": "function"
  }, {
    "id": 75,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 76,
    "text": "function bin_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"bin\")\r\nend",
    "type": "function"
  }, {
    "id": 77,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 78,
    "text": "function parse_name(file_name)\r\n   assert(type(file_name) == \"string\")\r\n   if file_name:match(\"%.rock$\") then\r\n      return dir.base_name(file_name):match(\"(.*)-([^-]+-%d+)%.([^.]+)%.rock$\")\r\n   else\r\n      return dir.base_name(file_name):match(\"(.*)-([^-]+-%d+)%.(rockspec)\")\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 79,
    "text": "assert(type(file_name) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 80,
    "text": "if file_name:match(\"%.rock$\") then\r\n      return dir.base_name(file_name):match(\"(.*)-([^-]+-%d+)%.([^.]+)%.rock$\")\r\n   else\r\n      return dir.base_name(file_name):match(\"(.*)-([^-]+-%d+)%.(rockspec)\")\r\n   end",
    "type": "statement:if"
  }, {
    "id": 81,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 82,
    "text": "function make_url(pathname, name, version, arch)\r\n   assert(type(pathname) == \"string\")\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   assert(type(arch) == \"string\")\r\n\r\n   local filename = name..\"-\"..version\r\n   if arch == \"installed\" then\r\n      filename = dir.path(name, version, filename..\".rockspec\")\r\n   elseif arch == \"rockspec\" then\r\n      filename = filename..\".rockspec\"\r\n   else\r\n      filename = filename..\".\"..arch..\".rock\"\r\n   end\r\n   return dir.path(pathname, filename)\r\nend",
    "type": "function"
  }, {
    "id": 83,
    "text": "assert(type(pathname) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 84,
    "text": "assert(type(arch) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 85,
    "text": "local filename = name..\"-\"..version",
    "type": "statement:localassign"
  }, {
    "id": 86,
    "text": "if arch == \"installed\" then\r\n      filename = dir.path(name, version, filename..\".rockspec\")\r\n   elseif arch == \"rockspec\" then\r\n      filename = filename..\".rockspec\"\r\n   else\r\n      filename = filename..\".\"..arch..\".rock\"\r\n   end",
    "type": "statement:if"
  }, {
    "id": 87,
    "text": "filename = dir.path(name, version, filename..\".rockspec\")",
    "type": "statement:assign"
  }, {
    "id": 88,
    "text": "filename = filename..\".rockspec\"",
    "type": "statement:assign"
  }, {
    "id": 89,
    "text": "filename = filename..\".\"..arch..\".rock\"",
    "type": "statement:assign"
  }, {
    "id": 90,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 91,
    "text": "function path_to_module(file)\r\n   assert(type(file) == \"string\")\r\n\r\n   local name = file:match(\"(.*)%.\"..cfg.lua_extension..\"$\")\r\n   if name then\r\n      name = name:gsub(dir.separator, \".\")\r\n      local init = name:match(\"(.*)%.init$\")\r\n      if init then\r\n         name = init\r\n      end\r\n   else\r\n      name = file:match(\"(.*)%.\"..cfg.lib_extension..\"$\")\r\n      if name then\r\n         name = name:gsub(dir.separator, \".\")\r\n      end\r\n   end\r\n   if not name then name = file end\r\n   name = name:gsub(\"^%.+\", \"\"):gsub(\"%.+$\", \"\")\r\n   return name\r\nend",
    "type": "function"
  }, {
    "id": 92,
    "text": "assert(type(file) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 93,
    "text": "local name = file:match(\"(.*)%.\"..cfg.lua_extension..\"$\")",
    "type": "statement:localassign"
  }, {
    "id": 94,
    "text": "if name then\r\n      name = name:gsub(dir.separator, \".\")\r\n      local init = name:match(\"(.*)%.init$\")\r\n      if init then\r\n         name = init\r\n      end\r\n   else\r\n      name = file:match(\"(.*)%.\"..cfg.lib_extension..\"$\")\r\n      if name then\r\n         name = name:gsub(dir.separator, \".\")\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 95,
    "text": "name = name:gsub(dir.separator, \".\")",
    "type": "statement:assign"
  }, {
    "id": 96,
    "text": "local init = name:match(\"(.*)%.init$\")",
    "type": "statement:localassign"
  }, {
    "id": 97,
    "text": "if init then\r\n         name = init\r\n      end",
    "type": "statement:if"
  }, {
    "id": 98,
    "text": "name = init",
    "type": "statement:assign"
  }, {
    "id": 99,
    "text": "name = file:match(\"(.*)%.\"..cfg.lib_extension..\"$\")",
    "type": "statement:assign"
  }, {
    "id": 100,
    "text": "if name then\r\n         name = name:gsub(dir.separator, \".\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 101,
    "text": "if not name then name = file end",
    "type": "statement:if"
  }, {
    "id": 102,
    "text": "name = file",
    "type": "statement:assign"
  }, {
    "id": 103,
    "text": "name = name:gsub(\"^%.+\", \"\"):gsub(\"%.+$\", \"\")",
    "type": "statement:assign"
  }, {
    "id": 104,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 105,
    "text": "function module_to_path(mod)\r\n   assert(type(mod) == \"string\")\r\n   return (mod:gsub(\"[^.]*$\", \"\"):gsub(\"%.\", dir.separator))\r\nend",
    "type": "function"
  }, {
    "id": 106,
    "text": "assert(type(mod) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 107,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 108,
    "text": "function configure_paths(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n   local vars = {}\r\n   for k,v in pairs(cfg.variables) do\r\n      vars[k] = v\r\n   end\r\n   local name, version = rockspec.name, rockspec.version\r\n   vars.PREFIX = install_dir(name, version)\r\n   vars.LUADIR = lua_dir(name, version)\r\n   vars.LIBDIR = lib_dir(name, version)\r\n   vars.CONFDIR = conf_dir(name, version)\r\n   vars.BINDIR = bin_dir(name, version)\r\n   vars.DOCDIR = doc_dir(name, version)\r\n   rockspec.variables = vars\r\nend",
    "type": "function"
  }, {
    "id": 109,
    "text": "assert(type(rockspec) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 110,
    "text": "local vars = {}",
    "type": "statement:localassign"
  }, {
    "id": 111,
    "text": "for k,v in pairs(cfg.variables) do\r\n      vars[k] = v\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 112,
    "text": "vars[k] = v",
    "type": "statement:assign"
  }, {
    "id": 113,
    "text": "local name, version = rockspec.name, rockspec.version",
    "type": "statement:localassign"
  }, {
    "id": 114,
    "text": "vars.PREFIX = install_dir(name, version)",
    "type": "statement:assign"
  }, {
    "id": 115,
    "text": "vars.LUADIR = lua_dir(name, version)",
    "type": "statement:assign"
  }, {
    "id": 116,
    "text": "vars.LIBDIR = lib_dir(name, version)",
    "type": "statement:assign"
  }, {
    "id": 117,
    "text": "vars.CONFDIR = conf_dir(name, version)",
    "type": "statement:assign"
  }, {
    "id": 118,
    "text": "vars.BINDIR = bin_dir(name, version)",
    "type": "statement:assign"
  }, {
    "id": 119,
    "text": "vars.DOCDIR = doc_dir(name, version)",
    "type": "statement:assign"
  }, {
    "id": 120,
    "text": "rockspec.variables = vars",
    "type": "statement:assign"
  }, {
    "id": 121,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 122,
    "text": "function versioned_name(file, prefix, name, version)\r\n   assert(type(file) == \"string\")\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local rest = file:sub(#prefix+1):gsub(\"^/*\", \"\")\r\n   local name_version = (name..\"_\"..version):gsub(\"%-\", \"_\"):gsub(\"%.\", \"_\")\r\n   return dir.path(prefix, name_version..\"-\"..rest)\r\nend",
    "type": "function"
  }, {
    "id": 123,
    "text": "local rest = file:sub(#prefix+1):gsub(\"^/*\", \"\")",
    "type": "statement:localassign"
  }, {
    "id": 124,
    "text": "local name_version = (name..\"_\"..version):gsub(\"%-\", \"_\"):gsub(\"%.\", \"_\")",
    "type": "statement:localassign"
  }, {
    "id": 125,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 126,
    "text": "function use_tree(tree)\r\n   cfg.root_dir = tree\r\n   cfg.rocks_dir = rocks_dir(tree)\r\n   cfg.deploy_bin_dir = deploy_bin_dir(tree)\r\n   cfg.deploy_lua_dir = deploy_lua_dir(tree)\r\n   cfg.deploy_lib_dir = deploy_lib_dir(tree)\r\nend",
    "type": "function"
  }, {
    "id": 127,
    "text": "cfg.root_dir = tree",
    "type": "statement:assign"
  }, {
    "id": 128,
    "text": "cfg.rocks_dir = rocks_dir(tree)",
    "type": "statement:assign"
  }, {
    "id": 129,
    "text": "cfg.deploy_bin_dir = deploy_bin_dir(tree)",
    "type": "statement:assign"
  }, {
    "id": 130,
    "text": "cfg.deploy_lua_dir = deploy_lua_dir(tree)",
    "type": "statement:assign"
  }, {
    "id": 131,
    "text": "cfg.deploy_lib_dir = deploy_lib_dir(tree)",
    "type": "statement:assign"
  }, {
    "id": 132,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 133,
    "text": "function map_trees(deps_mode, fn, ...)\r\n   local result = {}\r\n   if deps_mode == \"one\" then\r\n      table.insert(result, (fn(cfg.root_dir, ...)) or 0)\r\n   elseif deps_mode == \"all\" or deps_mode == \"order\" then\r\n      local use = false\r\n      if deps_mode == \"all\" then\r\n         use = true\r\n      end\r\n      for _, tree in ipairs(cfg.rocks_trees) do\r\n         if dir.normalize(rocks_tree_to_string(tree)) == dir.normalize(rocks_tree_to_string(cfg.root_dir)) then\r\n            use = true\r\n         end\r\n         if use then\r\n            table.insert(result, (fn(tree, ...)) or 0)\r\n         end\r\n      end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 134,
    "text": "local result = {}",
    "type": "statement:localassign"
  }, {
    "id": 135,
    "text": "if deps_mode == \"one\" then\r\n      table.insert(result, (fn(cfg.root_dir, ...)) or 0)\r\n   elseif deps_mode == \"all\" or deps_mode == \"order\" then\r\n      local use = false\r\n      if deps_mode == \"all\" then\r\n         use = true\r\n      end\r\n      for _, tree in ipairs(cfg.rocks_trees) do\r\n         if dir.normalize(rocks_tree_to_string(tree)) == dir.normalize(rocks_tree_to_string(cfg.root_dir)) then\r\n            use = true\r\n         end\r\n         if use then\r\n            table.insert(result, (fn(tree, ...)) or 0)\r\n         end\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 136,
    "text": "table.insert(result, (fn(cfg.root_dir, ...)) or 0)",
    "type": "statement:functioncall"
  }, {
    "id": 137,
    "text": "local use = false",
    "type": "statement:localassign"
  }, {
    "id": 138,
    "text": "if deps_mode == \"all\" then\r\n         use = true\r\n      end",
    "type": "statement:if"
  }, {
    "id": 139,
    "text": "use = true",
    "type": "statement:assign"
  }, {
    "id": 140,
    "text": "for _, tree in ipairs(cfg.rocks_trees) do\r\n         if dir.normalize(rocks_tree_to_string(tree)) == dir.normalize(rocks_tree_to_string(cfg.root_dir)) then\r\n            use = true\r\n         end\r\n         if use then\r\n            table.insert(result, (fn(tree, ...)) or 0)\r\n         end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 141,
    "text": "if dir.normalize(rocks_tree_to_string(tree)) == dir.normalize(rocks_tree_to_string(cfg.root_dir)) then\r\n            use = true\r\n         end",
    "type": "statement:if"
  }, {
    "id": 142,
    "text": "if use then\r\n            table.insert(result, (fn(tree, ...)) or 0)\r\n         end",
    "type": "statement:if"
  }, {
    "id": 143,
    "text": "table.insert(result, (fn(tree, ...)) or 0)",
    "type": "statement:functioncall"
  }, {
    "id": 144,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 145,
    "text": "function which_i(module_name, name, version, tree, i)\r\n   local deploy_dir\r\n   if module_name:match(\"%.lua$\") then\r\n      deploy_dir = deploy_lua_dir(tree)\r\n      module_name = dir.path(deploy_dir, module_name)\r\n   else\r\n      deploy_dir = deploy_lib_dir(tree)\r\n      module_name = dir.path(deploy_dir, module_name)\r\n   end\r\n   if i > 1 then\r\n      module_name = versioned_name(module_name, deploy_dir, name, version)\r\n   end\r\n   return module_name\r\nend",
    "type": "function"
  }, {
    "id": 146,
    "text": "local deploy_dir",
    "type": "statement:localassign"
  }, {
    "id": 147,
    "text": "if module_name:match(\"%.lua$\") then\r\n      deploy_dir = deploy_lua_dir(tree)\r\n      module_name = dir.path(deploy_dir, module_name)\r\n   else\r\n      deploy_dir = deploy_lib_dir(tree)\r\n      module_name = dir.path(deploy_dir, module_name)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 148,
    "text": "deploy_dir = deploy_lua_dir(tree)",
    "type": "statement:assign"
  }, {
    "id": 149,
    "text": "module_name = dir.path(deploy_dir, module_name)",
    "type": "statement:assign"
  }, {
    "id": 150,
    "text": "deploy_dir = deploy_lib_dir(tree)",
    "type": "statement:assign"
  }, {
    "id": 151,
    "text": "if i > 1 then\r\n      module_name = versioned_name(module_name, deploy_dir, name, version)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 152,
    "text": "module_name = versioned_name(module_name, deploy_dir, name, version)",
    "type": "statement:assign"
  }, {
    "id": 153,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 154,
    "text": "function which(module_name, filename, name, version, tree, manifest)\r\n   local versions = manifest.modules[module_name]\r\n   assert(versions)\r\n   for i, name_version in ipairs(versions) do\r\n      if name_version == name..\"/\"..version then\r\n         return which_i(filename, name, version, tree, i):gsub(\"//\", \"/\")\r\n      end\r\n   end\r\n   assert(false)\r\nend",
    "type": "function"
  }, {
    "id": 155,
    "text": "local versions = manifest.modules[module_name]",
    "type": "statement:localassign"
  }, {
    "id": 156,
    "text": "assert(versions)",
    "type": "statement:functioncall"
  }, {
    "id": 157,
    "text": "for i, name_version in ipairs(versions) do\r\n      if name_version == name..\"/\"..version then\r\n         return which_i(filename, name, version, tree, i):gsub(\"//\", \"/\")\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 158,
    "text": "if name_version == name..\"/\"..version then\r\n         return which_i(filename, name, version, tree, i):gsub(\"//\", \"/\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 159,
    "text": "assert(false)",
    "type": "statement:functioncall"
  }, {
    "id": 160,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 161,
    "text": "function run(...)\r\n   local flags = util.parse_flags(...)\r\n   local deps_mode = deps.get_deps_mode(flags)\r\n   \r\n   local lr_path, lr_cpath = cfg.package_paths()\r\n   local bin_dirs = map_trees(deps_mode, deploy_bin_dir)\r\n\r\n   if flags[\"lr-path\"] then\r\n      util.printout(util.remove_path_dupes(lr_path, ';'))\r\n      return true\r\n   elseif flags[\"lr-cpath\"] then\r\n      util.printout(util.remove_path_dupes(lr_cpath, ';'))\r\n      return true\r\n   elseif flags[\"lr-bin\"] then\r\n      local lr_bin = util.remove_path_dupes(table.concat(bin_dirs, cfg.export_path_separator), cfg.export_path_separator)\r\n      util.printout(util.remove_path_dupes(lr_bin, ';'))\r\n      return true\r\n   end\r\n   \r\n   if flags[\"append\"] then\r\n      lr_path = package.path .. \";\" .. lr_path\r\n      lr_cpath = package.cpath .. \";\" .. lr_cpath\r\n   else\r\n      lr_path =  lr_path.. \";\" .. package.path\r\n      lr_cpath = lr_cpath .. \";\" .. package.cpath\r\n   end\r\n\r\n   util.printout(cfg.export_lua_path:format(util.remove_path_dupes(lr_path, ';')))\r\n   util.printout(cfg.export_lua_cpath:format(util.remove_path_dupes(lr_cpath, ';')))\r\n   if flags[\"bin\"] then\r\n      table.insert(bin_dirs, 1, os.getenv(\"PATH\"))\r\n      local lr_bin = util.remove_path_dupes(table.concat(bin_dirs, cfg.export_path_separator), cfg.export_path_separator)\r\n      util.printout(cfg.export_path:format(lr_bin))\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 162,
    "text": "local flags = util.parse_flags(...)",
    "type": "statement:localassign"
  }, {
    "id": 163,
    "text": "local deps_mode = deps.get_deps_mode(flags)",
    "type": "statement:localassign"
  }, {
    "id": 164,
    "text": "local lr_path, lr_cpath = cfg.package_paths()",
    "type": "statement:localassign"
  }, {
    "id": 165,
    "text": "local bin_dirs = map_trees(deps_mode, deploy_bin_dir)",
    "type": "statement:localassign"
  }, {
    "id": 166,
    "text": "if flags[\"lr-path\"] then\r\n      util.printout(util.remove_path_dupes(lr_path, ';'))\r\n      return true\r\n   elseif flags[\"lr-cpath\"] then\r\n      util.printout(util.remove_path_dupes(lr_cpath, ';'))\r\n      return true\r\n   elseif flags[\"lr-bin\"] then\r\n      local lr_bin = util.remove_path_dupes(table.concat(bin_dirs, cfg.export_path_separator), cfg.export_path_separator)\r\n      util.printout(util.remove_path_dupes(lr_bin, ';'))\r\n      return true\r\n   end",
    "type": "statement:if"
  }, {
    "id": 167,
    "text": "util.printout(util.remove_path_dupes(lr_path, ';'))",
    "type": "statement:functioncall"
  }, {
    "id": 168,
    "text": "util.printout(util.remove_path_dupes(lr_cpath, ';'))",
    "type": "statement:functioncall"
  }, {
    "id": 169,
    "text": "local lr_bin = util.remove_path_dupes(table.concat(bin_dirs, cfg.export_path_separator), cfg.export_path_separator)",
    "type": "statement:localassign"
  }, {
    "id": 170,
    "text": "util.printout(util.remove_path_dupes(lr_bin, ';'))",
    "type": "statement:functioncall"
  }, {
    "id": 171,
    "text": "if flags[\"append\"] then\r\n      lr_path = package.path .. \";\" .. lr_path\r\n      lr_cpath = package.cpath .. \";\" .. lr_cpath\r\n   else\r\n      lr_path =  lr_path.. \";\" .. package.path\r\n      lr_cpath = lr_cpath .. \";\" .. package.cpath\r\n   end",
    "type": "statement:if"
  }, {
    "id": 172,
    "text": "lr_path = package.path .. \";\" .. lr_path",
    "type": "statement:assign"
  }, {
    "id": 173,
    "text": "lr_cpath = package.cpath .. \";\" .. lr_cpath",
    "type": "statement:assign"
  }, {
    "id": 174,
    "text": "lr_path =  lr_path.. \";\" .. package.path",
    "type": "statement:assign"
  }, {
    "id": 175,
    "text": "lr_cpath = lr_cpath .. \";\" .. package.cpath",
    "type": "statement:assign"
  }, {
    "id": 176,
    "text": "util.printout(cfg.export_lua_path:format(util.remove_path_dupes(lr_path, ';')))",
    "type": "statement:functioncall"
  }, {
    "id": 177,
    "text": "util.printout(cfg.export_lua_cpath:format(util.remove_path_dupes(lr_cpath, ';')))",
    "type": "statement:functioncall"
  }, {
    "id": 178,
    "text": "if flags[\"bin\"] then\r\n      table.insert(bin_dirs, 1, os.getenv(\"PATH\"))\r\n      local lr_bin = util.remove_path_dupes(table.concat(bin_dirs, cfg.export_path_separator), cfg.export_path_separator)\r\n      util.printout(cfg.export_path:format(lr_bin))\r\n   end",
    "type": "statement:if"
  }, {
    "id": 179,
    "text": "table.insert(bin_dirs, 1, os.getenv(\"PATH\"))",
    "type": "statement:functioncall"
  }, {
    "id": 180,
    "text": "util.printout(cfg.export_path:format(lr_bin))",
    "type": "statement:functioncall"
  }, {
    "id": 181,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 182,
    "text": "",
    "type": "function container"
  }, {
    "id": 183,
    "text": "function run(...)\r\n   local flags = util.parse_flags(...)\r\n   \r\n   local tree = flags[\"tree\"]\r\n\r\n   if type(tree) ~= \"string\" then\r\n      return nil, \"The --tree argument is mandatory. \"..util.see_help(\"purge\")\r\n   end\r\n   \r\n   local results = {}\r\n   local query = search.make_query(\"\")\r\n   query.exact_name = false\r\n   if not fs.is_dir(tree) then\r\n      return nil, \"Directory not found: \"..tree\r\n   end\r\n\r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n\r\n   search.manifest_search(results, path.rocks_dir(tree), query)\r\n\r\n   local sort = function(a,b) return deps.compare_versions(b,a) end\r\n   if flags[\"old-versions\"] then\r\n      sort = deps.compare_versions\r\n   end\r\n\r\n   for package, versions in util.sortedpairs(results) do\r\n      for version, repositories in util.sortedpairs(versions, sort) do\r\n         if flags[\"old-versions\"] then\r\n            util.printout(\"Keeping \"..package..\" \"..version..\"...\")\r\n            local ok, err = remove.remove_other_versions(package, version, flags[\"force\"])\r\n            if not ok then\r\n               util.printerr(err)\r\n            end\r\n            break\r\n         else\r\n            util.printout(\"Removing \"..package..\" \"..version..\"...\")\r\n            local ok, err = repos.delete_version(package, version, true)\r\n            if not ok then\r\n               util.printerr(err)\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return manif.make_manifest(cfg.rocks_dir, \"one\")\r\nend",
    "type": "function"
  }, {
    "id": 184,
    "text": "local function check_dependents(name, versions, deps_mode)\r\n   local dependents = {}\r\n   local blacklist = {}\r\n   blacklist[name] = {}\r\n   for version, _ in pairs(versions) do\r\n      blacklist[name][version] = true\r\n   end\r\n   local local_rocks = {}\r\n   local query_all = search.make_query(\"\")\r\n   query_all.exact_name = false\r\n   search.manifest_search(local_rocks, cfg.rocks_dir, query_all)\r\n   local_rocks[name] = nil\r\n   for rock_name, rock_versions in pairs(local_rocks) do\r\n      for rock_version, _ in pairs(rock_versions) do\r\n         local rockspec, err = fetch.load_rockspec(path.rockspec_file(rock_name, rock_version))\r\n         if rockspec then\r\n            local _, missing = deps.match_deps(rockspec, blacklist, deps_mode)\r\n            if missing[name] then\r\n               table.insert(dependents, { name = rock_name, version = rock_version })\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return dependents\r\nend",
    "type": "function"
  }, {
    "id": 185,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   \r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing, see help.\"\r\n   end\r\n   \r\n   local deps_mode = flags[\"deps-mode\"] or cfg.deps_mode\r\n   \r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n   \r\n   local rock_type = name:match(\"%.(rock)$\") or name:match(\"%.(rockspec)$\")\r\n   local filename = name\r\n   if rock_type then\r\n      name, version = path.parse_name(filename)\r\n      if not name then return nil, \"Invalid \"..rock_type..\" filename: \"..filename end\r\n   end\r\n\r\n   local results = {}\r\n   search.manifest_search(results, cfg.rocks_dir, search.make_query(name, version))\r\n   if not results[name] then\r\n      return nil, \"Could not find rock '\"..name..(version and \" \"..version or \"\")..\"' in local tree.\"\r\n   end\r\n\r\n   return remove_search_results(results, name, deps_mode, flags[\"force\"])\r\nend",
    "type": "function"
  }, {
    "id": 186,
    "text": "local function get_installed_versions(name)\r\n   assert(type(name) == \"string\")\r\n   \r\n   local dirs = fs.list_dir(path.versions_dir(name))\r\n   return (dirs and #dirs > 0) and dirs or nil\r\nend",
    "type": "function"
  }, {
    "id": 187,
    "text": "function is_installed(name, version)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n      \r\n   return fs.is_dir(path.install_dir(name, version))\r\nend",
    "type": "function"
  }, {
    "id": 188,
    "text": "local function store_package_data(result, name, file_tree)\r\n   if not file_tree then return end\r\n   return recurse_rock_manifest_tree(file_tree, \r\n      function(parent_path, parent_module, file)\r\n         local pathname = parent_path..file\r\n         result[path.path_to_module(pathname)] = pathname\r\n         return true\r\n      end\r\n   )\r\nend",
    "type": "function"
  }, {
    "id": 189,
    "text": "local function resolve_conflict(target, deploy_dir, name, version)\r\n   local cname, cversion = manif.find_current_provider(target)\r\n   if not cname then\r\n      return nil, cversion\r\n   end\r\n   if name ~= cname or deps.compare_versions(version, cversion) then\r\n      local versioned = path.versioned_name(target, deploy_dir, cname, cversion)\r\n      local ok, err = fs.make_dir(dir.dir_name(versioned))\r\n      if not ok then return nil, err end\r\n      fs.move(target, versioned)\r\n      return target\r\n   else\r\n      return path.versioned_name(target, deploy_dir, name, version)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 190,
    "text": "function delete_version(name, version, quick)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local function delete_deployed_file_tree(file_tree, deploy_dir, suffix)\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local versioned = path.versioned_name(target, deploy_dir, name, version)\r\n            local ok, name, err = delete_suffixed(versioned, suffix)\r\n            if ok then\r\n               fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               return true\r\n            end\r\n            if err == \"fail\" then return nil, name end\r\n            ok, name, err = delete_suffixed(target, suffix)\r\n            if err == \"fail\" then return nil, name end\r\n            if not quick then\r\n               local next_name, next_version = manif.find_next_provider(target)\r\n               if next_name then\r\n                  local versioned = path.versioned_name(name, deploy_dir, next_name, next_version)\r\n                  fs.move(versioned, name)\r\n                  fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               end\r\n            end\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(target))\r\n            return true\r\n         end\r\n      )\r\n   end\r\n\r\n   local rock_manifest = manif.load_rock_manifest(name, version)\r\n   if not rock_manifest then\r\n      return nil, \"rock_manifest file not found for \"..name..\" \"..version..\" - not a LuaRocks 2 tree?\"\r\n   end\r\n   \r\n   local ok, err = true\r\n   if rock_manifest.bin then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.bin, cfg.deploy_bin_dir, cfg.wrapper_suffix)\r\n   end\r\n   if ok and rock_manifest.lua then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.lua, cfg.deploy_lua_dir)\r\n   end\r\n   if ok and rock_manifest.lib then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.lib, cfg.deploy_lib_dir)\r\n   end\r\n   if err then return nil, err end\r\n\r\n   fs.delete(path.install_dir(name, version))\r\n   if not get_installed_versions(name) then\r\n      fs.delete(dir.path(cfg.rocks_dir, name))\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 191,
    "text": "local function delete_deployed_file_tree(file_tree, deploy_dir, suffix)\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local versioned = path.versioned_name(target, deploy_dir, name, version)\r\n            local ok, name, err = delete_suffixed(versioned, suffix)\r\n            if ok then\r\n               fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               return true\r\n            end\r\n            if err == \"fail\" then return nil, name end\r\n            ok, name, err = delete_suffixed(target, suffix)\r\n            if err == \"fail\" then return nil, name end\r\n            if not quick then\r\n               local next_name, next_version = manif.find_next_provider(target)\r\n               if next_name then\r\n                  local versioned = path.versioned_name(name, deploy_dir, next_name, next_version)\r\n                  fs.move(versioned, name)\r\n                  fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               end\r\n            end\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(target))\r\n            return true\r\n         end\r\n      )\r\n   end",
    "type": "function"
  }, {
    "id": 192,
    "text": "function disk_search(repo, query, results)\r\n   assert(type(repo) == \"string\")\r\n   assert(type(query) == \"table\")\r\n   assert(type(results) == \"table\" or not results)\r\n   \r\n   local fs = require(\"luarocks.fs\")\r\n     \r\n   if not results then\r\n      results = {}\r\n   end\r\n   query_arch_as_table(query)\r\n   \r\n   for _, name in pairs(fs.list_dir(repo)) do\r\n      local pathname = dir.path(repo, name)\r\n      local rname, rversion, rarch = path.parse_name(name)\r\n\r\n      if rname and (pathname:match(\".rockspec$\") or pathname:match(\".rock$\")) then\r\n         store_if_match(results, repo, rname, rversion, rarch, query)\r\n      elseif fs.is_dir(pathname) then\r\n         for _, version in pairs(fs.list_dir(pathname)) do\r\n            if version:match(\"-%d+$\") then\r\n               store_if_match(results, repo, name, version, \"installed\", query)\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return results\r\nend",
    "type": "function"
  }, {
    "id": 193,
    "text": "local function pick_latest_version(name, versions)\r\n   assert(type(name) == \"string\")\r\n   assert(type(versions) == \"table\")\r\n\r\n   local vtables = {}\r\n   for v, _ in pairs(versions) do\r\n      table.insert(vtables, deps.parse_version(v))\r\n   end\r\n   table.sort(vtables)\r\n   local version = vtables[#vtables].string\r\n   local items = versions[version]\r\n   if items then\r\n      local pick = 1\r\n      for i, item in ipairs(items) do\r\n         if (item.arch == 'src' and items[pick].arch == 'rockspec')\r\n         or (item.arch ~= 'src' and item.arch ~= 'rockspec') then\r\n            pick = i\r\n         end\r\n      end\r\n      return path.make_url(items[pick].repo, name, version, items[pick].arch)\r\n   end\r\n   return nil\r\nend",
    "type": "function"
  }, {
    "id": 194,
    "text": "local function module_name(mod, filename, name, version, repo, manifest)\r\n   local base_dir\r\n   if filename:match(\"%.lua$\") then\r\n      base_dir = path.deploy_lua_dir(repo)\r\n   else\r\n      base_dir = path.deploy_lib_dir(repo)\r\n   end\r\n   \r\n   return dir.path(base_dir, filename)\r\nend",
    "type": "function"
  }, {
    "id": 195,
    "text": "function pick_installed_rock(name, version, tree)\r\n   local results = {}\r\n   local query = search.make_query(name, version)\r\n   query.exact_name = true\r\n   local tree_map = {}\r\n   local trees = cfg.rocks_trees\r\n   if tree then\r\n      trees = { tree }\r\n   end\r\n   for _, tree in ipairs(trees) do\r\n      local rocks_dir = path.rocks_dir(tree)\r\n      tree_map[rocks_dir] = tree\r\n      search.manifest_search(results, rocks_dir, query)\r\n   end\r\n\r\n   if not next(results) then --\r\n      return nil,\"cannot find package \"..name..\" \"..(version or \"\")..\"\\nUse 'list' to find installed rocks.\"\r\n   end\r\n\r\n   version = nil\r\n   local repo_url\r\n   local package, versions = util.sortedpairs(results)()\r\n   --question: what do we do about multiple versions? This should\r\n   --give us the latest version on the last repo (which is usually the global one)\r\n   for vs, repositories in util.sortedpairs(versions, deps.compare_versions) do\r\n      if not version then version = vs end\r\n      for _, rp in ipairs(repositories) do repo_url = rp.repo end\r\n   end\r\n\r\n   local repo = tree_map[repo_url]\r\n   return name, version, repo, repo_url\r\nend",
    "type": "function"
  }, {
    "id": 196,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if not name then\r\n      return nil, \"Argument missing. \"..util.see_help(\"show\")\r\n   end\r\n   \r\n   local repo, repo_url\r\n   name, version, repo, repo_url = pick_installed_rock(name, version, flags[\"tree\"])\r\n   if not name then\r\n      return nil, version\r\n   end\r\n\r\n   local directory = path.install_dir(name,version,repo)\r\n   local rockspec_file = path.rockspec_file(name, version, repo)\r\n   local rockspec, err = fetch.load_local_rockspec(rockspec_file)\r\n   if not rockspec then return nil,err end\r\n\r\n   local descript = rockspec.description or {}\r\n   local manifest, err = manif.load_manifest(repo_url)\r\n   if not manifest then return nil,err end\r\n   local minfo = manifest.repository[name][version][1]\r\n\r\n   if flags[\"rock-tree\"] then util.printout(path.rocks_tree_to_string(repo))\r\n   elseif flags[\"rock-dir\"] then util.printout(directory)\r\n   elseif flags[\"home\"] then util.printout(descript.homepage)\r\n   elseif flags[\"modules\"] then util.printout(keys_as_string(minfo.modules))\r\n   elseif flags[\"deps\"] then util.printout(keys_as_string(minfo.dependencies))\r\n   elseif flags[\"rockspec\"] then util.printout(rockspec_file)\r\n   elseif flags[\"mversion\"] then util.printout(version)\r\n   else\r\n      util.printout()\r\n      util.printout(rockspec.package..\" \"..rockspec.version..\" - \"..(descript.summary or \"\"))\r\n      util.printout()\r\n      if descript.detailed then\r\n         util.printout(format_text(descript.detailed))\r\n         util.printout()\r\n      end\r\n      if descript.license then\r\n         util.printout(\"License: \", descript.license)\r\n      end\r\n      if descript.homepage then\r\n         util.printout(\"Homepage: \", descript.homepage)\r\n      end\r\n      util.printout(\"Installed in: \", path.rocks_tree_to_string(repo))\r\n      if next(minfo.modules) then\r\n         util.printout()\r\n         util.printout(\"Modules:\")\r\n         for mod, filename in util.sortedpairs(minfo.modules) do\r\n            util.printout(\"\\t\"..mod..\" (\"..path.which(mod, filename, name, version, repo, manifest)..\")\")\r\n         end\r\n      end\r\n      if next(minfo.dependencies) then\r\n         util.printout()\r\n         util.printout(\"Depends on:\")\r\n         util.printout(\"\\t\"..keys_as_string(minfo.dependencies, \"\\n\\t\"))\r\n      end\r\n      util.printout()\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 197,
    "text": "function matchquote(s)\r\n   return (s:gsub(\"[?%-+*%[%].%%()$^]\",\"%%%1\"))\r\nend",
    "type": "function"
  }, {
    "id": 198,
    "text": "function parse_flags(...)\r\n   local args = {...}\r\n   local flags = {}\r\n   for i = #args, 1, -1 do\r\n      local flag = args[i]:match(\"^%-%-(.*)\")\r\n      if flag then\r\n         local var,val = flag:match(\"([a-z_%-]*)=(.*)\")\r\n         if val then\r\n            flags[var] = val\r\n         else\r\n            flags[flag] = true\r\n         end\r\n         table.remove(args, i)\r\n      end\r\n   end\r\n   return flags, unpack(args)\r\nend",
    "type": "function"
  }, {
    "id": 199,
    "text": "function printout(...)\r\n   io.stdout:write(table.concat({...},\"\\t\"))\r\n   io.stdout:write(\"\\n\")\r\nend",
    "type": "function"
  }, {
    "id": 200,
    "text": "function remove_path_dupes(list, sep)\r\n   assert(type(list) == \"string\")\r\n   assert(type(sep) == \"string\")\r\n   local parts = split_string(list, sep)\r\n   local final, entries = {}, {}\r\n   for _, part in ipairs(parts) do\r\n      if not entries[part] then\r\n         table.insert(final, part)\r\n         entries[part] = true\r\n      end\r\n   end\r\n   return table.concat(final, sep)\r\nend",
    "type": "function"
  }, {
    "id": 201,
    "text": "local function prepare_sandbox(file)\r\n   local root_dir = fs.make_temp_dir(file):gsub(\"/+$\", \"\")\r\n   cfg.root_dir = root_dir\r\n   cfg.rocks_dir = path.rocks_dir(root_dir)\r\n   cfg.deploy_bin_dir = path.deploy_bin_dir(root_dir)\r\n   cfg.variables.ROCKS_TREE = cfg.rocks_dir\r\n   cfg.variables.SCRIPTS_DIR = cfg.deploy_bin_dir\r\n   return root_dir\r\nend",
    "type": "function"
  }, {
    "id": 202,
    "text": "local function fill_as_builtin(rockspec, libs)\r\n   rockspec.build.type = \"builtin\"\r\n   rockspec.build.modules = {}\r\n   local prefix = \"\"\r\n\r\n   for _, parent in ipairs({\"src\", \"lua\"}) do\r\n      if fs.is_dir(parent) then\r\n         fs.change_dir(parent)\r\n         prefix = parent..\"/\"\r\n         break\r\n      end\r\n   end\r\n   \r\n   local incdirs, libdirs\r\n   if libs then\r\n      incdirs, libdirs = {}, {}\r\n      for _, lib in ipairs(libs) do\r\n         local upper = lib:upper()\r\n         incdirs[#incdirs+1] = \"$(\"..upper..\"_INCDIR)\"\r\n         libdirs[#libdirs+1] = \"$(\"..upper..\"_LIBDIR)\"\r\n      end\r\n   end\r\n\r\n   for _, file in ipairs(fs.find()) do\r\n      local luamod = file:match(\"(.*)%.lua$\")\r\n      if luamod and not luamod_blacklist[luamod] then\r\n         rockspec.build.modules[path.path_to_module(file)] = prefix..file\r\n      else\r\n         local cmod = file:match(\"(.*)%.c$\")\r\n         if cmod then\r\n            local modname = get_cmod_name(file) or path.path_to_module(file:gsub(\"%.c$\", \".lua\"))\r\n            rockspec.build.modules[modname] = {\r\n               sources = prefix..file,\r\n               libraries = libs,\r\n               incdirs = incdirs,\r\n               libdirs = libdirs,\r\n            }\r\n         end\r\n      end\r\n   end\r\n   \r\n   for _, directory in ipairs({ \"doc\", \"docs\", \"samples\", \"tests\" }) do\r\n      if fs.is_dir(directory) then\r\n         if not rockspec.build.copy_directories then\r\n            rockspec.build.copy_directories = {}\r\n         end\r\n         table.insert(rockspec.build.copy_directories, directory)\r\n      end\r\n   end\r\n   \r\n   if prefix ~= \"\" then\r\n      fs.pop_dir()\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 203,
    "text": "function run(...)\r\n   local flags, name, version, url_or_dir = util.parse_flags(...)\r\n   \r\n   if not name then\r\n      return nil, \"Missing arguments. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n\r\n   if name and not version then\r\n      url_or_dir = name\r\n      name = nil\r\n   elseif not url_or_dir then\r\n      url_or_dir = version\r\n   end\r\n\r\n   if flags[\"tag\"] == true then\r\n      return nil, \"Incorrect usage: --tag requires an argument. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n   \r\n   if flags[\"tag\"] then\r\n      if not version then\r\n         version = flags[\"tag\"]:gsub(\"^v\", \"\")\r\n      end\r\n   end\r\n   \r\n   local protocol, pathname = dir.split_url(url_or_dir)\r\n   if not fetch.is_basic_protocol(protocol) then\r\n      if not name then\r\n         name = dir.base_name(url_or_dir):gsub(\"%.[^.]+$\", \"\")\r\n      end\r\n      if not version then\r\n         version = \"scm\"\r\n      end\r\n   elseif protocol ~= \"file\" then\r\n      local filename = dir.base_name(url_or_dir)\r\n      local newname, newversion = filename:match(\"(.*)-([^-]+)\")\r\n      if (not name) and newname then\r\n         name = newname\r\n      end\r\n      if (not version) and newversion then\r\n         version = newversion:gsub(\".[a-z]+$\", \"\"):gsub(\".tar$\", \"\")\r\n      end\r\n      if not (name and version) then\r\n         return nil, \"Missing name and version arguments. \"..util.see_help(\"write_rockspec\")\r\n      end\r\n   elseif not version then\r\n      return nil, \"Missing name and version arguments. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n\r\n   local filename = flags[\"output\"] or dir.path(fs.current_dir(), name:lower()..\"-\"..version..\"-1.rockspec\")\r\n   \r\n   if not flags[\"homepage\"] and url_or_dir:match(\"^git://github.com\") then\r\n      flags[\"homepage\"] = \"http://\"..url_or_dir:match(\"^[^:]+://(.*)\")\r\n   end\r\n\r\n   local rockspec = {\r\n      package = name,\r\n      name = name:lower(),\r\n      version = version..\"-1\",\r\n      source = {\r\n         url = \"*** please add URL for source tarball, zip or repository here ***\",\r\n         tag = flags[\"tag\"],\r\n      },\r\n      description = {\r\n         summary = flags[\"summary\"] or \"*** please specify description summary ***\",\r\n         detailed = flags[\"detailed\"] or \"*** please enter a detailed description ***\",\r\n         homepage = flags[\"homepage\"] or \"*** please enter a project homepage ***\",\r\n         license = flags[\"license\"] or \"*** please specify a license ***\",\r\n      },\r\n      dependencies = {},\r\n      build = {},\r\n   }\r\n   path.configure_paths(rockspec)\r\n   rockspec.source.protocol = protocol\r\n   \r\n   configure_lua_version(rockspec, flags[\"lua-version\"])\r\n   \r\n   local local_dir = url_or_dir\r\n\r\n   if url_or_dir:match(\"://\") then\r\n      rockspec.source.url = url_or_dir\r\n      rockspec.source.file = dir.base_name(url_or_dir)\r\n      rockspec.source.dir = \"dummy\"\r\n      if not fetch.is_basic_protocol(rockspec.source.protocol) then\r\n         if version ~= \"scm\" then\r\n            rockspec.source.tag = flags[\"tag\"] or \"v\" .. version\r\n         end\r\n      end\r\n      rockspec.source.dir = nil\r\n      local ok, base_dir, temp_dir = get_url(rockspec)\r\n      if ok then\r\n         if base_dir ~= dir.base_name(url_or_dir) then\r\n            rockspec.source.dir = base_dir\r\n         end\r\n      end\r\n      if base_dir then\r\n         local_dir = dir.path(temp_dir, base_dir)\r\n      else\r\n         local_dir = nil\r\n      end\r\n   end\r\n   \r\n   if not local_dir then\r\n      local_dir = \".\"\r\n   end\r\n   \r\n   local libs = nil\r\n   if flags[\"lib\"] then\r\n      libs = {}\r\n      rockspec.external_dependencies = {}\r\n      for lib in flags[\"lib\"]:gmatch(\"([^,]+)\") do\r\n         table.insert(libs, lib)\r\n         rockspec.external_dependencies[lib:upper()] = {\r\n            library = lib\r\n         }\r\n      end\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_dir)\r\n   if not ok then return nil, \"Failed reaching files from project - error entering directory \"..local_dir end\r\n\r\n   detect_description(rockspec)\r\n\r\n   local is_mit = show_license(rockspec)\r\n   \r\n   if is_mit and not flags[\"license\"] then\r\n      rockspec.description.license = \"MIT\"\r\n   end\r\n   \r\n   fill_as_builtin(rockspec, libs)\r\n      \r\n   rockspec_cleanup(rockspec)\r\n   \r\n   persist.save_from_table(filename, rockspec, type_check.rockspec_order)\r\n\r\n   util.printout()   \r\n   util.printout(\"Wrote template at \"..filename..\" -- you should now edit and finish it.\")\r\n   util.printout()   \r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 204,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 205,
    "text": "getenv",
    "type": "global function"
  }, {
    "id": 206,
    "text": "ipairs",
    "type": "global function"
  }, {
    "id": 207,
    "text": "module",
    "type": "global function"
  }, {
    "id": 208,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 209,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 210,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 211,
    "text": "fn",
    "type": "global function"
  }, {
    "id": 212,
    "text": "type",
    "type": "global function"
  }, {
    "id": 213,
    "text": "require",
    "type": "global function"
  }, {
    "id": 214,
    "text": "cfg)",
    "type": "module"
  }, {
    "id": 215,
    "text": "util)",
    "type": "module"
  }, {
    "id": 216,
    "text": "dir)",
    "type": "module"
  }, {
    "id": 217,
    "text": "deps)",
    "type": "module"
  }, {
    "id": 218,
    "text": "",
    "type": "variable container"
  }, {
    "id": 219,
    "text": "",
    "type": "require container"
  }, {
    "id": 220,
    "text": "",
    "type": "global variable"
  }, {
    "id": 221,
    "text": "",
    "type": "global variable"
  }, {
    "id": 222,
    "text": "",
    "type": "global variable"
  }, {
    "id": 223,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 224,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 225,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 226,
    "text": "",
    "type": "require local variable"
  } ]
}