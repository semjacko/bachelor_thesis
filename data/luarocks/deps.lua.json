{
  "_filename": "deps.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/luarocks/src/luarocks/deps.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "calls",
    "to": 140
  }, {
    "from": 4,
    "label": "calls",
    "to": 299
  }, {
    "from": 4,
    "label": "calls",
    "to": 299
  }, {
    "from": 2,
    "label": "calls",
    "to": 189
  }, {
    "from": 3,
    "label": "calls",
    "to": 302
  }, {
    "from": 5,
    "label": "calls",
    "to": 297
  }, {
    "from": 6,
    "label": "has",
    "to": 7
  }, {
    "from": 6,
    "label": "has",
    "to": 8
  }, {
    "from": 6,
    "label": "has",
    "to": 9
  }, {
    "from": 6,
    "label": "has",
    "to": 10
  }, {
    "from": 6,
    "label": "has",
    "to": 11
  }, {
    "from": 6,
    "label": "has",
    "to": 8
  }, {
    "from": 6,
    "label": "has",
    "to": 12
  }, {
    "from": 6,
    "label": "has",
    "to": 13
  }, {
    "from": 6,
    "label": "has",
    "to": 14
  }, {
    "from": 14,
    "label": "has",
    "to": 15
  }, {
    "from": 14,
    "label": "has",
    "to": 16
  }, {
    "from": 6,
    "label": "has",
    "to": 17
  }, {
    "from": 6,
    "label": "has",
    "to": 18
  }, {
    "from": 6,
    "label": "has",
    "to": 19
  }, {
    "from": 6,
    "label": "has",
    "to": 20
  }, {
    "from": 20,
    "label": "has",
    "to": 21
  }, {
    "from": 20,
    "label": "has",
    "to": 22
  }, {
    "from": 6,
    "label": "has",
    "to": 23
  }, {
    "from": 23,
    "label": "has",
    "to": 24
  }, {
    "from": 23,
    "label": "has",
    "to": 25
  }, {
    "from": 25,
    "label": "has",
    "to": 26
  }, {
    "from": 25,
    "label": "has",
    "to": 27
  }, {
    "from": 25,
    "label": "has",
    "to": 28
  }, {
    "from": 28,
    "label": "has",
    "to": 29
  }, {
    "from": 28,
    "label": "has",
    "to": 30
  }, {
    "from": 25,
    "label": "has",
    "to": 31
  }, {
    "from": 25,
    "label": "has",
    "to": 32
  }, {
    "from": 23,
    "label": "has",
    "to": 33
  }, {
    "from": 6,
    "label": "has",
    "to": 34
  }, {
    "from": 6,
    "label": "has",
    "to": 35
  }, {
    "from": 6,
    "label": "has",
    "to": 8
  }, {
    "from": 6,
    "label": "has",
    "to": 36
  }, {
    "from": 37,
    "label": "has",
    "to": 15
  }, {
    "from": 37,
    "label": "has",
    "to": 16
  }, {
    "from": 37,
    "label": "has",
    "to": 38
  }, {
    "from": 39,
    "label": "has",
    "to": 8
  }, {
    "from": 39,
    "label": "has",
    "to": 40
  }, {
    "from": 41,
    "label": "has",
    "to": 42
  }, {
    "from": 41,
    "label": "has",
    "to": 43
  }, {
    "from": 41,
    "label": "has",
    "to": 44
  }, {
    "from": 41,
    "label": "has",
    "to": 45
  }, {
    "from": 41,
    "label": "has",
    "to": 46
  }, {
    "from": 41,
    "label": "has",
    "to": 8
  }, {
    "from": 41,
    "label": "has",
    "to": 47
  }, {
    "from": 41,
    "label": "has",
    "to": 8
  }, {
    "from": 41,
    "label": "has",
    "to": 8
  }, {
    "from": 41,
    "label": "has",
    "to": 48
  }, {
    "from": 49,
    "label": "has",
    "to": 42
  }, {
    "from": 49,
    "label": "has",
    "to": 50
  }, {
    "from": 49,
    "label": "has",
    "to": 51
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 51,
    "label": "has",
    "to": 53
  }, {
    "from": 53,
    "label": "has",
    "to": 54
  }, {
    "from": 49,
    "label": "has",
    "to": 8
  }, {
    "from": 49,
    "label": "has",
    "to": 8
  }, {
    "from": 49,
    "label": "has",
    "to": 55
  }, {
    "from": 56,
    "label": "has",
    "to": 57
  }, {
    "from": 56,
    "label": "has",
    "to": 58
  }, {
    "from": 56,
    "label": "has",
    "to": 59
  }, {
    "from": 56,
    "label": "has",
    "to": 8
  }, {
    "from": 56,
    "label": "has",
    "to": 60
  }, {
    "from": 56,
    "label": "has",
    "to": 61
  }, {
    "from": 56,
    "label": "has",
    "to": 8
  }, {
    "from": 56,
    "label": "has",
    "to": 8
  }, {
    "from": 56,
    "label": "has",
    "to": 62
  }, {
    "from": 63,
    "label": "has",
    "to": 64
  }, {
    "from": 63,
    "label": "has",
    "to": 65
  }, {
    "from": 63,
    "label": "has",
    "to": 8
  }, {
    "from": 63,
    "label": "has",
    "to": 66
  }, {
    "from": 67,
    "label": "has",
    "to": 68
  }, {
    "from": 67,
    "label": "has",
    "to": 65
  }, {
    "from": 67,
    "label": "has",
    "to": 69
  }, {
    "from": 67,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 67,
    "label": "has",
    "to": 8
  }, {
    "from": 67,
    "label": "has",
    "to": 72
  }, {
    "from": 73,
    "label": "has",
    "to": 74
  }, {
    "from": 73,
    "label": "has",
    "to": 75
  }, {
    "from": 73,
    "label": "has",
    "to": 76
  }, {
    "from": 76,
    "label": "has",
    "to": 45
  }, {
    "from": 73,
    "label": "has",
    "to": 77
  }, {
    "from": 77,
    "label": "has",
    "to": 78
  }, {
    "from": 73,
    "label": "has",
    "to": 79
  }, {
    "from": 73,
    "label": "has",
    "to": 8
  }, {
    "from": 73,
    "label": "has",
    "to": 80
  }, {
    "from": 80,
    "label": "has",
    "to": 81
  }, {
    "from": 80,
    "label": "has",
    "to": 82
  }, {
    "from": 73,
    "label": "has",
    "to": 8
  }, {
    "from": 73,
    "label": "has",
    "to": 83
  }, {
    "from": 73,
    "label": "has",
    "to": 8
  }, {
    "from": 73,
    "label": "has",
    "to": 8
  }, {
    "from": 73,
    "label": "has",
    "to": 84
  }, {
    "from": 85,
    "label": "has",
    "to": 86
  }, {
    "from": 85,
    "label": "has",
    "to": 87
  }, {
    "from": 85,
    "label": "has",
    "to": 88
  }, {
    "from": 85,
    "label": "has",
    "to": 34
  }, {
    "from": 85,
    "label": "has",
    "to": 89
  }, {
    "from": 89,
    "label": "has",
    "to": 90
  }, {
    "from": 90,
    "label": "has",
    "to": 91
  }, {
    "from": 89,
    "label": "has",
    "to": 92
  }, {
    "from": 89,
    "label": "has",
    "to": 93
  }, {
    "from": 89,
    "label": "has",
    "to": 94
  }, {
    "from": 94,
    "label": "has",
    "to": 95
  }, {
    "from": 94,
    "label": "has",
    "to": 96
  }, {
    "from": 94,
    "label": "has",
    "to": 97
  }, {
    "from": 94,
    "label": "has",
    "to": 98
  }, {
    "from": 94,
    "label": "has",
    "to": 99
  }, {
    "from": 94,
    "label": "has",
    "to": 100
  }, {
    "from": 94,
    "label": "has",
    "to": 101
  }, {
    "from": 89,
    "label": "has",
    "to": 102
  }, {
    "from": 85,
    "label": "has",
    "to": 8
  }, {
    "from": 85,
    "label": "has",
    "to": 103
  }, {
    "from": 104,
    "label": "has",
    "to": 68
  }, {
    "from": 104,
    "label": "has",
    "to": 105
  }, {
    "from": 104,
    "label": "has",
    "to": 106
  }, {
    "from": 106,
    "label": "has",
    "to": 107
  }, {
    "from": 106,
    "label": "has",
    "to": 108
  }, {
    "from": 104,
    "label": "has",
    "to": 109
  }, {
    "from": 104,
    "label": "has",
    "to": 8
  }, {
    "from": 104,
    "label": "has",
    "to": 110
  }, {
    "from": 110,
    "label": "has",
    "to": 13
  }, {
    "from": 110,
    "label": "has",
    "to": 111
  }, {
    "from": 111,
    "label": "has",
    "to": 112
  }, {
    "from": 112,
    "label": "has",
    "to": 113
  }, {
    "from": 112,
    "label": "has",
    "to": 16
  }, {
    "from": 104,
    "label": "has",
    "to": 114
  }, {
    "from": 104,
    "label": "has",
    "to": 115
  }, {
    "from": 115,
    "label": "has",
    "to": 116
  }, {
    "from": 115,
    "label": "has",
    "to": 117
  }, {
    "from": 117,
    "label": "has",
    "to": 118
  }, {
    "from": 104,
    "label": "has",
    "to": 119
  }, {
    "from": 119,
    "label": "has",
    "to": 120
  }, {
    "from": 104,
    "label": "has",
    "to": 8
  }, {
    "from": 104,
    "label": "has",
    "to": 8
  }, {
    "from": 104,
    "label": "has",
    "to": 121
  }, {
    "from": 122,
    "label": "has",
    "to": 123
  }, {
    "from": 122,
    "label": "has",
    "to": 124
  }, {
    "from": 122,
    "label": "has",
    "to": 125
  }, {
    "from": 122,
    "label": "has",
    "to": 126
  }, {
    "from": 126,
    "label": "has",
    "to": 127
  }, {
    "from": 126,
    "label": "has",
    "to": 128
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 129,
    "label": "has",
    "to": 130
  }, {
    "from": 128,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 131,
    "label": "has",
    "to": 133
  }, {
    "from": 122,
    "label": "has",
    "to": 8
  }, {
    "from": 122,
    "label": "has",
    "to": 134
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 135,
    "label": "has",
    "to": 137
  }, {
    "from": 137,
    "label": "has",
    "to": 138
  }, {
    "from": 135,
    "label": "has",
    "to": 8
  }, {
    "from": 135,
    "label": "has",
    "to": 139
  }, {
    "from": 140,
    "label": "has",
    "to": 141
  }, {
    "from": 140,
    "label": "has",
    "to": 142
  }, {
    "from": 140,
    "label": "has",
    "to": 143
  }, {
    "from": 143,
    "label": "has",
    "to": 144
  }, {
    "from": 144,
    "label": "has",
    "to": 145
  }, {
    "from": 143,
    "label": "has",
    "to": 146
  }, {
    "from": 143,
    "label": "has",
    "to": 147
  }, {
    "from": 147,
    "label": "has",
    "to": 148
  }, {
    "from": 147,
    "label": "has",
    "to": 149
  }, {
    "from": 149,
    "label": "has",
    "to": 150
  }, {
    "from": 149,
    "label": "has",
    "to": 151
  }, {
    "from": 151,
    "label": "has",
    "to": 152
  }, {
    "from": 151,
    "label": "has",
    "to": 153
  }, {
    "from": 153,
    "label": "has",
    "to": 154
  }, {
    "from": 143,
    "label": "has",
    "to": 155
  }, {
    "from": 155,
    "label": "has",
    "to": 156
  }, {
    "from": 140,
    "label": "has",
    "to": 8
  }, {
    "from": 140,
    "label": "has",
    "to": 8
  }, {
    "from": 140,
    "label": "has",
    "to": 157
  }, {
    "from": 140,
    "label": "has",
    "to": 158
  }, {
    "from": 158,
    "label": "has",
    "to": 159
  }, {
    "from": 158,
    "label": "has",
    "to": 160
  }, {
    "from": 160,
    "label": "has",
    "to": 161
  }, {
    "from": 158,
    "label": "has",
    "to": 162
  }, {
    "from": 162,
    "label": "has",
    "to": 163
  }, {
    "from": 163,
    "label": "has",
    "to": 161
  }, {
    "from": 158,
    "label": "has",
    "to": 164
  }, {
    "from": 158,
    "label": "has",
    "to": 165
  }, {
    "from": 165,
    "label": "has",
    "to": 166
  }, {
    "from": 165,
    "label": "has",
    "to": 167
  }, {
    "from": 165,
    "label": "has",
    "to": 168
  }, {
    "from": 165,
    "label": "has",
    "to": 169
  }, {
    "from": 165,
    "label": "has",
    "to": 170
  }, {
    "from": 165,
    "label": "has",
    "to": 171
  }, {
    "from": 140,
    "label": "has",
    "to": 8
  }, {
    "from": 140,
    "label": "has",
    "to": 172
  }, {
    "from": 172,
    "label": "has",
    "to": 164
  }, {
    "from": 172,
    "label": "has",
    "to": 173
  }, {
    "from": 172,
    "label": "has",
    "to": 174
  }, {
    "from": 174,
    "label": "has",
    "to": 161
  }, {
    "from": 172,
    "label": "has",
    "to": 164
  }, {
    "from": 172,
    "label": "has",
    "to": 175
  }, {
    "from": 175,
    "label": "has",
    "to": 176
  }, {
    "from": 176,
    "label": "has",
    "to": 177
  }, {
    "from": 176,
    "label": "has",
    "to": 178
  }, {
    "from": 176,
    "label": "has",
    "to": 179
  }, {
    "from": 176,
    "label": "has",
    "to": 180
  }, {
    "from": 140,
    "label": "has",
    "to": 8
  }, {
    "from": 140,
    "label": "has",
    "to": 8
  }, {
    "from": 140,
    "label": "has",
    "to": 8
  }, {
    "from": 140,
    "label": "has",
    "to": 181
  }, {
    "from": 182,
    "label": "has",
    "to": 183
  }, {
    "from": 182,
    "label": "has",
    "to": 8
  }, {
    "from": 182,
    "label": "has",
    "to": 184
  }, {
    "from": 185,
    "label": "has",
    "to": 186
  }, {
    "from": 186,
    "label": "has",
    "to": 187
  }, {
    "from": 185,
    "label": "has",
    "to": 188
  }, {
    "from": 189,
    "label": "has",
    "to": 123
  }, {
    "from": 189,
    "label": "has",
    "to": 190
  }, {
    "from": 189,
    "label": "has",
    "to": 191
  }, {
    "from": 189,
    "label": "has",
    "to": 192
  }, {
    "from": 189,
    "label": "has",
    "to": 193
  }, {
    "from": 189,
    "label": "has",
    "to": 194
  }, {
    "from": 194,
    "label": "has",
    "to": 195
  }, {
    "from": 194,
    "label": "has",
    "to": 196
  }, {
    "from": 189,
    "label": "has",
    "to": 197
  }, {
    "from": 197,
    "label": "has",
    "to": 198
  }, {
    "from": 198,
    "label": "has",
    "to": 88
  }, {
    "from": 198,
    "label": "has",
    "to": 199
  }, {
    "from": 198,
    "label": "has",
    "to": 200
  }, {
    "from": 198,
    "label": "has",
    "to": 201
  }, {
    "from": 201,
    "label": "has",
    "to": 202
  }, {
    "from": 201,
    "label": "has",
    "to": 203
  }, {
    "from": 201,
    "label": "has",
    "to": 204
  }, {
    "from": 201,
    "label": "has",
    "to": 205
  }, {
    "from": 205,
    "label": "has",
    "to": 206
  }, {
    "from": 201,
    "label": "has",
    "to": 207
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 201,
    "label": "has",
    "to": 209
  }, {
    "from": 209,
    "label": "has",
    "to": 210
  }, {
    "from": 210,
    "label": "has",
    "to": 211
  }, {
    "from": 209,
    "label": "has",
    "to": 212
  }, {
    "from": 212,
    "label": "has",
    "to": 213
  }, {
    "from": 213,
    "label": "has",
    "to": 214
  }, {
    "from": 209,
    "label": "has",
    "to": 215
  }, {
    "from": 215,
    "label": "has",
    "to": 216
  }, {
    "from": 209,
    "label": "has",
    "to": 217
  }, {
    "from": 201,
    "label": "has",
    "to": 218
  }, {
    "from": 218,
    "label": "has",
    "to": 219
  }, {
    "from": 218,
    "label": "has",
    "to": 220
  }, {
    "from": 218,
    "label": "has",
    "to": 221
  }, {
    "from": 221,
    "label": "has",
    "to": 222
  }, {
    "from": 221,
    "label": "has",
    "to": 223
  }, {
    "from": 221,
    "label": "has",
    "to": 224
  }, {
    "from": 224,
    "label": "has",
    "to": 225
  }, {
    "from": 221,
    "label": "has",
    "to": 226
  }, {
    "from": 218,
    "label": "has",
    "to": 227
  }, {
    "from": 218,
    "label": "has",
    "to": 228
  }, {
    "from": 218,
    "label": "has",
    "to": 229
  }, {
    "from": 229,
    "label": "has",
    "to": 230
  }, {
    "from": 229,
    "label": "has",
    "to": 231
  }, {
    "from": 231,
    "label": "has",
    "to": 232
  }, {
    "from": 231,
    "label": "has",
    "to": 233
  }, {
    "from": 233,
    "label": "has",
    "to": 234
  }, {
    "from": 233,
    "label": "has",
    "to": 235
  }, {
    "from": 235,
    "label": "has",
    "to": 236
  }, {
    "from": 231,
    "label": "has",
    "to": 237
  }, {
    "from": 229,
    "label": "has",
    "to": 238
  }, {
    "from": 229,
    "label": "has",
    "to": 239
  }, {
    "from": 229,
    "label": "has",
    "to": 240
  }, {
    "from": 240,
    "label": "has",
    "to": 241
  }, {
    "from": 241,
    "label": "has",
    "to": 242
  }, {
    "from": 240,
    "label": "has",
    "to": 243
  }, {
    "from": 243,
    "label": "has",
    "to": 244
  }, {
    "from": 244,
    "label": "has",
    "to": 245
  }, {
    "from": 244,
    "label": "has",
    "to": 246
  }, {
    "from": 246,
    "label": "has",
    "to": 247
  }, {
    "from": 247,
    "label": "has",
    "to": 248
  }, {
    "from": 244,
    "label": "has",
    "to": 249
  }, {
    "from": 243,
    "label": "has",
    "to": 250
  }, {
    "from": 250,
    "label": "has",
    "to": 251
  }, {
    "from": 240,
    "label": "has",
    "to": 252
  }, {
    "from": 252,
    "label": "has",
    "to": 253
  }, {
    "from": 253,
    "label": "has",
    "to": 254
  }, {
    "from": 253,
    "label": "has",
    "to": 255
  }, {
    "from": 229,
    "label": "has",
    "to": 256
  }, {
    "from": 256,
    "label": "has",
    "to": 257
  }, {
    "from": 256,
    "label": "has",
    "to": 258
  }, {
    "from": 201,
    "label": "has",
    "to": 259
  }, {
    "from": 259,
    "label": "has",
    "to": 260
  }, {
    "from": 260,
    "label": "has",
    "to": 261
  }, {
    "from": 259,
    "label": "has",
    "to": 262
  }, {
    "from": 198,
    "label": "has",
    "to": 263
  }, {
    "from": 189,
    "label": "has",
    "to": 8
  }, {
    "from": 189,
    "label": "has",
    "to": 8
  }, {
    "from": 189,
    "label": "has",
    "to": 264
  }, {
    "from": 265,
    "label": "has",
    "to": 266
  }, {
    "from": 265,
    "label": "has",
    "to": 267
  }, {
    "from": 265,
    "label": "has",
    "to": 268
  }, {
    "from": 265,
    "label": "has",
    "to": 269
  }, {
    "from": 265,
    "label": "has",
    "to": 270
  }, {
    "from": 265,
    "label": "has",
    "to": 271
  }, {
    "from": 265,
    "label": "has",
    "to": 272
  }, {
    "from": 265,
    "label": "has",
    "to": 273
  }, {
    "from": 265,
    "label": "has",
    "to": 8
  }, {
    "from": 265,
    "label": "has",
    "to": 274
  }, {
    "from": 274,
    "label": "has",
    "to": 275
  }, {
    "from": 265,
    "label": "has",
    "to": 276
  }, {
    "from": 265,
    "label": "has",
    "to": 277
  }, {
    "from": 277,
    "label": "has",
    "to": 278
  }, {
    "from": 265,
    "label": "has",
    "to": 279
  }, {
    "from": 265,
    "label": "has",
    "to": 280
  }, {
    "from": 265,
    "label": "has",
    "to": 281
  }, {
    "from": 265,
    "label": "has",
    "to": 282
  }, {
    "from": 282,
    "label": "has",
    "to": 283
  }, {
    "from": 282,
    "label": "has",
    "to": 284
  }, {
    "from": 284,
    "label": "has",
    "to": 285
  }, {
    "from": 282,
    "label": "has",
    "to": 286
  }, {
    "from": 282,
    "label": "has",
    "to": 287
  }, {
    "from": 265,
    "label": "has",
    "to": 8
  }, {
    "from": 265,
    "label": "has",
    "to": 288
  }, {
    "from": 265,
    "label": "has",
    "to": 289
  }, {
    "from": 265,
    "label": "has",
    "to": 290
  }, {
    "from": 290,
    "label": "has",
    "to": 291
  }, {
    "from": 265,
    "label": "has",
    "to": 292
  }, {
    "from": 292,
    "label": "has",
    "to": 293
  }, {
    "from": 293,
    "label": "has",
    "to": 294
  }, {
    "from": 265,
    "label": "has",
    "to": 295
  }, {
    "from": 265,
    "label": "has",
    "to": 8
  }, {
    "from": 265,
    "label": "has",
    "to": 296
  }, {
    "from": 297,
    "label": "has",
    "to": 8
  }, {
    "from": 297,
    "label": "has",
    "to": 298
  }, {
    "from": 299,
    "label": "has",
    "to": 300
  }, {
    "from": 299,
    "label": "has",
    "to": 8
  }, {
    "from": 299,
    "label": "has",
    "to": 8
  }, {
    "from": 299,
    "label": "has",
    "to": 301
  }, {
    "from": 302,
    "label": "has",
    "to": 8
  }, {
    "from": 302,
    "label": "has",
    "to": 303
  }, {
    "from": 304,
    "label": "has",
    "to": 305
  }, {
    "from": 304,
    "label": "has",
    "to": 8
  }, {
    "from": 304,
    "label": "has",
    "to": 306
  }, {
    "from": 306,
    "label": "has",
    "to": 307
  }, {
    "from": 304,
    "label": "has",
    "to": 8
  }, {
    "from": 304,
    "label": "has",
    "to": 308
  }, {
    "from": 304,
    "label": "has",
    "to": 8
  }, {
    "from": 304,
    "label": "has",
    "to": 8
  }, {
    "from": 304,
    "label": "has",
    "to": 309
  }, {
    "from": 310,
    "label": "has",
    "to": 311
  }, {
    "from": 311,
    "label": "has",
    "to": 312
  }, {
    "from": 311,
    "label": "has",
    "to": 313
  }, {
    "from": 310,
    "label": "has",
    "to": 8
  }, {
    "from": 310,
    "label": "has",
    "to": 314
  }, {
    "from": 310,
    "label": "has",
    "to": 8
  }, {
    "from": 310,
    "label": "has",
    "to": 8
  }, {
    "from": 310,
    "label": "has",
    "to": 315
  }, {
    "from": 63,
    "label": "calls",
    "to": 348
  }, {
    "from": 67,
    "label": "calls",
    "to": 348
  }, {
    "from": 140,
    "label": "calls",
    "to": 348
  }, {
    "from": 6,
    "label": "calls",
    "to": 341
  }, {
    "from": 41,
    "label": "calls",
    "to": 341
  }, {
    "from": 49,
    "label": "calls",
    "to": 341
  }, {
    "from": 56,
    "label": "calls",
    "to": 341
  }, {
    "from": 63,
    "label": "calls",
    "to": 341
  }, {
    "from": 63,
    "label": "calls",
    "to": 341
  }, {
    "from": 67,
    "label": "calls",
    "to": 341
  }, {
    "from": 67,
    "label": "calls",
    "to": 341
  }, {
    "from": 73,
    "label": "calls",
    "to": 341
  }, {
    "from": 73,
    "label": "calls",
    "to": 341
  }, {
    "from": 85,
    "label": "calls",
    "to": 341
  }, {
    "from": 85,
    "label": "calls",
    "to": 341
  }, {
    "from": 104,
    "label": "calls",
    "to": 341
  }, {
    "from": 122,
    "label": "calls",
    "to": 341
  }, {
    "from": 122,
    "label": "calls",
    "to": 341
  }, {
    "from": 189,
    "label": "calls",
    "to": 341
  }, {
    "from": 265,
    "label": "calls",
    "to": 341
  }, {
    "from": 265,
    "label": "calls",
    "to": 341
  }, {
    "from": 265,
    "label": "calls",
    "to": 341
  }, {
    "from": 265,
    "label": "calls",
    "to": 341
  }, {
    "from": 265,
    "label": "calls",
    "to": 341
  }, {
    "from": 85,
    "label": "calls",
    "to": 73
  }, {
    "from": 41,
    "label": "calls",
    "to": 342
  }, {
    "from": 49,
    "label": "calls",
    "to": 342
  }, {
    "from": 56,
    "label": "calls",
    "to": 342
  }, {
    "from": 63,
    "label": "calls",
    "to": 342
  }, {
    "from": 189,
    "label": "calls",
    "to": 317
  }, {
    "from": 189,
    "label": "calls",
    "to": 317
  }, {
    "from": 189,
    "label": "calls",
    "to": 317
  }, {
    "from": 6,
    "label": "calls",
    "to": 343
  }, {
    "from": 6,
    "label": "calls",
    "to": 343
  }, {
    "from": 122,
    "label": "calls",
    "to": 104
  }, {
    "from": 140,
    "label": "calls",
    "to": 104
  }, {
    "from": 67,
    "label": "calls",
    "to": 344
  }, {
    "from": 73,
    "label": "calls",
    "to": 344
  }, {
    "from": 104,
    "label": "calls",
    "to": 344
  }, {
    "from": 122,
    "label": "calls",
    "to": 344
  }, {
    "from": 185,
    "label": "calls",
    "to": 344
  }, {
    "from": 189,
    "label": "calls",
    "to": 344
  }, {
    "from": 189,
    "label": "calls",
    "to": 344
  }, {
    "from": 189,
    "label": "calls",
    "to": 344
  }, {
    "from": 189,
    "label": "calls",
    "to": 344
  }, {
    "from": 189,
    "label": "calls",
    "to": 344
  }, {
    "from": 56,
    "label": "calls",
    "to": 49
  }, {
    "from": 67,
    "label": "calls",
    "to": 63
  }, {
    "from": 6,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 340
  }, {
    "from": 140,
    "label": "calls",
    "to": 122
  }, {
    "from": 265,
    "label": "calls",
    "to": 122
  }, {
    "from": 140,
    "label": "calls",
    "to": 322
  }, {
    "from": 49,
    "label": "calls",
    "to": 41
  }, {
    "from": 6,
    "label": "calls",
    "to": 37
  }, {
    "from": 85,
    "label": "calls",
    "to": 350
  }, {
    "from": 135,
    "label": "calls",
    "to": 350
  }, {
    "from": 140,
    "label": "calls",
    "to": 350
  }, {
    "from": 140,
    "label": "calls",
    "to": 350
  }, {
    "from": 140,
    "label": "calls",
    "to": 350
  }, {
    "from": 140,
    "label": "calls",
    "to": 350
  }, {
    "from": 140,
    "label": "calls",
    "to": 350
  }, {
    "from": 140,
    "label": "calls",
    "to": 350
  }, {
    "from": 189,
    "label": "calls",
    "to": 350
  }, {
    "from": 189,
    "label": "calls",
    "to": 350
  }, {
    "from": 189,
    "label": "calls",
    "to": 350
  }, {
    "from": 189,
    "label": "calls",
    "to": 350
  }, {
    "from": 265,
    "label": "calls",
    "to": 350
  }, {
    "from": 265,
    "label": "calls",
    "to": 350
  }, {
    "from": 104,
    "label": "calls",
    "to": 85
  }, {
    "from": 265,
    "label": "calls",
    "to": 318
  }, {
    "from": 104,
    "label": "calls",
    "to": 351
  }, {
    "from": 316,
    "label": "calls",
    "to": 349
  }, {
    "from": 189,
    "label": "calls",
    "to": 182
  }, {
    "from": 140,
    "label": "calls",
    "to": 135
  }, {
    "from": 140,
    "label": "calls",
    "to": 67
  }, {
    "from": 140,
    "label": "calls",
    "to": 67
  }, {
    "from": 140,
    "label": "calls",
    "to": 67
  }, {
    "from": 140,
    "label": "calls",
    "to": 67
  }, {
    "from": 140,
    "label": "calls",
    "to": 67
  }, {
    "from": 265,
    "label": "calls",
    "to": 67
  }, {
    "from": 140,
    "label": "calls",
    "to": 339
  }, {
    "from": 189,
    "label": "calls",
    "to": 319
  }, {
    "from": 104,
    "label": "calls",
    "to": 330
  }, {
    "from": 49,
    "label": "calls",
    "to": 346
  }, {
    "from": 67,
    "label": "calls",
    "to": 346
  }, {
    "from": 104,
    "label": "calls",
    "to": 346
  }, {
    "from": 185,
    "label": "calls",
    "to": 346
  }, {
    "from": 189,
    "label": "calls",
    "to": 346
  }, {
    "from": 140,
    "label": "calls",
    "to": 353
  }, {
    "from": 140,
    "label": "calls",
    "to": 353
  }, {
    "from": 140,
    "label": "calls",
    "to": 353
  }, {
    "from": 265,
    "label": "calls",
    "to": 353
  }, {
    "from": 316,
    "label": "calls",
    "to": 345
  }, {
    "from": 39,
    "label": "calls",
    "to": 6
  }, {
    "from": 39,
    "label": "calls",
    "to": 6
  }, {
    "from": 41,
    "label": "calls",
    "to": 6
  }, {
    "from": 73,
    "label": "calls",
    "to": 6
  }, {
    "from": 73,
    "label": "calls",
    "to": 6
  }, {
    "from": 85,
    "label": "calls",
    "to": 6
  }, {
    "from": 104,
    "label": "calls",
    "to": 6
  }, {
    "from": 189,
    "label": "calls",
    "to": 320
  }, {
    "from": 316,
    "label": "calls",
    "to": 354
  }, {
    "from": 6,
    "label": "calls",
    "to": 354
  }, {
    "from": 85,
    "label": "calls",
    "to": 354
  }, {
    "from": 85,
    "label": "calls",
    "to": 354
  }, {
    "from": 265,
    "label": "calls",
    "to": 265
  }, {
    "from": 265,
    "label": "calls",
    "to": 331
  }, {
    "from": 6,
    "label": "calls",
    "to": 352
  }, {
    "from": 41,
    "label": "calls",
    "to": 352
  }, {
    "from": 49,
    "label": "calls",
    "to": 352
  }, {
    "from": 56,
    "label": "calls",
    "to": 352
  }, {
    "from": 63,
    "label": "calls",
    "to": 352
  }, {
    "from": 63,
    "label": "calls",
    "to": 352
  }, {
    "from": 67,
    "label": "calls",
    "to": 352
  }, {
    "from": 67,
    "label": "calls",
    "to": 352
  }, {
    "from": 73,
    "label": "calls",
    "to": 352
  }, {
    "from": 73,
    "label": "calls",
    "to": 352
  }, {
    "from": 73,
    "label": "calls",
    "to": 352
  }, {
    "from": 73,
    "label": "calls",
    "to": 352
  }, {
    "from": 73,
    "label": "calls",
    "to": 352
  }, {
    "from": 73,
    "label": "calls",
    "to": 352
  }, {
    "from": 85,
    "label": "calls",
    "to": 352
  }, {
    "from": 85,
    "label": "calls",
    "to": 352
  }, {
    "from": 85,
    "label": "calls",
    "to": 352
  }, {
    "from": 104,
    "label": "calls",
    "to": 352
  }, {
    "from": 122,
    "label": "calls",
    "to": 352
  }, {
    "from": 122,
    "label": "calls",
    "to": 352
  }, {
    "from": 189,
    "label": "calls",
    "to": 352
  }, {
    "from": 189,
    "label": "calls",
    "to": 352
  }, {
    "from": 189,
    "label": "calls",
    "to": 352
  }, {
    "from": 265,
    "label": "calls",
    "to": 352
  }, {
    "from": 265,
    "label": "calls",
    "to": 352
  }, {
    "from": 265,
    "label": "calls",
    "to": 352
  }, {
    "from": 265,
    "label": "calls",
    "to": 352
  }, {
    "from": 265,
    "label": "calls",
    "to": 352
  }, {
    "from": 316,
    "label": "calls",
    "to": 355
  }, {
    "from": 316,
    "label": "calls",
    "to": 355
  }, {
    "from": 316,
    "label": "calls",
    "to": 355
  }, {
    "from": 316,
    "label": "calls",
    "to": 355
  }, {
    "from": 316,
    "label": "calls",
    "to": 355
  }, {
    "from": 140,
    "label": "calls",
    "to": 355
  }, {
    "from": 140,
    "label": "calls",
    "to": 355
  }, {
    "from": 189,
    "label": "calls",
    "to": 355
  }, {
    "from": 265,
    "label": "calls",
    "to": 355
  }, {
    "from": 189,
    "label": "calls",
    "to": 185
  }, {
    "from": 189,
    "label": "calls",
    "to": 185
  }, {
    "from": 104,
    "label": "calls",
    "to": 347
  }, {
    "from": 1,
    "label": "contains",
    "to": 316
  }, {
    "from": 316,
    "label": "declares",
    "to": 6
  }, {
    "from": 316,
    "label": "declares",
    "to": 37
  }, {
    "from": 316,
    "label": "declares",
    "to": 39
  }, {
    "from": 316,
    "label": "declares",
    "to": 41
  }, {
    "from": 316,
    "label": "declares",
    "to": 49
  }, {
    "from": 316,
    "label": "declares",
    "to": 56
  }, {
    "from": 316,
    "label": "declares",
    "to": 63
  }, {
    "from": 316,
    "label": "declares",
    "to": 67
  }, {
    "from": 316,
    "label": "declares",
    "to": 73
  }, {
    "from": 316,
    "label": "declares",
    "to": 85
  }, {
    "from": 316,
    "label": "declares",
    "to": 104
  }, {
    "from": 316,
    "label": "declares",
    "to": 122
  }, {
    "from": 316,
    "label": "declares",
    "to": 135
  }, {
    "from": 316,
    "label": "declares",
    "to": 140
  }, {
    "from": 316,
    "label": "declares",
    "to": 182
  }, {
    "from": 316,
    "label": "declares",
    "to": 185
  }, {
    "from": 316,
    "label": "declares",
    "to": 189
  }, {
    "from": 316,
    "label": "declares",
    "to": 265
  }, {
    "from": 316,
    "label": "declares",
    "to": 297
  }, {
    "from": 316,
    "label": "declares",
    "to": 299
  }, {
    "from": 316,
    "label": "declares",
    "to": 302
  }, {
    "from": 316,
    "label": "declares",
    "to": 304
  }, {
    "from": 316,
    "label": "declares",
    "to": 310
  }, {
    "from": 318,
    "label": "calls",
    "to": 39
  }, {
    "from": 318,
    "label": "calls",
    "to": 56
  }, {
    "from": 321,
    "label": "calls",
    "to": 189
  }, {
    "from": 321,
    "label": "calls",
    "to": 140
  }, {
    "from": 322,
    "label": "calls",
    "to": 299
  }, {
    "from": 323,
    "label": "calls",
    "to": 6
  }, {
    "from": 324,
    "label": "calls",
    "to": 6
  }, {
    "from": 323,
    "label": "calls",
    "to": 85
  }, {
    "from": 325,
    "label": "calls",
    "to": 299
  }, {
    "from": 325,
    "label": "calls",
    "to": 299
  }, {
    "from": 326,
    "label": "calls",
    "to": 299
  }, {
    "from": 327,
    "label": "calls",
    "to": 39
  }, {
    "from": 328,
    "label": "calls",
    "to": 265
  }, {
    "from": 329,
    "label": "calls",
    "to": 6
  }, {
    "from": 329,
    "label": "calls",
    "to": 85
  }, {
    "from": 332,
    "label": "calls",
    "to": 299
  }, {
    "from": 333,
    "label": "calls",
    "to": 39
  }, {
    "from": 334,
    "label": "calls",
    "to": 122
  }, {
    "from": 335,
    "label": "calls",
    "to": 39
  }, {
    "from": 336,
    "label": "calls",
    "to": 6
  }, {
    "from": 337,
    "label": "calls",
    "to": 6
  }, {
    "from": 338,
    "label": "calls",
    "to": 6
  }, {
    "from": 336,
    "label": "calls",
    "to": 85
  }, {
    "from": 1,
    "label": "contains",
    "to": 364
  }, {
    "from": 1,
    "label": "contains",
    "to": 365
  }, {
    "from": 364,
    "label": "initializes",
    "to": 366
  }, {
    "from": 366,
    "label": "assigns",
    "to": 367
  }, {
    "from": 367,
    "label": "assigns",
    "to": 368
  }, {
    "from": 368,
    "label": "assigns",
    "to": 369
  }, {
    "from": 367,
    "label": "assigns",
    "to": 370
  }, {
    "from": 370,
    "label": "assigns",
    "to": 371
  }, {
    "from": 367,
    "label": "assigns",
    "to": 372
  }, {
    "from": 372,
    "label": "assigns",
    "to": 373
  }, {
    "from": 367,
    "label": "assigns",
    "to": 374
  }, {
    "from": 374,
    "label": "assigns",
    "to": 375
  }, {
    "from": 367,
    "label": "assigns",
    "to": 376
  }, {
    "from": 376,
    "label": "assigns",
    "to": 377
  }, {
    "from": 367,
    "label": "assigns",
    "to": 378
  }, {
    "from": 378,
    "label": "assigns",
    "to": 379
  }, {
    "from": 367,
    "label": "assigns",
    "to": 380
  }, {
    "from": 380,
    "label": "assigns",
    "to": 381
  }, {
    "from": 367,
    "label": "assigns",
    "to": 382
  }, {
    "from": 382,
    "label": "assigns",
    "to": 383
  }, {
    "from": 367,
    "label": "assigns",
    "to": 384
  }, {
    "from": 384,
    "label": "assigns",
    "to": 385
  }, {
    "from": 367,
    "label": "assigns",
    "to": 386
  }, {
    "from": 386,
    "label": "assigns",
    "to": 387
  }, {
    "from": 364,
    "label": "initializes",
    "to": 388
  }, {
    "from": 388,
    "label": "assigns",
    "to": 389
  }, {
    "from": 389,
    "label": "assigns",
    "to": 390
  }, {
    "from": 390,
    "label": "assigns",
    "to": 391
  }, {
    "from": 389,
    "label": "assigns",
    "to": 392
  }, {
    "from": 392,
    "label": "assigns",
    "to": 393
  }, {
    "from": 389,
    "label": "assigns",
    "to": 394
  }, {
    "from": 394,
    "label": "assigns",
    "to": 395
  }, {
    "from": 389,
    "label": "assigns",
    "to": 396
  }, {
    "from": 396,
    "label": "assigns",
    "to": 397
  }, {
    "from": 389,
    "label": "assigns",
    "to": 398
  }, {
    "from": 398,
    "label": "assigns",
    "to": 399
  }, {
    "from": 389,
    "label": "assigns",
    "to": 400
  }, {
    "from": 400,
    "label": "assigns",
    "to": 401
  }, {
    "from": 364,
    "label": "initializes",
    "to": 402
  }, {
    "from": 402,
    "label": "assigns",
    "to": 403
  }, {
    "from": 403,
    "label": "assigns",
    "to": 404
  }, {
    "from": 404,
    "label": "assigns",
    "to": 405
  }, {
    "from": 403,
    "label": "assigns",
    "to": 406
  }, {
    "from": 406,
    "label": "assigns",
    "to": 407
  }, {
    "from": 364,
    "label": "initializes",
    "to": 408
  }, {
    "from": 408,
    "label": "assigns",
    "to": 409
  }, {
    "from": 364,
    "label": "initializes",
    "to": 410
  }, {
    "from": 410,
    "label": "assigns",
    "to": 411
  }, {
    "from": 411,
    "label": "assigns",
    "to": 412
  }, {
    "from": 412,
    "label": "assigns",
    "to": 413
  }, {
    "from": 411,
    "label": "assigns",
    "to": 414
  }, {
    "from": 414,
    "label": "assigns",
    "to": 415
  }, {
    "from": 411,
    "label": "assigns",
    "to": 416
  }, {
    "from": 416,
    "label": "assigns",
    "to": 417
  }, {
    "from": 411,
    "label": "assigns",
    "to": 418
  }, {
    "from": 418,
    "label": "assigns",
    "to": 419
  }, {
    "from": 365,
    "label": "initializes",
    "to": 420
  }, {
    "from": 420,
    "label": "requires",
    "to": 356
  }, {
    "from": 365,
    "label": "initializes",
    "to": 421
  }, {
    "from": 421,
    "label": "requires",
    "to": 422
  }, {
    "from": 365,
    "label": "initializes",
    "to": 423
  }, {
    "from": 423,
    "label": "requires",
    "to": 361
  }, {
    "from": 365,
    "label": "initializes",
    "to": 424
  }, {
    "from": 424,
    "label": "requires",
    "to": 359
  }, {
    "from": 365,
    "label": "initializes",
    "to": 425
  }, {
    "from": 425,
    "label": "requires",
    "to": 357
  }, {
    "from": 365,
    "label": "initializes",
    "to": 426
  }, {
    "from": 426,
    "label": "requires",
    "to": 362
  }, {
    "from": 365,
    "label": "initializes",
    "to": 427
  }, {
    "from": 427,
    "label": "requires",
    "to": 363
  }, {
    "from": 365,
    "label": "initializes",
    "to": 428
  }, {
    "from": 428,
    "label": "requires",
    "to": 360
  }, {
    "from": 365,
    "label": "initializes",
    "to": 429
  }, {
    "from": 429,
    "label": "requires",
    "to": 358
  }, {
    "from": 430,
    "label": "requires",
    "to": 422
  }, {
    "from": 431,
    "label": "requires",
    "to": 422
  }, {
    "from": 9,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 9,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 26,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 26,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 29,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 29,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 34,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 34,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 42,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 42,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 54,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 54,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 57,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 57,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 64,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 64,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 65,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 65,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 68,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 68,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 71,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 71,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 74,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 74,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 75,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 75,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 86,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 86,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 87,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 87,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 93,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 93,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 113,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 113,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 118,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 118,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 120,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 120,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 123,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 123,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 124,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 124,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 159,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 159,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 161,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 161,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 164,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 164,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 166,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 166,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 167,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 167,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 168,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 168,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 169,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 169,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 170,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 170,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 171,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 171,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 173,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 173,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 187,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 187,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 232,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 232,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 236,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 236,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 237,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 237,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 266,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 266,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 267,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 267,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 268,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 268,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 269,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 269,
    "label": "hasArgument",
    "to": 407
  }, {
    "from": 270,
    "label": "hasArgument",
    "to": 405
  }, {
    "from": 270,
    "label": "hasArgument",
    "to": 407
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "deps",
    "type": "module"
  }, {
    "id": 2,
    "text": "function build_rockspec(rockspec_file, need_to_fetch, minimal_mode, deps_mode)\r\n   assert(type(rockspec_file) == \"string\")\r\n   assert(type(need_to_fetch) == \"boolean\")\r\n\r\n   local rockspec, err, errcode = fetch.load_rockspec(rockspec_file)\r\n   if err then\r\n      return nil, err, errcode\r\n   elseif not rockspec.build then\r\n      return nil, \"Rockspec error: build table not specified\"\r\n   elseif not rockspec.build.type then\r\n      return nil, \"Rockspec error: build type not specified\"\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      local ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then\r\n         return nil, err, errcode\r\n      end\r\n   end\r\n\r\n   local ok, err, errcode = deps.check_external_deps(rockspec, \"build\")\r\n   if err then\r\n      return nil, err, errcode\r\n   end\r\n\r\n   local name, version = rockspec.name, rockspec.version\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n\r\n   if not minimal_mode then\r\n      local _, source_dir\r\n      if need_to_fetch then\r\n         ok, source_dir, errcode = fetch.fetch_sources(rockspec, true)\r\n         if not ok then\r\n            return nil, source_dir, errcode\r\n         end\r\n         local ok, err = fs.change_dir(source_dir)\r\n         if not ok then return nil, err end\r\n      elseif rockspec.source.file then\r\n         local ok, err = fs.unpack_archive(rockspec.source.file)\r\n         if not ok then\r\n            return nil, err\r\n         end\r\n      end\r\n      fs.change_dir(rockspec.source.dir)\r\n   end\r\n   \r\n   local dirs = {\r\n      lua = { name = path.lua_dir(name, version), is_module_path = true },\r\n      lib = { name = path.lib_dir(name, version), is_module_path = true },\r\n      conf = { name = path.conf_dir(name, version), is_module_path = false },\r\n      bin = { name = path.bin_dir(name, version), is_module_path = false },\r\n   }\r\n   \r\n   for _, d in pairs(dirs) do\r\n      local ok, err = fs.make_dir(d.name)\r\n      if not ok then return nil, err end\r\n   end\r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n\r\n   local build = rockspec.build\r\n   \r\n   if not minimal_mode then\r\n      ok, err = apply_patches(rockspec)\r\n      if err then\r\n         return nil, err\r\n      end\r\n   end\r\n   \r\n   if build.type ~= \"none\" then\r\n\r\n      -- Temporary compatibility\r\n      if build.type == \"module\" then\r\n         util.printout(\"Do not use 'module' as a build type. Use 'builtin' instead.\")\r\n         build.type = \"builtin\"\r\n      end\r\n\r\n      if cfg.accepted_build_types and util.array_contains(cfg.accepted_build_types, build.type) then\r\n         return nil, \"This rockspec uses the '\"..build.type..\"' build type, which is blocked by the 'accepted_build_types' setting in your LuaRocks configuration.\"\r\n      end\r\n\r\n      local build_type\r\n      ok, build_type = pcall(require, \"luarocks.build.\" .. build.type)\r\n      if not ok or not type(build_type) == \"table\" then\r\n         return nil, \"Failed initializing build back-end for build type '\"..build.type..\"': \"..build_type\r\n      end\r\n  \r\n      ok, err = build_type.run(rockspec)\r\n      if not ok then\r\n         return nil, \"Build error: \" .. err\r\n      end\r\n   end\r\n\r\n   if build.install then\r\n      for id, install_dir in pairs(dirs) do\r\n         ok, err = install_files(build.install[id], install_dir.name, install_dir.is_module_path)\r\n         if not ok then \r\n            return nil, err\r\n         end\r\n      end\r\n   end\r\n   \r\n   local copy_directories = build.copy_directories\r\n   local copying_default = false\r\n   if not copy_directories then\r\n      copy_directories = {\"doc\"}\r\n      copying_default = true\r\n   end\r\n\r\n   for _, copy_dir in pairs(copy_directories) do\r\n      if fs.is_dir(copy_dir) then\r\n         local dest = dir.path(path.install_dir(name, version), copy_dir)\r\n         fs.make_dir(dest)\r\n         fs.copy_contents(copy_dir, dest)\r\n      else\r\n         if not copying_default then\r\n            return nil, \"Directory '\"..copy_dir..\"' not found\"\r\n         end\r\n      end\r\n   end\r\n\r\n   for _, d in pairs(dirs) do\r\n      fs.remove_dir_if_empty(d.name)\r\n   end\r\n\r\n   fs.pop_dir()\r\n   \r\n   fs.copy(rockspec.local_filename, path.rockspec_file(name, version))\r\n   if need_to_fetch then\r\n      fs.pop_dir()\r\n   end\r\n\r\n   ok, err = manif.make_rock_manifest(name, version)\r\n   if err then return nil, err end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n\r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n\r\n   local license = \"\"\r\n   if rockspec.description and rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now built and installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "local function do_build(name, version, deps_mode)\r\n   if name:match(\"%.rockspec$\") then\r\n      return build_rockspec(name, true, false, deps_mode)\r\n   elseif name:match(\"%.src%.rock$\") then\r\n      return build_rock(name, false, deps_mode)\r\n   elseif name:match(\"%.all%.rock$\") then\r\n      local install = require(\"luarocks.install\")\r\n      return install.install_binary_rock(name, deps_mode)\r\n   elseif name:match(\"%.rock$\") then\r\n      return build_rock(name, true, deps_mode)\r\n   elseif not name:match(dir.separator) then\r\n      local search = require(\"luarocks.search\")\r\n      return search.act_on_src_or_rockspec(run, name:lower(), version, deps.deps_mode_to_flag(deps_mode))\r\n   end\r\n   return nil, \"Don't know what to do with \"..name\r\nend",
    "type": "function"
  }, {
    "id": 4,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"build\")\r\n   end\r\n   assert(type(version) == \"string\" or not version)\r\n\r\n   if flags[\"pack-binary-rock\"] then\r\n      return pack.pack_binary_rock(name, version, do_build, name, version, deps.get_deps_mode(flags))\r\n   else\r\n      local ok, err = fs.check_command_permissions(flags)\r\n      if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n      ok, err = do_build(name, version, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 5,
    "text": "function run_command(...)\r\n   local args = {...}\r\n   local cmdline_vars = {}\r\n   for i = #args, 1, -1 do\r\n      local arg = args[i]\r\n      if arg:match(\"^[^-][^=]*=\") then\r\n         local var, val = arg:match(\"^([A-Z_][A-Z0-9_]*)=(.*)\")\r\n         if val then\r\n            cmdline_vars[var] = val\r\n            table.remove(args, i)\r\n         else\r\n            die(\"Invalid assignment: \"..arg)\r\n         end\r\n      end\r\n   end\r\n   local nonflags = { util.parse_flags(unpack(args)) }\r\n   local flags = table.remove(nonflags, 1)\r\n   \r\n   if flags[\"from\"] then flags[\"server\"] = flags[\"from\"] end\r\n   if flags[\"only-from\"] then flags[\"only-server\"] = flags[\"only-from\"] end\r\n   if flags[\"only-sources-from\"] then flags[\"only-sources\"] = flags[\"only-sources-from\"] end\r\n   if flags[\"to\"] then flags[\"tree\"] = flags[\"to\"] end\r\n   if flags[\"nodeps\"] then\r\n      flags[\"deps-mode\"] = \"none\"\r\n      table.insert(args, \"--deps-mode=none\")\r\n   end\r\n   \r\n   cfg.flags = flags\r\n\r\n   local command\r\n   \r\n   if flags[\"verbose\"] then   -- setting it in the config file will kick-in earlier in the process\r\n      cfg.verbose = true\r\n      local fs = require(\"luarocks.fs\")\r\n      fs.verbose()\r\n   end\r\n\r\n   if flags[\"version\"] then\r\n      util.printout(program..\" \"..cfg.program_version)\r\n      util.printout(program_description)\r\n      util.printout()\r\n      os.exit(cfg.errorcodes.OK)\r\n   elseif flags[\"help\"] or #nonflags == 0 then\r\n      command = \"help\"\r\n      args = nonflags\r\n   else\r\n      command = nonflags[1]\r\n      for i, arg in ipairs(args) do\r\n         if arg == command then\r\n            table.remove(args, i)\r\n            break\r\n         end\r\n      end\r\n   end\r\n   command = command:gsub(\"-\", \"_\")\r\n\r\n   if flags[\"extensions\"] then\r\n      cfg.use_extensions = true\r\n      local type_check = require(\"luarocks.type_check\")\r\n      type_check.load_extensions()\r\n   end\r\n   \r\n   if cfg.local_by_default then\r\n      flags[\"local\"] = true\r\n   end\r\n\r\n   if flags[\"deps-mode\"] and not deps.check_deps_mode_flag(flags[\"deps-mode\"]) then\r\n      die(\"Invalid entry for --deps-mode.\")\r\n   end\r\n   \r\n   if flags[\"tree\"] then\r\n      if flags[\"tree\"] == true or flags[\"tree\"] == \"\" then\r\n         die(\"Argument error: use --tree=<path>\")\r\n      end\r\n      local named = false\r\n      for _, tree in ipairs(cfg.rocks_trees) do\r\n         if type(tree) == \"table\" and flags[\"tree\"] == tree.name then\r\n            if not tree.root then\r\n               die(\"Configuration error: tree '\"..tree.name..\"' has no 'root' field.\")\r\n            end\r\n            replace_tree(flags, args, tree.root)\r\n            named = true\r\n            break\r\n         end\r\n      end\r\n      if not named then\r\n         local fs = require(\"luarocks.fs\")\r\n         local root_dir = fs.absolute_name(flags[\"tree\"])\r\n         replace_tree(flags, args, root_dir)\r\n      end\r\n   elseif flags[\"local\"] then\r\n      replace_tree(flags, args, cfg.home_tree)\r\n   else\r\n      local trees = cfg.rocks_trees\r\n      path.use_tree(trees[#trees])\r\n   end\r\n\r\n   if type(cfg.root_dir) == \"string\" then\r\n     cfg.root_dir = cfg.root_dir:gsub(\"/+$\", \"\")\r\n   else\r\n     cfg.root_dir.root = cfg.root_dir.root:gsub(\"/+$\", \"\")\r\n   end\r\n   cfg.rocks_dir = cfg.rocks_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_bin_dir = cfg.deploy_bin_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_lua_dir = cfg.deploy_lua_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_lib_dir = cfg.deploy_lib_dir:gsub(\"/+$\", \"\")\r\n   \r\n   cfg.variables.ROCKS_TREE = cfg.rocks_dir\r\n   cfg.variables.SCRIPTS_DIR = cfg.deploy_bin_dir\r\n\r\n   if flags[\"server\"] then\r\n      if flags[\"server\"] == true then\r\n         die(\"Argument error: use --server=<url>\")\r\n      end\r\n      local protocol, path = dir.split_url(flags[\"server\"])\r\n      table.insert(cfg.rocks_servers, 1, protocol..\"://\"..path)\r\n   end\r\n   \r\n   if flags[\"only-server\"] then\r\n      if flags[\"only-server\"] == true then\r\n         die(\"Argument error: use --only-server=<url>\")\r\n      end\r\n      cfg.rocks_servers = { flags[\"only-server\"] }\r\n   end\r\n\r\n   if flags[\"only-sources\"] then\r\n      cfg.only_sources_from = flags[\"only-sources\"]\r\n   end\r\n  \r\n   if command ~= \"help\" then\r\n      for k, v in pairs(cmdline_vars) do\r\n         cfg.variables[k] = v\r\n      end\r\n   end\r\n   \r\n   if commands[command] then\r\n      -- TODO the interface of run should be modified, to receive the\r\n      -- flags table and the (possibly unpacked) nonflags arguments.\r\n      -- This would remove redundant parsing of arguments.\r\n      -- I'm not changing this now to avoid messing with the run()\r\n      -- interface, which I know some people use (even though\r\n      -- I never published it as a public API...)\r\n      local cmd = require(commands[command])\r\n      local xp, ok, err, exitcode = xpcall(function() return cmd.run(unpack(args)) end, function(err)\r\n         die(debug.traceback(\"LuaRocks \"..cfg.program_version\r\n            ..\" bug (please report at luarocks-developers@lists.sourceforge.net).\\n\"\r\n            ..err, 2))\r\n      end)\r\n      if xp and (not ok) then\r\n         die(err, exitcode)\r\n      end\r\n   else\r\n      die(\"Unknown command: \"..command)\r\n   end\r\n   util.run_scheduled_functions()\r\nend",
    "type": "function"
  }, {
    "id": 6,
    "text": "function parse_version(vstring)\r\n   if not vstring then return nil end\r\n   assert(type(vstring) == \"string\")\r\n\r\n   local cached = version_cache[vstring]\r\n   if cached then\r\n      return cached\r\n   end\r\n\r\n   local version = {}\r\n   local i = 1\r\n\r\n   local function add_token(number)\r\n      version[i] = version[i] and version[i] + number/100000 or number\r\n      i = i + 1\r\n   end\r\n   \r\n   -- trim leading and trailing spaces\r\n   vstring = vstring:match(\"^%s*(.*)%s*$\")\r\n   version.string = vstring\r\n   -- store revision separately if any\r\n   local main, revision = vstring:match(\"(.*)%-(%d+)$\")\r\n   if revision then\r\n      vstring = main\r\n      version.revision = tonumber(revision)\r\n   end\r\n   while #vstring > 0 do\r\n      -- extract a number\r\n      local token, rest = vstring:match(\"^(%d+)[%.%-%_]*(.*)\")\r\n      if token then\r\n         add_token(tonumber(token))\r\n      else\r\n         -- extract a word\r\n         token, rest = vstring:match(\"^(%a+)[%.%-%_]*(.*)\")\r\n         if not token then\r\n            util.printerr(\"Warning: version number '\"..vstring..\"' could not be parsed.\")\r\n            version[i] = 0\r\n            break\r\n         end\r\n         local last = #version\r\n         version[i] = deltas[token] or (token:byte() / 1000)\r\n      end\r\n      vstring = rest\r\n   end\r\n   setmetatable(version, version_mt)\r\n   version_cache[vstring] = version\r\n   return version\r\nend",
    "type": "function"
  }, {
    "id": 7,
    "text": "if not vstring then return nil end",
    "type": "statement:if"
  }, {
    "id": 8,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 9,
    "text": "assert(type(vstring) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 10,
    "text": "local cached = version_cache[vstring]",
    "type": "statement:localassign"
  }, {
    "id": 11,
    "text": "if cached then\r\n      return cached\r\n   end",
    "type": "statement:if"
  }, {
    "id": 12,
    "text": "local version = {}",
    "type": "statement:localassign"
  }, {
    "id": 13,
    "text": "local i = 1",
    "type": "statement:localassign"
  }, {
    "id": 14,
    "text": "local function add_token(number)\r\n      version[i] = version[i] and version[i] + number/100000 or number\r\n      i = i + 1\r\n   end",
    "type": "statement:localfunction"
  }, {
    "id": 15,
    "text": "version[i] = version[i] and version[i] + number/100000 or number",
    "type": "statement:assign"
  }, {
    "id": 16,
    "text": "i = i + 1",
    "type": "statement:assign"
  }, {
    "id": 17,
    "text": "vstring = vstring:match(\"^%s*(.*)%s*$\")",
    "type": "statement:assign"
  }, {
    "id": 18,
    "text": "version.string = vstring",
    "type": "statement:assign"
  }, {
    "id": 19,
    "text": "local main, revision = vstring:match(\"(.*)%-(%d+)$\")",
    "type": "statement:localassign"
  }, {
    "id": 20,
    "text": "if revision then\r\n      vstring = main\r\n      version.revision = tonumber(revision)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 21,
    "text": "vstring = main",
    "type": "statement:assign"
  }, {
    "id": 22,
    "text": "version.revision = tonumber(revision)",
    "type": "statement:assign"
  }, {
    "id": 23,
    "text": "while #vstring > 0 do\r\n      -- extract a number\r\n      local token, rest = vstring:match(\"^(%d+)[%.%-%_]*(.*)\")\r\n      if token then\r\n         add_token(tonumber(token))\r\n      else\r\n         -- extract a word\r\n         token, rest = vstring:match(\"^(%a+)[%.%-%_]*(.*)\")\r\n         if not token then\r\n            util.printerr(\"Warning: version number '\"..vstring..\"' could not be parsed.\")\r\n            version[i] = 0\r\n            break\r\n         end\r\n         local last = #version\r\n         version[i] = deltas[token] or (token:byte() / 1000)\r\n      end\r\n      vstring = rest\r\n   end",
    "type": "statement:while"
  }, {
    "id": 24,
    "text": "local token, rest = vstring:match(\"^(%d+)[%.%-%_]*(.*)\")",
    "type": "statement:localassign"
  }, {
    "id": 25,
    "text": "if token then\r\n         add_token(tonumber(token))\r\n      else\r\n         -- extract a word\r\n         token, rest = vstring:match(\"^(%a+)[%.%-%_]*(.*)\")\r\n         if not token then\r\n            util.printerr(\"Warning: version number '\"..vstring..\"' could not be parsed.\")\r\n            version[i] = 0\r\n            break\r\n         end\r\n         local last = #version\r\n         version[i] = deltas[token] or (token:byte() / 1000)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 26,
    "text": "add_token(tonumber(token))",
    "type": "statement:functioncall"
  }, {
    "id": 27,
    "text": "token, rest = vstring:match(\"^(%a+)[%.%-%_]*(.*)\")",
    "type": "statement:assign"
  }, {
    "id": 28,
    "text": "if not token then\r\n            util.printerr(\"Warning: version number '\"..vstring..\"' could not be parsed.\")\r\n            version[i] = 0\r\n            break\r\n         end",
    "type": "statement:if"
  }, {
    "id": 29,
    "text": "util.printerr(\"Warning: version number '\"..vstring..\"' could not be parsed.\")",
    "type": "statement:functioncall"
  }, {
    "id": 30,
    "text": "version[i] = 0",
    "type": "statement:assign"
  }, {
    "id": 31,
    "text": "local last = #version",
    "type": "statement:localassign"
  }, {
    "id": 32,
    "text": "version[i] = deltas[token] or (token:byte() / 1000)",
    "type": "statement:assign"
  }, {
    "id": 33,
    "text": "vstring = rest",
    "type": "statement:assign"
  }, {
    "id": 34,
    "text": "setmetatable(version, version_mt)",
    "type": "statement:functioncall"
  }, {
    "id": 35,
    "text": "version_cache[vstring] = version",
    "type": "statement:assign"
  }, {
    "id": 36,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 37,
    "text": "local function add_token(number)\r\n      version[i] = version[i] and version[i] + number/100000 or number\r\n      i = i + 1\r\n   end",
    "type": "function"
  }, {
    "id": 38,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 39,
    "text": "function compare_versions(a, b)\r\n   return parse_version(a) > parse_version(b)\r\nend",
    "type": "function"
  }, {
    "id": 40,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 41,
    "text": "local function parse_constraint(input)\r\n   assert(type(input) == \"string\")\r\n\r\n   local no_upgrade, op, version, rest = input:match(\"^(@?)([<>=~!]*)%s*([%w%.%_%-]+)[%s,]*(.*)\")\r\n   local _op = operators[op]\r\n   version = parse_version(version)\r\n   if not _op then\r\n      return nil, \"Encountered bad constraint operator: '\"..tostring(op)..\"' in '\"..input..\"'\"\r\n   end\r\n   if not version then \r\n      return nil, \"Could not parse version from constraint: '\"..input..\"'\"\r\n   end\r\n   return { op = _op, version = version, no_upgrade = no_upgrade==\"@\" and true or nil }, rest\r\nend",
    "type": "function"
  }, {
    "id": 42,
    "text": "assert(type(input) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 43,
    "text": "local no_upgrade, op, version, rest = input:match(\"^(@?)([<>=~!]*)%s*([%w%.%_%-]+)[%s,]*(.*)\")",
    "type": "statement:localassign"
  }, {
    "id": 44,
    "text": "local _op = operators[op]",
    "type": "statement:localassign"
  }, {
    "id": 45,
    "text": "version = parse_version(version)",
    "type": "statement:assign"
  }, {
    "id": 46,
    "text": "if not _op then\r\n      return nil, \"Encountered bad constraint operator: '\"..tostring(op)..\"' in '\"..input..\"'\"\r\n   end",
    "type": "statement:if"
  }, {
    "id": 47,
    "text": "if not version then \r\n      return nil, \"Could not parse version from constraint: '\"..input..\"'\"\r\n   end",
    "type": "statement:if"
  }, {
    "id": 48,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 49,
    "text": "function parse_constraints(input)\r\n   assert(type(input) == \"string\")\r\n\r\n   local constraints, constraint, oinput = {}, nil, input\r\n   while #input > 0 do\r\n      constraint, input = parse_constraint(input)\r\n      if constraint then\r\n         table.insert(constraints, constraint)\r\n      else\r\n         return nil, \"Failed to parse constraint '\"..tostring(oinput)..\"' with error: \".. input\r\n      end\r\n   end\r\n   return constraints\r\nend",
    "type": "function"
  }, {
    "id": 50,
    "text": "local constraints, constraint, oinput = {}, nil, input",
    "type": "statement:localassign"
  }, {
    "id": 51,
    "text": "while #input > 0 do\r\n      constraint, input = parse_constraint(input)\r\n      if constraint then\r\n         table.insert(constraints, constraint)\r\n      else\r\n         return nil, \"Failed to parse constraint '\"..tostring(oinput)..\"' with error: \".. input\r\n      end\r\n   end",
    "type": "statement:while"
  }, {
    "id": 52,
    "text": "constraint, input = parse_constraint(input)",
    "type": "statement:assign"
  }, {
    "id": 53,
    "text": "if constraint then\r\n         table.insert(constraints, constraint)\r\n      else\r\n         return nil, \"Failed to parse constraint '\"..tostring(oinput)..\"' with error: \".. input\r\n      end",
    "type": "statement:if"
  }, {
    "id": 54,
    "text": "table.insert(constraints, constraint)",
    "type": "statement:functioncall"
  }, {
    "id": 55,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 56,
    "text": "function parse_dep(dep)\r\n   assert(type(dep) == \"string\")\r\n\r\n   local name, rest = dep:match(\"^%s*([a-zA-Z0-9][a-zA-Z0-9%.%-%_]*)%s*(.*)\")\r\n   if not name then return nil, \"failed to extract dependency name from '\"..tostring(dep)..\"'\" end\r\n   local constraints, err = parse_constraints(rest)\r\n   if not constraints then return nil, err end\r\n   return { name = name, constraints = constraints }\r\nend",
    "type": "function"
  }, {
    "id": 57,
    "text": "assert(type(dep) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 58,
    "text": "local name, rest = dep:match(\"^%s*([a-zA-Z0-9][a-zA-Z0-9%.%-%_]*)%s*(.*)\")",
    "type": "statement:localassign"
  }, {
    "id": 59,
    "text": "if not name then return nil, \"failed to extract dependency name from '\"..tostring(dep)..\"'\" end",
    "type": "statement:if"
  }, {
    "id": 60,
    "text": "local constraints, err = parse_constraints(rest)",
    "type": "statement:localassign"
  }, {
    "id": 61,
    "text": "if not constraints then return nil, err end",
    "type": "statement:if"
  }, {
    "id": 62,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 63,
    "text": "function show_version(v, internal)\r\n   assert(type(v) == \"table\")\r\n   assert(type(internal) == \"boolean\" or not internal)\r\n\r\n   return (internal\r\n           and table.concat(v, \":\")..(v.revision and tostring(v.revision) or \"\")\r\n           or v.string)\r\nend",
    "type": "function"
  }, {
    "id": 64,
    "text": "assert(type(v) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 65,
    "text": "assert(type(internal) == \"boolean\" or not internal)",
    "type": "statement:functioncall"
  }, {
    "id": 66,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 67,
    "text": "function show_dep(dep, internal)\r\n   assert(type(dep) == \"table\")\r\n   assert(type(internal) == \"boolean\" or not internal)\r\n   \r\n   local pretty = {}\r\n   for _, c in ipairs(dep.constraints) do\r\n      table.insert(pretty, c.op .. \" \" .. show_version(c.version, internal))\r\n   end\r\n   return dep.name..\" \"..table.concat(pretty, \", \")\r\nend",
    "type": "function"
  }, {
    "id": 68,
    "text": "assert(type(dep) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 69,
    "text": "local pretty = {}",
    "type": "statement:localassign"
  }, {
    "id": 70,
    "text": "for _, c in ipairs(dep.constraints) do\r\n      table.insert(pretty, c.op .. \" \" .. show_version(c.version, internal))\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 71,
    "text": "table.insert(pretty, c.op .. \" \" .. show_version(c.version, internal))",
    "type": "statement:functioncall"
  }, {
    "id": 72,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 73,
    "text": "local function partial_match(version, requested)\r\n   assert(type(version) == \"string\" or type(version) == \"table\")\r\n   assert(type(requested) == \"string\" or type(version) == \"table\")\r\n\r\n   if type(version) ~= \"table\" then version = parse_version(version) end\r\n   if type(requested) ~= \"table\" then requested = parse_version(requested) end\r\n   if not version or not requested then return false end\r\n   \r\n   for i, ri in ipairs(requested) do\r\n      local vi = version[i] or 0\r\n      if ri ~= vi then return false end\r\n   end\r\n   if requested.revision then\r\n      return requested.revision == version.revision\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 74,
    "text": "assert(type(version) == \"string\" or type(version) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 75,
    "text": "assert(type(requested) == \"string\" or type(version) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 76,
    "text": "if type(version) ~= \"table\" then version = parse_version(version) end",
    "type": "statement:if"
  }, {
    "id": 77,
    "text": "if type(requested) ~= \"table\" then requested = parse_version(requested) end",
    "type": "statement:if"
  }, {
    "id": 78,
    "text": "requested = parse_version(requested)",
    "type": "statement:assign"
  }, {
    "id": 79,
    "text": "if not version or not requested then return false end",
    "type": "statement:if"
  }, {
    "id": 80,
    "text": "for i, ri in ipairs(requested) do\r\n      local vi = version[i] or 0\r\n      if ri ~= vi then return false end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 81,
    "text": "local vi = version[i] or 0",
    "type": "statement:localassign"
  }, {
    "id": 82,
    "text": "if ri ~= vi then return false end",
    "type": "statement:if"
  }, {
    "id": 83,
    "text": "if requested.revision then\r\n      return requested.revision == version.revision\r\n   end",
    "type": "statement:if"
  }, {
    "id": 84,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 85,
    "text": "function match_constraints(version, constraints)\r\n   assert(type(version) == \"table\")\r\n   assert(type(constraints) == \"table\")\r\n   local ok = true\r\n   setmetatable(version, version_mt)\r\n   for _, constr in pairs(constraints) do\r\n      if type(constr.version) == \"string\" then\r\n         constr.version = parse_version(constr.version)\r\n      end\r\n      local constr_version, constr_op = constr.version, constr.op\r\n      setmetatable(constr_version, version_mt)\r\n      if     constr_op == \"==\" then ok = version == constr_version\r\n      elseif constr_op == \"~=\" then ok = version ~= constr_version\r\n      elseif constr_op == \">\"  then ok = version >  constr_version\r\n      elseif constr_op == \"<\"  then ok = version <  constr_version\r\n      elseif constr_op == \">=\" then ok = version >= constr_version\r\n      elseif constr_op == \"<=\" then ok = version <= constr_version\r\n      elseif constr_op == \"~>\" then ok = partial_match(version, constr_version)\r\n      end\r\n      if not ok then break end\r\n   end\r\n   return ok\r\nend",
    "type": "function"
  }, {
    "id": 86,
    "text": "assert(type(version) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 87,
    "text": "assert(type(constraints) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 88,
    "text": "local ok = true",
    "type": "statement:localassign"
  }, {
    "id": 89,
    "text": "for _, constr in pairs(constraints) do\r\n      if type(constr.version) == \"string\" then\r\n         constr.version = parse_version(constr.version)\r\n      end\r\n      local constr_version, constr_op = constr.version, constr.op\r\n      setmetatable(constr_version, version_mt)\r\n      if     constr_op == \"==\" then ok = version == constr_version\r\n      elseif constr_op == \"~=\" then ok = version ~= constr_version\r\n      elseif constr_op == \">\"  then ok = version >  constr_version\r\n      elseif constr_op == \"<\"  then ok = version <  constr_version\r\n      elseif constr_op == \">=\" then ok = version >= constr_version\r\n      elseif constr_op == \"<=\" then ok = version <= constr_version\r\n      elseif constr_op == \"~>\" then ok = partial_match(version, constr_version)\r\n      end\r\n      if not ok then break end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 90,
    "text": "if type(constr.version) == \"string\" then\r\n         constr.version = parse_version(constr.version)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 91,
    "text": "constr.version = parse_version(constr.version)",
    "type": "statement:assign"
  }, {
    "id": 92,
    "text": "local constr_version, constr_op = constr.version, constr.op",
    "type": "statement:localassign"
  }, {
    "id": 93,
    "text": "setmetatable(constr_version, version_mt)",
    "type": "statement:functioncall"
  }, {
    "id": 94,
    "text": "if     constr_op == \"==\" then ok = version == constr_version\r\n      elseif constr_op == \"~=\" then ok = version ~= constr_version\r\n      elseif constr_op == \">\"  then ok = version >  constr_version\r\n      elseif constr_op == \"<\"  then ok = version <  constr_version\r\n      elseif constr_op == \">=\" then ok = version >= constr_version\r\n      elseif constr_op == \"<=\" then ok = version <= constr_version\r\n      elseif constr_op == \"~>\" then ok = partial_match(version, constr_version)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 95,
    "text": "ok = version == constr_version",
    "type": "statement:assign"
  }, {
    "id": 96,
    "text": "ok = version ~= constr_version",
    "type": "statement:assign"
  }, {
    "id": 97,
    "text": "ok = version >  constr_version",
    "type": "statement:assign"
  }, {
    "id": 98,
    "text": "ok = version <  constr_version",
    "type": "statement:assign"
  }, {
    "id": 99,
    "text": "ok = version >= constr_version",
    "type": "statement:assign"
  }, {
    "id": 100,
    "text": "ok = version <= constr_version",
    "type": "statement:assign"
  }, {
    "id": 101,
    "text": "ok = partial_match(version, constr_version)",
    "type": "statement:assign"
  }, {
    "id": 102,
    "text": "if not ok then break end",
    "type": "statement:if"
  }, {
    "id": 103,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 104,
    "text": "local function match_dep(dep, blacklist, deps_mode)\r\n   assert(type(dep) == \"table\")\r\n\r\n   local versions = cfg.rocks_provided[dep.name]\r\n   if cfg.rocks_provided[dep.name] then\r\n      -- provided rocks have higher priority than manifest's rocks\r\n      versions = { cfg.rocks_provided[dep.name] }\r\n   else\r\n      versions = manif_core.get_versions(dep.name, deps_mode)\r\n   end\r\n   if not versions then\r\n      return nil\r\n   end\r\n   if blacklist then\r\n      local i = 1\r\n      while versions[i] do\r\n         if blacklist[versions[i]] then\r\n            table.remove(versions, i)\r\n         else\r\n            i = i + 1\r\n         end\r\n      end\r\n   end\r\n   local candidates = {}\r\n   for _, vstring in ipairs(versions) do\r\n      local version = parse_version(vstring)\r\n      if match_constraints(version, dep.constraints) then\r\n         table.insert(candidates, version)\r\n      end\r\n   end\r\n   if #candidates == 0 then\r\n      return nil\r\n   else\r\n      table.sort(candidates)\r\n      return {\r\n         name = dep.name,\r\n         version = candidates[#candidates].string\r\n      }\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 105,
    "text": "local versions = cfg.rocks_provided[dep.name]",
    "type": "statement:localassign"
  }, {
    "id": 106,
    "text": "if cfg.rocks_provided[dep.name] then\r\n      -- provided rocks have higher priority than manifest's rocks\r\n      versions = { cfg.rocks_provided[dep.name] }\r\n   else\r\n      versions = manif_core.get_versions(dep.name, deps_mode)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 107,
    "text": "versions = { cfg.rocks_provided[dep.name] }",
    "type": "statement:assign"
  }, {
    "id": 108,
    "text": "versions = manif_core.get_versions(dep.name, deps_mode)",
    "type": "statement:assign"
  }, {
    "id": 109,
    "text": "if not versions then\r\n      return nil\r\n   end",
    "type": "statement:if"
  }, {
    "id": 110,
    "text": "if blacklist then\r\n      local i = 1\r\n      while versions[i] do\r\n         if blacklist[versions[i]] then\r\n            table.remove(versions, i)\r\n         else\r\n            i = i + 1\r\n         end\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 111,
    "text": "while versions[i] do\r\n         if blacklist[versions[i]] then\r\n            table.remove(versions, i)\r\n         else\r\n            i = i + 1\r\n         end\r\n      end",
    "type": "statement:while"
  }, {
    "id": 112,
    "text": "if blacklist[versions[i]] then\r\n            table.remove(versions, i)\r\n         else\r\n            i = i + 1\r\n         end",
    "type": "statement:if"
  }, {
    "id": 113,
    "text": "table.remove(versions, i)",
    "type": "statement:functioncall"
  }, {
    "id": 114,
    "text": "local candidates = {}",
    "type": "statement:localassign"
  }, {
    "id": 115,
    "text": "for _, vstring in ipairs(versions) do\r\n      local version = parse_version(vstring)\r\n      if match_constraints(version, dep.constraints) then\r\n         table.insert(candidates, version)\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 116,
    "text": "local version = parse_version(vstring)",
    "type": "statement:localassign"
  }, {
    "id": 117,
    "text": "if match_constraints(version, dep.constraints) then\r\n         table.insert(candidates, version)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 118,
    "text": "table.insert(candidates, version)",
    "type": "statement:functioncall"
  }, {
    "id": 119,
    "text": "if #candidates == 0 then\r\n      return nil\r\n   else\r\n      table.sort(candidates)\r\n      return {\r\n         name = dep.name,\r\n         version = candidates[#candidates].string\r\n      }\r\n   end",
    "type": "statement:if"
  }, {
    "id": 120,
    "text": "table.sort(candidates)",
    "type": "statement:functioncall"
  }, {
    "id": 121,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 122,
    "text": "function match_deps(rockspec, blacklist, deps_mode)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(blacklist) == \"table\" or not blacklist)\r\n   local matched, missing, no_upgrade = {}, {}, {}\r\n   \r\n   for _, dep in ipairs(rockspec.dependencies) do\r\n      local found = match_dep(dep, blacklist and blacklist[dep.name] or nil, deps_mode)\r\n      if found then\r\n         if not cfg.rocks_provided[dep.name] then\r\n            matched[dep] = found\r\n         end\r\n      else\r\n         if dep.constraints[1] and dep.constraints[1].no_upgrade then\r\n            no_upgrade[dep.name] = dep\r\n         else\r\n            missing[dep.name] = dep\r\n         end\r\n      end\r\n   end\r\n   return matched, missing, no_upgrade\r\nend",
    "type": "function"
  }, {
    "id": 123,
    "text": "assert(type(rockspec) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 124,
    "text": "assert(type(blacklist) == \"table\" or not blacklist)",
    "type": "statement:functioncall"
  }, {
    "id": 125,
    "text": "local matched, missing, no_upgrade = {}, {}, {}",
    "type": "statement:localassign"
  }, {
    "id": 126,
    "text": "for _, dep in ipairs(rockspec.dependencies) do\r\n      local found = match_dep(dep, blacklist and blacklist[dep.name] or nil, deps_mode)\r\n      if found then\r\n         if not cfg.rocks_provided[dep.name] then\r\n            matched[dep] = found\r\n         end\r\n      else\r\n         if dep.constraints[1] and dep.constraints[1].no_upgrade then\r\n            no_upgrade[dep.name] = dep\r\n         else\r\n            missing[dep.name] = dep\r\n         end\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 127,
    "text": "local found = match_dep(dep, blacklist and blacklist[dep.name] or nil, deps_mode)",
    "type": "statement:localassign"
  }, {
    "id": 128,
    "text": "if found then\r\n         if not cfg.rocks_provided[dep.name] then\r\n            matched[dep] = found\r\n         end\r\n      else\r\n         if dep.constraints[1] and dep.constraints[1].no_upgrade then\r\n            no_upgrade[dep.name] = dep\r\n         else\r\n            missing[dep.name] = dep\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 129,
    "text": "if not cfg.rocks_provided[dep.name] then\r\n            matched[dep] = found\r\n         end",
    "type": "statement:if"
  }, {
    "id": 130,
    "text": "matched[dep] = found",
    "type": "statement:assign"
  }, {
    "id": 131,
    "text": "if dep.constraints[1] and dep.constraints[1].no_upgrade then\r\n            no_upgrade[dep.name] = dep\r\n         else\r\n            missing[dep.name] = dep\r\n         end",
    "type": "statement:if"
  }, {
    "id": 132,
    "text": "no_upgrade[dep.name] = dep",
    "type": "statement:assign"
  }, {
    "id": 133,
    "text": "missing[dep.name] = dep",
    "type": "statement:assign"
  }, {
    "id": 134,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 135,
    "text": "local function values_set(tbl)\r\n   local set = {}\r\n   for _, v in pairs(tbl) do\r\n      set[v] = true\r\n   end\r\n   return set\r\nend",
    "type": "function"
  }, {
    "id": 136,
    "text": "local set = {}",
    "type": "statement:localassign"
  }, {
    "id": 137,
    "text": "for _, v in pairs(tbl) do\r\n      set[v] = true\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 138,
    "text": "set[v] = true",
    "type": "statement:assign"
  }, {
    "id": 139,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 140,
    "text": "function fulfill_dependencies(rockspec, deps_mode)\r\n\r\n   local search = require(\"luarocks.search\")\r\n   local install = require(\"luarocks.install\")\r\n\r\n   if rockspec.supported_platforms then\r\n      if not platforms_set then\r\n         platforms_set = values_set(cfg.platforms)\r\n      end\r\n      local supported = nil\r\n      for _, plat in pairs(rockspec.supported_platforms) do\r\n         local neg, plat = plat:match(\"^(!?)(.*)\")\r\n         if neg == \"!\" then\r\n            if platforms_set[plat] then\r\n               return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plat..\" platforms.\"\r\n            end\r\n         else\r\n            if platforms_set[plat] then\r\n               supported = true\r\n            else\r\n               if supported == nil then\r\n                  supported = false\r\n               end\r\n            end\r\n         end\r\n      end\r\n      if supported == false then\r\n         local plats = table.concat(cfg.platforms, \", \")\r\n         return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plats..\" platforms.\"\r\n      end\r\n   end\r\n\r\n   local _, missing, no_upgrade = match_deps(rockspec, nil, deps_mode)\r\n\r\n   if next(no_upgrade) then\r\n      util.printerr(\"Missing dependencies for \"..rockspec.name..\" \"..rockspec.version..\":\")\r\n      for _, dep in pairs(no_upgrade) do\r\n         util.printerr(show_dep(dep))\r\n      end\r\n      if next(missing) then\r\n         for _, dep in pairs(missing) do\r\n            util.printerr(show_dep(dep))\r\n         end\r\n      end\r\n      util.printerr()\r\n      for _, dep in pairs(no_upgrade) do\r\n         util.printerr(\"This version of \"..rockspec.name..\" is designed for use with\")\r\n         util.printerr(show_dep(dep)..\", but is configured to avoid upgrading it\")\r\n         util.printerr(\"automatically. Please upgrade \"..dep.name..\" with\")\r\n         util.printerr(\"   luarocks install \"..dep.name)\r\n         util.printerr(\"or choose an older version of \"..rockspec.name..\" with\")\r\n         util.printerr(\"   luarocks search \"..rockspec.name)\r\n      end\r\n      return nil, \"Failed matching dependencies.\"\r\n   end\r\n\r\n   if next(missing) then\r\n      util.printerr()\r\n      util.printerr(\"Missing dependencies for \"..rockspec.name..\":\")\r\n      for _, dep in pairs(missing) do\r\n         util.printerr(show_dep(dep))\r\n      end\r\n      util.printerr()\r\n\r\n      for _, dep in pairs(missing) do\r\n         -- Double-check in case dependency was filled during recursion.\r\n         if not match_dep(dep, nil, deps_mode) then\r\n            local rock = search.find_suitable_rock(dep)\r\n            if not rock then\r\n               return nil, \"Could not satisfy dependency: \"..show_dep(dep)\r\n            end\r\n            local ok, err, errcode = install.run(rock)\r\n            if not ok then\r\n               return nil, \"Failed installing dependency: \"..rock..\" - \"..err, errcode\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 141,
    "text": "local search = require(\"luarocks.search\")",
    "type": "statement:localassign"
  }, {
    "id": 142,
    "text": "local install = require(\"luarocks.install\")",
    "type": "statement:localassign"
  }, {
    "id": 143,
    "text": "if rockspec.supported_platforms then\r\n      if not platforms_set then\r\n         platforms_set = values_set(cfg.platforms)\r\n      end\r\n      local supported = nil\r\n      for _, plat in pairs(rockspec.supported_platforms) do\r\n         local neg, plat = plat:match(\"^(!?)(.*)\")\r\n         if neg == \"!\" then\r\n            if platforms_set[plat] then\r\n               return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plat..\" platforms.\"\r\n            end\r\n         else\r\n            if platforms_set[plat] then\r\n               supported = true\r\n            else\r\n               if supported == nil then\r\n                  supported = false\r\n               end\r\n            end\r\n         end\r\n      end\r\n      if supported == false then\r\n         local plats = table.concat(cfg.platforms, \", \")\r\n         return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plats..\" platforms.\"\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 144,
    "text": "if not platforms_set then\r\n         platforms_set = values_set(cfg.platforms)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 145,
    "text": "platforms_set = values_set(cfg.platforms)",
    "type": "statement:assign"
  }, {
    "id": 146,
    "text": "local supported = nil",
    "type": "statement:localassign"
  }, {
    "id": 147,
    "text": "for _, plat in pairs(rockspec.supported_platforms) do\r\n         local neg, plat = plat:match(\"^(!?)(.*)\")\r\n         if neg == \"!\" then\r\n            if platforms_set[plat] then\r\n               return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plat..\" platforms.\"\r\n            end\r\n         else\r\n            if platforms_set[plat] then\r\n               supported = true\r\n            else\r\n               if supported == nil then\r\n                  supported = false\r\n               end\r\n            end\r\n         end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 148,
    "text": "local neg, plat = plat:match(\"^(!?)(.*)\")",
    "type": "statement:localassign"
  }, {
    "id": 149,
    "text": "if neg == \"!\" then\r\n            if platforms_set[plat] then\r\n               return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plat..\" platforms.\"\r\n            end\r\n         else\r\n            if platforms_set[plat] then\r\n               supported = true\r\n            else\r\n               if supported == nil then\r\n                  supported = false\r\n               end\r\n            end\r\n         end",
    "type": "statement:if"
  }, {
    "id": 150,
    "text": "if platforms_set[plat] then\r\n               return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plat..\" platforms.\"\r\n            end",
    "type": "statement:if"
  }, {
    "id": 151,
    "text": "if platforms_set[plat] then\r\n               supported = true\r\n            else\r\n               if supported == nil then\r\n                  supported = false\r\n               end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 152,
    "text": "supported = true",
    "type": "statement:assign"
  }, {
    "id": 153,
    "text": "if supported == nil then\r\n                  supported = false\r\n               end",
    "type": "statement:if"
  }, {
    "id": 154,
    "text": "supported = false",
    "type": "statement:assign"
  }, {
    "id": 155,
    "text": "if supported == false then\r\n         local plats = table.concat(cfg.platforms, \", \")\r\n         return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plats..\" platforms.\"\r\n      end",
    "type": "statement:if"
  }, {
    "id": 156,
    "text": "local plats = table.concat(cfg.platforms, \", \")",
    "type": "statement:localassign"
  }, {
    "id": 157,
    "text": "local _, missing, no_upgrade = match_deps(rockspec, nil, deps_mode)",
    "type": "statement:localassign"
  }, {
    "id": 158,
    "text": "if next(no_upgrade) then\r\n      util.printerr(\"Missing dependencies for \"..rockspec.name..\" \"..rockspec.version..\":\")\r\n      for _, dep in pairs(no_upgrade) do\r\n         util.printerr(show_dep(dep))\r\n      end\r\n      if next(missing) then\r\n         for _, dep in pairs(missing) do\r\n            util.printerr(show_dep(dep))\r\n         end\r\n      end\r\n      util.printerr()\r\n      for _, dep in pairs(no_upgrade) do\r\n         util.printerr(\"This version of \"..rockspec.name..\" is designed for use with\")\r\n         util.printerr(show_dep(dep)..\", but is configured to avoid upgrading it\")\r\n         util.printerr(\"automatically. Please upgrade \"..dep.name..\" with\")\r\n         util.printerr(\"   luarocks install \"..dep.name)\r\n         util.printerr(\"or choose an older version of \"..rockspec.name..\" with\")\r\n         util.printerr(\"   luarocks search \"..rockspec.name)\r\n      end\r\n      return nil, \"Failed matching dependencies.\"\r\n   end",
    "type": "statement:if"
  }, {
    "id": 159,
    "text": "util.printerr(\"Missing dependencies for \"..rockspec.name..\" \"..rockspec.version..\":\")",
    "type": "statement:functioncall"
  }, {
    "id": 160,
    "text": "for _, dep in pairs(no_upgrade) do\r\n         util.printerr(show_dep(dep))\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 161,
    "text": "util.printerr(show_dep(dep))",
    "type": "statement:functioncall"
  }, {
    "id": 162,
    "text": "if next(missing) then\r\n         for _, dep in pairs(missing) do\r\n            util.printerr(show_dep(dep))\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 163,
    "text": "for _, dep in pairs(missing) do\r\n            util.printerr(show_dep(dep))\r\n         end",
    "type": "statement:genericfor"
  }, {
    "id": 164,
    "text": "util.printerr()",
    "type": "statement:functioncall"
  }, {
    "id": 165,
    "text": "for _, dep in pairs(no_upgrade) do\r\n         util.printerr(\"This version of \"..rockspec.name..\" is designed for use with\")\r\n         util.printerr(show_dep(dep)..\", but is configured to avoid upgrading it\")\r\n         util.printerr(\"automatically. Please upgrade \"..dep.name..\" with\")\r\n         util.printerr(\"   luarocks install \"..dep.name)\r\n         util.printerr(\"or choose an older version of \"..rockspec.name..\" with\")\r\n         util.printerr(\"   luarocks search \"..rockspec.name)\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 166,
    "text": "util.printerr(\"This version of \"..rockspec.name..\" is designed for use with\")",
    "type": "statement:functioncall"
  }, {
    "id": 167,
    "text": "util.printerr(show_dep(dep)..\", but is configured to avoid upgrading it\")",
    "type": "statement:functioncall"
  }, {
    "id": 168,
    "text": "util.printerr(\"automatically. Please upgrade \"..dep.name..\" with\")",
    "type": "statement:functioncall"
  }, {
    "id": 169,
    "text": "util.printerr(\"   luarocks install \"..dep.name)",
    "type": "statement:functioncall"
  }, {
    "id": 170,
    "text": "util.printerr(\"or choose an older version of \"..rockspec.name..\" with\")",
    "type": "statement:functioncall"
  }, {
    "id": 171,
    "text": "util.printerr(\"   luarocks search \"..rockspec.name)",
    "type": "statement:functioncall"
  }, {
    "id": 172,
    "text": "if next(missing) then\r\n      util.printerr()\r\n      util.printerr(\"Missing dependencies for \"..rockspec.name..\":\")\r\n      for _, dep in pairs(missing) do\r\n         util.printerr(show_dep(dep))\r\n      end\r\n      util.printerr()\r\n\r\n      for _, dep in pairs(missing) do\r\n         -- Double-check in case dependency was filled during recursion.\r\n         if not match_dep(dep, nil, deps_mode) then\r\n            local rock = search.find_suitable_rock(dep)\r\n            if not rock then\r\n               return nil, \"Could not satisfy dependency: \"..show_dep(dep)\r\n            end\r\n            local ok, err, errcode = install.run(rock)\r\n            if not ok then\r\n               return nil, \"Failed installing dependency: \"..rock..\" - \"..err, errcode\r\n            end\r\n         end\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 173,
    "text": "util.printerr(\"Missing dependencies for \"..rockspec.name..\":\")",
    "type": "statement:functioncall"
  }, {
    "id": 174,
    "text": "for _, dep in pairs(missing) do\r\n         util.printerr(show_dep(dep))\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 175,
    "text": "for _, dep in pairs(missing) do\r\n         -- Double-check in case dependency was filled during recursion.\r\n         if not match_dep(dep, nil, deps_mode) then\r\n            local rock = search.find_suitable_rock(dep)\r\n            if not rock then\r\n               return nil, \"Could not satisfy dependency: \"..show_dep(dep)\r\n            end\r\n            local ok, err, errcode = install.run(rock)\r\n            if not ok then\r\n               return nil, \"Failed installing dependency: \"..rock..\" - \"..err, errcode\r\n            end\r\n         end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 176,
    "text": "if not match_dep(dep, nil, deps_mode) then\r\n            local rock = search.find_suitable_rock(dep)\r\n            if not rock then\r\n               return nil, \"Could not satisfy dependency: \"..show_dep(dep)\r\n            end\r\n            local ok, err, errcode = install.run(rock)\r\n            if not ok then\r\n               return nil, \"Failed installing dependency: \"..rock..\" - \"..err, errcode\r\n            end\r\n         end",
    "type": "statement:if"
  }, {
    "id": 177,
    "text": "local rock = search.find_suitable_rock(dep)",
    "type": "statement:localassign"
  }, {
    "id": 178,
    "text": "if not rock then\r\n               return nil, \"Could not satisfy dependency: \"..show_dep(dep)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 179,
    "text": "local ok, err, errcode = install.run(rock)",
    "type": "statement:localassign"
  }, {
    "id": 180,
    "text": "if not ok then\r\n               return nil, \"Failed installing dependency: \"..rock..\" - \"..err, errcode\r\n            end",
    "type": "statement:if"
  }, {
    "id": 181,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 182,
    "text": "local function deconstruct_pattern(file, pattern)\r\n   local depattern = \"^\"..(pattern:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\"):gsub(\"?\", \"(.*)\"))..\"$\"\r\n   return (file:match(depattern))\r\nend",
    "type": "function"
  }, {
    "id": 183,
    "text": "local depattern = \"^\"..(pattern:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\"):gsub(\"?\", \"(.*)\"))..\"$\"",
    "type": "statement:localassign"
  }, {
    "id": 184,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 185,
    "text": "local function add_all_patterns(file, patterns, files)\r\n   for _, pattern in ipairs(patterns) do\r\n      table.insert(files, (pattern:gsub(\"?\", file)))\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 186,
    "text": "for _, pattern in ipairs(patterns) do\r\n      table.insert(files, (pattern:gsub(\"?\", file)))\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 187,
    "text": "table.insert(files, (pattern:gsub(\"?\", file)))",
    "type": "statement:functioncall"
  }, {
    "id": 188,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 189,
    "text": "function check_external_deps(rockspec, mode)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   local fs = require(\"luarocks.fs\")\r\n   \r\n   local vars = rockspec.variables\r\n   local patterns = cfg.external_deps_patterns\r\n   local subdirs = cfg.external_deps_subdirs\r\n   if mode == \"install\" then\r\n      patterns = cfg.runtime_external_deps_patterns\r\n      subdirs = cfg.runtime_external_deps_subdirs\r\n   end\r\n   if rockspec.external_dependencies then\r\n      for name, files in pairs(rockspec.external_dependencies) do\r\n         local ok = true\r\n         local failed_file = nil\r\n         local failed_dirname = nil\r\n         for _, extdir in ipairs(cfg.external_deps_dirs) do\r\n            ok = true\r\n            local prefix = vars[name..\"_DIR\"]\r\n            local dirs = {\r\n               BINDIR = { subdir = subdirs.bin, testfile = \"program\", pattern = patterns.bin },\r\n               INCDIR = { subdir = subdirs.include, testfile = \"header\", pattern = patterns.include },\r\n               LIBDIR = { subdir = subdirs.lib, testfile = \"library\", pattern = patterns.lib }\r\n            }\r\n            if mode == \"install\" then\r\n               dirs.INCDIR = nil\r\n            end\r\n            if not prefix then\r\n               prefix = extdir\r\n            end\r\n            if type(prefix) == \"table\" then\r\n               if prefix.bin then\r\n                  dirs.BINDIR.subdir = prefix.bin\r\n               end\r\n               if prefix.include then\r\n                  if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end\r\n               end\r\n               if prefix.lib then\r\n                  dirs.LIBDIR.subdir = prefix.lib\r\n               end\r\n               prefix = prefix.prefix\r\n            end\r\n            for dirname, dirdata in pairs(dirs) do\r\n               local paths\r\n               local path_var_value = vars[name..\"_\"..dirname]\r\n               if path_var_value then\r\n                  paths = { path_var_value }\r\n               elseif type(dirdata.subdir) == \"table\" then\r\n                  paths = {}\r\n                  for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end\r\n               else\r\n                  paths = { dir.path(prefix, dirdata.subdir) }\r\n               end\r\n               dirdata.dir = paths[1]\r\n               local file = files[dirdata.testfile]\r\n               if file then\r\n                  local files = {}\r\n                  if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end\r\n                  local found = false\r\n                  failed_file = nil\r\n                  for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end\r\n                  if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end\r\n               end\r\n            end\r\n            if ok then\r\n               for dirname, dirdata in pairs(dirs) do\r\n                  vars[name..\"_\"..dirname] = dirdata.dir\r\n               end\r\n               vars[name..\"_DIR\"] = prefix\r\n               break\r\n            end\r\n         end\r\n         if not ok then\r\n            return nil, \"Could not find expected file \"..failed_file..\" for \"..name..\" -- you may have to install \"..name..\" in your system and/or pass \"..name..\"_DIR or \"..name..\"_\"..failed_dirname..\" to the luarocks command. Example: luarocks install \"..rockspec.name..\" \"..name..\"_DIR=/usr/local\", \"dependency\"\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 190,
    "text": "local fs = require(\"luarocks.fs\")",
    "type": "statement:localassign"
  }, {
    "id": 191,
    "text": "local vars = rockspec.variables",
    "type": "statement:localassign"
  }, {
    "id": 192,
    "text": "local patterns = cfg.external_deps_patterns",
    "type": "statement:localassign"
  }, {
    "id": 193,
    "text": "local subdirs = cfg.external_deps_subdirs",
    "type": "statement:localassign"
  }, {
    "id": 194,
    "text": "if mode == \"install\" then\r\n      patterns = cfg.runtime_external_deps_patterns\r\n      subdirs = cfg.runtime_external_deps_subdirs\r\n   end",
    "type": "statement:if"
  }, {
    "id": 195,
    "text": "patterns = cfg.runtime_external_deps_patterns",
    "type": "statement:assign"
  }, {
    "id": 196,
    "text": "subdirs = cfg.runtime_external_deps_subdirs",
    "type": "statement:assign"
  }, {
    "id": 197,
    "text": "if rockspec.external_dependencies then\r\n      for name, files in pairs(rockspec.external_dependencies) do\r\n         local ok = true\r\n         local failed_file = nil\r\n         local failed_dirname = nil\r\n         for _, extdir in ipairs(cfg.external_deps_dirs) do\r\n            ok = true\r\n            local prefix = vars[name..\"_DIR\"]\r\n            local dirs = {\r\n               BINDIR = { subdir = subdirs.bin, testfile = \"program\", pattern = patterns.bin },\r\n               INCDIR = { subdir = subdirs.include, testfile = \"header\", pattern = patterns.include },\r\n               LIBDIR = { subdir = subdirs.lib, testfile = \"library\", pattern = patterns.lib }\r\n            }\r\n            if mode == \"install\" then\r\n               dirs.INCDIR = nil\r\n            end\r\n            if not prefix then\r\n               prefix = extdir\r\n            end\r\n            if type(prefix) == \"table\" then\r\n               if prefix.bin then\r\n                  dirs.BINDIR.subdir = prefix.bin\r\n               end\r\n               if prefix.include then\r\n                  if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end\r\n               end\r\n               if prefix.lib then\r\n                  dirs.LIBDIR.subdir = prefix.lib\r\n               end\r\n               prefix = prefix.prefix\r\n            end\r\n            for dirname, dirdata in pairs(dirs) do\r\n               local paths\r\n               local path_var_value = vars[name..\"_\"..dirname]\r\n               if path_var_value then\r\n                  paths = { path_var_value }\r\n               elseif type(dirdata.subdir) == \"table\" then\r\n                  paths = {}\r\n                  for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end\r\n               else\r\n                  paths = { dir.path(prefix, dirdata.subdir) }\r\n               end\r\n               dirdata.dir = paths[1]\r\n               local file = files[dirdata.testfile]\r\n               if file then\r\n                  local files = {}\r\n                  if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end\r\n                  local found = false\r\n                  failed_file = nil\r\n                  for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end\r\n                  if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end\r\n               end\r\n            end\r\n            if ok then\r\n               for dirname, dirdata in pairs(dirs) do\r\n                  vars[name..\"_\"..dirname] = dirdata.dir\r\n               end\r\n               vars[name..\"_DIR\"] = prefix\r\n               break\r\n            end\r\n         end\r\n         if not ok then\r\n            return nil, \"Could not find expected file \"..failed_file..\" for \"..name..\" -- you may have to install \"..name..\" in your system and/or pass \"..name..\"_DIR or \"..name..\"_\"..failed_dirname..\" to the luarocks command. Example: luarocks install \"..rockspec.name..\" \"..name..\"_DIR=/usr/local\", \"dependency\"\r\n         end\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 198,
    "text": "for name, files in pairs(rockspec.external_dependencies) do\r\n         local ok = true\r\n         local failed_file = nil\r\n         local failed_dirname = nil\r\n         for _, extdir in ipairs(cfg.external_deps_dirs) do\r\n            ok = true\r\n            local prefix = vars[name..\"_DIR\"]\r\n            local dirs = {\r\n               BINDIR = { subdir = subdirs.bin, testfile = \"program\", pattern = patterns.bin },\r\n               INCDIR = { subdir = subdirs.include, testfile = \"header\", pattern = patterns.include },\r\n               LIBDIR = { subdir = subdirs.lib, testfile = \"library\", pattern = patterns.lib }\r\n            }\r\n            if mode == \"install\" then\r\n               dirs.INCDIR = nil\r\n            end\r\n            if not prefix then\r\n               prefix = extdir\r\n            end\r\n            if type(prefix) == \"table\" then\r\n               if prefix.bin then\r\n                  dirs.BINDIR.subdir = prefix.bin\r\n               end\r\n               if prefix.include then\r\n                  if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end\r\n               end\r\n               if prefix.lib then\r\n                  dirs.LIBDIR.subdir = prefix.lib\r\n               end\r\n               prefix = prefix.prefix\r\n            end\r\n            for dirname, dirdata in pairs(dirs) do\r\n               local paths\r\n               local path_var_value = vars[name..\"_\"..dirname]\r\n               if path_var_value then\r\n                  paths = { path_var_value }\r\n               elseif type(dirdata.subdir) == \"table\" then\r\n                  paths = {}\r\n                  for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end\r\n               else\r\n                  paths = { dir.path(prefix, dirdata.subdir) }\r\n               end\r\n               dirdata.dir = paths[1]\r\n               local file = files[dirdata.testfile]\r\n               if file then\r\n                  local files = {}\r\n                  if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end\r\n                  local found = false\r\n                  failed_file = nil\r\n                  for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end\r\n                  if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end\r\n               end\r\n            end\r\n            if ok then\r\n               for dirname, dirdata in pairs(dirs) do\r\n                  vars[name..\"_\"..dirname] = dirdata.dir\r\n               end\r\n               vars[name..\"_DIR\"] = prefix\r\n               break\r\n            end\r\n         end\r\n         if not ok then\r\n            return nil, \"Could not find expected file \"..failed_file..\" for \"..name..\" -- you may have to install \"..name..\" in your system and/or pass \"..name..\"_DIR or \"..name..\"_\"..failed_dirname..\" to the luarocks command. Example: luarocks install \"..rockspec.name..\" \"..name..\"_DIR=/usr/local\", \"dependency\"\r\n         end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 199,
    "text": "local failed_file = nil",
    "type": "statement:localassign"
  }, {
    "id": 200,
    "text": "local failed_dirname = nil",
    "type": "statement:localassign"
  }, {
    "id": 201,
    "text": "for _, extdir in ipairs(cfg.external_deps_dirs) do\r\n            ok = true\r\n            local prefix = vars[name..\"_DIR\"]\r\n            local dirs = {\r\n               BINDIR = { subdir = subdirs.bin, testfile = \"program\", pattern = patterns.bin },\r\n               INCDIR = { subdir = subdirs.include, testfile = \"header\", pattern = patterns.include },\r\n               LIBDIR = { subdir = subdirs.lib, testfile = \"library\", pattern = patterns.lib }\r\n            }\r\n            if mode == \"install\" then\r\n               dirs.INCDIR = nil\r\n            end\r\n            if not prefix then\r\n               prefix = extdir\r\n            end\r\n            if type(prefix) == \"table\" then\r\n               if prefix.bin then\r\n                  dirs.BINDIR.subdir = prefix.bin\r\n               end\r\n               if prefix.include then\r\n                  if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end\r\n               end\r\n               if prefix.lib then\r\n                  dirs.LIBDIR.subdir = prefix.lib\r\n               end\r\n               prefix = prefix.prefix\r\n            end\r\n            for dirname, dirdata in pairs(dirs) do\r\n               local paths\r\n               local path_var_value = vars[name..\"_\"..dirname]\r\n               if path_var_value then\r\n                  paths = { path_var_value }\r\n               elseif type(dirdata.subdir) == \"table\" then\r\n                  paths = {}\r\n                  for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end\r\n               else\r\n                  paths = { dir.path(prefix, dirdata.subdir) }\r\n               end\r\n               dirdata.dir = paths[1]\r\n               local file = files[dirdata.testfile]\r\n               if file then\r\n                  local files = {}\r\n                  if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end\r\n                  local found = false\r\n                  failed_file = nil\r\n                  for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end\r\n                  if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end\r\n               end\r\n            end\r\n            if ok then\r\n               for dirname, dirdata in pairs(dirs) do\r\n                  vars[name..\"_\"..dirname] = dirdata.dir\r\n               end\r\n               vars[name..\"_DIR\"] = prefix\r\n               break\r\n            end\r\n         end",
    "type": "statement:genericfor"
  }, {
    "id": 202,
    "text": "ok = true",
    "type": "statement:assign"
  }, {
    "id": 203,
    "text": "local prefix = vars[name..\"_DIR\"]",
    "type": "statement:localassign"
  }, {
    "id": 204,
    "text": "local dirs = {\r\n               BINDIR = { subdir = subdirs.bin, testfile = \"program\", pattern = patterns.bin },\r\n               INCDIR = { subdir = subdirs.include, testfile = \"header\", pattern = patterns.include },\r\n               LIBDIR = { subdir = subdirs.lib, testfile = \"library\", pattern = patterns.lib }\r\n            }",
    "type": "statement:localassign"
  }, {
    "id": 205,
    "text": "if mode == \"install\" then\r\n               dirs.INCDIR = nil\r\n            end",
    "type": "statement:if"
  }, {
    "id": 206,
    "text": "dirs.INCDIR = nil",
    "type": "statement:assign"
  }, {
    "id": 207,
    "text": "if not prefix then\r\n               prefix = extdir\r\n            end",
    "type": "statement:if"
  }, {
    "id": 208,
    "text": "prefix = extdir",
    "type": "statement:assign"
  }, {
    "id": 209,
    "text": "if type(prefix) == \"table\" then\r\n               if prefix.bin then\r\n                  dirs.BINDIR.subdir = prefix.bin\r\n               end\r\n               if prefix.include then\r\n                  if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end\r\n               end\r\n               if prefix.lib then\r\n                  dirs.LIBDIR.subdir = prefix.lib\r\n               end\r\n               prefix = prefix.prefix\r\n            end",
    "type": "statement:if"
  }, {
    "id": 210,
    "text": "if prefix.bin then\r\n                  dirs.BINDIR.subdir = prefix.bin\r\n               end",
    "type": "statement:if"
  }, {
    "id": 211,
    "text": "dirs.BINDIR.subdir = prefix.bin",
    "type": "statement:assign"
  }, {
    "id": 212,
    "text": "if prefix.include then\r\n                  if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end\r\n               end",
    "type": "statement:if"
  }, {
    "id": 213,
    "text": "if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end",
    "type": "statement:if"
  }, {
    "id": 214,
    "text": "dirs.INCDIR.subdir = prefix.include",
    "type": "statement:assign"
  }, {
    "id": 215,
    "text": "if prefix.lib then\r\n                  dirs.LIBDIR.subdir = prefix.lib\r\n               end",
    "type": "statement:if"
  }, {
    "id": 216,
    "text": "dirs.LIBDIR.subdir = prefix.lib",
    "type": "statement:assign"
  }, {
    "id": 217,
    "text": "prefix = prefix.prefix",
    "type": "statement:assign"
  }, {
    "id": 218,
    "text": "for dirname, dirdata in pairs(dirs) do\r\n               local paths\r\n               local path_var_value = vars[name..\"_\"..dirname]\r\n               if path_var_value then\r\n                  paths = { path_var_value }\r\n               elseif type(dirdata.subdir) == \"table\" then\r\n                  paths = {}\r\n                  for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end\r\n               else\r\n                  paths = { dir.path(prefix, dirdata.subdir) }\r\n               end\r\n               dirdata.dir = paths[1]\r\n               local file = files[dirdata.testfile]\r\n               if file then\r\n                  local files = {}\r\n                  if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end\r\n                  local found = false\r\n                  failed_file = nil\r\n                  for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end\r\n                  if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end\r\n               end\r\n            end",
    "type": "statement:genericfor"
  }, {
    "id": 219,
    "text": "local paths",
    "type": "statement:localassign"
  }, {
    "id": 220,
    "text": "local path_var_value = vars[name..\"_\"..dirname]",
    "type": "statement:localassign"
  }, {
    "id": 221,
    "text": "if path_var_value then\r\n                  paths = { path_var_value }\r\n               elseif type(dirdata.subdir) == \"table\" then\r\n                  paths = {}\r\n                  for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end\r\n               else\r\n                  paths = { dir.path(prefix, dirdata.subdir) }\r\n               end",
    "type": "statement:if"
  }, {
    "id": 222,
    "text": "paths = { path_var_value }",
    "type": "statement:assign"
  }, {
    "id": 223,
    "text": "paths = {}",
    "type": "statement:assign"
  }, {
    "id": 224,
    "text": "for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end",
    "type": "statement:genericfor"
  }, {
    "id": 225,
    "text": "paths[i] = dir.path(prefix, v)",
    "type": "statement:assign"
  }, {
    "id": 226,
    "text": "paths = { dir.path(prefix, dirdata.subdir) }",
    "type": "statement:assign"
  }, {
    "id": 227,
    "text": "dirdata.dir = paths[1]",
    "type": "statement:assign"
  }, {
    "id": 228,
    "text": "local file = files[dirdata.testfile]",
    "type": "statement:localassign"
  }, {
    "id": 229,
    "text": "if file then\r\n                  local files = {}\r\n                  if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end\r\n                  local found = false\r\n                  failed_file = nil\r\n                  for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end\r\n                  if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end\r\n               end",
    "type": "statement:if"
  }, {
    "id": 230,
    "text": "local files = {}",
    "type": "statement:localassign"
  }, {
    "id": 231,
    "text": "if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end",
    "type": "statement:if"
  }, {
    "id": 232,
    "text": "add_all_patterns(file, dirdata.pattern, files)",
    "type": "statement:functioncall"
  }, {
    "id": 233,
    "text": "for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end",
    "type": "statement:genericfor"
  }, {
    "id": 234,
    "text": "local matched = deconstruct_pattern(file, pattern)",
    "type": "statement:localassign"
  }, {
    "id": 235,
    "text": "if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 236,
    "text": "add_all_patterns(matched, dirdata.pattern, files)",
    "type": "statement:functioncall"
  }, {
    "id": 237,
    "text": "table.insert(files, file)",
    "type": "statement:functioncall"
  }, {
    "id": 238,
    "text": "local found = false",
    "type": "statement:localassign"
  }, {
    "id": 239,
    "text": "failed_file = nil",
    "type": "statement:assign"
  }, {
    "id": 240,
    "text": "for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end",
    "type": "statement:genericfor"
  }, {
    "id": 241,
    "text": "if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end",
    "type": "statement:if"
  }, {
    "id": 242,
    "text": "f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)",
    "type": "statement:assign"
  }, {
    "id": 243,
    "text": "for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end",
    "type": "statement:genericfor"
  }, {
    "id": 244,
    "text": "if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 245,
    "text": "local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")",
    "type": "statement:localassign"
  }, {
    "id": 246,
    "text": "for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end",
    "type": "statement:genericfor"
  }, {
    "id": 247,
    "text": "if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end",
    "type": "statement:if"
  }, {
    "id": 248,
    "text": "found = true",
    "type": "statement:assign"
  }, {
    "id": 249,
    "text": "found = fs.is_file(dir.path(d, f))",
    "type": "statement:assign"
  }, {
    "id": 250,
    "text": "if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 251,
    "text": "dirdata.dir = d",
    "type": "statement:assign"
  }, {
    "id": 252,
    "text": "if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end",
    "type": "statement:if"
  }, {
    "id": 253,
    "text": "if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 254,
    "text": "failed_file = failed_file .. \", or \" .. f",
    "type": "statement:assign"
  }, {
    "id": 255,
    "text": "failed_file = f",
    "type": "statement:assign"
  }, {
    "id": 256,
    "text": "if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end",
    "type": "statement:if"
  }, {
    "id": 257,
    "text": "ok = false",
    "type": "statement:assign"
  }, {
    "id": 258,
    "text": "failed_dirname = dirname",
    "type": "statement:assign"
  }, {
    "id": 259,
    "text": "if ok then\r\n               for dirname, dirdata in pairs(dirs) do\r\n                  vars[name..\"_\"..dirname] = dirdata.dir\r\n               end\r\n               vars[name..\"_DIR\"] = prefix\r\n               break\r\n            end",
    "type": "statement:if"
  }, {
    "id": 260,
    "text": "for dirname, dirdata in pairs(dirs) do\r\n                  vars[name..\"_\"..dirname] = dirdata.dir\r\n               end",
    "type": "statement:genericfor"
  }, {
    "id": 261,
    "text": "vars[name..\"_\"..dirname] = dirdata.dir",
    "type": "statement:assign"
  }, {
    "id": 262,
    "text": "vars[name..\"_DIR\"] = prefix",
    "type": "statement:assign"
  }, {
    "id": 263,
    "text": "if not ok then\r\n            return nil, \"Could not find expected file \"..failed_file..\" for \"..name..\" -- you may have to install \"..name..\" in your system and/or pass \"..name..\"_DIR or \"..name..\"_\"..failed_dirname..\" to the luarocks command. Example: luarocks install \"..rockspec.name..\" \"..name..\"_DIR=/usr/local\", \"dependency\"\r\n         end",
    "type": "statement:if"
  }, {
    "id": 264,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 265,
    "text": "function scan_deps(results, missing, manifest, name, version, deps_mode)\r\n   assert(type(results) == \"table\")\r\n   assert(type(missing) == \"table\")\r\n   assert(type(manifest) == \"table\")\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local fetch = require(\"luarocks.fetch\")\r\n\r\n   local err\r\n   if results[name] then\r\n      return results, missing\r\n   end\r\n   if not manifest.dependencies then manifest.dependencies = {} end\r\n   local dependencies = manifest.dependencies\r\n   if not dependencies[name] then dependencies[name] = {} end\r\n   local dependencies_name = dependencies[name]\r\n   local deplist = dependencies_name[version]\r\n   local rockspec, err\r\n   if not deplist then\r\n      rockspec, err = fetch.load_local_rockspec(path.rockspec_file(name, version), false)\r\n      if err then\r\n         missing[name..\" \"..version] = err\r\n         return results, missing\r\n      end\r\n      dependencies_name[version] = rockspec.dependencies\r\n   else\r\n      rockspec = { dependencies = deplist }\r\n   end\r\n   local matched, failures = match_deps(rockspec, nil, deps_mode)\r\n   results[name] = results\r\n   for _, match in pairs(matched) do\r\n      results, missing = scan_deps(results, missing, manifest, match.name, match.version, deps_mode)\r\n   end\r\n   if next(failures) then\r\n      for _, failure in pairs(failures) do\r\n         missing[show_dep(failure)] = \"failed\"\r\n      end\r\n   end\r\n   results[name] = version\r\n   return results, missing\r\nend",
    "type": "function"
  }, {
    "id": 266,
    "text": "assert(type(results) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 267,
    "text": "assert(type(missing) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 268,
    "text": "assert(type(manifest) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 269,
    "text": "assert(type(name) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 270,
    "text": "assert(type(version) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 271,
    "text": "local fetch = require(\"luarocks.fetch\")",
    "type": "statement:localassign"
  }, {
    "id": 272,
    "text": "local err",
    "type": "statement:localassign"
  }, {
    "id": 273,
    "text": "if results[name] then\r\n      return results, missing\r\n   end",
    "type": "statement:if"
  }, {
    "id": 274,
    "text": "if not manifest.dependencies then manifest.dependencies = {} end",
    "type": "statement:if"
  }, {
    "id": 275,
    "text": "manifest.dependencies = {}",
    "type": "statement:assign"
  }, {
    "id": 276,
    "text": "local dependencies = manifest.dependencies",
    "type": "statement:localassign"
  }, {
    "id": 277,
    "text": "if not dependencies[name] then dependencies[name] = {} end",
    "type": "statement:if"
  }, {
    "id": 278,
    "text": "dependencies[name] = {}",
    "type": "statement:assign"
  }, {
    "id": 279,
    "text": "local dependencies_name = dependencies[name]",
    "type": "statement:localassign"
  }, {
    "id": 280,
    "text": "local deplist = dependencies_name[version]",
    "type": "statement:localassign"
  }, {
    "id": 281,
    "text": "local rockspec, err",
    "type": "statement:localassign"
  }, {
    "id": 282,
    "text": "if not deplist then\r\n      rockspec, err = fetch.load_local_rockspec(path.rockspec_file(name, version), false)\r\n      if err then\r\n         missing[name..\" \"..version] = err\r\n         return results, missing\r\n      end\r\n      dependencies_name[version] = rockspec.dependencies\r\n   else\r\n      rockspec = { dependencies = deplist }\r\n   end",
    "type": "statement:if"
  }, {
    "id": 283,
    "text": "rockspec, err = fetch.load_local_rockspec(path.rockspec_file(name, version), false)",
    "type": "statement:assign"
  }, {
    "id": 284,
    "text": "if err then\r\n         missing[name..\" \"..version] = err\r\n         return results, missing\r\n      end",
    "type": "statement:if"
  }, {
    "id": 285,
    "text": "missing[name..\" \"..version] = err",
    "type": "statement:assign"
  }, {
    "id": 286,
    "text": "dependencies_name[version] = rockspec.dependencies",
    "type": "statement:assign"
  }, {
    "id": 287,
    "text": "rockspec = { dependencies = deplist }",
    "type": "statement:assign"
  }, {
    "id": 288,
    "text": "local matched, failures = match_deps(rockspec, nil, deps_mode)",
    "type": "statement:localassign"
  }, {
    "id": 289,
    "text": "results[name] = results",
    "type": "statement:assign"
  }, {
    "id": 290,
    "text": "for _, match in pairs(matched) do\r\n      results, missing = scan_deps(results, missing, manifest, match.name, match.version, deps_mode)\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 291,
    "text": "results, missing = scan_deps(results, missing, manifest, match.name, match.version, deps_mode)",
    "type": "statement:assign"
  }, {
    "id": 292,
    "text": "if next(failures) then\r\n      for _, failure in pairs(failures) do\r\n         missing[show_dep(failure)] = \"failed\"\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 293,
    "text": "for _, failure in pairs(failures) do\r\n         missing[show_dep(failure)] = \"failed\"\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 294,
    "text": "missing[show_dep(failure)] = \"failed\"",
    "type": "statement:assign"
  }, {
    "id": 295,
    "text": "results[name] = version",
    "type": "statement:assign"
  }, {
    "id": 296,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 297,
    "text": "function check_deps_mode_flag(flag)\r\n   return valid_deps_modes[flag]\r\nend",
    "type": "function"
  }, {
    "id": 298,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 299,
    "text": "function get_deps_mode(flags)\r\n   if flags[\"deps-mode\"] then\r\n      return flags[\"deps-mode\"]\r\n   else\r\n      return cfg.deps_mode\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 300,
    "text": "if flags[\"deps-mode\"] then\r\n      return flags[\"deps-mode\"]\r\n   else\r\n      return cfg.deps_mode\r\n   end",
    "type": "statement:if"
  }, {
    "id": 301,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 302,
    "text": "function deps_mode_to_flag(deps_mode)\r\n   return \"--deps-mode=\"..deps_mode\r\nend",
    "type": "function"
  }, {
    "id": 303,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 304,
    "text": "function(v1, v2)\r\n      if #v1 ~= #v2 then\r\n         return false\r\n      end\r\n      for i = 1, #v1 do\r\n         if v1[i] ~= v2[i] then\r\n            return false\r\n         end\r\n      end\r\n      if v1.revision and v2.revision then\r\n         return (v1.revision == v2.revision)\r\n      end\r\n      return true\r\n   end",
    "type": "function"
  }, {
    "id": 305,
    "text": "if #v1 ~= #v2 then\r\n         return false\r\n      end",
    "type": "statement:if"
  }, {
    "id": 306,
    "text": "for i = 1, #v1 do\r\n         if v1[i] ~= v2[i] then\r\n            return false\r\n         end\r\n      end",
    "type": "statement:numericfor"
  }, {
    "id": 307,
    "text": "if v1[i] ~= v2[i] then\r\n            return false\r\n         end",
    "type": "statement:if"
  }, {
    "id": 308,
    "text": "if v1.revision and v2.revision then\r\n         return (v1.revision == v2.revision)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 309,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 310,
    "text": "function(v1, v2)\r\n      for i = 1, math.max(#v1, #v2) do\r\n         local v1i, v2i = v1[i] or 0, v2[i] or 0\r\n         if v1i ~= v2i then\r\n            return (v1i < v2i)\r\n         end\r\n      end\r\n      if v1.revision and v2.revision then\r\n         return (v1.revision < v2.revision)\r\n      end\r\n      return false\r\n   end",
    "type": "function"
  }, {
    "id": 311,
    "text": "for i = 1, math.max(#v1, #v2) do\r\n         local v1i, v2i = v1[i] or 0, v2[i] or 0\r\n         if v1i ~= v2i then\r\n            return (v1i < v2i)\r\n         end\r\n      end",
    "type": "statement:numericfor"
  }, {
    "id": 312,
    "text": "local v1i, v2i = v1[i] or 0, v2[i] or 0",
    "type": "statement:localassign"
  }, {
    "id": 313,
    "text": "if v1i ~= v2i then\r\n            return (v1i < v2i)\r\n         end",
    "type": "statement:if"
  }, {
    "id": 314,
    "text": "if v1.revision and v2.revision then\r\n         return (v1.revision < v2.revision)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 315,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 316,
    "text": "",
    "type": "function container"
  }, {
    "id": 317,
    "text": "function path(...)\r\n   local t = {...}\r\n   while t[1] == \"\" do\r\n      table.remove(t, 1)\r\n   end\r\n   return (table.concat(t, \"/\"):gsub(\"([^:])/+\", \"%1/\"):gsub(\"^/+\", \"/\"):gsub(\"/*$\", \"\"))\r\nend",
    "type": "function"
  }, {
    "id": 318,
    "text": "function load_local_rockspec(filename, quick)\r\n   assert(type(filename) == \"string\")\r\n   filename = fs.absolute_name(filename)\r\n   local rockspec, err = persist.load_into_table(filename)\r\n   if not rockspec then\r\n      return nil, \"Could not load rockspec file \"..filename..\" (\"..err..\")\"\r\n   end\r\n\r\n   local ok, err = true, nil\r\n   if not quick then\r\n      ok, err = type_check.type_check_rockspec(rockspec)\r\n      if not ok then\r\n         return nil, filename..\": \"..err\r\n      end\r\n   end\r\n   \r\n   if rockspec.rockspec_format then\r\n      if deps.compare_versions(rockspec.rockspec_format, type_check.rockspec_format) then\r\n         return nil, \"Rockspec format \"..rockspec.rockspec_format..\" is not supported, please upgrade LuaRocks.\"\r\n      end\r\n   end\r\n\r\n   util.platform_overrides(rockspec.build)\r\n   util.platform_overrides(rockspec.dependencies)\r\n   util.platform_overrides(rockspec.external_dependencies)\r\n   util.platform_overrides(rockspec.source)\r\n   util.platform_overrides(rockspec.hooks)\r\n\r\n   local basename = dir.base_name(filename)\r\n   if basename == \"rockspec\" then\r\n      rockspec.name = rockspec.package:lower()\r\n   else\r\n      rockspec.name = basename:match(\"(.*)-[^-]*-[0-9]*\")\r\n      if not rockspec.name then\r\n         return nil, \"Expected filename in format 'name-version-revision.rockspec'.\"\r\n      end\r\n   end\r\n\r\n   local protocol, pathname = dir.split_url(rockspec.source.url)\r\n   if is_basic_protocol(protocol) then\r\n      rockspec.source.file = rockspec.source.file or dir.base_name(rockspec.source.url)\r\n   end\r\n   rockspec.source.protocol, rockspec.source.pathname = protocol, pathname\r\n\r\n   -- Temporary compatibility\r\n   if rockspec.source.cvs_module then rockspec.source.module = rockspec.source.cvs_module end\r\n   if rockspec.source.cvs_tag then rockspec.source.tag = rockspec.source.cvs_tag end\r\n\r\n   local name_version = rockspec.package:lower() .. \"-\" .. rockspec.version\r\n   if basename ~= \"rockspec\" and basename ~= name_version .. \".rockspec\" then\r\n      return nil, \"Inconsistency between rockspec filename (\"..basename..\") and its contents (\"..name_version..\".rockspec).\"\r\n   end\r\n\r\n   rockspec.local_filename = filename\r\n   local filebase = rockspec.source.file or rockspec.source.url\r\n   local base = url_to_base_dir(filebase)\r\n   rockspec.source.dir = rockspec.source.dir\r\n                      or rockspec.source.module\r\n                      or ((filebase:match(\".lua$\") or filebase:match(\".c$\")) and \".\")\r\n                      or base\r\n   if rockspec.dependencies then\r\n      for i = 1, #rockspec.dependencies do\r\n         local parsed, err = deps.parse_dep(rockspec.dependencies[i])\r\n         if not parsed then\r\n            return nil, \"Parse error processing dependency '\"..rockspec.dependencies[i]..\"': \"..tostring(err)\r\n         end\r\n         rockspec.dependencies[i] = parsed\r\n      end\r\n   else\r\n      rockspec.dependencies = {}\r\n   end\r\n   if not quick then\r\n      path.configure_paths(rockspec)\r\n   end\r\n\r\n   return rockspec\r\nend",
    "type": "function"
  }, {
    "id": 319,
    "text": "function list_dir(at)\r\n   assert(type(at) == \"string\" or not at)\r\n   if not at then\r\n      at = fs.current_dir()\r\n   end\r\n   at = dir.normalize(at)\r\n   if not fs.is_dir(at) then\r\n      return {}\r\n   end\r\n   local result = {}\r\n   for file in lfs.dir(at) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         table.insert(result, file)\r\n      end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 320,
    "text": "function is_file(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   return lfs.attributes(file, \"mode\") == \"file\"\r\nend",
    "type": "function"
  }, {
    "id": 321,
    "text": "function install_binary_rock(rock_file, deps_mode)\r\n   assert(type(rock_file) == \"string\")\r\n\r\n   local name, version, arch = path.parse_name(rock_file)\r\n   if not name then\r\n      return nil, \"Filename \"..rock_file..\" does not match format 'name-version-revision.arch.rock'.\"\r\n   end\r\n   \r\n   if arch ~= \"all\" and arch ~= cfg.arch then\r\n      return nil, \"Incompatible architecture \"..arch, \"arch\"\r\n   end\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n   \r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n   \r\n   local ok, err, errcode = fetch.fetch_and_unpack_rock(rock_file, path.install_dir(name, version))\r\n   if not ok then return nil, err, errcode end\r\n   \r\n   local rockspec, err, errcode = fetch.load_rockspec(path.rockspec_file(name, version))\r\n   if err then\r\n      return nil, \"Failed loading rockspec for installed package: \"..err, errcode\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      ok, err, errcode = deps.check_external_deps(rockspec, \"install\")\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   -- For compatibility with .rock files built with LuaRocks 1\r\n   if not fs.exists(path.rock_manifest_file(name, version)) then\r\n      ok, err = manif.make_rock_manifest(name, version)\r\n      if err then return nil, err end\r\n   end\r\n\r\n   if deps_mode ~= \"none\" then\r\n      ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   local wrap_bin_scripts = true\r\n   if rockspec.deploy and rockspec.deploy.wrap_bin_scripts == false then\r\n      wrap_bin_scripts = false\r\n   end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n\r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n   \r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n   \r\n   local license = \"\"\r\n   if rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 322,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"install\")\r\n   end\r\n\r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n\r\n   if name:match(\"%.rockspec$\") or name:match(\"%.src%.rock$\") then\r\n      util.printout(\"Using \"..name..\"... switching to 'build' mode\")\r\n      local build = require(\"luarocks.build\")\r\n      return build.run(name, util.forward_flags(flags, \"local\", \"keep\", \"deps-mode\"))\r\n   elseif name:match(\"%.rock$\") then\r\n      ok, err = install_binary_rock(name, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   else\r\n      local search = require(\"luarocks.search\")\r\n      local results, err = search.find_suitable_rock(search.make_query(name:lower(), version))\r\n      if err then\r\n         return nil, err\r\n      elseif type(results) == \"string\" then\r\n         local url = results\r\n         util.printout(\"Installing \"..url..\"...\")\r\n         return run(url, util.forward_flags(flags))\r\n      else\r\n         util.printout()\r\n         util.printerr(\"Could not determine which rock to install.\")\r\n         util.title(\"Search results:\")\r\n         search.print_results(results)\r\n         return nil, (next(results) and \"Please narrow your query.\" or \"No results found.\")\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 323,
    "text": "function add_context(name, version)\r\n   -- assert(type(name) == \"string\")\r\n   -- assert(type(version) == \"string\")\r\n\r\n   if context[name] then\r\n      return\r\n   end\r\n   context[name] = version\r\n\r\n   if not rocks_trees and not load_rocks_trees() then\r\n      return nil\r\n   end\r\n\r\n   local providers = {}\r\n   for _, tree in ipairs(rocks_trees) do\r\n      local manifest = tree.manifest\r\n\r\n      local pkgdeps\r\n      if manifest.dependencies and manifest.dependencies[name] then\r\n         pkgdeps = manifest.dependencies[name][version]\r\n      end\r\n      if not pkgdeps then\r\n         return nil\r\n      end\r\n      for _, dep in ipairs(pkgdeps) do\r\n         local pkg, constraints = dep.name, dep.constraints\r\n   \r\n         for _, tree in ipairs(rocks_trees) do\r\n            local entries = tree.manifest.repository[pkg]\r\n            if entries then\r\n               for version, pkgs in pairs(entries) do\r\n                  if (not constraints) or deps.match_constraints(deps.parse_version(version), constraints) then\r\n                     add_context(pkg, version)\r\n                  end\r\n               end\r\n            end\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 324,
    "text": "local function select_module(module, filter_module_name)\r\n   --assert(type(module) == \"string\")\r\n   --assert(type(filter_module_name) == \"function\")\r\n\r\n   if not rocks_trees and not load_rocks_trees() then\r\n      return nil\r\n   end\r\n\r\n   local providers = {}\r\n   for _, tree in ipairs(rocks_trees) do\r\n      local entries = tree.manifest.modules[module]\r\n      if entries then\r\n         for i, entry in ipairs(entries) do\r\n            local name, version = entry:match(\"^([^/]*)/(.*)$\")\r\n            local module_name = tree.manifest.repository[name][version][1].modules[module]\r\n            if type(module_name) ~= \"string\" then\r\n               error(\"Invalid data in manifest file for module \"..tostring(module)..\" (invalid data for \"..tostring(name)..\" \"..tostring(version)..\")\")\r\n            end\r\n            module_name = filter_module_name(module_name, name, version, tree.tree, i)\r\n            if context[name] == version then\r\n               return name, version, module_name\r\n            end\r\n            version = deps.parse_version(version)\r\n            table.insert(providers, {name = name, version = version, module_name = module_name})\r\n         end\r\n      end\r\n   end\r\n\r\n   if next(providers) then\r\n      table.sort(providers, sort_versions)\r\n      local first = providers[1]\r\n      return first.name, first.version.string, first.module_name\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 325,
    "text": "function run(...)\r\n   local flags, rockspec = util.parse_flags(...)\r\n   assert(type(rockspec) == \"string\" or not rockspec)\r\n   \r\n   if not rockspec then\r\n      local files = fs.list_dir(fs.current_dir())\r\n      for _, file in pairs(files) do\r\n         if file:match(\"rockspec$\") then\r\n            if rockspec then\r\n               return nil, \"Please specify which rockspec file to use.\"\r\n            else\r\n               rockspec = file\r\n            end\r\n         end\r\n      end\r\n      if not rockspec then\r\n         return nil, \"Argument missing: please specify a rockspec to use on current directory.\"\r\n      end\r\n   end\r\n   if not rockspec:match(\"rockspec$\") then\r\n      return nil, \"Invalid argument: 'make' takes a rockspec as a parameter. \"..util.see_help(\"make\")\r\n   end\r\n\r\n   if flags[\"pack-binary-rock\"] then\r\n      local rspec, err, errcode = fetch.load_rockspec(rockspec)\r\n      if not rspec then\r\n         return nil, err\r\n      end\r\n      return pack.pack_binary_rock(rspec.name, rspec.version, build.build_rockspec, rockspec, false, true, deps.get_deps_mode(flags))\r\n   else\r\n      local ok, err = fs.check_command_permissions(flags)\r\n      if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n      ok, err = build.build_rockspec(rockspec, false, true, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 326,
    "text": "function run(...)\r\n   local flags, repo = util.parse_flags(...)\r\n\r\n   assert(type(repo) == \"string\" or not repo)\r\n   repo = repo or cfg.rocks_dir\r\n  \r\n   util.printout(\"Making manifest for \"..repo)\r\n   \r\n   if repo:match(\"/lib/luarocks\") and not flags[\"local-tree\"] then\r\n      util.warning(\"This looks like a local rocks tree, but you did not pass --local-tree.\")\r\n   end\r\n   \r\n   local ok, err = manif.make_manifest(repo, deps.get_deps_mode(flags), not flags[\"local-tree\"])\r\n   if ok and not flags[\"local-tree\"] then\r\n      util.printout(\"Generating index.html for \"..repo)\r\n      index.make_index(repo)\r\n   end\r\n   if flags[\"local-tree\"] then\r\n      for luaver in util.lua_versions() do\r\n         fs.delete(dir.path(repo, \"manifest-\"..luaver))\r\n      end\r\n   end\r\n   return ok, err\r\nend",
    "type": "function"
  }, {
    "id": 327,
    "text": "local function sort_pkgs(a, b)\r\n   assert(type(a) == \"string\")\r\n   assert(type(b) == \"string\")\r\n\r\n   local na, va = a:match(\"(.*)/(.*)$\")\r\n   local nb, vb = b:match(\"(.*)/(.*)$\")\r\n\r\n   return (na == nb) and deps.compare_versions(va, vb) or na < nb\r\nend",
    "type": "function"
  }, {
    "id": 328,
    "text": "local function update_dependencies(manifest, deps_mode)\r\n   assert(type(manifest) == \"table\")\r\n   assert(type(deps_mode) == \"string\")\r\n   \r\n   for pkg, versions in pairs(manifest.repository) do\r\n      for version, repositories in pairs(versions) do\r\n         local current = pkg..\" \"..version\r\n         for _, repo in ipairs(repositories) do\r\n            if repo.arch == \"installed\" then\r\n               local missing\r\n               repo.dependencies, missing = deps.scan_deps({}, {}, manifest, pkg, version, deps_mode)\r\n               repo.dependencies[pkg] = nil\r\n               if missing then\r\n                  for miss, err in pairs(missing) do\r\n                     if miss == current then\r\n                        util.printerr(\"Tree inconsistency detected: \"..current..\" has no rockspec. \"..err)\r\n                     else\r\n                        util.printerr(\"Missing dependency for \"..pkg..\" \"..version..\": \"..miss)\r\n                     end\r\n                  end\r\n               end\r\n            end\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 329,
    "text": "local function filter_by_lua_version(manifest, lua_version, repodir, cache)\r\n   assert(type(manifest) == \"table\")\r\n   assert(type(repodir) == \"string\")\r\n   assert((not cache) or type(cache) == \"table\")\r\n   \r\n   cache = cache or {}\r\n   lua_version = deps.parse_version(lua_version)\r\n   for pkg, versions in pairs(manifest.repository) do\r\n      local to_remove = {}\r\n      for version, repositories in pairs(versions) do\r\n         for _, repo in ipairs(repositories) do\r\n            if repo.arch == \"rockspec\" then\r\n               local pathname = dir.path(repodir, pkg..\"-\"..version..\".rockspec\")\r\n               local rockspec, err = cache[pathname]\r\n               if not rockspec then\r\n                  rockspec, err = fetch.load_local_rockspec(pathname, true)\r\n               end\r\n               if rockspec then\r\n                  cache[pathname] = rockspec\r\n                  for _, dep in ipairs(rockspec.dependencies) do\r\n                     if dep.name == \"lua\" then \r\n                        if not deps.match_constraints(lua_version, dep.constraints) then\r\n                           table.insert(to_remove, version)\r\n                        end\r\n                        break\r\n                     end\r\n                  end\r\n               else\r\n                  util.printerr(\"Error loading rockspec for \"..pkg..\" \"..version..\": \"..err)\r\n               end\r\n            end\r\n         end\r\n      end\r\n      if next(to_remove) then\r\n         for _, incompat in ipairs(to_remove) do\r\n            versions[incompat] = nil\r\n         end\r\n         if not next(versions) then\r\n            manifest.repository[pkg] = nil\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 330,
    "text": "function get_versions(name, deps_mode)\r\n   assert(type(name) == \"string\")\r\n   assert(type(deps_mode) == \"string\")\r\n   \r\n   local manifest = {}\r\n   path.map_trees(deps_mode, function(tree)\r\n      local loaded = load_local_manifest(path.rocks_dir(tree))\r\n      if loaded then\r\n         util.deep_merge(manifest, loaded)\r\n      end\r\n   end)\r\n   \r\n   local item = next(manifest) and manifest.repository[name]\r\n   if item then\r\n      return util.keys(item)\r\n   end\r\n   return {}\r\nend",
    "type": "function"
  }, {
    "id": 331,
    "text": "function rockspec_file(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, name..\"-\"..version..\".rockspec\")\r\nend",
    "type": "function"
  }, {
    "id": 332,
    "text": "function run(...)\r\n   local flags = util.parse_flags(...)\r\n   local deps_mode = deps.get_deps_mode(flags)\r\n   \r\n   local lr_path, lr_cpath = cfg.package_paths()\r\n   local bin_dirs = map_trees(deps_mode, deploy_bin_dir)\r\n\r\n   if flags[\"lr-path\"] then\r\n      util.printout(util.remove_path_dupes(lr_path, ';'))\r\n      return true\r\n   elseif flags[\"lr-cpath\"] then\r\n      util.printout(util.remove_path_dupes(lr_cpath, ';'))\r\n      return true\r\n   elseif flags[\"lr-bin\"] then\r\n      local lr_bin = util.remove_path_dupes(table.concat(bin_dirs, cfg.export_path_separator), cfg.export_path_separator)\r\n      util.printout(util.remove_path_dupes(lr_bin, ';'))\r\n      return true\r\n   end\r\n   \r\n   if flags[\"append\"] then\r\n      lr_path = package.path .. \";\" .. lr_path\r\n      lr_cpath = package.cpath .. \";\" .. lr_cpath\r\n   else\r\n      lr_path =  lr_path.. \";\" .. package.path\r\n      lr_cpath = lr_cpath .. \";\" .. package.cpath\r\n   end\r\n\r\n   util.printout(cfg.export_lua_path:format(util.remove_path_dupes(lr_path, ';')))\r\n   util.printout(cfg.export_lua_cpath:format(util.remove_path_dupes(lr_cpath, ';')))\r\n   if flags[\"bin\"] then\r\n      table.insert(bin_dirs, 1, os.getenv(\"PATH\"))\r\n      local lr_bin = util.remove_path_dupes(table.concat(bin_dirs, cfg.export_path_separator), cfg.export_path_separator)\r\n      util.printout(cfg.export_path:format(lr_bin))\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 333,
    "text": "function run(...)\r\n   local flags = util.parse_flags(...)\r\n   \r\n   local tree = flags[\"tree\"]\r\n\r\n   if type(tree) ~= \"string\" then\r\n      return nil, \"The --tree argument is mandatory. \"..util.see_help(\"purge\")\r\n   end\r\n   \r\n   local results = {}\r\n   local query = search.make_query(\"\")\r\n   query.exact_name = false\r\n   if not fs.is_dir(tree) then\r\n      return nil, \"Directory not found: \"..tree\r\n   end\r\n\r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n\r\n   search.manifest_search(results, path.rocks_dir(tree), query)\r\n\r\n   local sort = function(a,b) return deps.compare_versions(b,a) end\r\n   if flags[\"old-versions\"] then\r\n      sort = deps.compare_versions\r\n   end\r\n\r\n   for package, versions in util.sortedpairs(results) do\r\n      for version, repositories in util.sortedpairs(versions, sort) do\r\n         if flags[\"old-versions\"] then\r\n            util.printout(\"Keeping \"..package..\" \"..version..\"...\")\r\n            local ok, err = remove.remove_other_versions(package, version, flags[\"force\"])\r\n            if not ok then\r\n               util.printerr(err)\r\n            end\r\n            break\r\n         else\r\n            util.printout(\"Removing \"..package..\" \"..version..\"...\")\r\n            local ok, err = repos.delete_version(package, version, true)\r\n            if not ok then\r\n               util.printerr(err)\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return manif.make_manifest(cfg.rocks_dir, \"one\")\r\nend",
    "type": "function"
  }, {
    "id": 334,
    "text": "local function check_dependents(name, versions, deps_mode)\r\n   local dependents = {}\r\n   local blacklist = {}\r\n   blacklist[name] = {}\r\n   for version, _ in pairs(versions) do\r\n      blacklist[name][version] = true\r\n   end\r\n   local local_rocks = {}\r\n   local query_all = search.make_query(\"\")\r\n   query_all.exact_name = false\r\n   search.manifest_search(local_rocks, cfg.rocks_dir, query_all)\r\n   local_rocks[name] = nil\r\n   for rock_name, rock_versions in pairs(local_rocks) do\r\n      for rock_version, _ in pairs(rock_versions) do\r\n         local rockspec, err = fetch.load_rockspec(path.rockspec_file(rock_name, rock_version))\r\n         if rockspec then\r\n            local _, missing = deps.match_deps(rockspec, blacklist, deps_mode)\r\n            if missing[name] then\r\n               table.insert(dependents, { name = rock_name, version = rock_version })\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return dependents\r\nend",
    "type": "function"
  }, {
    "id": 335,
    "text": "local function resolve_conflict(target, deploy_dir, name, version)\r\n   local cname, cversion = manif.find_current_provider(target)\r\n   if not cname then\r\n      return nil, cversion\r\n   end\r\n   if name ~= cname or deps.compare_versions(version, cversion) then\r\n      local versioned = path.versioned_name(target, deploy_dir, cname, cversion)\r\n      local ok, err = fs.make_dir(dir.dir_name(versioned))\r\n      if not ok then return nil, err end\r\n      fs.move(target, versioned)\r\n      return target\r\n   else\r\n      return path.versioned_name(target, deploy_dir, name, version)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 336,
    "text": "local function store_if_match(results, repo, name, version, arch, query)\r\n   if match_name(query, name) then\r\n      if query.arch[arch] or query.arch[\"any\"] then\r\n         if deps.match_constraints(deps.parse_version(version), query.constraints) then\r\n            store_result(results, name, version, arch, repo)\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 337,
    "text": "function make_query(name, version)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\" or not version)\r\n   \r\n   local query = {\r\n      name = name,\r\n      constraints = {}\r\n   }\r\n   if version then\r\n      table.insert(query.constraints, { op = \"==\", version = deps.parse_version(version)})\r\n   end\r\n   return query\r\nend",
    "type": "function"
  }, {
    "id": 338,
    "text": "local function pick_latest_version(name, versions)\r\n   assert(type(name) == \"string\")\r\n   assert(type(versions) == \"table\")\r\n\r\n   local vtables = {}\r\n   for v, _ in pairs(versions) do\r\n      table.insert(vtables, deps.parse_version(v))\r\n   end\r\n   table.sort(vtables)\r\n   local version = vtables[#vtables].string\r\n   local items = versions[version]\r\n   if items then\r\n      local pick = 1\r\n      for i, item in ipairs(items) do\r\n         if (item.arch == 'src' and items[pick].arch == 'rockspec')\r\n         or (item.arch ~= 'src' and item.arch ~= 'rockspec') then\r\n            pick = i\r\n         end\r\n      end\r\n      return path.make_url(items[pick].repo, name, version, items[pick].arch)\r\n   end\r\n   return nil\r\nend",
    "type": "function"
  }, {
    "id": 339,
    "text": "function find_suitable_rock(query)\r\n   assert(type(query) == \"table\")\r\n   \r\n   local results = search_repos(query)\r\n   local first = next(results)\r\n   if not first then\r\n      return nil, \"No results matching query were found.\"\r\n   elseif not next(results, first) then\r\n      if cfg.rocks_provided[query.name] ~= nil then\r\n         -- do not install versions that listed in cfg.rocks_provided\r\n         return nil, \"Rock \"..query.name..\r\n                     \" \"..cfg.rocks_provided[query.name]..\r\n                     \" was found but it is provided by VM or 'rocks_provided' in the config file.\"\r\n      end\r\n      return pick_latest_version(query.name, results[first])\r\n   else\r\n      return results\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 340,
    "text": "function printerr(...)\r\n   io.stderr:write(table.concat({...},\"\\t\"))\r\n   io.stderr:write(\"\\n\")\r\nend",
    "type": "function"
  }, {
    "id": 341,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 342,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 343,
    "text": "tonumber",
    "type": "global function"
  }, {
    "id": 344,
    "text": "ipairs",
    "type": "global function"
  }, {
    "id": 345,
    "text": "module",
    "type": "global function"
  }, {
    "id": 346,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 347,
    "text": "remove",
    "type": "global function"
  }, {
    "id": 348,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 349,
    "text": "max",
    "type": "global function"
  }, {
    "id": 350,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 351,
    "text": "sort",
    "type": "global function"
  }, {
    "id": 352,
    "text": "type",
    "type": "global function"
  }, {
    "id": 353,
    "text": "next",
    "type": "global function"
  }, {
    "id": 354,
    "text": "setmetatable",
    "type": "global function"
  }, {
    "id": 355,
    "text": "require",
    "type": "global function"
  }, {
    "id": 356,
    "text": "cfg)",
    "type": "module"
  }, {
    "id": 357,
    "text": "util)",
    "type": "module"
  }, {
    "id": 358,
    "text": "fetch)",
    "type": "module"
  }, {
    "id": 359,
    "text": "dir)",
    "type": "module"
  }, {
    "id": 360,
    "text": "fs)",
    "type": "module"
  }, {
    "id": 361,
    "text": "path)",
    "type": "module"
  }, {
    "id": 362,
    "text": "search)",
    "type": "module"
  }, {
    "id": 363,
    "text": "install)",
    "type": "module"
  }, {
    "id": 364,
    "text": "",
    "type": "variable container"
  }, {
    "id": 365,
    "text": "",
    "type": "require container"
  }, {
    "id": 366,
    "text": "",
    "type": "local variable"
  }, {
    "id": 367,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 368,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 369,
    "text": "",
    "type": "string"
  }, {
    "id": 370,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 371,
    "text": "",
    "type": "string"
  }, {
    "id": 372,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 373,
    "text": "",
    "type": "string"
  }, {
    "id": 374,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 375,
    "text": "",
    "type": "string"
  }, {
    "id": 376,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 377,
    "text": "",
    "type": "string"
  }, {
    "id": 378,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 379,
    "text": "",
    "type": "string"
  }, {
    "id": 380,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 381,
    "text": "",
    "type": "string"
  }, {
    "id": 382,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 383,
    "text": "",
    "type": "string"
  }, {
    "id": 384,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 385,
    "text": "",
    "type": "string"
  }, {
    "id": 386,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 387,
    "text": "",
    "type": "string"
  }, {
    "id": 388,
    "text": "",
    "type": "local variable"
  }, {
    "id": 389,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 390,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 391,
    "text": "",
    "type": "number"
  }, {
    "id": 392,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 393,
    "text": "",
    "type": "number"
  }, {
    "id": 394,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 395,
    "text": "",
    "type": "_simpleexp"
  }, {
    "id": 396,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 397,
    "text": "",
    "type": "_simpleexp"
  }, {
    "id": 398,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 399,
    "text": "",
    "type": "_simpleexp"
  }, {
    "id": 400,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 401,
    "text": "",
    "type": "_simpleexp"
  }, {
    "id": 402,
    "text": "",
    "type": "local variable"
  }, {
    "id": 403,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 404,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 405,
    "text": "",
    "type": "function"
  }, {
    "id": 406,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 407,
    "text": "",
    "type": "function"
  }, {
    "id": 408,
    "text": "",
    "type": "local variable"
  }, {
    "id": 409,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 410,
    "text": "",
    "type": "local variable"
  }, {
    "id": 411,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 412,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 413,
    "text": "",
    "type": "boolean"
  }, {
    "id": 414,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 415,
    "text": "",
    "type": "boolean"
  }, {
    "id": 416,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 417,
    "text": "",
    "type": "boolean"
  }, {
    "id": 418,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 419,
    "text": "",
    "type": "boolean"
  }, {
    "id": 420,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 421,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 422,
    "text": "manif_core)",
    "type": "module"
  }, {
    "id": 423,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 424,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 425,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 426,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 427,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 428,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 429,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 430,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 431,
    "text": "",
    "type": "require local variable"
  } ]
}