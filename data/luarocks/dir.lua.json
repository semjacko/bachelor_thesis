{
  "_filename": "dir.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/luarocks/src/luarocks/dir.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "calls",
    "to": 12
  }, {
    "from": 3,
    "label": "calls",
    "to": 19
  }, {
    "from": 3,
    "label": "calls",
    "to": 12
  }, {
    "from": 4,
    "label": "calls",
    "to": 19
  }, {
    "from": 4,
    "label": "calls",
    "to": 19
  }, {
    "from": 4,
    "label": "calls",
    "to": 19
  }, {
    "from": 4,
    "label": "calls",
    "to": 19
  }, {
    "from": 4,
    "label": "calls",
    "to": 19
  }, {
    "from": 4,
    "label": "calls",
    "to": 19
  }, {
    "from": 4,
    "label": "calls",
    "to": 19
  }, {
    "from": 4,
    "label": "calls",
    "to": 19
  }, {
    "from": 4,
    "label": "calls",
    "to": 19
  }, {
    "from": 4,
    "label": "calls",
    "to": 12
  }, {
    "from": 4,
    "label": "calls",
    "to": 12
  }, {
    "from": 4,
    "label": "calls",
    "to": 17
  }, {
    "from": 5,
    "label": "calls",
    "to": 12
  }, {
    "from": 5,
    "label": "calls",
    "to": 12
  }, {
    "from": 5,
    "label": "calls",
    "to": 19
  }, {
    "from": 5,
    "label": "calls",
    "to": 19
  }, {
    "from": 5,
    "label": "calls",
    "to": 19
  }, {
    "from": 5,
    "label": "calls",
    "to": 19
  }, {
    "from": 6,
    "label": "calls",
    "to": 19
  }, {
    "from": 7,
    "label": "calls",
    "to": 19
  }, {
    "from": 5,
    "label": "calls",
    "to": 17
  }, {
    "from": 8,
    "label": "calls",
    "to": 24
  }, {
    "from": 10,
    "label": "calls",
    "to": 24
  }, {
    "from": 9,
    "label": "calls",
    "to": 31
  }, {
    "from": 11,
    "label": "calls",
    "to": 19
  }, {
    "from": 11,
    "label": "calls",
    "to": 19
  }, {
    "from": 11,
    "label": "calls",
    "to": 19
  }, {
    "from": 12,
    "label": "has",
    "to": 13
  }, {
    "from": 12,
    "label": "has",
    "to": 14
  }, {
    "from": 12,
    "label": "has",
    "to": 15
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 17,
    "label": "has",
    "to": 13
  }, {
    "from": 17,
    "label": "has",
    "to": 15
  }, {
    "from": 17,
    "label": "has",
    "to": 18
  }, {
    "from": 19,
    "label": "has",
    "to": 20
  }, {
    "from": 19,
    "label": "has",
    "to": 21
  }, {
    "from": 21,
    "label": "has",
    "to": 22
  }, {
    "from": 19,
    "label": "has",
    "to": 15
  }, {
    "from": 19,
    "label": "has",
    "to": 23
  }, {
    "from": 24,
    "label": "has",
    "to": 25
  }, {
    "from": 24,
    "label": "has",
    "to": 26
  }, {
    "from": 24,
    "label": "has",
    "to": 27
  }, {
    "from": 27,
    "label": "has",
    "to": 28
  }, {
    "from": 27,
    "label": "has",
    "to": 29
  }, {
    "from": 24,
    "label": "has",
    "to": 15
  }, {
    "from": 24,
    "label": "has",
    "to": 30
  }, {
    "from": 31,
    "label": "has",
    "to": 32
  }, {
    "from": 31,
    "label": "has",
    "to": 33
  }, {
    "from": 31,
    "label": "has",
    "to": 34
  }, {
    "from": 34,
    "label": "has",
    "to": 35
  }, {
    "from": 31,
    "label": "has",
    "to": 15
  }, {
    "from": 31,
    "label": "has",
    "to": 36
  }, {
    "from": 19,
    "label": "calls",
    "to": 135
  }, {
    "from": 37,
    "label": "calls",
    "to": 133
  }, {
    "from": 12,
    "label": "calls",
    "to": 132
  }, {
    "from": 17,
    "label": "calls",
    "to": 132
  }, {
    "from": 24,
    "label": "calls",
    "to": 132
  }, {
    "from": 12,
    "label": "calls",
    "to": 136
  }, {
    "from": 17,
    "label": "calls",
    "to": 136
  }, {
    "from": 24,
    "label": "calls",
    "to": 136
  }, {
    "from": 19,
    "label": "calls",
    "to": 134
  }, {
    "from": 31,
    "label": "calls",
    "to": 24
  }, {
    "from": 1,
    "label": "contains",
    "to": 37
  }, {
    "from": 37,
    "label": "declares",
    "to": 12
  }, {
    "from": 37,
    "label": "declares",
    "to": 17
  }, {
    "from": 37,
    "label": "declares",
    "to": 19
  }, {
    "from": 37,
    "label": "declares",
    "to": 24
  }, {
    "from": 37,
    "label": "declares",
    "to": 31
  }, {
    "from": 38,
    "label": "calls",
    "to": 19
  }, {
    "from": 38,
    "label": "calls",
    "to": 19
  }, {
    "from": 38,
    "label": "calls",
    "to": 31
  }, {
    "from": 39,
    "label": "calls",
    "to": 24
  }, {
    "from": 40,
    "label": "calls",
    "to": 12
  }, {
    "from": 41,
    "label": "calls",
    "to": 19
  }, {
    "from": 41,
    "label": "calls",
    "to": 19
  }, {
    "from": 41,
    "label": "calls",
    "to": 12
  }, {
    "from": 42,
    "label": "calls",
    "to": 19
  }, {
    "from": 42,
    "label": "calls",
    "to": 19
  }, {
    "from": 42,
    "label": "calls",
    "to": 12
  }, {
    "from": 43,
    "label": "calls",
    "to": 12
  }, {
    "from": 44,
    "label": "calls",
    "to": 19
  }, {
    "from": 44,
    "label": "calls",
    "to": 12
  }, {
    "from": 44,
    "label": "calls",
    "to": 12
  }, {
    "from": 46,
    "label": "calls",
    "to": 17
  }, {
    "from": 46,
    "label": "calls",
    "to": 12
  }, {
    "from": 47,
    "label": "calls",
    "to": 12
  }, {
    "from": 48,
    "label": "calls",
    "to": 12
  }, {
    "from": 49,
    "label": "calls",
    "to": 12
  }, {
    "from": 49,
    "label": "calls",
    "to": 12
  }, {
    "from": 50,
    "label": "calls",
    "to": 12
  }, {
    "from": 45,
    "label": "calls",
    "to": 24
  }, {
    "from": 46,
    "label": "calls",
    "to": 24
  }, {
    "from": 49,
    "label": "calls",
    "to": 24
  }, {
    "from": 58,
    "label": "calls",
    "to": 12
  }, {
    "from": 59,
    "label": "calls",
    "to": 12
  }, {
    "from": 72,
    "label": "calls",
    "to": 12
  }, {
    "from": 51,
    "label": "calls",
    "to": 19
  }, {
    "from": 58,
    "label": "calls",
    "to": 19
  }, {
    "from": 59,
    "label": "calls",
    "to": 19
  }, {
    "from": 59,
    "label": "calls",
    "to": 19
  }, {
    "from": 60,
    "label": "calls",
    "to": 19
  }, {
    "from": 61,
    "label": "calls",
    "to": 19
  }, {
    "from": 64,
    "label": "calls",
    "to": 19
  }, {
    "from": 70,
    "label": "calls",
    "to": 19
  }, {
    "from": 70,
    "label": "calls",
    "to": 19
  }, {
    "from": 51,
    "label": "calls",
    "to": 31
  }, {
    "from": 52,
    "label": "calls",
    "to": 31
  }, {
    "from": 53,
    "label": "calls",
    "to": 31
  }, {
    "from": 54,
    "label": "calls",
    "to": 31
  }, {
    "from": 55,
    "label": "calls",
    "to": 31
  }, {
    "from": 56,
    "label": "calls",
    "to": 31
  }, {
    "from": 57,
    "label": "calls",
    "to": 31
  }, {
    "from": 58,
    "label": "calls",
    "to": 31
  }, {
    "from": 58,
    "label": "calls",
    "to": 31
  }, {
    "from": 60,
    "label": "calls",
    "to": 31
  }, {
    "from": 60,
    "label": "calls",
    "to": 31
  }, {
    "from": 62,
    "label": "calls",
    "to": 31
  }, {
    "from": 63,
    "label": "calls",
    "to": 31
  }, {
    "from": 65,
    "label": "calls",
    "to": 31
  }, {
    "from": 66,
    "label": "calls",
    "to": 31
  }, {
    "from": 67,
    "label": "calls",
    "to": 31
  }, {
    "from": 68,
    "label": "calls",
    "to": 31
  }, {
    "from": 69,
    "label": "calls",
    "to": 31
  }, {
    "from": 71,
    "label": "calls",
    "to": 24
  }, {
    "from": 57,
    "label": "calls",
    "to": 17
  }, {
    "from": 73,
    "label": "calls",
    "to": 17
  }, {
    "from": 74,
    "label": "calls",
    "to": 19
  }, {
    "from": 75,
    "label": "calls",
    "to": 17
  }, {
    "from": 74,
    "label": "calls",
    "to": 12
  }, {
    "from": 75,
    "label": "calls",
    "to": 12
  }, {
    "from": 76,
    "label": "calls",
    "to": 19
  }, {
    "from": 76,
    "label": "calls",
    "to": 12
  }, {
    "from": 77,
    "label": "calls",
    "to": 31
  }, {
    "from": 78,
    "label": "calls",
    "to": 17
  }, {
    "from": 78,
    "label": "calls",
    "to": 12
  }, {
    "from": 79,
    "label": "calls",
    "to": 19
  }, {
    "from": 81,
    "label": "calls",
    "to": 19
  }, {
    "from": 80,
    "label": "calls",
    "to": 17
  }, {
    "from": 79,
    "label": "calls",
    "to": 12
  }, {
    "from": 80,
    "label": "calls",
    "to": 12
  }, {
    "from": 81,
    "label": "calls",
    "to": 31
  }, {
    "from": 82,
    "label": "calls",
    "to": 31
  }, {
    "from": 82,
    "label": "calls",
    "to": 31
  }, {
    "from": 82,
    "label": "calls",
    "to": 31
  }, {
    "from": 82,
    "label": "calls",
    "to": 31
  }, {
    "from": 83,
    "label": "calls",
    "to": 19
  }, {
    "from": 83,
    "label": "calls",
    "to": 19
  }, {
    "from": 84,
    "label": "calls",
    "to": 19
  }, {
    "from": 85,
    "label": "calls",
    "to": 19
  }, {
    "from": 86,
    "label": "calls",
    "to": 19
  }, {
    "from": 87,
    "label": "calls",
    "to": 19
  }, {
    "from": 87,
    "label": "calls",
    "to": 19
  }, {
    "from": 87,
    "label": "calls",
    "to": 19
  }, {
    "from": 88,
    "label": "calls",
    "to": 19
  }, {
    "from": 89,
    "label": "calls",
    "to": 19
  }, {
    "from": 90,
    "label": "calls",
    "to": 19
  }, {
    "from": 88,
    "label": "calls",
    "to": 24
  }, {
    "from": 88,
    "label": "calls",
    "to": 17
  }, {
    "from": 91,
    "label": "calls",
    "to": 19
  }, {
    "from": 93,
    "label": "calls",
    "to": 19
  }, {
    "from": 93,
    "label": "calls",
    "to": 19
  }, {
    "from": 94,
    "label": "calls",
    "to": 19
  }, {
    "from": 94,
    "label": "calls",
    "to": 19
  }, {
    "from": 92,
    "label": "calls",
    "to": 12
  }, {
    "from": 92,
    "label": "calls",
    "to": 12
  }, {
    "from": 95,
    "label": "calls",
    "to": 12
  }, {
    "from": 97,
    "label": "calls",
    "to": 19
  }, {
    "from": 97,
    "label": "calls",
    "to": 19
  }, {
    "from": 98,
    "label": "calls",
    "to": 19
  }, {
    "from": 98,
    "label": "calls",
    "to": 19
  }, {
    "from": 99,
    "label": "calls",
    "to": 19
  }, {
    "from": 99,
    "label": "calls",
    "to": 19
  }, {
    "from": 100,
    "label": "calls",
    "to": 19
  }, {
    "from": 100,
    "label": "calls",
    "to": 19
  }, {
    "from": 101,
    "label": "calls",
    "to": 19
  }, {
    "from": 101,
    "label": "calls",
    "to": 19
  }, {
    "from": 101,
    "label": "calls",
    "to": 19
  }, {
    "from": 102,
    "label": "calls",
    "to": 19
  }, {
    "from": 103,
    "label": "calls",
    "to": 19
  }, {
    "from": 104,
    "label": "calls",
    "to": 19
  }, {
    "from": 105,
    "label": "calls",
    "to": 19
  }, {
    "from": 106,
    "label": "calls",
    "to": 19
  }, {
    "from": 107,
    "label": "calls",
    "to": 19
  }, {
    "from": 108,
    "label": "calls",
    "to": 19
  }, {
    "from": 109,
    "label": "calls",
    "to": 19
  }, {
    "from": 110,
    "label": "calls",
    "to": 19
  }, {
    "from": 112,
    "label": "calls",
    "to": 19
  }, {
    "from": 112,
    "label": "calls",
    "to": 19
  }, {
    "from": 113,
    "label": "calls",
    "to": 19
  }, {
    "from": 115,
    "label": "calls",
    "to": 19
  }, {
    "from": 115,
    "label": "calls",
    "to": 19
  }, {
    "from": 114,
    "label": "calls",
    "to": 31
  }, {
    "from": 114,
    "label": "calls",
    "to": 31
  }, {
    "from": 96,
    "label": "calls",
    "to": 12
  }, {
    "from": 111,
    "label": "calls",
    "to": 12
  }, {
    "from": 111,
    "label": "calls",
    "to": 12
  }, {
    "from": 116,
    "label": "calls",
    "to": 19
  }, {
    "from": 118,
    "label": "calls",
    "to": 19
  }, {
    "from": 118,
    "label": "calls",
    "to": 19
  }, {
    "from": 120,
    "label": "calls",
    "to": 19
  }, {
    "from": 119,
    "label": "calls",
    "to": 19
  }, {
    "from": 117,
    "label": "calls",
    "to": 17
  }, {
    "from": 118,
    "label": "calls",
    "to": 17
  }, {
    "from": 118,
    "label": "calls",
    "to": 17
  }, {
    "from": 120,
    "label": "calls",
    "to": 17
  }, {
    "from": 120,
    "label": "calls",
    "to": 17
  }, {
    "from": 120,
    "label": "calls",
    "to": 17
  }, {
    "from": 121,
    "label": "calls",
    "to": 19
  }, {
    "from": 123,
    "label": "calls",
    "to": 31
  }, {
    "from": 122,
    "label": "calls",
    "to": 24
  }, {
    "from": 124,
    "label": "calls",
    "to": 19
  }, {
    "from": 125,
    "label": "calls",
    "to": 19
  }, {
    "from": 125,
    "label": "calls",
    "to": 17
  }, {
    "from": 126,
    "label": "calls",
    "to": 19
  }, {
    "from": 127,
    "label": "calls",
    "to": 19
  }, {
    "from": 127,
    "label": "calls",
    "to": 12
  }, {
    "from": 129,
    "label": "calls",
    "to": 19
  }, {
    "from": 128,
    "label": "calls",
    "to": 24
  }, {
    "from": 130,
    "label": "calls",
    "to": 19
  }, {
    "from": 131,
    "label": "calls",
    "to": 19
  }, {
    "from": 131,
    "label": "calls",
    "to": 19
  }, {
    "from": 131,
    "label": "calls",
    "to": 12
  }, {
    "from": 131,
    "label": "calls",
    "to": 12
  }, {
    "from": 131,
    "label": "calls",
    "to": 12
  }, {
    "from": 131,
    "label": "calls",
    "to": 12
  }, {
    "from": 131,
    "label": "calls",
    "to": 24
  }, {
    "from": 1,
    "label": "contains",
    "to": 137
  }, {
    "from": 1,
    "label": "contains",
    "to": 138
  }, {
    "from": 137,
    "label": "initializes",
    "to": 139
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "dir",
    "type": "module"
  }, {
    "id": 2,
    "text": "local function add_files_to_server(refresh, rockfiles, server, upload_server)\r\n   assert(type(refresh) == \"boolean\" or not refresh)\r\n   assert(type(rockfiles) == \"table\")\r\n   assert(type(server) == \"string\")\r\n   assert(type(upload_server) == \"table\" or not upload_server)\r\n   \r\n   local download_url, login_url = cache.get_server_urls(server, upload_server)\r\n   local at = fs.current_dir()\r\n   local refresh_fn = refresh and cache.refresh_local_cache or cache.split_server_url\r\n   \r\n   local local_cache, protocol, server_path, user, password = refresh_fn(server, download_url, cfg.upload_user, cfg.upload_password)\r\n   if not local_cache then\r\n      return nil, protocol\r\n   end\r\n   if protocol == \"file\" then\r\n      return nil, \"Server \"..server..\" is not recognized, check your configuration.\"\r\n   end\r\n   \r\n   if not login_url then\r\n      login_url = protocol..\"://\"..server_path\r\n   end\r\n   \r\n   local ok, err = fs.change_dir(at)\r\n   if not ok then return nil, err end\r\n   \r\n   local files = {}\r\n   for i, rockfile in ipairs(rockfiles) do\r\n      if fs.exists(rockfile) then\r\n         util.printout(\"Copying file \"..rockfile..\" to \"..local_cache..\"...\")\r\n         local absolute = fs.absolute_name(rockfile)\r\n         fs.copy(absolute, local_cache)\r\n         table.insert(files, dir.base_name(absolute))\r\n      else\r\n         util.printerr(\"File \"..rockfile..\" not found\")\r\n      end\r\n   end\r\n   if #files == 0 then\r\n      return nil, \"No files found\"\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_cache)\r\n   if not ok then return nil, err end\r\n\r\n   util.printout(\"Updating manifest...\")\r\n   manif.make_manifest(local_cache, \"one\", true)\r\n   \r\n   manif.zip_manifests()\r\n   \r\n   util.printout(\"Updating index.html...\")\r\n   index.make_index(local_cache)\r\n\r\n   local login_info = \"\"\r\n   if user then login_info = \" -u \"..user end\r\n   if password then login_info = login_info..\":\"..password end\r\n   if not login_url:match(\"/$\") then\r\n      login_url = login_url .. \"/\"\r\n   end\r\n\r\n   table.insert(files, \"index.html\")\r\n   table.insert(files, \"manifest\")\r\n   for ver in util.lua_versions() do\r\n      table.insert(files, \"manifest-\"..ver)\r\n      table.insert(files, \"manifest-\"..ver..\".zip\")\r\n   end\r\n\r\n   -- TODO abstract away explicit 'curl' call\r\n\r\n   local cmd\r\n   if protocol == \"rsync\" then\r\n      local srv, path = server_path:match(\"([^/]+)(/.+)\")\r\n      cmd = cfg.variables.RSYNC..\" \"..cfg.variables.RSYNCFLAGS..\" -e ssh \"..local_cache..\"/ \"..user..\"@\"..srv..\":\"..path..\"/\"\r\n   elseif upload_server and upload_server.sftp then\r\n      local part1, part2 = upload_server.sftp:match(\"^([^/]*)/(.*)$\")\r\n      cmd = cfg.variables.SCP..\" \"..table.concat(files, \" \")..\" \"..user..\"@\"..part1..\":/\"..part2\r\n   else\r\n      cmd = cfg.variables.CURL..\" \"..login_info..\" -T '{\"..table.concat(files, \",\")..\"}' \"..login_url\r\n   end\r\n\r\n   util.printout(cmd)\r\n   fs.execute(cmd)\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "local function remove_files_from_server(refresh, rockfiles, server, upload_server)\r\n   assert(type(refresh) == \"boolean\" or not refresh)\r\n   assert(type(rockfiles) == \"table\")\r\n   assert(type(server) == \"string\")\r\n   assert(type(upload_server) == \"table\" or not upload_server)\r\n\r\n   local download_url, login_url = cache.get_server_urls(server, upload_server)\r\n   local at = fs.current_dir()\r\n   local refresh_fn = refresh and cache.refresh_local_cache or cache.split_server_url\r\n   \r\n   local local_cache, protocol, server_path, user, password = refresh_fn(server, download_url, cfg.upload_user, cfg.upload_password)\r\n   if not local_cache then\r\n      return nil, protocol\r\n   end\r\n   if protocol ~= \"rsync\" then\r\n      return nil, \"This command requires 'rsync', check your configuration.\"\r\n   end\r\n   \r\n   local ok, err = fs.change_dir(at)\r\n   if not ok then return nil, err end\r\n   \r\n   local nr_files = 0\r\n   for i, rockfile in ipairs(rockfiles) do\r\n      local basename = dir.base_name(rockfile)\r\n      local file = dir.path(local_cache, basename)\r\n      util.printout(\"Removing file \"..file..\"...\")\r\n      fs.delete(file)\r\n      if not fs.exists(file) then\r\n         nr_files = nr_files + 1\r\n      else\r\n         util.printerr(\"Failed removing \"..file)\r\n      end\r\n   end\r\n   if nr_files == 0 then\r\n      return nil, \"No files removed.\"\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_cache)\r\n   if not ok then return nil, err end\r\n\r\n   util.printout(\"Updating manifest...\")\r\n   manif.make_manifest(local_cache, \"one\", true)\r\n   util.printout(\"Updating index.html...\")\r\n   index.make_index(local_cache)\r\n\r\n   local srv, path = server_path:match(\"([^/]+)(/.+)\")\r\n   local cmd = cfg.variables.RSYNC..\" \"..cfg.variables.RSYNCFLAGS..\" --delete -e ssh \"..local_cache..\"/ \"..user..\"@\"..srv..\":\"..path..\"/\"\r\n\r\n   util.printout(cmd)\r\n   fs.execute(cmd)\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 4,
    "text": "function run(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n   local compile_object, compile_library, compile_wrapper_binary\r\n\r\n   local build = rockspec.build\r\n   local variables = rockspec.variables\r\n\r\n   local function add_flags(extras, flag, flags)\r\n      if flags then\r\n         if type(flags) ~= \"table\" then\r\n            flags = { tostring(flags) }\r\n         end\r\n         util.variable_substitutions(flags, variables)\r\n         for _, v in ipairs(flags) do\r\n            table.insert(extras, flag:format(v))\r\n         end\r\n      end\r\n   end\r\n\r\n   -- MinGW basically behaves the same as Unix\r\n   if cfg.is_platform(\"mingw32\") then\r\n         compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR, \"-c\", source, \"-o\", object, unpack(extras))\r\n      end\r\n      compile_library = function (library, objects, libraries, libdirs)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-L%s\", libdirs)\r\n         add_flags(extras, \"-l%s\", libraries)\r\n         extras[#extras+1] = dir.path(variables.LUA_LIBDIR, variables.LUALIB)\r\n         extras[#extras+1] = \"-l\" .. (variables.MSVCRT or \"m\")\r\n         local ok = execute(variables.LD..\" \"..variables.LIBFLAG, \"-o\", library, unpack(extras))\r\n         return ok\r\n      end\r\n      compile_wrapper_binary = function(fullname, name)\r\n         local fullbasename = fullname:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local basename = name:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local rcname = basename..\".rc\"\r\n         local resname = basename..\".o\"\r\n         local wrapname = basename..\".exe\"\r\n         make_rc(fullname, fullbasename..\".rc\")\r\n         local ok = execute(variables.RC, \"-o\", resname, rcname)\r\n         if not ok then return ok end\r\n         ok = execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR,\r\n                      \"-o\", wrapname, resname, variables.WRAPPER,\r\n                      dir.path(variables.LUA_LIBDIR, variables.LUALIB),\r\n                      \"-l\" .. (variables.MSVCRT or \"m\"), \"-luser32\")\r\n         return ok, wrapname\r\n      end\r\n      compile_wrapper_binary = function(fullname, name) return true, name end\r\n\t-- MSVC specific commands\r\n\telseif cfg.is_platform(\"win32\") then\r\n      compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-c\", \"-Fo\"..object, \"-I\"..variables.LUA_INCDIR, source, unpack(extras))\r\n      end\r\n      compile_library = function(library, objects, libraries, libdirs, name)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-libpath:%s\", libdirs)\r\n         add_flags(extras, \"%s.lib\", libraries)\r\n         local basename = dir.base_name(library):gsub(\".[^.]*$\", \"\")\r\n         local deffile = basename .. \".def\"\r\n         local def = io.open(dir.path(fs.current_dir(), deffile), \"w+\")\r\n         def:write(\"EXPORTS\\n\")\r\n         def:write(\"luaopen_\"..name:gsub(\"%.\", \"_\")..\"\\n\")\r\n         def:close()\r\n         local ok = execute(variables.LD, \"-dll\", \"-def:\"..deffile, \"-out:\"..library, dir.path(variables.LUA_LIBDIR, variables.LUALIB), unpack(extras))\r\n         local basedir = \"\"\r\n         if name:find(\"%.\") ~= nil then\r\n            basedir = name:gsub(\"%.%w+$\", \"\\\\\")\r\n            basedir = basedir:gsub(\"%.\", \"\\\\\")\r\n         end\r\n         local manifestfile = basedir .. basename..\".dll.manifest\"\r\n\r\n         if ok and fs.exists(manifestfile) then\r\n            ok = execute(variables.MT, \"-manifest\", manifestfile, \"-outputresource:\"..basedir..basename..\".dll;2\")\r\n         end\r\n         return ok\r\n      end\r\n      compile_wrapper_binary = function(fullname, name)\r\n         local fullbasename = fullname:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local basename = name:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local object = basename..\".obj\"\r\n         local rcname = basename..\".rc\"\r\n         local resname = basename..\".res\"\r\n         local wrapname = basename..\".exe\"\r\n         make_rc(fullname, fullbasename..\".rc\")\r\n         local ok = execute(variables.RC, \"-r\", \"-fo\"..resname, rcname)\r\n         if not ok then return ok end\r\n         ok = execute(variables.CC..\" \"..variables.CFLAGS, \"-c\", \"-Fo\"..object,\r\n                      \"-I\"..variables.LUA_INCDIR, variables.WRAPPER)\r\n         if not ok then return ok end\r\n         ok = execute(variables.LD, \"-out:\"..wrapname, resname, object,\r\n                      dir.path(variables.LUA_LIBDIR, variables.LUALIB), \"user32.lib\")\r\n         local manifestfile = wrapname..\".manifest\"\r\n         if ok and fs.exists(manifestfile) then\r\n            ok = execute(variables.MT, \"-manifest\", manifestfile, \"-outputresource:\"..wrapname..\";1\")\r\n         end\r\n         return ok, wrapname\r\n      end\r\n   else\r\n\t-- Unix, Linux, Cygwin\r\n      compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR, \"-c\", source, \"-o\", object, unpack(extras))\r\n      end\r\n      compile_library = function (library, objects, libraries, libdirs)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-L%s\", libdirs)\r\n         if cfg.gcc_rpath then\r\n            add_flags(extras, \"-Wl,-rpath,%s:\", libdirs)\r\n         end\r\n         add_flags(extras, \"-l%s\", libraries)\r\n\t\t -- Link to Lua\r\n         add_flags(extras, \"-l%s\", variables.LUA_LIB)\r\n         return execute(variables.LD..\" \"..variables.LIBFLAG, \"-o\", library, \"-L\"..variables.LUA_LIBDIR, unpack(extras))\r\n      end\r\n      compile_wrapper_binary = function(fullname, name) return true, name end\r\n   end\r\n\r\n   local ok = true\r\n   local err = \"Build error\"\r\n   local built_modules = {}\r\n   local luadir = path.lua_dir(rockspec.name, rockspec.version)\r\n   local libdir = path.lib_dir(rockspec.name, rockspec.version)\r\n   local docdir = path.doc_dir(rockspec.name, rockspec.version)\r\n   -- On Windows, compiles an .exe for each Lua file in build.install.bin, and\r\n   -- replaces the filename with the .exe name. Strips the .lua extension if it exists,\r\n   -- otherwise just appends .exe to the name\r\n   if build.install and build.install.bin then\r\n     for i, name in ipairs(build.install.bin) do\r\n       local fullname = dir.path(fs.current_dir(), name)\r\n       local match = name:match(\"%.lua$\")\r\n       local basename = name:gsub(\"%.lua$\", \"\")\r\n       local file\r\n       if not match then\r\n          file = io.open(fullname)\r\n       end\r\n       if match or (file and file:read():match(\"#!.*lua.*\")) then\r\n          ok, name = compile_wrapper_binary(fullname, name)\r\n          if ok then\r\n             build.install.bin[i] = name\r\n          else\r\n             if file then file:close() end\r\n             return nil, \"Build error in wrapper binaries\"\r\n          end\r\n       end\r\n       if file then file:close() end\r\n     end\r\n   end\r\n   for name, info in pairs(build.modules) do\r\n      local moddir = path.module_to_path(name)\r\n      if type(info) == \"string\" then\r\n         local ext = info:match(\".([^.]+)$\")\r\n         if ext == \"lua\" then\r\n            local filename = dir.base_name(info)\r\n            if info:match(\"init%.lua$\") and not name:match(\"%.init$\") then\r\n               moddir = path.module_to_path(name..\".init\")\r\n            else\r\n               local basename = name:match(\"([^.]+)$\")\r\n               local baseinfo = filename:gsub(\"%.lua$\", \"\")\r\n               if basename ~= baseinfo then\r\n                  filename = basename..\".lua\"\r\n               end\r\n            end\r\n            local dest = dir.path(luadir, moddir, filename)\r\n            built_modules[info] = dest\r\n         else\r\n            info = {info}\r\n         end\r\n      end\r\n      if type(info) == \"table\" then\r\n         local objects = {}\r\n         local sources = info.sources\r\n         if info[1] then sources = info end\r\n         if type(sources) == \"string\" then sources = {sources} end\r\n         for _, source in ipairs(sources) do\r\n            local object = source:gsub(\".[^.]*$\", \".\"..cfg.obj_extension)\r\n            if not object then\r\n               object = source..\".\"..cfg.obj_extension\r\n            end\r\n            ok = compile_object(object, source, info.defines, info.incdirs)\r\n            if not ok then\r\n               return nil, \"Failed compiling object \"..object\r\n            end\r\n            table.insert(objects, object)\r\n         end\r\n         if not ok then break end\r\n         local module_name = name:match(\"([^.]*)$\")..\".\"..util.matchquote(cfg.lib_extension)\r\n         if moddir ~= \"\" then\r\n            module_name = dir.path(moddir, module_name)\r\n            local ok, err = fs.make_dir(moddir)\r\n            if not ok then return nil, err end\r\n         end\r\n         built_modules[module_name] = dir.path(libdir, module_name)\r\n         ok = compile_library(module_name, objects, info.libraries, info.libdirs, name)\r\n         if not ok then\r\n            return nil, \"Failed compiling module \"..module_name\r\n         end\r\n      end\r\n   end\r\n   for name, dest in pairs(built_modules) do\r\n      fs.make_dir(dir.dir_name(dest))\r\n      ok = fs.copy(name, dest)\r\n      if not ok then\r\n         return nil, \"Failed installing \"..name..\" in \"..dest\r\n      end\r\n   end\r\n   if fs.is_dir(\"lua\") then\r\n      local ok, err = fs.copy_contents(\"lua\", luadir)\r\n      if not ok then\r\n         return nil, \"Failed copying contents of 'lua' directory: \"..err\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 5,
    "text": "local function install_files(files, location, is_module_path)\r\n   assert(type(files) == \"table\" or not files)\r\n   assert(type(location) == \"string\")\r\n   if files then\r\n      for k, file in pairs(files) do\r\n         local dest = location\r\n         local filename = dir.base_name(file)\r\n         if type(k) == \"string\" then\r\n            local modname = k\r\n            if is_module_path then\r\n               dest = dir.path(location, path.module_to_path(modname))\r\n               local ok, err = fs.make_dir(dest)\r\n               if not ok then return nil, err end\r\n               if filename:match(\"%.lua$\") then\r\n                  local basename = modname:match(\"([^.]+)$\")\r\n                  local baseinfo = filename:gsub(\"%.lua$\", \"\")\r\n                  if basename ~= baseinfo then\r\n                     filename = basename..\".lua\"\r\n                  end\r\n               end\r\n            else\r\n               dest = dir.path(location, dir.dir_name(modname))\r\n               local ok, err = fs.make_dir(dest)\r\n               if not ok then return nil, err end\r\n               filename = dir.base_name(modname)\r\n            end\r\n         else\r\n            local ok, err = fs.make_dir(dest)\r\n            if not ok then return nil, err end\r\n         end\r\n         local ok = fs.copy(dir.path(file), dir.path(dest, filename))\r\n         if not ok then\r\n            return nil, \"Failed copying \"..file\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 6,
    "text": "local function extract_from_rockspec(files)\r\n   for name, content in pairs(files) do\r\n      local fd = io.open(dir.path(fs.current_dir(), name), \"w+\")\r\n      fd:write(content)\r\n      fd:close()\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 7,
    "text": "function build_rockspec(rockspec_file, need_to_fetch, minimal_mode, deps_mode)\r\n   assert(type(rockspec_file) == \"string\")\r\n   assert(type(need_to_fetch) == \"boolean\")\r\n\r\n   local rockspec, err, errcode = fetch.load_rockspec(rockspec_file)\r\n   if err then\r\n      return nil, err, errcode\r\n   elseif not rockspec.build then\r\n      return nil, \"Rockspec error: build table not specified\"\r\n   elseif not rockspec.build.type then\r\n      return nil, \"Rockspec error: build type not specified\"\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      local ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then\r\n         return nil, err, errcode\r\n      end\r\n   end\r\n\r\n   local ok, err, errcode = deps.check_external_deps(rockspec, \"build\")\r\n   if err then\r\n      return nil, err, errcode\r\n   end\r\n\r\n   local name, version = rockspec.name, rockspec.version\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n\r\n   if not minimal_mode then\r\n      local _, source_dir\r\n      if need_to_fetch then\r\n         ok, source_dir, errcode = fetch.fetch_sources(rockspec, true)\r\n         if not ok then\r\n            return nil, source_dir, errcode\r\n         end\r\n         local ok, err = fs.change_dir(source_dir)\r\n         if not ok then return nil, err end\r\n      elseif rockspec.source.file then\r\n         local ok, err = fs.unpack_archive(rockspec.source.file)\r\n         if not ok then\r\n            return nil, err\r\n         end\r\n      end\r\n      fs.change_dir(rockspec.source.dir)\r\n   end\r\n   \r\n   local dirs = {\r\n      lua = { name = path.lua_dir(name, version), is_module_path = true },\r\n      lib = { name = path.lib_dir(name, version), is_module_path = true },\r\n      conf = { name = path.conf_dir(name, version), is_module_path = false },\r\n      bin = { name = path.bin_dir(name, version), is_module_path = false },\r\n   }\r\n   \r\n   for _, d in pairs(dirs) do\r\n      local ok, err = fs.make_dir(d.name)\r\n      if not ok then return nil, err end\r\n   end\r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n\r\n   local build = rockspec.build\r\n   \r\n   if not minimal_mode then\r\n      ok, err = apply_patches(rockspec)\r\n      if err then\r\n         return nil, err\r\n      end\r\n   end\r\n   \r\n   if build.type ~= \"none\" then\r\n\r\n      -- Temporary compatibility\r\n      if build.type == \"module\" then\r\n         util.printout(\"Do not use 'module' as a build type. Use 'builtin' instead.\")\r\n         build.type = \"builtin\"\r\n      end\r\n\r\n      if cfg.accepted_build_types and util.array_contains(cfg.accepted_build_types, build.type) then\r\n         return nil, \"This rockspec uses the '\"..build.type..\"' build type, which is blocked by the 'accepted_build_types' setting in your LuaRocks configuration.\"\r\n      end\r\n\r\n      local build_type\r\n      ok, build_type = pcall(require, \"luarocks.build.\" .. build.type)\r\n      if not ok or not type(build_type) == \"table\" then\r\n         return nil, \"Failed initializing build back-end for build type '\"..build.type..\"': \"..build_type\r\n      end\r\n  \r\n      ok, err = build_type.run(rockspec)\r\n      if not ok then\r\n         return nil, \"Build error: \" .. err\r\n      end\r\n   end\r\n\r\n   if build.install then\r\n      for id, install_dir in pairs(dirs) do\r\n         ok, err = install_files(build.install[id], install_dir.name, install_dir.is_module_path)\r\n         if not ok then \r\n            return nil, err\r\n         end\r\n      end\r\n   end\r\n   \r\n   local copy_directories = build.copy_directories\r\n   local copying_default = false\r\n   if not copy_directories then\r\n      copy_directories = {\"doc\"}\r\n      copying_default = true\r\n   end\r\n\r\n   for _, copy_dir in pairs(copy_directories) do\r\n      if fs.is_dir(copy_dir) then\r\n         local dest = dir.path(path.install_dir(name, version), copy_dir)\r\n         fs.make_dir(dest)\r\n         fs.copy_contents(copy_dir, dest)\r\n      else\r\n         if not copying_default then\r\n            return nil, \"Directory '\"..copy_dir..\"' not found\"\r\n         end\r\n      end\r\n   end\r\n\r\n   for _, d in pairs(dirs) do\r\n      fs.remove_dir_if_empty(d.name)\r\n   end\r\n\r\n   fs.pop_dir()\r\n   \r\n   fs.copy(rockspec.local_filename, path.rockspec_file(name, version))\r\n   if need_to_fetch then\r\n      fs.pop_dir()\r\n   end\r\n\r\n   ok, err = manif.make_rock_manifest(name, version)\r\n   if err then return nil, err end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n\r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n\r\n   local license = \"\"\r\n   if rockspec.description and rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now built and installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 8,
    "text": "function split_server_url(server, url, user, password)\r\n   local protocol, server_path = dir.split_url(url)\r\n   if server_path:match(\"@\") then\r\n      local credentials\r\n      credentials, server_path = server_path:match(\"([^@]*)@(.*)\")\r\n      if credentials:match(\":\") then\r\n         user, password = credentials:match(\"([^:]*):(.*)\")\r\n      else\r\n         user = credentials\r\n      end\r\n   end\r\n   local local_cache\r\n   if cfg.local_cache then\r\n      local_cache = cfg.local_cache .. \"/\" .. server\r\n   end\r\n   return local_cache, protocol, server_path, user, password\r\nend",
    "type": "function"
  }, {
    "id": 9,
    "text": "local function replace_tree(flags, args, tree)\r\n   local tree = dir.normalize(tree)\r\n   flags[\"tree\"] = tree\r\n   for i = 1, #args do\r\n      if args[i]:match(\"%-%-tree=\") then\r\n         args[i] = \"--tree=\"..tree\r\n         break\r\n      end\r\n   end\r\n   path.use_tree(tree)\r\nend",
    "type": "function"
  }, {
    "id": 10,
    "text": "function run_command(...)\r\n   local args = {...}\r\n   local cmdline_vars = {}\r\n   for i = #args, 1, -1 do\r\n      local arg = args[i]\r\n      if arg:match(\"^[^-][^=]*=\") then\r\n         local var, val = arg:match(\"^([A-Z_][A-Z0-9_]*)=(.*)\")\r\n         if val then\r\n            cmdline_vars[var] = val\r\n            table.remove(args, i)\r\n         else\r\n            die(\"Invalid assignment: \"..arg)\r\n         end\r\n      end\r\n   end\r\n   local nonflags = { util.parse_flags(unpack(args)) }\r\n   local flags = table.remove(nonflags, 1)\r\n   \r\n   if flags[\"from\"] then flags[\"server\"] = flags[\"from\"] end\r\n   if flags[\"only-from\"] then flags[\"only-server\"] = flags[\"only-from\"] end\r\n   if flags[\"only-sources-from\"] then flags[\"only-sources\"] = flags[\"only-sources-from\"] end\r\n   if flags[\"to\"] then flags[\"tree\"] = flags[\"to\"] end\r\n   if flags[\"nodeps\"] then\r\n      flags[\"deps-mode\"] = \"none\"\r\n      table.insert(args, \"--deps-mode=none\")\r\n   end\r\n   \r\n   cfg.flags = flags\r\n\r\n   local command\r\n   \r\n   if flags[\"verbose\"] then   -- setting it in the config file will kick-in earlier in the process\r\n      cfg.verbose = true\r\n      local fs = require(\"luarocks.fs\")\r\n      fs.verbose()\r\n   end\r\n\r\n   if flags[\"version\"] then\r\n      util.printout(program..\" \"..cfg.program_version)\r\n      util.printout(program_description)\r\n      util.printout()\r\n      os.exit(cfg.errorcodes.OK)\r\n   elseif flags[\"help\"] or #nonflags == 0 then\r\n      command = \"help\"\r\n      args = nonflags\r\n   else\r\n      command = nonflags[1]\r\n      for i, arg in ipairs(args) do\r\n         if arg == command then\r\n            table.remove(args, i)\r\n            break\r\n         end\r\n      end\r\n   end\r\n   command = command:gsub(\"-\", \"_\")\r\n\r\n   if flags[\"extensions\"] then\r\n      cfg.use_extensions = true\r\n      local type_check = require(\"luarocks.type_check\")\r\n      type_check.load_extensions()\r\n   end\r\n   \r\n   if cfg.local_by_default then\r\n      flags[\"local\"] = true\r\n   end\r\n\r\n   if flags[\"deps-mode\"] and not deps.check_deps_mode_flag(flags[\"deps-mode\"]) then\r\n      die(\"Invalid entry for --deps-mode.\")\r\n   end\r\n   \r\n   if flags[\"tree\"] then\r\n      if flags[\"tree\"] == true or flags[\"tree\"] == \"\" then\r\n         die(\"Argument error: use --tree=<path>\")\r\n      end\r\n      local named = false\r\n      for _, tree in ipairs(cfg.rocks_trees) do\r\n         if type(tree) == \"table\" and flags[\"tree\"] == tree.name then\r\n            if not tree.root then\r\n               die(\"Configuration error: tree '\"..tree.name..\"' has no 'root' field.\")\r\n            end\r\n            replace_tree(flags, args, tree.root)\r\n            named = true\r\n            break\r\n         end\r\n      end\r\n      if not named then\r\n         local fs = require(\"luarocks.fs\")\r\n         local root_dir = fs.absolute_name(flags[\"tree\"])\r\n         replace_tree(flags, args, root_dir)\r\n      end\r\n   elseif flags[\"local\"] then\r\n      replace_tree(flags, args, cfg.home_tree)\r\n   else\r\n      local trees = cfg.rocks_trees\r\n      path.use_tree(trees[#trees])\r\n   end\r\n\r\n   if type(cfg.root_dir) == \"string\" then\r\n     cfg.root_dir = cfg.root_dir:gsub(\"/+$\", \"\")\r\n   else\r\n     cfg.root_dir.root = cfg.root_dir.root:gsub(\"/+$\", \"\")\r\n   end\r\n   cfg.rocks_dir = cfg.rocks_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_bin_dir = cfg.deploy_bin_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_lua_dir = cfg.deploy_lua_dir:gsub(\"/+$\", \"\")\r\n   cfg.deploy_lib_dir = cfg.deploy_lib_dir:gsub(\"/+$\", \"\")\r\n   \r\n   cfg.variables.ROCKS_TREE = cfg.rocks_dir\r\n   cfg.variables.SCRIPTS_DIR = cfg.deploy_bin_dir\r\n\r\n   if flags[\"server\"] then\r\n      if flags[\"server\"] == true then\r\n         die(\"Argument error: use --server=<url>\")\r\n      end\r\n      local protocol, path = dir.split_url(flags[\"server\"])\r\n      table.insert(cfg.rocks_servers, 1, protocol..\"://\"..path)\r\n   end\r\n   \r\n   if flags[\"only-server\"] then\r\n      if flags[\"only-server\"] == true then\r\n         die(\"Argument error: use --only-server=<url>\")\r\n      end\r\n      cfg.rocks_servers = { flags[\"only-server\"] }\r\n   end\r\n\r\n   if flags[\"only-sources\"] then\r\n      cfg.only_sources_from = flags[\"only-sources\"]\r\n   end\r\n  \r\n   if command ~= \"help\" then\r\n      for k, v in pairs(cmdline_vars) do\r\n         cfg.variables[k] = v\r\n      end\r\n   end\r\n   \r\n   if commands[command] then\r\n      -- TODO the interface of run should be modified, to receive the\r\n      -- flags table and the (possibly unpacked) nonflags arguments.\r\n      -- This would remove redundant parsing of arguments.\r\n      -- I'm not changing this now to avoid messing with the run()\r\n      -- interface, which I know some people use (even though\r\n      -- I never published it as a public API...)\r\n      local cmd = require(commands[command])\r\n      local xp, ok, err, exitcode = xpcall(function() return cmd.run(unpack(args)) end, function(err)\r\n         die(debug.traceback(\"LuaRocks \"..cfg.program_version\r\n            ..\" bug (please report at luarocks-developers@lists.sourceforge.net).\\n\"\r\n            ..err, 2))\r\n      end)\r\n      if xp and (not ok) then\r\n         die(err, exitcode)\r\n      end\r\n   else\r\n      die(\"Unknown command: \"..command)\r\n   end\r\n   util.run_scheduled_functions()\r\nend",
    "type": "function"
  }, {
    "id": 11,
    "text": "function check_external_deps(rockspec, mode)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   local fs = require(\"luarocks.fs\")\r\n   \r\n   local vars = rockspec.variables\r\n   local patterns = cfg.external_deps_patterns\r\n   local subdirs = cfg.external_deps_subdirs\r\n   if mode == \"install\" then\r\n      patterns = cfg.runtime_external_deps_patterns\r\n      subdirs = cfg.runtime_external_deps_subdirs\r\n   end\r\n   if rockspec.external_dependencies then\r\n      for name, files in pairs(rockspec.external_dependencies) do\r\n         local ok = true\r\n         local failed_file = nil\r\n         local failed_dirname = nil\r\n         for _, extdir in ipairs(cfg.external_deps_dirs) do\r\n            ok = true\r\n            local prefix = vars[name..\"_DIR\"]\r\n            local dirs = {\r\n               BINDIR = { subdir = subdirs.bin, testfile = \"program\", pattern = patterns.bin },\r\n               INCDIR = { subdir = subdirs.include, testfile = \"header\", pattern = patterns.include },\r\n               LIBDIR = { subdir = subdirs.lib, testfile = \"library\", pattern = patterns.lib }\r\n            }\r\n            if mode == \"install\" then\r\n               dirs.INCDIR = nil\r\n            end\r\n            if not prefix then\r\n               prefix = extdir\r\n            end\r\n            if type(prefix) == \"table\" then\r\n               if prefix.bin then\r\n                  dirs.BINDIR.subdir = prefix.bin\r\n               end\r\n               if prefix.include then\r\n                  if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end\r\n               end\r\n               if prefix.lib then\r\n                  dirs.LIBDIR.subdir = prefix.lib\r\n               end\r\n               prefix = prefix.prefix\r\n            end\r\n            for dirname, dirdata in pairs(dirs) do\r\n               local paths\r\n               local path_var_value = vars[name..\"_\"..dirname]\r\n               if path_var_value then\r\n                  paths = { path_var_value }\r\n               elseif type(dirdata.subdir) == \"table\" then\r\n                  paths = {}\r\n                  for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end\r\n               else\r\n                  paths = { dir.path(prefix, dirdata.subdir) }\r\n               end\r\n               dirdata.dir = paths[1]\r\n               local file = files[dirdata.testfile]\r\n               if file then\r\n                  local files = {}\r\n                  if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end\r\n                  local found = false\r\n                  failed_file = nil\r\n                  for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end\r\n                  if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end\r\n               end\r\n            end\r\n            if ok then\r\n               for dirname, dirdata in pairs(dirs) do\r\n                  vars[name..\"_\"..dirname] = dirdata.dir\r\n               end\r\n               vars[name..\"_DIR\"] = prefix\r\n               break\r\n            end\r\n         end\r\n         if not ok then\r\n            return nil, \"Could not find expected file \"..failed_file..\" for \"..name..\" -- you may have to install \"..name..\" in your system and/or pass \"..name..\"_DIR or \"..name..\"_\"..failed_dirname..\" to the luarocks command. Example: luarocks install \"..rockspec.name..\" \"..name..\"_DIR=/usr/local\", \"dependency\"\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 12,
    "text": "function base_name(pathname)\r\n   assert(type(pathname) == \"string\")\r\n\r\n   local base = pathname:gsub(\"[/\\\\]*$\", \"\"):match(\".*[/\\\\]([^/\\\\]*)\")\r\n   return base or pathname\r\nend",
    "type": "function"
  }, {
    "id": 13,
    "text": "assert(type(pathname) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 14,
    "text": "local base = pathname:gsub(\"[/\\\\]*$\", \"\"):match(\".*[/\\\\]([^/\\\\]*)\")",
    "type": "statement:localassign"
  }, {
    "id": 15,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 16,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 17,
    "text": "function dir_name(pathname)\r\n   assert(type(pathname) == \"string\")\r\n   return (pathname:gsub(\"/*$\", \"\"):match(\"(.*)[/]+[^/]*\")) or \"\"\r\nend",
    "type": "function"
  }, {
    "id": 18,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 19,
    "text": "function path(...)\r\n   local t = {...}\r\n   while t[1] == \"\" do\r\n      table.remove(t, 1)\r\n   end\r\n   return (table.concat(t, \"/\"):gsub(\"([^:])/+\", \"%1/\"):gsub(\"^/+\", \"/\"):gsub(\"/*$\", \"\"))\r\nend",
    "type": "function"
  }, {
    "id": 20,
    "text": "local t = {...}",
    "type": "statement:localassign"
  }, {
    "id": 21,
    "text": "while t[1] == \"\" do\r\n      table.remove(t, 1)\r\n   end",
    "type": "statement:while"
  }, {
    "id": 22,
    "text": "table.remove(t, 1)",
    "type": "statement:functioncall"
  }, {
    "id": 23,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 24,
    "text": "function split_url(url)\r\n   assert(type(url) == \"string\")\r\n   \r\n   local protocol, pathname = url:match(\"^([^:]*)://(.*)\")\r\n   if not protocol then\r\n      protocol = \"file\"\r\n      pathname = url\r\n   end\r\n   return protocol, pathname\r\nend",
    "type": "function"
  }, {
    "id": 25,
    "text": "assert(type(url) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 26,
    "text": "local protocol, pathname = url:match(\"^([^:]*)://(.*)\")",
    "type": "statement:localassign"
  }, {
    "id": 27,
    "text": "if not protocol then\r\n      protocol = \"file\"\r\n      pathname = url\r\n   end",
    "type": "statement:if"
  }, {
    "id": 28,
    "text": "protocol = \"file\"",
    "type": "statement:assign"
  }, {
    "id": 29,
    "text": "pathname = url",
    "type": "statement:assign"
  }, {
    "id": 30,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 31,
    "text": "function normalize(name)\r\n   local protocol, pathname = split_url(name)\r\n   pathname = pathname:gsub(\"\\\\\", \"/\"):gsub(\"(.)/*$\", \"%1\"):gsub(\"//\", \"/\")\r\n   if protocol ~= \"file\" then pathname = protocol ..\"://\"..pathname end\r\n   return pathname\r\nend",
    "type": "function"
  }, {
    "id": 32,
    "text": "local protocol, pathname = split_url(name)",
    "type": "statement:localassign"
  }, {
    "id": 33,
    "text": "pathname = pathname:gsub(\"\\\\\", \"/\"):gsub(\"(.)/*$\", \"%1\"):gsub(\"//\", \"/\")",
    "type": "statement:assign"
  }, {
    "id": 34,
    "text": "if protocol ~= \"file\" then pathname = protocol ..\"://\"..pathname end",
    "type": "statement:if"
  }, {
    "id": 35,
    "text": "pathname = protocol ..\"://\"..pathname",
    "type": "statement:assign"
  }, {
    "id": 36,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 37,
    "text": "",
    "type": "function container"
  }, {
    "id": 38,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if not name then\r\n      return nil, \"Argument missing. \"..util.see_help(\"doc\")\r\n   end\r\n\r\n   local repo\r\n   name, version, repo = show.pick_installed_rock(name, version, flags[\"tree\"])\r\n   if not name then\r\n      return nil, version\r\n   end\r\n   \r\n   local rockspec, err = fetch.load_local_rockspec(path.rockspec_file(name, version, repo))\r\n   if not rockspec then return nil,err end\r\n   local descript = rockspec.description or {}\r\n\r\n   if flags[\"homepage\"] then\r\n      if not descript.homepage then\r\n         return nil, \"No 'homepage' field in rockspec for \"..name..\" \"..version\r\n      end\r\n      util.printout(\"Opening \"..descript.homepage..\" ...\")\r\n      fs.browser(descript.homepage)\r\n      return true\r\n   end\r\n\r\n   local directory = path.install_dir(name,version,repo)\r\n   \r\n   local docdir\r\n   local directories = { \"doc\", \"docs\" }\r\n   for _, d in ipairs(directories) do\r\n      local dirname = dir.path(directory, d)\r\n      if fs.is_dir(dirname) then\r\n         docdir = dirname\r\n         break\r\n      end\r\n   end\r\n   if not docdir then\r\n      if descript.homepage and not flags[\"list\"] then\r\n         util.printout(\"Local documentation directory not found -- opening \"..descript.homepage..\" ...\")\r\n         fs.browser(descript.homepage)\r\n         return true\r\n      end\r\n      return nil, \"Documentation directory not found for \"..name..\" \"..version\r\n   end\r\n\r\n   docdir = dir.normalize(docdir):gsub(\"/+\", \"/\")\r\n   local files = fs.find(docdir)\r\n   local htmlpatt = \"%.html?$\"\r\n   local extensions = { htmlpatt, \"%.md$\", \"%.txt$\",  \"%.textile$\", \"\" }\r\n   local basenames = { \"index\", \"readme\", \"manual\" }\r\n   \r\n   local porcelain = flags[\"porcelain\"]\r\n   if #files > 0 then\r\n      util.title(\"Documentation files for \"..name..\" \"..version, porcelain)\r\n      if porcelain then\r\n         for _, file in ipairs(files) do\r\n            util.printout(docdir..\"/\"..file)\r\n         end\r\n      else\r\n         util.printout(docdir..\"/\")\r\n         for _, file in ipairs(files) do\r\n            util.printout(\"\\t\"..file)\r\n         end\r\n      end\r\n   end\r\n   \r\n   if flags[\"list\"] then\r\n      return true\r\n   end\r\n   \r\n   for _, extension in ipairs(extensions) do\r\n      for _, basename in ipairs(basenames) do\r\n         local filename = basename..extension\r\n         local found\r\n         for _, file in ipairs(files) do\r\n            if file:lower():match(filename) and ((not found) or #file < #found) then\r\n               found = file\r\n            end\r\n         end\r\n         if found then\r\n            local pathname = dir.path(docdir, found)\r\n            util.printout()\r\n            util.printout(\"Opening \"..pathname..\" ...\")\r\n            util.printout()\r\n            local ok = fs.browser(pathname)\r\n            if not ok and not pathname:match(htmlpatt) then\r\n               local fd = io.open(pathname, \"r\")\r\n               util.printout(fd:read(\"*a\"))\r\n               fd:close()\r\n            end\r\n            return true\r\n         end\r\n      end\r\n   end\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 39,
    "text": "local function get_file(filename)\r\n   local protocol, pathname = dir.split_url(filename)\r\n   if protocol == \"file\" then\r\n      local ok, err = fs.copy(pathname, fs.current_dir())\r\n      if ok then\r\n         return pathname\r\n      else\r\n         return nil, err\r\n      end\r\n   else\r\n      return fetch.fetch_url(filename)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 40,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local module = rockspec.source.module or dir.base_name(rockspec.source.url)\r\n   local command = {rockspec.variables.CVS, \"-d\"..rockspec.source.pathname, \"export\", module}\r\n   if rockspec.source.tag then\r\n      table.insert(command, 4, \"-r\")\r\n      table.insert(command, 5, rockspec.source.tag)\r\n   end\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed fetching files from CVS.\"\r\n   end\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 41,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local git_cmd = rockspec.variables.GIT\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local module = dir.base_name(rockspec.source.url)\r\n   -- Strip off .git from base name if present\r\n   module = module:gsub(\"%.git$\", \"\")\r\n\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   store_dir = fs.absolute_name(store_dir)\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n\r\n   local command = {git_cmd, \"clone\", \"--depth=1\", rockspec.source.url, module}\r\n   local tag_or_branch = rockspec.source.tag or rockspec.source.branch\r\n   -- If the tag or branch is explicitly set to \"master\" in the rockspec, then\r\n   -- we can avoid passing it to Git since it's the default.\r\n   if tag_or_branch == \"master\" then tag_or_branch = nil end\r\n   if tag_or_branch then\r\n      if git_can_clone_by_tag(git_cmd) then\r\n         -- The argument to `--branch` can actually be a branch or a tag as of\r\n         -- Git 1.7.10.\r\n         table.insert(command, 4, \"--branch=\" .. tag_or_branch)\r\n      end\r\n   end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed cloning git repository.\"\r\n   end\r\n   local ok, err = fs.change_dir(module)\r\n   if not ok then return nil, err end\r\n   if tag_or_branch and not git_can_clone_by_tag() then\r\n      local checkout_command = {git_cmd, \"checkout\", tag_or_branch}\r\n      if not fs.execute(unpack(checkout_command)) then\r\n         return nil, 'Failed to check out the \"' .. tag_or_branch ..'\" tag or branch.'\r\n      end\r\n   end\r\n\r\n   fs.delete(dir.path(store_dir, module, \".git\"))\r\n   fs.delete(dir.path(store_dir, module, \".gitignore\"))\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 42,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local hg_cmd = rockspec.variables.HG\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   -- Strip off special hg:// protocol type\r\n   local url = rockspec.source.url:gsub(\"^hg://\", \"\") \r\n\r\n   local module = dir.base_name(url)\r\n\r\n   local command = {hg_cmd, \"clone\", url, module}\r\n   local tag_or_branch = rockspec.source.tag or rockspec.source.branch\r\n   if tag_or_branch then\r\n      command = {hg_cmd, \"clone\", \"--rev\", url, module}\r\n   end\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed cloning hg repository.\"\r\n   end\r\n   local ok, err = fs.change_dir(module)\r\n   if not ok then return nil, err end\r\n\r\n   fs.delete(dir.path(store_dir, module, \".hg\"))\r\n   fs.delete(dir.path(store_dir, module, \".hgignore\"))\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 43,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local sscm_cmd = rockspec.variables.SSCM\r\n   local module = rockspec.source.module or dir.base_name(rockspec.source.url)\r\n   local branch, repository = string.match(rockspec.source.pathname, \"^([^/]*)/(.*)\")\r\n   if not branch or not repository then\r\n      return nil, \"Error retrieving branch and repository from rockspec.\"\r\n   end\r\n   -- Search for working directory.\r\n   local working_dir\r\n   local tmp = io.popen(string.format(sscm_cmd..[[ property \"/\" -d -b%s -p%s]], branch, repository))\r\n   for line in tmp:lines() do\r\n      --%c because a chr(13) comes in the end.\r\n      working_dir = string.match(line, \"Working directory:[%s]*(.*)%c$\")\r\n      if working_dir then break end\r\n   end\r\n   tmp:close()\r\n   if not working_dir then\r\n      return nil, \"Error retrieving working directory from SSCM.\"\r\n   end\r\n   if not fs.execute(sscm_cmd, \"get\", \"*\", \"-e\" , \"-r\", \"-b\"..branch, \"-p\"..repository, \"-tmodify\", \"-wreplace\") then\r\n      return nil, \"Failed fetching files from SSCM.\"\r\n   end\r\n   -- FIXME: This function does not honor the dest_dir parameter.\r\n   return module, working_dir\r\nend",
    "type": "function"
  }, {
    "id": 44,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local svn_cmd = rockspec.variables.SVN\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local module = rockspec.source.module or dir.base_name(rockspec.source.url)\r\n   local url = rockspec.source.url:gsub(\"^svn://\", \"\")\r\n   local command = {svn_cmd, \"checkout\", url, module}\r\n   if rockspec.source.tag then\r\n      table.insert(command, 5, \"-r\")\r\n      table.insert(command, 6, rockspec.source.tag)\r\n   end\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed fetching files from Subversion.\"\r\n   end\r\n   ok, err = fs.change_dir(module)\r\n   if not ok then return nil, err end\r\n   for _, d in ipairs(fs.find(\".\")) do\r\n      if dir.base_name(d) == \".svn\" then\r\n         fs.delete(dir.path(store_dir, module, d))\r\n      end\r\n   end\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 45,
    "text": "function fetch_url(url, filename, cache)\r\n   assert(type(url) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n\r\n   local protocol, pathname = dir.split_url(url)\r\n   if protocol == \"file\" then\r\n      return fs.absolute_name(pathname)\r\n   elseif is_basic_protocol(protocol, true) then\r\n      local ok, filename = fs.download(url, filename, cache)\r\n      if not ok then\r\n         return nil, \"Failed downloading \"..url..(filename and \" - \"..filename or \"\"), \"network\"\r\n      end\r\n      return filename\r\n   else\r\n      return nil, \"Unsupported protocol \"..protocol\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 46,
    "text": "function fetch_url_at_temp_dir(url, tmpname, filename)\r\n   assert(type(url) == \"string\")\r\n   assert(type(tmpname) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n   filename = filename or dir.base_name(url)\r\n\r\n   local protocol, pathname = dir.split_url(url)\r\n   if protocol == \"file\" then\r\n      if fs.exists(pathname) then\r\n         return pathname, dir.dir_name(fs.absolute_name(pathname))\r\n      else\r\n         return nil, \"File not found: \"..pathname\r\n      end\r\n   else\r\n      local temp_dir, err = fs.make_temp_dir(tmpname)\r\n      if not temp_dir then\r\n         return nil, \"Failed creating temporary directory \"..tmpname..\": \"..err\r\n      end\r\n      util.schedule_function(fs.delete, temp_dir)\r\n      local ok, err = fs.change_dir(temp_dir)\r\n      if not ok then return nil, err end\r\n      local file, err, errcode = fetch_url(url, filename)\r\n      fs.pop_dir()\r\n      if not file then\r\n         return nil, \"Error fetching file: \"..err, errcode\r\n      end\r\n      return file, temp_dir\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 47,
    "text": "function fetch_and_unpack_rock(rock_file, dest)\r\n   assert(type(rock_file) == \"string\")\r\n   assert(type(dest) == \"string\" or not dest)\r\n\r\n   local name = dir.base_name(rock_file):match(\"(.*)%.[^.]*%.rock\")\r\n   \r\n   local rock_file, err, errcode = fetch_url_at_temp_dir(rock_file,\"luarocks-rock-\"..name)\r\n   if not rock_file then\r\n      return nil, \"Could not fetch rock file: \" .. err, errcode\r\n   end\r\n\r\n   rock_file = fs.absolute_name(rock_file)\r\n   local unpack_dir\r\n   if dest then\r\n      unpack_dir = dest\r\n      local ok, err = fs.make_dir(unpack_dir)\r\n      if not ok then\r\n         return nil, \"Failed unpacking rock file: \" .. err\r\n      end\r\n   else\r\n      unpack_dir = fs.make_temp_dir(name)\r\n   end\r\n   if not dest then\r\n      util.schedule_function(fs.delete, unpack_dir)\r\n   end\r\n   local ok, err = fs.change_dir(unpack_dir)\r\n   if not ok then return nil, err end\r\n   ok = fs.unzip(rock_file)\r\n   if not ok then\r\n      return nil, \"Failed unpacking rock file: \" .. rock_file\r\n   end\r\n   fs.pop_dir()\r\n   return unpack_dir\r\nend",
    "type": "function"
  }, {
    "id": 48,
    "text": "function url_to_base_dir(url)\r\n   local base = dir.base_name(url)\r\n   return base:gsub(\"%.[^.]*$\", \"\"):gsub(\"%.tar$\", \"\")\r\nend",
    "type": "function"
  }, {
    "id": 49,
    "text": "function load_local_rockspec(filename, quick)\r\n   assert(type(filename) == \"string\")\r\n   filename = fs.absolute_name(filename)\r\n   local rockspec, err = persist.load_into_table(filename)\r\n   if not rockspec then\r\n      return nil, \"Could not load rockspec file \"..filename..\" (\"..err..\")\"\r\n   end\r\n\r\n   local ok, err = true, nil\r\n   if not quick then\r\n      ok, err = type_check.type_check_rockspec(rockspec)\r\n      if not ok then\r\n         return nil, filename..\": \"..err\r\n      end\r\n   end\r\n   \r\n   if rockspec.rockspec_format then\r\n      if deps.compare_versions(rockspec.rockspec_format, type_check.rockspec_format) then\r\n         return nil, \"Rockspec format \"..rockspec.rockspec_format..\" is not supported, please upgrade LuaRocks.\"\r\n      end\r\n   end\r\n\r\n   util.platform_overrides(rockspec.build)\r\n   util.platform_overrides(rockspec.dependencies)\r\n   util.platform_overrides(rockspec.external_dependencies)\r\n   util.platform_overrides(rockspec.source)\r\n   util.platform_overrides(rockspec.hooks)\r\n\r\n   local basename = dir.base_name(filename)\r\n   if basename == \"rockspec\" then\r\n      rockspec.name = rockspec.package:lower()\r\n   else\r\n      rockspec.name = basename:match(\"(.*)-[^-]*-[0-9]*\")\r\n      if not rockspec.name then\r\n         return nil, \"Expected filename in format 'name-version-revision.rockspec'.\"\r\n      end\r\n   end\r\n\r\n   local protocol, pathname = dir.split_url(rockspec.source.url)\r\n   if is_basic_protocol(protocol) then\r\n      rockspec.source.file = rockspec.source.file or dir.base_name(rockspec.source.url)\r\n   end\r\n   rockspec.source.protocol, rockspec.source.pathname = protocol, pathname\r\n\r\n   -- Temporary compatibility\r\n   if rockspec.source.cvs_module then rockspec.source.module = rockspec.source.cvs_module end\r\n   if rockspec.source.cvs_tag then rockspec.source.tag = rockspec.source.cvs_tag end\r\n\r\n   local name_version = rockspec.package:lower() .. \"-\" .. rockspec.version\r\n   if basename ~= \"rockspec\" and basename ~= name_version .. \".rockspec\" then\r\n      return nil, \"Inconsistency between rockspec filename (\"..basename..\") and its contents (\"..name_version..\".rockspec).\"\r\n   end\r\n\r\n   rockspec.local_filename = filename\r\n   local filebase = rockspec.source.file or rockspec.source.url\r\n   local base = url_to_base_dir(filebase)\r\n   rockspec.source.dir = rockspec.source.dir\r\n                      or rockspec.source.module\r\n                      or ((filebase:match(\".lua$\") or filebase:match(\".c$\")) and \".\")\r\n                      or base\r\n   if rockspec.dependencies then\r\n      for i = 1, #rockspec.dependencies do\r\n         local parsed, err = deps.parse_dep(rockspec.dependencies[i])\r\n         if not parsed then\r\n            return nil, \"Parse error processing dependency '\"..rockspec.dependencies[i]..\"': \"..tostring(err)\r\n         end\r\n         rockspec.dependencies[i] = parsed\r\n      end\r\n   else\r\n      rockspec.dependencies = {}\r\n   end\r\n   if not quick then\r\n      path.configure_paths(rockspec)\r\n   end\r\n\r\n   return rockspec\r\nend",
    "type": "function"
  }, {
    "id": 50,
    "text": "function load_rockspec(filename, location)\r\n   assert(type(filename) == \"string\")\r\n\r\n   local name\r\n   local basename = dir.base_name(filename)\r\n   if basename == \"rockspec\" then\r\n      name = \"rockspec\"\r\n   else\r\n      name = basename:match(\"(.*)%.rockspec\")\r\n      if not name then\r\n         return nil, \"Filename '\"..filename..\"' does not look like a rockspec.\"\r\n      end\r\n   end\r\n   \r\n   local err, errcode\r\n   if location then\r\n      local ok, err = fs.change_dir(location)\r\n      if not ok then return nil, err end\r\n      filename, err = fetch_url(filename)\r\n      fs.pop_dir()\r\n   else\r\n      filename, err, errcode = fetch_url_at_temp_dir(filename,\"luarocks-rockspec-\"..name)\r\n   end\r\n   if not filename then\r\n      return nil, err, errcode\r\n   end\r\n\r\n   return load_local_rockspec(filename)\r\nend",
    "type": "function"
  }, {
    "id": 51,
    "text": "function is_writable(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   local result\r\n   if fs.is_dir(file) then\r\n      local file2 = dir.path(file, '.tmpluarockstestwritable')\r\n      local fh = io.open(file2, 'wb')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n      os.remove(file2)\r\n   else\r\n      local fh = io.open(file, 'r+b')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 52,
    "text": "function make_temp_dir(name)\r\n   assert(type(name) == \"string\")\r\n   name = dir.normalize(name)\r\n\r\n   local temp_dir = (os.getenv(\"TMP\") or \"/tmp\") .. \"/luarocks_\" .. name:gsub(dir.separator, \"_\") .. \"-\" .. tostring(math.floor(math.random() * 10000))\r\n   local ok, err = fs.make_dir(temp_dir)\r\n   if ok then\r\n      return temp_dir\r\n   else\r\n      return nil, err\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 53,
    "text": "function check_md5(file, md5sum)\r\n   file = dir.normalize(file)\r\n   local computed, msg = fs.get_md5(file)\r\n   if not computed then\r\n      return false, msg\r\n   end\r\n   if computed:match(\"^\"..md5sum) then\r\n      return true\r\n   else\r\n      return false, \"Mismatch MD5 hash for file \"..file\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 54,
    "text": "function change_dir(d)\r\n   table.insert(dir_stack, lfs.currentdir())\r\n   d = dir.normalize(d)\r\n   return lfs.chdir(d)\r\nend",
    "type": "function"
  }, {
    "id": 55,
    "text": "function make_dir(directory)\r\n   assert(type(directory) == \"string\")\r\n   directory = dir.normalize(directory)\r\n   local path = nil\r\n   if directory:sub(2, 2) == \":\" then\r\n     path = directory:sub(1, 2)\r\n     directory = directory:sub(4)\r\n   else\r\n     if directory:match(\"^/\") then\r\n        path = \"\"\r\n     end\r\n   end\r\n   for d in directory:gmatch(\"([^\"..dir.separator..\"]+)\"..dir.separator..\"*\") do\r\n      path = path and path .. dir.separator .. d or d\r\n      local mode = lfs.attributes(path, \"mode\")\r\n      if not mode then\r\n         local ok, err = lfs.mkdir(path)\r\n         if not ok then\r\n            return false, err\r\n         end\r\n      elseif mode ~= \"directory\" then\r\n         return false, path..\" is not a directory\"\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 56,
    "text": "function remove_dir_if_empty(d)\r\n   assert(d)\r\n   d = dir.normalize(d)\r\n   lfs.rmdir(d)\r\nend",
    "type": "function"
  }, {
    "id": 57,
    "text": "function remove_dir_tree_if_empty(d)\r\n   assert(d)\r\n   d = dir.normalize(d)\r\n   for i=1,10 do\r\n      lfs.rmdir(d)\r\n      d = dir.dir_name(d)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 58,
    "text": "function copy(src, dest, perms)\r\n   assert(src and dest)\r\n   src = dir.normalize(src)\r\n   dest = dir.normalize(dest)\r\n   local destmode = lfs.attributes(dest, \"mode\")\r\n   if destmode == \"directory\" then\r\n      dest = dir.path(dest, dir.base_name(src))\r\n   end\r\n   if not perms then perms = fs.get_permissions(src) end\r\n   local src_h, err = io.open(src, \"rb\")\r\n   if not src_h then return nil, err end\r\n   local dest_h, err = io.open(dest, \"w+b\")\r\n   if not dest_h then src_h:close() return nil, err end\r\n   while true do\r\n      local block = src_h:read(8192)\r\n      if not block then break end\r\n      dest_h:write(block)\r\n   end\r\n   src_h:close()\r\n   dest_h:close()\r\n   fs.chmod(dest, perms)\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 59,
    "text": "local function recursive_copy(src, dest)\r\n   local srcmode = lfs.attributes(src, \"mode\")\r\n\r\n   if srcmode == \"file\" then\r\n      local ok = fs.copy(src, dest)\r\n      if not ok then return false end\r\n   elseif srcmode == \"directory\" then\r\n      local subdir = dir.path(dest, dir.base_name(src))\r\n      local ok, err = fs.make_dir(subdir)\r\n      if not ok then return nil, err end\r\n      for file in lfs.dir(src) do\r\n         if file ~= \".\" and file ~= \"..\" then\r\n            local ok = recursive_copy(dir.path(src, file), subdir)\r\n            if not ok then return false end\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 60,
    "text": "function copy_contents(src, dest)\r\n   assert(src and dest)\r\n   src = dir.normalize(src)\r\n   dest = dir.normalize(dest)\r\n   assert(lfs.attributes(src, \"mode\") == \"directory\")\r\n\r\n   for file in lfs.dir(src) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         local ok = recursive_copy(dir.path(src, file), dest)\r\n         if not ok then\r\n            return false, \"Failed copying \"..src..\" to \"..dest\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 61,
    "text": "local function recursive_delete(name)\r\n   local ok = os.remove(name)\r\n   if ok then return true end\r\n   local pok, ok, err = pcall(function()\r\n      for file in lfs.dir(name) do\r\n         if file ~= \".\" and file ~= \"..\" then\r\n            local ok, err = recursive_delete(dir.path(name, file))\r\n            if not ok then return nil, err end\r\n         end\r\n      end\r\n      local ok, err = lfs.rmdir(name)\r\n      return ok, (not ok) and err\r\n   end)\r\n   if pok then\r\n      return ok, err\r\n   else\r\n      return pok, ok\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 62,
    "text": "function delete(name)\r\n   name = dir.normalize(name)\r\n   recursive_delete(name)\r\nend",
    "type": "function"
  }, {
    "id": 63,
    "text": "function list_dir(at)\r\n   assert(type(at) == \"string\" or not at)\r\n   if not at then\r\n      at = fs.current_dir()\r\n   end\r\n   at = dir.normalize(at)\r\n   if not fs.is_dir(at) then\r\n      return {}\r\n   end\r\n   local result = {}\r\n   for file in lfs.dir(at) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         table.insert(result, file)\r\n      end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 64,
    "text": "local function recursive_find(cwd, prefix, result)\r\n   for file in lfs.dir(cwd) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         local item = prefix .. file\r\n         table.insert(result, item)\r\n         local pathname = dir.path(cwd, file)\r\n         if lfs.attributes(pathname, \"mode\") == \"directory\" then\r\n            recursive_find(pathname, item..dir_separator, result)\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 65,
    "text": "function find(at)\r\n   assert(type(at) == \"string\" or not at)\r\n   if not at then\r\n      at = fs.current_dir()\r\n   end\r\n   at = dir.normalize(at)\r\n   if not fs.is_dir(at) then\r\n      return {}\r\n   end\r\n   local result = {}\r\n   recursive_find(at, \"\", result)\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 66,
    "text": "function exists(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   return type(lfs.attributes(file)) == \"table\"\r\nend",
    "type": "function"
  }, {
    "id": 67,
    "text": "function is_dir(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   return lfs.attributes(file, \"mode\") == \"directory\"\r\nend",
    "type": "function"
  }, {
    "id": 68,
    "text": "function is_file(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   return lfs.attributes(file, \"mode\") == \"file\"\r\nend",
    "type": "function"
  }, {
    "id": 69,
    "text": "function set_time(file, time)\r\n   file = dir.normalize(file)\r\n   return lfs.touch(file, time)\r\nend",
    "type": "function"
  }, {
    "id": 70,
    "text": "function unzip(zipfile)\r\n   local zipfile, err = luazip.open(zipfile)\r\n   if not zipfile then return nil, err end\r\n   local files = zipfile:files()\r\n   local file = files()\r\n   repeat\r\n      if file.filename:sub(#file.filename) == \"/\" then\r\n         local ok, err = fs.make_dir(dir.path(fs.current_dir(), file.filename))\r\n         if not ok then return nil, err end\r\n      else\r\n         local rf, err = zipfile:open(file.filename)\r\n         if not rf then zipfile:close(); return nil, err end\r\n         local contents = rf:read(\"*a\")\r\n         rf:close()\r\n         local wf, err = io.open(dir.path(fs.current_dir(), file.filename), \"wb\")\r\n         if not wf then zipfile:close(); return nil, err end\r\n         wf:write(contents)\r\n         wf:close()\r\n      end\r\n      file = files()\r\n   until not file\r\n   zipfile:close()\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 71,
    "text": "local function request(url, method, http, loop_control)\r\n   local result = {}\r\n   \r\n   local proxy = cfg.proxy\r\n   if type(proxy) ~= \"string\" then proxy = nil end\r\n   -- LuaSocket's http.request crashes when given URLs missing the scheme part.\r\n   if proxy and not proxy:find(\"://\") then\r\n      proxy = \"http://\" .. proxy\r\n   end\r\n   \r\n   if cfg.show_downloads then\r\n      io.write(method..\" \"..url..\" ...\\n\")\r\n   end\r\n   local dots = 0\r\n   local res, status, headers, err = http.request {\r\n      url = url,\r\n      proxy = proxy,\r\n      method = method,\r\n      redirect = false,\r\n      sink = ltn12.sink.table(result),\r\n      step = cfg.show_downloads and function(...)\r\n         io.write(\".\")\r\n         io.flush()\r\n         dots = dots + 1\r\n         if dots == 70 then\r\n            io.write(\"\\n\")\r\n            dots = 0\r\n         end\r\n         return ltn12.pump.step(...)\r\n      end,\r\n      headers = {\r\n         [\"user-agent\"] = cfg.user_agent..\" via LuaSocket\"\r\n      },\r\n   }\r\n   if cfg.show_downloads then\r\n      io.write(\"\\n\")\r\n   end\r\n   if not res then\r\n      return nil, status\r\n   elseif status == 301 or status == 302 then\r\n      local location = headers.location\r\n      if location then\r\n         local protocol, rest = dir.split_url(location)\r\n         if redirect_protocols[protocol] then\r\n            if not loop_control then\r\n               loop_control = {}\r\n            elseif loop_control[location] then\r\n               return nil, \"Redirection loop -- broken URL?\"\r\n            end\r\n            loop_control[url] = true\r\n            return request(location, method, redirect_protocols[protocol], loop_control)\r\n         else\r\n            return nil, \"URL redirected to unsupported protocol - install luasec to get HTTPS support.\"\r\n         end\r\n      end\r\n      return nil, err\r\n   elseif status ~= 200 then\r\n      return nil, err\r\n   else\r\n      return result, status, headers, err\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 72,
    "text": "function download(url, filename, cache)\r\n   assert(type(url) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n\r\n   filename = fs.absolute_name(filename or dir.base_name(url))\r\n   \r\n   local content, err\r\n   if util.starts_with(url, \"http:\") then\r\n      content, err = http_request(url, http, cache and filename)\r\n   elseif util.starts_with(url, \"ftp:\") then\r\n      content, err = ftp.get(url)\r\n   elseif util.starts_with(url, \"https:\") then\r\n      if luasec_ok then\r\n         content, err = http_request(url, https, cache and filename)\r\n      else\r\n         err = \"Unsupported protocol - install luasec to get HTTPS support.\"\r\n      end\r\n   else\r\n      err = \"Unsupported protocol\"\r\n   end\r\n   if cache and content == true then\r\n      return true, filename\r\n   end\r\n   if not content then\r\n      return false, tostring(err)\r\n   end\r\n   local file = io.open(filename, \"wb\")\r\n   if not file then return false end\r\n   file:write(content)\r\n   file:close()\r\n   return true, filename\r\nend",
    "type": "function"
  }, {
    "id": 73,
    "text": "function check_command_permissions(flags)\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   local ok = true\r\n   local err = \"\"\r\n   for _, dir in ipairs { cfg.rocks_dir, root_dir } do\r\n      if fs.exists(dir) and not fs.is_writable(dir) then\r\n         ok = false\r\n         err = \"Your user does not have write permissions in \" .. dir\r\n         break\r\n      end\r\n   end\r\n   local root_parent = dir.dir_name(root_dir)\r\n   if ok and not fs.exists(root_dir) and not fs.is_writable(root_parent) then\r\n      ok = false\r\n      err = root_dir..\" does not exist and your user does not have write permissions in \" .. root_parent\r\n   end\r\n   if ok then\r\n      return true\r\n   else\r\n      if flags[\"local\"] then\r\n         err = err .. \" \\n-- please check your permissions.\"\r\n      else\r\n         err = err .. \" \\n-- you may want to run as a privileged user or use your local tree with --local.\"\r\n      end\r\n      return nil, err\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 74,
    "text": "function copy(src, dest, perm)\r\n   assert(src and dest)\r\n   if fs.execute(vars.CP, src, dest) then\r\n      if perm then\r\n         if fs.is_dir(dest) then\r\n            dest = dir.path(dest, dir.base_name(src))\r\n         end\r\n         if fs.chmod(dest, perm) then\r\n            return true\r\n         else\r\n            return false, \"Failed setting permissions of \"..dest\r\n         end\r\n      end\r\n      return true\r\n   else\r\n      return false, \"Failed copying \"..src..\" to \"..dest\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 75,
    "text": "function download(url, filename, cache)\r\n   assert(type(url) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n\r\n   filename = fs.absolute_name(filename or dir.base_name(url))\r\n\r\n   local ok\r\n   if cfg.downloader == \"wget\" then\r\n      local wget_cmd = vars.WGET..\" --no-check-certificate --no-cache --user-agent='\"..cfg.user_agent..\" via wget' --quiet \"\r\n      if cache then\r\n         -- --timestamping is incompatible with --output-document,\r\n         -- but that's not a problem for our use cases.\r\n         fs.change_dir(dir.dir_name(filename))\r\n         ok = fs.execute(wget_cmd..\" --timestamping \", url)\r\n         fs.pop_dir()\r\n      elseif filename then\r\n         ok = fs.execute(wget_cmd..\" --output-document \"..fs.Q(filename), url)\r\n      else\r\n         ok = fs.execute(wget_cmd, url)\r\n      end\r\n   elseif cfg.downloader == \"curl\" then\r\n      ok = fs.execute_string(vars.CURL..\" -L --user-agent '\"..cfg.user_agent..\" via curl' \"..fs.Q(url)..\" 2> /dev/null 1> \"..fs.Q(filename))\r\n   end\r\n   if ok then\r\n      return true, filename\r\n   else\r\n      return false\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 76,
    "text": "function wrap_script(file, dest, name, version)\r\n   assert(type(file) == \"string\")\r\n   assert(type(dest) == \"string\")\r\n   \r\n   local base = dir.base_name(file)\r\n   local wrapname = fs.is_dir(dest) and dest..\"/\"..base or dest\r\n   local lpath, lcpath = cfg.package_paths()\r\n   local wrapper = io.open(wrapname, \"w\")\r\n   if not wrapper then\r\n      return nil, \"Could not open \"..wrapname..\" for writing.\"\r\n   end\r\n   wrapper:write(\"#!/bin/sh\\n\\n\")\r\n   local lua = dir.path(cfg.variables[\"LUA_BINDIR\"], cfg.lua_interpreter)\r\n   local ppaths = \"package.path=\"..util.LQ(lpath..\";\")..\"..package.path; package.cpath=\"..util.LQ(lcpath..\";\")..\"..package.cpath\"\r\n   local addctx = \"local k,l,_=pcall(require,\"..util.LQ(\"luarocks.loader\")..\") _=k and l.add_context(\"..util.LQ(name)..\",\"..util.LQ(version)..\")\"\r\n   wrapper:write('exec '..fs.Q(lua)..' -e '..fs.Q(ppaths)..' -e '..fs.Q(addctx)..' '..fs.Q(file)..' \"$@\"\\n')\r\n   wrapper:close()\r\n   if fs.chmod(wrapname, \"0755\") then\r\n      return true\r\n   else\r\n      return nil, \"Could not make \"..wrapname..\" executable.\"\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 77,
    "text": "function make_dir(directory)\r\n   assert(directory)\r\n   directory = dir.normalize(directory)\r\n   fs.execute_quiet(fs.Q(vars.MKDIR)..\" -p \", directory)\r\n   if not fs.is_dir(directory) then\r\n      return false, \"failed making directory \"..directory\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 78,
    "text": "function download(url, filename, cache)\r\n   assert(type(url) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n\r\n   filename = fs.absolute_name(filename or dir.base_name(url))\r\n\r\n   local ok   \r\n   if cfg.downloader == \"wget\" then\r\n      local wget_cmd = fs.Q(vars.WGET)..\" --no-check-certificate --no-cache --user-agent=\\\"\"..cfg.user_agent..\" via wget\\\" --quiet \"\r\n      if cache then\r\n         -- --timestamping is incompatible with --output-document,\r\n         -- but that's not a problem for our use cases.\r\n         fs.change_dir(dir.dir_name(filename))\r\n         ok = fs.execute(wget_cmd..\" --timestamping \"..fs.Q(url)..\" 2> NUL 1> NUL\")\r\n         fs.pop_dir()\r\n      elseif filename then\r\n         ok = fs.execute(wget_cmd..\" --output-document \"..fs.Q(filename)..\" \"..fs.Q(url)..\" 2> NUL 1> NUL\")\r\n      else\r\n         ok = fs.execute(wget_cmd..fs.Q(url)..\" 2> NUL 1> NUL\")\r\n      end\r\n   elseif cfg.downloader == \"curl\" then\r\n      ok = fs.execute_string(fs.Q(vars.CURL)..\" -L --user-agent \\\"\"..cfg.user_agent..\" via curl\\\" \"..fs.Q(url)..\" 2> NUL 1> \"..fs.Q(filename))\r\n   end\r\n   if ok then\r\n      return true, filename\r\n   else\r\n      return false\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 79,
    "text": "function wrap_script(file, dest, name, version)\r\n   assert(type(file) == \"string\")\r\n   assert(type(dest) == \"string\")\r\n\r\n   local base = dir.base_name(file)\r\n   local wrapname = fs.is_dir(dest) and dest..\"/\"..base or dest\r\n   wrapname = wrapname..\".bat\"\r\n   local lpath, lcpath = cfg.package_paths()\r\n   local wrapper = io.open(wrapname, \"w\")\r\n   if not wrapper then\r\n      return nil, \"Could not open \"..wrapname..\" for writing.\"\r\n   end\r\n   wrapper:write(\"@echo off\\n\")\r\n   local lua = dir.path(cfg.variables[\"LUA_BINDIR\"], cfg.lua_interpreter)\r\n   local ppaths = \"package.path=\"..util.LQ(lpath..\";\")..\"..package.path; package.cpath=\"..util.LQ(lcpath..\";\")..\"..package.cpath\"\r\n   local addctx = \"local k,l,_=pcall(require,\"..util.LQ(\"luarocks.loader\")..\") _=k and l.add_context(\"..util.LQ(name)..\",\"..util.LQ(version)..\")\"\r\n   wrapper:write(fs.Qb(lua)..' -e '..fs.Qb(ppaths)..' -e '..fs.Qb(addctx)..' '..fs.Qb(file)..' %*\\n')\r\n   wrapper:close()\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 80,
    "text": "function copy_binary(filename, dest) \r\n   local ok, err = fs.copy(filename, dest)\r\n   if not ok then\r\n      return nil, err\r\n   end\r\n   local exe_pattern = \"%.[Ee][Xx][Ee]$\"\r\n   local base = dir.base_name(filename)\r\n   local dest = dir.dir_name(dest)\r\n   if base:match(exe_pattern) then\r\n      base = base:gsub(exe_pattern, \".lua\")\r\n      local helpname = dest..\"/\"..base\r\n      local helper = io.open(helpname, \"w\")\r\n      if not helper then\r\n         return nil, \"Could not open \"..helpname..\" for writing.\"\r\n      end\r\n      helper:write('package.path=\\\"'..package.path:gsub(\"\\\\\",\"\\\\\\\\\")..';\\\"..package.path\\n')\r\n      helper:write('package.cpath=\\\"'..package.path:gsub(\"\\\\\",\"\\\\\\\\\")..';\\\"..package.cpath\\n')\r\n      helper:close()\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 81,
    "text": "function is_writable(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   local result\r\n   local tmpname = 'tmpluarockstestwritable.deleteme'\r\n   if fs.is_dir(file) then\r\n      local file2 = dir.path(file, tmpname)\r\n      local fh = io.open(file2, 'wb')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n      if result then\r\n         -- the above test might give a false positive when writing to\r\n         -- c:\\program files\\ because of VirtualStore redirection on Vista and up\r\n         -- So check whether it's really there\r\n         result = fs.exists(file2)\r\n      end\r\n      os.remove(file2)\r\n   else\r\n      local fh = io.open(file, 'r+b')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 82,
    "text": "function run(...)\r\n   local flags, command = util.parse_flags(...)\r\n\r\n   if not command then\r\n      local sys_file, sys_ok, home_file, home_ok = cfg.which_config()\r\n      print_banner()\r\n      print_section(\"NAME\")\r\n      util.printout(\"\\t\"..program..[[ - ]]..program_description)\r\n      print_section(\"SYNOPSIS\")\r\n      util.printout(\"\\t\"..program..[[ [--from=<server> | --only-from=<server>] [--to=<tree>] [VAR=VALUE]... <command> [<argument>] ]])\r\n      print_section(\"GENERAL OPTIONS\")\r\n      util.printout([[\r\n\tThese apply to all commands, as appropriate:\r\n\r\n\t--server=<server>      Fetch rocks/rockspecs from this server\r\n\t                       (takes priority over config file)\r\n\t--only-server=<server> Fetch rocks/rockspecs from this server only\r\n\t                       (overrides any entries in the config file)\r\n\t--only-sources=<url>   Restrict downloads to paths matching the\r\n\t                       given URL.\r\n\t--tree=<tree>          Which tree to operate on.\r\n\t--local                Use the tree in the user's home directory.\r\n\t                       To enable it, see ']]..program..[[ help path'.]])\r\n      print_section(\"VARIABLES\")\r\n      util.printout([[\r\n\tVariables from the \"variables\" table of the configuration file\r\n\tcan be overriden with VAR=VALUE assignments.]])\r\n      print_section(\"COMMANDS\")\r\n      local names = {}\r\n      for name, command in util.sortedpairs(commands) do\r\n         local cmd = require(command)\r\n         util.printout(\"\", name)\r\n         util.printout(\"\\t\", cmd.help_summary)\r\n      end\r\n      print_section(\"CONFIGURATION\")\r\n      util.printout(\"\\tLua version: \" .. cfg.lua_version)\r\n      util.printout(\"\\tConfiguration files:\")\r\n      util.printout(\"\\t\\tSystem: \".. dir.normalize(sys_file) .. \" (\" .. get_status(sys_ok) ..\")\")\r\n      if home_file then\r\n         util.printout(\"\\t\\tUser  : \".. dir.normalize(home_file) .. \" (\" .. get_status(home_ok) ..\")\\n\")\r\n      else\r\n         util.printout(\"\\t\\tUser  : disabled in this LuaRocks installation.\\n\")\r\n      end\r\n      util.printout(\"\\tRocks trees in use: \")\r\n      for _, tree in ipairs(cfg.rocks_trees) do\r\n      \tif type(tree) == \"string\" then\r\n      \t   util.printout(\"\\t\\t\"..dir.normalize(tree))\r\n      \telse\r\n      \t   local name = tree.name and \" (\\\"\"..tree.name..\"\\\")\" or \"\"\r\n      \t   util.printout(\"\\t\\t\"..dir.normalize(tree.root)..name)\r\n      \tend\r\n      end\r\n   else\r\n      command = command:gsub(\"-\", \"_\")\r\n      local cmd = require(commands[command])\r\n      if cmd then\r\n         local arguments = cmd.help_arguments or \"<argument>\"\r\n         print_banner()\r\n         print_section(\"NAME\")\r\n         util.printout(\"\\t\"..program..\" \"..command..\" - \"..cmd.help_summary)\r\n         print_section(\"SYNOPSIS\")\r\n         util.printout(\"\\t\"..program..\" \"..command..\" \"..arguments)\r\n         print_section(\"DESCRIPTION\")\r\n         util.printout(\"\",(cmd.help:gsub(\"\\n\",\"\\n\\t\"):gsub(\"\\n\\t$\",\"\")))\r\n         print_section(\"SEE ALSO\")\r\n         util.printout(\"\",\"'\"..program..\" help' for general options and configuration.\\n\")\r\n      else\r\n         return nil, \"Unknown command '\"..command..\"'\"\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 83,
    "text": "function make_index(repo)\r\n   if not fs.is_dir(repo) then\r\n      return nil, \"Cannot access repository at \"..repo\r\n   end\r\n   local manifest = manif.load_manifest(repo)\r\n   local out = io.open(dir.path(repo, \"index.html\"), \"w\")\r\n   \r\n   out:write(index_header)\r\n   for package, version_list in util.sortedpairs(manifest.repository) do\r\n      local latest_rockspec = nil\r\n      local output = index_package_begin\r\n      for version, data in util.sortedpairs(version_list, deps.compare_versions) do\r\n         local versions = {}\r\n         output = output..version..':&nbsp;'\r\n         table.sort(data, function(a,b) return a.arch < b.arch end)\r\n         for _, item in ipairs(data) do\r\n            local file\r\n            if item.arch == 'rockspec' then\r\n               file = (\"%s-%s.rockspec\"):format(package, version)\r\n               if not latest_rockspec then latest_rockspec = file end\r\n            else\r\n               file = (\"%s-%s.%s.rock\"):format(package, version, item.arch)\r\n            end\r\n            table.insert(versions, '<a href=\"'..file..'\">'..item.arch..'</a>')\r\n         end\r\n         output = output .. table.concat(versions, ',&nbsp;') .. '<br/>'\r\n      end\r\n      output = output .. index_package_end\r\n      if latest_rockspec then\r\n         local rockspec = persist.load_into_table(dir.path(repo, latest_rockspec))\r\n         local descript = rockspec.description or {}\r\n         local vars = {\r\n            anchor = package,\r\n            package = rockspec.package,\r\n            original = rockspec.source.url,\r\n            summary = descript.summary or \"\",\r\n            detailed = descript.detailed or \"\",\r\n            license = descript.license or \"N/A\",\r\n            homepage = descript.homepage and ('| <a href=\"'..descript.homepage..'\"'..ext_url_target..'>project homepage</a>') or \"\",\r\n            externaldependencies = format_external_dependencies(rockspec)\r\n         }\r\n         vars.detailed = vars.detailed:gsub(\"\\n\\n\", \"</p><p>\"):gsub(\"%s+\", \" \")\r\n         vars.detailed = vars.detailed:gsub(\"(https?://[a-zA-Z0-9%.%%-_%+%[%]=%?&/$@;:]+)\", '<a href=\"%1\"'..ext_url_target..'>%1</a>')\r\n         output = output:gsub(\"$(%w+)\", vars)\r\n      else\r\n         output = output:gsub(\"$anchor\", package)\r\n         output = output:gsub(\"$package\", package)\r\n         output = output:gsub(\"$(%w+)\", \"\")\r\n      end\r\n      out:write(output)\r\n   end\r\n   out:write(index_footer_begin)\r\n   for ver in util.lua_versions() do\r\n      out:write((index_manifest_ver:gsub(\"$VER\", ver)))\r\n   end\r\n   out:write(index_footer_end)\r\n   out:close()\r\nend",
    "type": "function"
  }, {
    "id": 84,
    "text": "function run(...)\r\n   local flags, repo = util.parse_flags(...)\r\n\r\n   assert(type(repo) == \"string\" or not repo)\r\n   repo = repo or cfg.rocks_dir\r\n  \r\n   util.printout(\"Making manifest for \"..repo)\r\n   \r\n   if repo:match(\"/lib/luarocks\") and not flags[\"local-tree\"] then\r\n      util.warning(\"This looks like a local rocks tree, but you did not pass --local-tree.\")\r\n   end\r\n   \r\n   local ok, err = manif.make_manifest(repo, deps.get_deps_mode(flags), not flags[\"local-tree\"])\r\n   if ok and not flags[\"local-tree\"] then\r\n      util.printout(\"Generating index.html for \"..repo)\r\n      index.make_index(repo)\r\n   end\r\n   if flags[\"local-tree\"] then\r\n      for luaver in util.lua_versions() do\r\n         fs.delete(dir.path(repo, \"manifest-\"..luaver))\r\n      end\r\n   end\r\n   return ok, err\r\nend",
    "type": "function"
  }, {
    "id": 85,
    "text": "local function save_table(where, name, tbl)\r\n   assert(type(where) == \"string\")\r\n   assert(type(name) == \"string\")\r\n   assert(type(tbl) == \"table\")\r\n\r\n   local filename = dir.path(where, name)\r\n   local ok, err = persist.save_from_table(filename..\".tmp\", tbl)\r\n   if ok then\r\n      ok, err = fs.replace_file(filename, filename..\".tmp\")\r\n   end\r\n   return ok, err\r\nend",
    "type": "function"
  }, {
    "id": 86,
    "text": "function make_rock_manifest(name, version)\r\n   local install_dir = path.install_dir(name, version)\r\n   local rock_manifest = path.rock_manifest_file(name, version)\r\n   local tree = {}\r\n   for _, file in ipairs(fs.find(install_dir)) do\r\n      local full_path = dir.path(install_dir, file)\r\n      local walk = tree\r\n      local last\r\n      local last_name\r\n      for name in file:gmatch(\"[^/]+\") do\r\n         local next = walk[name]\r\n         if not next then\r\n            next = {}\r\n            walk[name] = next\r\n         end\r\n         last = walk\r\n         last_name = name\r\n         walk = next\r\n      end\r\n      if fs.is_file(full_path) then\r\n         local sum, err = fs.get_md5(full_path)\r\n         if not sum then\r\n            return nil, \"Failed producing checksum: \"..tostring(err)\r\n         end\r\n         last[last_name] = sum\r\n      end\r\n   end\r\n   local rock_manifest = { rock_manifest=tree }\r\n   rock_manifest_cache[name..\"/\"..version] = rock_manifest\r\n   save_table(install_dir, \"rock_manifest\", rock_manifest )\r\nend",
    "type": "function"
  }, {
    "id": 87,
    "text": "local function fetch_manifest_from(repo_url, filename)\r\n   local url = dir.path(repo_url, filename)\r\n   local name = repo_url:gsub(\"[/:]\",\"_\")\r\n   local cache_dir = dir.path(cfg.local_cache, name)\r\n   local ok = fs.make_dir(cache_dir)\r\n   if not ok then\r\n      return nil, \"Failed creating temporary cache directory \"..cache_dir\r\n   end\r\n   local file, err, errcode = fetch.fetch_url(url, dir.path(cache_dir, filename), true)\r\n   if not file then\r\n      return nil, \"Failed fetching manifest for \"..repo_url..(err and \" - \"..err or \"\"), errcode\r\n   end\r\n   return file\r\nend",
    "type": "function"
  }, {
    "id": 88,
    "text": "function load_manifest(repo_url)\r\n   assert(type(repo_url) == \"string\")\r\n\r\n   if manif_core.manifest_cache[repo_url] then\r\n      return manif_core.manifest_cache[repo_url]\r\n   end\r\n   \r\n   local filenames = {\r\n      \"manifest-\"..cfg.lua_version..\".zip\",\r\n      \"manifest-\"..cfg.lua_version,\r\n      \"manifest\",\r\n   }\r\n\r\n   local protocol, repodir = dir.split_url(repo_url)\r\n   local pathname\r\n   if protocol == \"file\" then\r\n      for _, filename in ipairs(filenames) do\r\n         pathname = dir.path(repodir, filename)\r\n         if fs.exists(pathname) then\r\n            break\r\n         end\r\n      end\r\n   else\r\n      local err\r\n      for _, filename in ipairs(filenames) do\r\n         pathname, err = fetch_manifest_from(repo_url, filename)\r\n         if pathname then\r\n            break\r\n         end\r\n      end\r\n      if not pathname then \r\n         return nil, err\r\n      end\r\n   end\r\n   if pathname:match(\".*%.zip$\") then\r\n      pathname = fs.absolute_name(pathname)\r\n      local dir = dir.dir_name(pathname)\r\n      fs.change_dir(dir)\r\n      local nozip = pathname:match(\"(.*)%.zip$\")\r\n      fs.delete(nozip)\r\n      local ok = fs.unzip(pathname)\r\n      fs.pop_dir()\r\n      if not ok then\r\n         fs.delete(pathname)\r\n         fs.delete(pathname..\".timestamp\")\r\n         return nil, \"Failed extracting manifest file\"\r\n      end\r\n      pathname = nozip\r\n   end\r\n   return manif_core.manifest_loader(pathname, repo_url)\r\nend",
    "type": "function"
  }, {
    "id": 89,
    "text": "local function filter_by_lua_version(manifest, lua_version, repodir, cache)\r\n   assert(type(manifest) == \"table\")\r\n   assert(type(repodir) == \"string\")\r\n   assert((not cache) or type(cache) == \"table\")\r\n   \r\n   cache = cache or {}\r\n   lua_version = deps.parse_version(lua_version)\r\n   for pkg, versions in pairs(manifest.repository) do\r\n      local to_remove = {}\r\n      for version, repositories in pairs(versions) do\r\n         for _, repo in ipairs(repositories) do\r\n            if repo.arch == \"rockspec\" then\r\n               local pathname = dir.path(repodir, pkg..\"-\"..version..\".rockspec\")\r\n               local rockspec, err = cache[pathname]\r\n               if not rockspec then\r\n                  rockspec, err = fetch.load_local_rockspec(pathname, true)\r\n               end\r\n               if rockspec then\r\n                  cache[pathname] = rockspec\r\n                  for _, dep in ipairs(rockspec.dependencies) do\r\n                     if dep.name == \"lua\" then \r\n                        if not deps.match_constraints(lua_version, dep.constraints) then\r\n                           table.insert(to_remove, version)\r\n                        end\r\n                        break\r\n                     end\r\n                  end\r\n               else\r\n                  util.printerr(\"Error loading rockspec for \"..pkg..\" \"..version..\": \"..err)\r\n               end\r\n            end\r\n         end\r\n      end\r\n      if next(to_remove) then\r\n         for _, incompat in ipairs(to_remove) do\r\n            versions[incompat] = nil\r\n         end\r\n         if not next(versions) then\r\n            manifest.repository[pkg] = nil\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 90,
    "text": "function zip_manifests()\r\n   for ver in util.lua_versions() do\r\n      local file = \"manifest-\"..ver\r\n      local zip = file..\".zip\"\r\n      fs.delete(dir.path(fs.current_dir(), zip))\r\n      fs.zip(zip, file)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 91,
    "text": "function load_local_manifest(repo_url)\r\n   assert(type(repo_url) == \"string\")\r\n\r\n   if manifest_cache[repo_url] then\r\n      return manifest_cache[repo_url]\r\n   end\r\n\r\n   local pathname = dir.path(repo_url, \"manifest\")\r\n\r\n   return manifest_loader(pathname, repo_url, true)\r\nend",
    "type": "function"
  }, {
    "id": 92,
    "text": "local function pack_source_rock(rockspec_file)\r\n   assert(type(rockspec_file) == \"string\")\r\n\r\n   local rockspec, err = fetch.load_rockspec(rockspec_file)\r\n   if err then\r\n      return nil, \"Error loading rockspec: \"..err\r\n   end\r\n   rockspec_file = rockspec.local_filename\r\n\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local rock_file = fs.absolute_name(name_version .. \".src.rock\")\r\n\r\n   local source_file, source_dir = fetch.fetch_sources(rockspec, false)\r\n   if not source_file then\r\n      return nil, source_dir\r\n   end\r\n   local ok, err = fs.change_dir(source_dir)\r\n   if not ok then return nil, err end\r\n\r\n   fs.delete(rock_file)\r\n   fs.copy(rockspec_file, source_dir)\r\n   if not fs.zip(rock_file, dir.base_name(rockspec_file), dir.base_name(source_file)) then\r\n      return nil, \"Failed packing \"..rock_file\r\n   end\r\n   fs.pop_dir()\r\n\r\n   return rock_file\r\nend",
    "type": "function"
  }, {
    "id": 93,
    "text": "local function copy_back_files(name, version, file_tree, deploy_dir, pack_dir)\r\n   local ok, err = fs.make_dir(pack_dir)\r\n   if not ok then return nil, err end\r\n   for file, sub in pairs(file_tree) do\r\n      local source = dir.path(deploy_dir, file)\r\n      local target = dir.path(pack_dir, file)\r\n      if type(sub) == \"table\" then\r\n         local ok, err = copy_back_files(name, version, sub, source, target)\r\n         if not ok then return nil, err end\r\n      else\r\n         local versioned = path.versioned_name(source, deploy_dir, name, version)\r\n         if fs.exists(versioned) then\r\n            fs.copy(versioned, target)\r\n         else\r\n            fs.copy(source, target)\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 94,
    "text": "local function do_pack_binary_rock(name, version)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\" or not version)\r\n\r\n   local query = search.make_query(name, version)\r\n   query.exact_name = true\r\n   local results = {}\r\n   \r\n   search.manifest_search(results, cfg.rocks_dir, query)\r\n   \r\n   if not next(results) then\r\n      return nil, \"'\"..name..\"' does not seem to be an installed rock.\"\r\n   end\r\n   \r\n   local versions = results[name]\r\n   \r\n   if not version then\r\n      local first = next(versions)\r\n      if next(versions, first) then\r\n         return nil, \"Please specify which version of '\"..name..\"' to pack.\"\r\n      end\r\n      version = first\r\n   end\r\n   if not version:match(\"[^-]+%-%d+\") then\r\n      return nil, \"Expected version \"..version..\" in version-revision format.\"\r\n   end\r\n   \r\n   local info = versions[version][1]\r\n   \r\n   local root = path.root_dir(info.repo)\r\n   local prefix = path.install_dir(name, version, root)\r\n   if not fs.exists(prefix) then\r\n      return nil, \"'\"..name..\" \"..version..\"' does not seem to be an installed rock.\"\r\n   end\r\n   \r\n   local rock_manifest = manif.load_rock_manifest(name, version, root)\r\n   if not rock_manifest then\r\n      return nil, \"rock_manifest file not found for \"..name..\" \"..version..\" - not a LuaRocks 2 tree?\"\r\n   end\r\n\r\n   local name_version = name .. \"-\" .. version\r\n   local rock_file = fs.absolute_name(name_version .. \".\"..cfg.arch..\".rock\")\r\n   \r\n   local temp_dir = fs.make_temp_dir(\"pack\")\r\n   fs.copy_contents(prefix, temp_dir)\r\n\r\n   local is_binary = false\r\n   if rock_manifest.lib then\r\n      local ok, err = copy_back_files(name, version, rock_manifest.lib, path.deploy_lib_dir(root), dir.path(temp_dir, \"lib\"))\r\n      if not ok then return nil, \"Failed copying back files: \" .. err end\r\n      is_binary = true\r\n   end\r\n   if rock_manifest.lua then\r\n      local ok, err = copy_back_files(name, version, rock_manifest.lua, path.deploy_lua_dir(root), dir.path(temp_dir, \"lua\"))\r\n      if not ok then return nil, \"Failed copying back files: \" .. err end\r\n   end\r\n   \r\n   local ok, err = fs.change_dir(temp_dir)\r\n   if not ok then return nil, err end\r\n   if not is_binary and not repos.has_binaries(name, version) then\r\n      rock_file = rock_file:gsub(\"%.\"..cfg.arch:gsub(\"%-\",\"%%-\")..\"%.\", \".all.\")\r\n   end\r\n   fs.delete(rock_file)\r\n   if not fs.zip(rock_file, unpack(fs.list_dir())) then\r\n      return nil, \"Failed packing \"..rock_file\r\n   end\r\n   fs.pop_dir()\r\n   fs.delete(temp_dir)\r\n   return rock_file\r\nend",
    "type": "function"
  }, {
    "id": 95,
    "text": "function pack_binary_rock(name, version, cmd, ...)\r\n\r\n   -- The --pack-binary-rock option for \"luarocks build\" basically performs\r\n   -- \"luarocks build\" on a temporary tree and then \"luarocks pack\". The\r\n   -- alternative would require refactoring parts of luarocks.build and\r\n   -- luarocks.pack, which would save a few file operations: the idea would be\r\n   -- to shave off the final deploy steps from the build phase and the initial\r\n   -- collect steps from the pack phase.\r\n\r\n   local temp_dir, err = fs.make_temp_dir(\"luarocks-build-pack-\"..dir.base_name(name))\r\n   if not temp_dir then\r\n      return nil, \"Failed creating temporary directory: \"..err\r\n   end\r\n   util.schedule_function(fs.delete, temp_dir)\r\n\r\n   path.use_tree(temp_dir)\r\n   local ok, err = cmd(...)\r\n   if not ok then\r\n      return nil, err\r\n   end\r\n   local rname, rversion = path.parse_name(name)\r\n   if not rname then\r\n      rname, rversion = name, version\r\n   end\r\n   return do_pack_binary_rock(rname, rversion)\r\nend",
    "type": "function"
  }, {
    "id": 96,
    "text": "function rockspec_name_from_rock(rock_name)\r\n   assert(type(rock_name) == \"string\")\r\n   local base_name = dir.base_name(rock_name)\r\n   return base_name:match(\"(.*)%.[^.]*.rock\") .. \".rockspec\"\r\nend",
    "type": "function"
  }, {
    "id": 97,
    "text": "function rocks_dir(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.rocks_subdir)\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.rocks_dir or dir.path(tree.root, cfg.rocks_subdir)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 98,
    "text": "function deploy_bin_dir(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, \"bin\")\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.bin_dir or dir.path(tree.root, \"bin\")\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 99,
    "text": "function deploy_lua_dir(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.lua_modules_path)\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.lua_dir or dir.path(tree.root, cfg.lua_modules_path)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 100,
    "text": "function deploy_lib_dir(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.lib_modules_path)\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return tree.lib_dir or dir.path(tree.root, cfg.lib_modules_path)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 101,
    "text": "function manifest_file(tree)\r\n   if type(tree) == \"string\" then\r\n      return dir.path(tree, cfg.rocks_subdir, \"manifest\")\r\n   else\r\n      assert(type(tree) == \"table\")\r\n      return (tree.rocks_dir and dir.path(tree.rocks_dir, \"manifest\")) or dir.path(tree.root, cfg.rocks_subdir, \"manifest\")\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 102,
    "text": "function versions_dir(name, tree)\r\n   assert(type(name) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name)\r\nend",
    "type": "function"
  }, {
    "id": 103,
    "text": "function install_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version)\r\nend",
    "type": "function"
  }, {
    "id": 104,
    "text": "function rockspec_file(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, name..\"-\"..version..\".rockspec\")\r\nend",
    "type": "function"
  }, {
    "id": 105,
    "text": "function rock_manifest_file(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"rock_manifest\")\r\nend",
    "type": "function"
  }, {
    "id": 106,
    "text": "function lib_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"lib\")\r\nend",
    "type": "function"
  }, {
    "id": 107,
    "text": "function lua_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"lua\")\r\nend",
    "type": "function"
  }, {
    "id": 108,
    "text": "function doc_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"doc\")\r\nend",
    "type": "function"
  }, {
    "id": 109,
    "text": "function conf_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"conf\")\r\nend",
    "type": "function"
  }, {
    "id": 110,
    "text": "function bin_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"bin\")\r\nend",
    "type": "function"
  }, {
    "id": 111,
    "text": "function parse_name(file_name)\r\n   assert(type(file_name) == \"string\")\r\n   if file_name:match(\"%.rock$\") then\r\n      return dir.base_name(file_name):match(\"(.*)-([^-]+-%d+)%.([^.]+)%.rock$\")\r\n   else\r\n      return dir.base_name(file_name):match(\"(.*)-([^-]+-%d+)%.(rockspec)\")\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 112,
    "text": "function make_url(pathname, name, version, arch)\r\n   assert(type(pathname) == \"string\")\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   assert(type(arch) == \"string\")\r\n\r\n   local filename = name..\"-\"..version\r\n   if arch == \"installed\" then\r\n      filename = dir.path(name, version, filename..\".rockspec\")\r\n   elseif arch == \"rockspec\" then\r\n      filename = filename..\".rockspec\"\r\n   else\r\n      filename = filename..\".\"..arch..\".rock\"\r\n   end\r\n   return dir.path(pathname, filename)\r\nend",
    "type": "function"
  }, {
    "id": 113,
    "text": "function versioned_name(file, prefix, name, version)\r\n   assert(type(file) == \"string\")\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local rest = file:sub(#prefix+1):gsub(\"^/*\", \"\")\r\n   local name_version = (name..\"_\"..version):gsub(\"%-\", \"_\"):gsub(\"%.\", \"_\")\r\n   return dir.path(prefix, name_version..\"-\"..rest)\r\nend",
    "type": "function"
  }, {
    "id": 114,
    "text": "function map_trees(deps_mode, fn, ...)\r\n   local result = {}\r\n   if deps_mode == \"one\" then\r\n      table.insert(result, (fn(cfg.root_dir, ...)) or 0)\r\n   elseif deps_mode == \"all\" or deps_mode == \"order\" then\r\n      local use = false\r\n      if deps_mode == \"all\" then\r\n         use = true\r\n      end\r\n      for _, tree in ipairs(cfg.rocks_trees) do\r\n         if dir.normalize(rocks_tree_to_string(tree)) == dir.normalize(rocks_tree_to_string(cfg.root_dir)) then\r\n            use = true\r\n         end\r\n         if use then\r\n            table.insert(result, (fn(tree, ...)) or 0)\r\n         end\r\n      end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 115,
    "text": "function which_i(module_name, name, version, tree, i)\r\n   local deploy_dir\r\n   if module_name:match(\"%.lua$\") then\r\n      deploy_dir = deploy_lua_dir(tree)\r\n      module_name = dir.path(deploy_dir, module_name)\r\n   else\r\n      deploy_dir = deploy_lib_dir(tree)\r\n      module_name = dir.path(deploy_dir, module_name)\r\n   end\r\n   if i > 1 then\r\n      module_name = versioned_name(module_name, deploy_dir, name, version)\r\n   end\r\n   return module_name\r\nend",
    "type": "function"
  }, {
    "id": 116,
    "text": "function has_binaries(name, version)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local rock_manifest = manif.load_rock_manifest(name, version)\r\n   if rock_manifest.bin then\r\n      for name, md5 in pairs(rock_manifest.bin) do\r\n         -- TODO verify that it is the same file. If it isn't, find the actual command.\r\n         if fs.is_actual_binary(dir.path(cfg.deploy_bin_dir, name)) then\r\n            return true\r\n         end\r\n      end\r\n   end\r\n   return false\r\nend",
    "type": "function"
  }, {
    "id": 117,
    "text": "local function resolve_conflict(target, deploy_dir, name, version)\r\n   local cname, cversion = manif.find_current_provider(target)\r\n   if not cname then\r\n      return nil, cversion\r\n   end\r\n   if name ~= cname or deps.compare_versions(version, cversion) then\r\n      local versioned = path.versioned_name(target, deploy_dir, cname, cversion)\r\n      local ok, err = fs.make_dir(dir.dir_name(versioned))\r\n      if not ok then return nil, err end\r\n      fs.move(target, versioned)\r\n      return target\r\n   else\r\n      return path.versioned_name(target, deploy_dir, name, version)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 118,
    "text": "local function deploy_file_tree(file_tree, path_fn, deploy_dir, move_fn)\r\n      local source_dir = path_fn(name, version)\r\n      if not move_fn then\r\n         move_fn = fs.move\r\n      end\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local source = dir.path(source_dir, parent_path, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local ok, err\r\n            if fs.exists(target) then\r\n               local new_target, err = resolve_conflict(target, deploy_dir, name, version)\r\n               if err == \"untracked\" then\r\n                  local backup = target\r\n                  repeat\r\n                     backup = backup..\"~\"\r\n                  until not fs.exists(backup) -- slight race condition here, but shouldn't be a problem.\r\n                  util.printerr(\"Warning: \"..target..\" is not tracked by this installation of LuaRocks. Moving it to \"..backup)\r\n                  fs.move(target, backup)\r\n               elseif err then\r\n                  return nil, err..\" Cannot install new version.\"\r\n               else\r\n                  target = new_target\r\n               end\r\n            end\r\n            ok, err = fs.make_dir(dir.dir_name(target))\r\n            if not ok then return nil, err end\r\n            ok, err = move_fn(source, target, name, version)\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(source))\r\n            if not ok then return nil, err end\r\n            return true\r\n         end\r\n      )\r\n   end",
    "type": "function"
  }, {
    "id": 119,
    "text": "function delete_version(name, version, quick)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local function delete_deployed_file_tree(file_tree, deploy_dir, suffix)\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local versioned = path.versioned_name(target, deploy_dir, name, version)\r\n            local ok, name, err = delete_suffixed(versioned, suffix)\r\n            if ok then\r\n               fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               return true\r\n            end\r\n            if err == \"fail\" then return nil, name end\r\n            ok, name, err = delete_suffixed(target, suffix)\r\n            if err == \"fail\" then return nil, name end\r\n            if not quick then\r\n               local next_name, next_version = manif.find_next_provider(target)\r\n               if next_name then\r\n                  local versioned = path.versioned_name(name, deploy_dir, next_name, next_version)\r\n                  fs.move(versioned, name)\r\n                  fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               end\r\n            end\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(target))\r\n            return true\r\n         end\r\n      )\r\n   end\r\n\r\n   local rock_manifest = manif.load_rock_manifest(name, version)\r\n   if not rock_manifest then\r\n      return nil, \"rock_manifest file not found for \"..name..\" \"..version..\" - not a LuaRocks 2 tree?\"\r\n   end\r\n   \r\n   local ok, err = true\r\n   if rock_manifest.bin then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.bin, cfg.deploy_bin_dir, cfg.wrapper_suffix)\r\n   end\r\n   if ok and rock_manifest.lua then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.lua, cfg.deploy_lua_dir)\r\n   end\r\n   if ok and rock_manifest.lib then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.lib, cfg.deploy_lib_dir)\r\n   end\r\n   if err then return nil, err end\r\n\r\n   fs.delete(path.install_dir(name, version))\r\n   if not get_installed_versions(name) then\r\n      fs.delete(dir.path(cfg.rocks_dir, name))\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 120,
    "text": "local function delete_deployed_file_tree(file_tree, deploy_dir, suffix)\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local versioned = path.versioned_name(target, deploy_dir, name, version)\r\n            local ok, name, err = delete_suffixed(versioned, suffix)\r\n            if ok then\r\n               fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               return true\r\n            end\r\n            if err == \"fail\" then return nil, name end\r\n            ok, name, err = delete_suffixed(target, suffix)\r\n            if err == \"fail\" then return nil, name end\r\n            if not quick then\r\n               local next_name, next_version = manif.find_next_provider(target)\r\n               if next_name then\r\n                  local versioned = path.versioned_name(name, deploy_dir, next_name, next_version)\r\n                  fs.move(versioned, name)\r\n                  fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               end\r\n            end\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(target))\r\n            return true\r\n         end\r\n      )\r\n   end",
    "type": "function"
  }, {
    "id": 121,
    "text": "function disk_search(repo, query, results)\r\n   assert(type(repo) == \"string\")\r\n   assert(type(query) == \"table\")\r\n   assert(type(results) == \"table\" or not results)\r\n   \r\n   local fs = require(\"luarocks.fs\")\r\n     \r\n   if not results then\r\n      results = {}\r\n   end\r\n   query_arch_as_table(query)\r\n   \r\n   for _, name in pairs(fs.list_dir(repo)) do\r\n      local pathname = dir.path(repo, name)\r\n      local rname, rversion, rarch = path.parse_name(name)\r\n\r\n      if rname and (pathname:match(\".rockspec$\") or pathname:match(\".rock$\")) then\r\n         store_if_match(results, repo, rname, rversion, rarch, query)\r\n      elseif fs.is_dir(pathname) then\r\n         for _, version in pairs(fs.list_dir(pathname)) do\r\n            if version:match(\"-%d+$\") then\r\n               store_if_match(results, repo, name, version, \"installed\", query)\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return results\r\nend",
    "type": "function"
  }, {
    "id": 122,
    "text": "function search_repos(query)\r\n   assert(type(query) == \"table\")\r\n\r\n   local results = {}\r\n   for _, repo in ipairs(cfg.rocks_servers) do\r\n      if type(repo) == \"string\" then\r\n         repo = { repo }\r\n      end\r\n      for _, mirror in ipairs(repo) do\r\n         local protocol, pathname = dir.split_url(mirror)\r\n         if protocol == \"file\" then\r\n            mirror = pathname\r\n         end\r\n         local ok, err = manifest_search(results, mirror, query)\r\n         if ok then\r\n            break\r\n         else\r\n            util.warning(\"Failed searching manifest: \"..err)\r\n         end\r\n      end\r\n   end\r\n   -- search through rocks in cfg.rocks_provided\r\n   local provided_repo = \"provided by VM or rocks_provided\"\r\n   local name, versions\r\n   for name, versions in pairs(cfg.rocks_provided) do\r\n      store_if_match(results, provided_repo, name, versions, \"installed\", query)\r\n   end\r\n   return results\r\nend",
    "type": "function"
  }, {
    "id": 123,
    "text": "function print_results(results, porcelain)\r\n   assert(type(results) == \"table\")\r\n   assert(type(porcelain) == \"boolean\" or not porcelain)\r\n   \r\n   for package, versions in util.sortedpairs(results) do\r\n      if not porcelain then\r\n         util.printout(package)\r\n      end\r\n      for version, repos in util.sortedpairs(versions, deps.compare_versions) do\r\n         for _, repo in ipairs(repos) do\r\n            repo.repo = dir.normalize(repo.repo)\r\n            if porcelain then\r\n               util.printout(package, version, repo.arch, repo.repo)\r\n            else\r\n               util.printout(\"   \"..version..\" (\"..repo.arch..\") - \"..repo.repo)\r\n            end\r\n         end\r\n      end\r\n      if not porcelain then\r\n         util.printout()\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 124,
    "text": "local function module_name(mod, filename, name, version, repo, manifest)\r\n   local base_dir\r\n   if filename:match(\"%.lua$\") then\r\n      base_dir = path.deploy_lua_dir(repo)\r\n   else\r\n      base_dir = path.deploy_lib_dir(repo)\r\n   end\r\n   \r\n   return dir.path(base_dir, filename)\r\nend",
    "type": "function"
  }, {
    "id": 125,
    "text": "function untar(filename, destdir)\r\n   assert(type(filename) == \"string\")\r\n   assert(type(destdir) == \"string\")\r\n\r\n   local tar_handle = io.open(filename, \"r\")\r\n   if not tar_handle then return nil, \"Error opening file \"..filename end\r\n   \r\n   local long_name, long_link_name\r\n   while true do\r\n      local block\r\n      repeat \r\n         block = tar_handle:read(blocksize)\r\n      until (not block) or checksum_header(block) > 256\r\n      if not block then break end\r\n      local header, err = read_header_block(block)\r\n      if not header then\r\n         util.printerr(err)\r\n      end\r\n\r\n      local file_data = tar_handle:read(math.ceil(header.size / blocksize) * blocksize):sub(1,header.size)\r\n\r\n      if header.typeflag == \"long name\" then\r\n         long_name = nullterm(file_data)\r\n      elseif header.typeflag == \"long link name\" then\r\n         long_link_name = nullterm(file_data)\r\n      else\r\n         if long_name then\r\n            header.name = long_name\r\n            long_name = nil\r\n         end\r\n         if long_link_name then\r\n            header.name = long_link_name\r\n            long_link_name = nil\r\n         end\r\n      end\r\n      local pathname = dir.path(destdir, header.name)\r\n      if header.typeflag == \"directory\" then\r\n         local ok, err = fs.make_dir(pathname)\r\n         if not ok then return nil, err end\r\n      elseif header.typeflag == \"file\" then\r\n         local dirname = dir.dir_name(pathname)\r\n         if dirname ~= \"\" then\r\n            local ok, err = fs.make_dir(dirname)\r\n            if not ok then return nil, err end\r\n         end\r\n         local file_handle = io.open(pathname, \"wb\")\r\n         file_handle:write(file_data)\r\n         file_handle:close()\r\n         fs.set_time(pathname, header.mtime)\r\n         if fs.chmod then\r\n            fs.chmod(pathname, header.mode)\r\n         end\r\n      end\r\n      --[[\r\n      for k,v in pairs(header) do\r\n         util.printout(\"[\\\"\"..tostring(k)..\"\\\"] = \"..(type(v)==\"number\" and v or \"\\\"\"..v:gsub(\"%z\", \"\\\\0\")..\"\\\"\"))\r\n      end\r\n      util.printout()\r\n      --]]\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 126,
    "text": "function zip(zipfile, ...)\r\n   local zw = new_zipwriter(zipfile)\r\n   if not zw then\r\n      return nil, \"error opening \"..zipfile\r\n   end\r\n\r\n   local ok, err\r\n   for _, file in pairs({...}) do\r\n      if fs.is_dir(file) then\r\n         for _, entry in pairs(fs.find(file)) do\r\n            local fullname = dir.path(file, entry)\r\n            if fs.is_file(fullname) then\r\n               ok, err = zw:add(fullname)\r\n               if not ok then break end\r\n            end\r\n         end\r\n      else\r\n         ok, err = zw:add(file)\r\n         if not ok then break end\r\n      end\r\n   end\r\n\r\n   local ok = zw:close()\r\n   if not ok then\r\n      return false, \"error closing \"..zipfile\r\n   end\r\n   return ok, err\r\nend",
    "type": "function"
  }, {
    "id": 127,
    "text": "local function run_unpacker(file, force)\r\n   assert(type(file) == \"string\")\r\n   \r\n   local base_name = dir.base_name(file)\r\n   local dir_name, kind, extension = base_name:match(\"(.*)%.([^.]+)%.(rock)$\")\r\n   if not extension then\r\n      dir_name, extension = base_name:match(\"(.*)%.(rockspec)$\")\r\n      kind = \"rockspec\"\r\n   end\r\n   if not extension then\r\n      return nil, file..\" does not seem to be a valid filename.\"\r\n   end\r\n\r\n   local exists = fs.exists(dir_name)\r\n   if exists and not force then\r\n      return nil, \"Directory \"..dir_name..\" already exists.\"\r\n   end\r\n   if not exists then\r\n      local ok, err = fs.make_dir(dir_name)\r\n      if not ok then return nil, err end\r\n   end\r\n   local rollback = util.schedule_function(fs.delete, fs.absolute_name(dir_name))\r\n\r\n   local rockspec, err\r\n   if extension == \"rock\" then\r\n      rockspec, err = unpack_rock(file, dir_name, kind)\r\n   elseif extension == \"rockspec\" then\r\n      rockspec, err = unpack_rockspec(file, dir_name)\r\n   end\r\n   if not rockspec then\r\n      return nil, err\r\n   end\r\n   if kind == \"src\" or kind == \"rockspec\" then\r\n      if rockspec.source.dir ~= \".\" then\r\n         local ok = fs.copy(rockspec.local_filename, rockspec.source.dir)\r\n         if not ok then\r\n            return nil, \"Failed copying unpacked rockspec into unpacked source directory.\"\r\n         end\r\n      end\r\n      util.printout()   \r\n      util.printout(\"Done. You may now enter directory \")\r\n      util.printout(dir.path(dir_name, rockspec.source.dir))\r\n      util.printout(\"and type 'luarocks make' to build.\")\r\n   end\r\n   util.remove_scheduled_function(rollback)\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 128,
    "text": "local function save_settings(repo)\r\n   local protocol, path = dir.split_url(repo)\r\n   table.insert(cfg.rocks_servers, 1, protocol..\"://\"..path)\r\n   return {\r\n      root_dir = cfg.root_dir,\r\n      rocks_dir = cfg.rocks_dir,\r\n      deploy_bin_dir = cfg.deploy_bin_dir,\r\n      deploy_lua_dir = cfg.deploy_lua_dir,\r\n      deploy_lib_dir = cfg.deploy_lib_dir,\r\n   }\r\nend",
    "type": "function"
  }, {
    "id": 129,
    "text": "local function validate(repo, flags)\r\n   local results = {\r\n      ok = {}\r\n   }\r\n   local settings = save_settings(repo)\r\n   local sandbox\r\n   if flags[\"quick\"] then\r\n      sandbox = prepare_sandbox(\"luarocks_validate\")\r\n   end\r\n   if not fs.exists(repo) then\r\n      return nil, repo..\" is not a local repository.\"\r\n   end\r\n   for _, file in pairs(fs.list_dir(repo)) do for _=1,1 do\r\n      if file == \"manifest\" or file == \"index.html\" then\r\n         break -- continue for\r\n      end\r\n      local pathname = fs.absolute_name(dir.path(repo, file))\r\n      if not flags[\"quick\"] then\r\n         sandbox = prepare_sandbox(file)\r\n      end\r\n      local ok, err, errcode\r\n      util.printout()\r\n      util.printout(\"Verifying \"..pathname)\r\n      if file:match(\"%.rockspec$\") then\r\n         ok, err, errcode = validate_rockspec(pathname, \"one\")\r\n      elseif file:match(\"%.src%.rock$\") then\r\n         ok, err, errcode = validate_src_rock(pathname)\r\n      elseif file:match(\"%.rock$\") then\r\n         ok, err, errcode = validate_rock(pathname)\r\n      end\r\n      if ok then\r\n         table.insert(results.ok, {file=file} )\r\n      else\r\n         if not errcode then\r\n            errcode = \"misc\"\r\n         end\r\n         if not results[errcode] then\r\n            results[errcode] = {}\r\n         end\r\n         table.insert(results[errcode], {file=file, err=err} )\r\n      end\r\n      util.run_scheduled_functions()\r\n      if not flags[\"quick\"] then\r\n         fs.delete(sandbox)\r\n      end\r\n      repeat until not fs.pop_dir()\r\n   end end\r\n   if flags[\"quick\"] then\r\n      fs.delete(sandbox)\r\n   end\r\n   restore_settings(settings)\r\n   util.title(\"Results:\")\r\n   util.printout(\"OK: \"..tostring(#results.ok))\r\n   for _, entry in ipairs(results.ok) do\r\n      util.printout(entry.file)\r\n   end\r\n   for errcode, errors in pairs(results) do\r\n      if errcode ~= \"ok\" then\r\n         util.printout()\r\n         util.printout(errcode..\" errors: \"..tostring(#errors))\r\n         for _, entry in ipairs(errors) do\r\n            util.printout(entry.file, entry.err)\r\n         end\r\n      end\r\n   end\r\n\r\n   util.title(\"Summary:\")\r\n   local total = 0\r\n   for errcode, errors in pairs(results) do\r\n      util.printout(errcode..\": \"..tostring(#errors))\r\n      total = total + #errors\r\n   end\r\n   util.printout(\"Total: \"..total)\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 130,
    "text": "local function open_file(name)\r\n   return io.open(dir.path(fs.current_dir(), name), \"r\")\r\nend",
    "type": "function"
  }, {
    "id": 131,
    "text": "function run(...)\r\n   local flags, name, version, url_or_dir = util.parse_flags(...)\r\n   \r\n   if not name then\r\n      return nil, \"Missing arguments. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n\r\n   if name and not version then\r\n      url_or_dir = name\r\n      name = nil\r\n   elseif not url_or_dir then\r\n      url_or_dir = version\r\n   end\r\n\r\n   if flags[\"tag\"] == true then\r\n      return nil, \"Incorrect usage: --tag requires an argument. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n   \r\n   if flags[\"tag\"] then\r\n      if not version then\r\n         version = flags[\"tag\"]:gsub(\"^v\", \"\")\r\n      end\r\n   end\r\n   \r\n   local protocol, pathname = dir.split_url(url_or_dir)\r\n   if not fetch.is_basic_protocol(protocol) then\r\n      if not name then\r\n         name = dir.base_name(url_or_dir):gsub(\"%.[^.]+$\", \"\")\r\n      end\r\n      if not version then\r\n         version = \"scm\"\r\n      end\r\n   elseif protocol ~= \"file\" then\r\n      local filename = dir.base_name(url_or_dir)\r\n      local newname, newversion = filename:match(\"(.*)-([^-]+)\")\r\n      if (not name) and newname then\r\n         name = newname\r\n      end\r\n      if (not version) and newversion then\r\n         version = newversion:gsub(\".[a-z]+$\", \"\"):gsub(\".tar$\", \"\")\r\n      end\r\n      if not (name and version) then\r\n         return nil, \"Missing name and version arguments. \"..util.see_help(\"write_rockspec\")\r\n      end\r\n   elseif not version then\r\n      return nil, \"Missing name and version arguments. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n\r\n   local filename = flags[\"output\"] or dir.path(fs.current_dir(), name:lower()..\"-\"..version..\"-1.rockspec\")\r\n   \r\n   if not flags[\"homepage\"] and url_or_dir:match(\"^git://github.com\") then\r\n      flags[\"homepage\"] = \"http://\"..url_or_dir:match(\"^[^:]+://(.*)\")\r\n   end\r\n\r\n   local rockspec = {\r\n      package = name,\r\n      name = name:lower(),\r\n      version = version..\"-1\",\r\n      source = {\r\n         url = \"*** please add URL for source tarball, zip or repository here ***\",\r\n         tag = flags[\"tag\"],\r\n      },\r\n      description = {\r\n         summary = flags[\"summary\"] or \"*** please specify description summary ***\",\r\n         detailed = flags[\"detailed\"] or \"*** please enter a detailed description ***\",\r\n         homepage = flags[\"homepage\"] or \"*** please enter a project homepage ***\",\r\n         license = flags[\"license\"] or \"*** please specify a license ***\",\r\n      },\r\n      dependencies = {},\r\n      build = {},\r\n   }\r\n   path.configure_paths(rockspec)\r\n   rockspec.source.protocol = protocol\r\n   \r\n   configure_lua_version(rockspec, flags[\"lua-version\"])\r\n   \r\n   local local_dir = url_or_dir\r\n\r\n   if url_or_dir:match(\"://\") then\r\n      rockspec.source.url = url_or_dir\r\n      rockspec.source.file = dir.base_name(url_or_dir)\r\n      rockspec.source.dir = \"dummy\"\r\n      if not fetch.is_basic_protocol(rockspec.source.protocol) then\r\n         if version ~= \"scm\" then\r\n            rockspec.source.tag = flags[\"tag\"] or \"v\" .. version\r\n         end\r\n      end\r\n      rockspec.source.dir = nil\r\n      local ok, base_dir, temp_dir = get_url(rockspec)\r\n      if ok then\r\n         if base_dir ~= dir.base_name(url_or_dir) then\r\n            rockspec.source.dir = base_dir\r\n         end\r\n      end\r\n      if base_dir then\r\n         local_dir = dir.path(temp_dir, base_dir)\r\n      else\r\n         local_dir = nil\r\n      end\r\n   end\r\n   \r\n   if not local_dir then\r\n      local_dir = \".\"\r\n   end\r\n   \r\n   local libs = nil\r\n   if flags[\"lib\"] then\r\n      libs = {}\r\n      rockspec.external_dependencies = {}\r\n      for lib in flags[\"lib\"]:gmatch(\"([^,]+)\") do\r\n         table.insert(libs, lib)\r\n         rockspec.external_dependencies[lib:upper()] = {\r\n            library = lib\r\n         }\r\n      end\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_dir)\r\n   if not ok then return nil, \"Failed reaching files from project - error entering directory \"..local_dir end\r\n\r\n   detect_description(rockspec)\r\n\r\n   local is_mit = show_license(rockspec)\r\n   \r\n   if is_mit and not flags[\"license\"] then\r\n      rockspec.description.license = \"MIT\"\r\n   end\r\n   \r\n   fill_as_builtin(rockspec, libs)\r\n      \r\n   rockspec_cleanup(rockspec)\r\n   \r\n   persist.save_from_table(filename, rockspec, type_check.rockspec_order)\r\n\r\n   util.printout()   \r\n   util.printout(\"Wrote template at \"..filename..\" -- you should now edit and finish it.\")\r\n   util.printout()   \r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 132,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 133,
    "text": "module",
    "type": "global function"
  }, {
    "id": 134,
    "text": "remove",
    "type": "global function"
  }, {
    "id": 135,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 136,
    "text": "type",
    "type": "global function"
  }, {
    "id": 137,
    "text": "",
    "type": "variable container"
  }, {
    "id": 138,
    "text": "",
    "type": "require container"
  }, {
    "id": 139,
    "text": "",
    "type": "global variable"
  } ]
}