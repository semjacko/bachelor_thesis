{
  "_filename": "install.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/luarocks/src/luarocks/install.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "calls",
    "to": 12
  }, {
    "from": 3,
    "label": "calls",
    "to": 51
  }, {
    "from": 12,
    "label": "has",
    "to": 13
  }, {
    "from": 12,
    "label": "has",
    "to": 14
  }, {
    "from": 12,
    "label": "has",
    "to": 15
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 17
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 18
  }, {
    "from": 18,
    "label": "has",
    "to": 19
  }, {
    "from": 12,
    "label": "has",
    "to": 20
  }, {
    "from": 20,
    "label": "has",
    "to": 21
  }, {
    "from": 20,
    "label": "has",
    "to": 22
  }, {
    "from": 12,
    "label": "has",
    "to": 23
  }, {
    "from": 12,
    "label": "has",
    "to": 24
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 25
  }, {
    "from": 12,
    "label": "has",
    "to": 26
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 27
  }, {
    "from": 27,
    "label": "has",
    "to": 28
  }, {
    "from": 27,
    "label": "has",
    "to": 29
  }, {
    "from": 27,
    "label": "has",
    "to": 30
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 31
  }, {
    "from": 31,
    "label": "has",
    "to": 32
  }, {
    "from": 31,
    "label": "has",
    "to": 33
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 34
  }, {
    "from": 34,
    "label": "has",
    "to": 35
  }, {
    "from": 34,
    "label": "has",
    "to": 30
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 36
  }, {
    "from": 12,
    "label": "has",
    "to": 37
  }, {
    "from": 37,
    "label": "has",
    "to": 38
  }, {
    "from": 12,
    "label": "has",
    "to": 39
  }, {
    "from": 12,
    "label": "has",
    "to": 33
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 40
  }, {
    "from": 12,
    "label": "has",
    "to": 41
  }, {
    "from": 41,
    "label": "has",
    "to": 19
  }, {
    "from": 12,
    "label": "has",
    "to": 42
  }, {
    "from": 12,
    "label": "has",
    "to": 33
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 43
  }, {
    "from": 12,
    "label": "has",
    "to": 33
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 44
  }, {
    "from": 12,
    "label": "has",
    "to": 45
  }, {
    "from": 45,
    "label": "has",
    "to": 46
  }, {
    "from": 12,
    "label": "has",
    "to": 47
  }, {
    "from": 12,
    "label": "has",
    "to": 48
  }, {
    "from": 12,
    "label": "has",
    "to": 49
  }, {
    "from": 12,
    "label": "has",
    "to": 40
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 12,
    "label": "has",
    "to": 50
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 51,
    "label": "has",
    "to": 53
  }, {
    "from": 51,
    "label": "has",
    "to": 16
  }, {
    "from": 51,
    "label": "has",
    "to": 54
  }, {
    "from": 51,
    "label": "has",
    "to": 55
  }, {
    "from": 51,
    "label": "has",
    "to": 16
  }, {
    "from": 51,
    "label": "has",
    "to": 56
  }, {
    "from": 56,
    "label": "has",
    "to": 57
  }, {
    "from": 56,
    "label": "has",
    "to": 58
  }, {
    "from": 56,
    "label": "has",
    "to": 59
  }, {
    "from": 56,
    "label": "has",
    "to": 60
  }, {
    "from": 56,
    "label": "has",
    "to": 61
  }, {
    "from": 56,
    "label": "has",
    "to": 62
  }, {
    "from": 62,
    "label": "has",
    "to": 63
  }, {
    "from": 62,
    "label": "has",
    "to": 64
  }, {
    "from": 64,
    "label": "has",
    "to": 65
  }, {
    "from": 56,
    "label": "has",
    "to": 66
  }, {
    "from": 56,
    "label": "has",
    "to": 67
  }, {
    "from": 56,
    "label": "has",
    "to": 68
  }, {
    "from": 68,
    "label": "has",
    "to": 69
  }, {
    "from": 68,
    "label": "has",
    "to": 70
  }, {
    "from": 68,
    "label": "has",
    "to": 48
  }, {
    "from": 68,
    "label": "has",
    "to": 71
  }, {
    "from": 68,
    "label": "has",
    "to": 72
  }, {
    "from": 68,
    "label": "has",
    "to": 73
  }, {
    "from": 51,
    "label": "has",
    "to": 16
  }, {
    "from": 51,
    "label": "has",
    "to": 16
  }, {
    "from": 51,
    "label": "has",
    "to": 16
  }, {
    "from": 51,
    "label": "has",
    "to": 16
  }, {
    "from": 51,
    "label": "has",
    "to": 16
  }, {
    "from": 51,
    "label": "has",
    "to": 16
  }, {
    "from": 51,
    "label": "has",
    "to": 74
  }, {
    "from": 75,
    "label": "has",
    "to": 21
  }, {
    "from": 75,
    "label": "has",
    "to": 22
  }, {
    "from": 75,
    "label": "has",
    "to": 76
  }, {
    "from": 77,
    "label": "has",
    "to": 19
  }, {
    "from": 77,
    "label": "has",
    "to": 78
  }, {
    "from": 12,
    "label": "calls",
    "to": 85
  }, {
    "from": 12,
    "label": "calls",
    "to": 10
  }, {
    "from": 12,
    "label": "calls",
    "to": 107
  }, {
    "from": 12,
    "label": "calls",
    "to": 81
  }, {
    "from": 51,
    "label": "calls",
    "to": 12
  }, {
    "from": 51,
    "label": "calls",
    "to": 51
  }, {
    "from": 51,
    "label": "calls",
    "to": 88
  }, {
    "from": 12,
    "label": "calls",
    "to": 4
  }, {
    "from": 12,
    "label": "calls",
    "to": 6
  }, {
    "from": 12,
    "label": "calls",
    "to": 7
  }, {
    "from": 12,
    "label": "calls",
    "to": 102
  }, {
    "from": 51,
    "label": "calls",
    "to": 102
  }, {
    "from": 51,
    "label": "calls",
    "to": 102
  }, {
    "from": 12,
    "label": "calls",
    "to": 93
  }, {
    "from": 12,
    "label": "calls",
    "to": 93
  }, {
    "from": 12,
    "label": "calls",
    "to": 97
  }, {
    "from": 12,
    "label": "calls",
    "to": 97
  }, {
    "from": 12,
    "label": "calls",
    "to": 84
  }, {
    "from": 12,
    "label": "calls",
    "to": 84
  }, {
    "from": 12,
    "label": "calls",
    "to": 8
  }, {
    "from": 51,
    "label": "calls",
    "to": 99
  }, {
    "from": 51,
    "label": "calls",
    "to": 11
  }, {
    "from": 12,
    "label": "calls",
    "to": 90
  }, {
    "from": 51,
    "label": "calls",
    "to": 100
  }, {
    "from": 51,
    "label": "calls",
    "to": 100
  }, {
    "from": 51,
    "label": "calls",
    "to": 51
  }, {
    "from": 12,
    "label": "calls",
    "to": 92
  }, {
    "from": 12,
    "label": "calls",
    "to": 3
  }, {
    "from": 12,
    "label": "calls",
    "to": 98
  }, {
    "from": 12,
    "label": "calls",
    "to": 98
  }, {
    "from": 12,
    "label": "calls",
    "to": 82
  }, {
    "from": 12,
    "label": "calls",
    "to": 83
  }, {
    "from": 51,
    "label": "calls",
    "to": 103
  }, {
    "from": 12,
    "label": "calls",
    "to": 91
  }, {
    "from": 51,
    "label": "calls",
    "to": 105
  }, {
    "from": 51,
    "label": "calls",
    "to": 95
  }, {
    "from": 12,
    "label": "calls",
    "to": 101
  }, {
    "from": 12,
    "label": "calls",
    "to": 101
  }, {
    "from": 51,
    "label": "calls",
    "to": 101
  }, {
    "from": 51,
    "label": "calls",
    "to": 101
  }, {
    "from": 51,
    "label": "calls",
    "to": 101
  }, {
    "from": 51,
    "label": "calls",
    "to": 94
  }, {
    "from": 12,
    "label": "calls",
    "to": 87
  }, {
    "from": 51,
    "label": "calls",
    "to": 110
  }, {
    "from": 79,
    "label": "calls",
    "to": 104
  }, {
    "from": 79,
    "label": "calls",
    "to": 108
  }, {
    "from": 12,
    "label": "calls",
    "to": 80
  }, {
    "from": 12,
    "label": "calls",
    "to": 9
  }, {
    "from": 51,
    "label": "calls",
    "to": 5
  }, {
    "from": 12,
    "label": "calls",
    "to": 86
  }, {
    "from": 12,
    "label": "calls",
    "to": 109
  }, {
    "from": 51,
    "label": "calls",
    "to": 109
  }, {
    "from": 51,
    "label": "calls",
    "to": 109
  }, {
    "from": 79,
    "label": "calls",
    "to": 111
  }, {
    "from": 79,
    "label": "calls",
    "to": 111
  }, {
    "from": 79,
    "label": "calls",
    "to": 111
  }, {
    "from": 79,
    "label": "calls",
    "to": 111
  }, {
    "from": 79,
    "label": "calls",
    "to": 111
  }, {
    "from": 79,
    "label": "calls",
    "to": 111
  }, {
    "from": 79,
    "label": "calls",
    "to": 111
  }, {
    "from": 79,
    "label": "calls",
    "to": 111
  }, {
    "from": 79,
    "label": "calls",
    "to": 111
  }, {
    "from": 51,
    "label": "calls",
    "to": 111
  }, {
    "from": 51,
    "label": "calls",
    "to": 111
  }, {
    "from": 12,
    "label": "calls",
    "to": 89
  }, {
    "from": 51,
    "label": "calls",
    "to": 96
  }, {
    "from": 1,
    "label": "contains",
    "to": 79
  }, {
    "from": 79,
    "label": "declares",
    "to": 12
  }, {
    "from": 79,
    "label": "declares",
    "to": 51
  }, {
    "from": 79,
    "label": "declares",
    "to": 75
  }, {
    "from": 79,
    "label": "declares",
    "to": 77
  }, {
    "from": 106,
    "label": "calls",
    "to": 12
  }, {
    "from": 1,
    "label": "contains",
    "to": 122
  }, {
    "from": 1,
    "label": "contains",
    "to": 123
  }, {
    "from": 122,
    "label": "initializes",
    "to": 124
  }, {
    "from": 122,
    "label": "initializes",
    "to": 125
  }, {
    "from": 122,
    "label": "initializes",
    "to": 126
  }, {
    "from": 126,
    "label": "assigns",
    "to": 127
  }, {
    "from": 123,
    "label": "initializes",
    "to": 128
  }, {
    "from": 128,
    "label": "requires",
    "to": 117
  }, {
    "from": 123,
    "label": "initializes",
    "to": 129
  }, {
    "from": 129,
    "label": "requires",
    "to": 118
  }, {
    "from": 123,
    "label": "initializes",
    "to": 130
  }, {
    "from": 130,
    "label": "requires",
    "to": 114
  }, {
    "from": 123,
    "label": "initializes",
    "to": 131
  }, {
    "from": 131,
    "label": "requires",
    "to": 113
  }, {
    "from": 123,
    "label": "initializes",
    "to": 132
  }, {
    "from": 132,
    "label": "requires",
    "to": 116
  }, {
    "from": 123,
    "label": "initializes",
    "to": 133
  }, {
    "from": 133,
    "label": "requires",
    "to": 119
  }, {
    "from": 123,
    "label": "initializes",
    "to": 134
  }, {
    "from": 134,
    "label": "requires",
    "to": 115
  }, {
    "from": 123,
    "label": "initializes",
    "to": 135
  }, {
    "from": 135,
    "label": "requires",
    "to": 121
  }, {
    "from": 123,
    "label": "initializes",
    "to": 136
  }, {
    "from": 136,
    "label": "requires",
    "to": 112
  }, {
    "from": 123,
    "label": "initializes",
    "to": 137
  }, {
    "from": 137,
    "label": "requires",
    "to": 138
  }, {
    "from": 123,
    "label": "initializes",
    "to": 139
  }, {
    "from": 139,
    "label": "requires",
    "to": 120
  }, {
    "from": 140,
    "label": "requires",
    "to": 138
  }, {
    "from": 141,
    "label": "requires",
    "to": 138
  }, {
    "from": 142,
    "label": "requires",
    "to": 138
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "install",
    "type": "module"
  }, {
    "id": 2,
    "text": "local function do_build(name, version, deps_mode)\r\n   if name:match(\"%.rockspec$\") then\r\n      return build_rockspec(name, true, false, deps_mode)\r\n   elseif name:match(\"%.src%.rock$\") then\r\n      return build_rock(name, false, deps_mode)\r\n   elseif name:match(\"%.all%.rock$\") then\r\n      local install = require(\"luarocks.install\")\r\n      return install.install_binary_rock(name, deps_mode)\r\n   elseif name:match(\"%.rock$\") then\r\n      return build_rock(name, true, deps_mode)\r\n   elseif not name:match(dir.separator) then\r\n      local search = require(\"luarocks.search\")\r\n      return search.act_on_src_or_rockspec(run, name:lower(), version, deps.deps_mode_to_flag(deps_mode))\r\n   end\r\n   return nil, \"Don't know what to do with \"..name\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "function fulfill_dependencies(rockspec, deps_mode)\r\n\r\n   local search = require(\"luarocks.search\")\r\n   local install = require(\"luarocks.install\")\r\n\r\n   if rockspec.supported_platforms then\r\n      if not platforms_set then\r\n         platforms_set = values_set(cfg.platforms)\r\n      end\r\n      local supported = nil\r\n      for _, plat in pairs(rockspec.supported_platforms) do\r\n         local neg, plat = plat:match(\"^(!?)(.*)\")\r\n         if neg == \"!\" then\r\n            if platforms_set[plat] then\r\n               return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plat..\" platforms.\"\r\n            end\r\n         else\r\n            if platforms_set[plat] then\r\n               supported = true\r\n            else\r\n               if supported == nil then\r\n                  supported = false\r\n               end\r\n            end\r\n         end\r\n      end\r\n      if supported == false then\r\n         local plats = table.concat(cfg.platforms, \", \")\r\n         return nil, \"This rockspec for \"..rockspec.package..\" does not support \"..plats..\" platforms.\"\r\n      end\r\n   end\r\n\r\n   local _, missing, no_upgrade = match_deps(rockspec, nil, deps_mode)\r\n\r\n   if next(no_upgrade) then\r\n      util.printerr(\"Missing dependencies for \"..rockspec.name..\" \"..rockspec.version..\":\")\r\n      for _, dep in pairs(no_upgrade) do\r\n         util.printerr(show_dep(dep))\r\n      end\r\n      if next(missing) then\r\n         for _, dep in pairs(missing) do\r\n            util.printerr(show_dep(dep))\r\n         end\r\n      end\r\n      util.printerr()\r\n      for _, dep in pairs(no_upgrade) do\r\n         util.printerr(\"This version of \"..rockspec.name..\" is designed for use with\")\r\n         util.printerr(show_dep(dep)..\", but is configured to avoid upgrading it\")\r\n         util.printerr(\"automatically. Please upgrade \"..dep.name..\" with\")\r\n         util.printerr(\"   luarocks install \"..dep.name)\r\n         util.printerr(\"or choose an older version of \"..rockspec.name..\" with\")\r\n         util.printerr(\"   luarocks search \"..rockspec.name)\r\n      end\r\n      return nil, \"Failed matching dependencies.\"\r\n   end\r\n\r\n   if next(missing) then\r\n      util.printerr()\r\n      util.printerr(\"Missing dependencies for \"..rockspec.name..\":\")\r\n      for _, dep in pairs(missing) do\r\n         util.printerr(show_dep(dep))\r\n      end\r\n      util.printerr()\r\n\r\n      for _, dep in pairs(missing) do\r\n         -- Double-check in case dependency was filled during recursion.\r\n         if not match_dep(dep, nil, deps_mode) then\r\n            local rock = search.find_suitable_rock(dep)\r\n            if not rock then\r\n               return nil, \"Could not satisfy dependency: \"..show_dep(dep)\r\n            end\r\n            local ok, err, errcode = install.run(rock)\r\n            if not ok then\r\n               return nil, \"Failed installing dependency: \"..rock..\" - \"..err, errcode\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 4,
    "text": "function check_external_deps(rockspec, mode)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   local fs = require(\"luarocks.fs\")\r\n   \r\n   local vars = rockspec.variables\r\n   local patterns = cfg.external_deps_patterns\r\n   local subdirs = cfg.external_deps_subdirs\r\n   if mode == \"install\" then\r\n      patterns = cfg.runtime_external_deps_patterns\r\n      subdirs = cfg.runtime_external_deps_subdirs\r\n   end\r\n   if rockspec.external_dependencies then\r\n      for name, files in pairs(rockspec.external_dependencies) do\r\n         local ok = true\r\n         local failed_file = nil\r\n         local failed_dirname = nil\r\n         for _, extdir in ipairs(cfg.external_deps_dirs) do\r\n            ok = true\r\n            local prefix = vars[name..\"_DIR\"]\r\n            local dirs = {\r\n               BINDIR = { subdir = subdirs.bin, testfile = \"program\", pattern = patterns.bin },\r\n               INCDIR = { subdir = subdirs.include, testfile = \"header\", pattern = patterns.include },\r\n               LIBDIR = { subdir = subdirs.lib, testfile = \"library\", pattern = patterns.lib }\r\n            }\r\n            if mode == \"install\" then\r\n               dirs.INCDIR = nil\r\n            end\r\n            if not prefix then\r\n               prefix = extdir\r\n            end\r\n            if type(prefix) == \"table\" then\r\n               if prefix.bin then\r\n                  dirs.BINDIR.subdir = prefix.bin\r\n               end\r\n               if prefix.include then\r\n                  if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end\r\n               end\r\n               if prefix.lib then\r\n                  dirs.LIBDIR.subdir = prefix.lib\r\n               end\r\n               prefix = prefix.prefix\r\n            end\r\n            for dirname, dirdata in pairs(dirs) do\r\n               local paths\r\n               local path_var_value = vars[name..\"_\"..dirname]\r\n               if path_var_value then\r\n                  paths = { path_var_value }\r\n               elseif type(dirdata.subdir) == \"table\" then\r\n                  paths = {}\r\n                  for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end\r\n               else\r\n                  paths = { dir.path(prefix, dirdata.subdir) }\r\n               end\r\n               dirdata.dir = paths[1]\r\n               local file = files[dirdata.testfile]\r\n               if file then\r\n                  local files = {}\r\n                  if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end\r\n                  local found = false\r\n                  failed_file = nil\r\n                  for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end\r\n                  if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end\r\n               end\r\n            end\r\n            if ok then\r\n               for dirname, dirdata in pairs(dirs) do\r\n                  vars[name..\"_\"..dirname] = dirdata.dir\r\n               end\r\n               vars[name..\"_DIR\"] = prefix\r\n               break\r\n            end\r\n         end\r\n         if not ok then\r\n            return nil, \"Could not find expected file \"..failed_file..\" for \"..name..\" -- you may have to install \"..name..\" in your system and/or pass \"..name..\"_DIR or \"..name..\"_\"..failed_dirname..\" to the luarocks command. Example: luarocks install \"..rockspec.name..\" \"..name..\"_DIR=/usr/local\", \"dependency\"\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 5,
    "text": "function get_deps_mode(flags)\r\n   if flags[\"deps-mode\"] then\r\n      return flags[\"deps-mode\"]\r\n   else\r\n      return cfg.deps_mode\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 6,
    "text": "function fetch_and_unpack_rock(rock_file, dest)\r\n   assert(type(rock_file) == \"string\")\r\n   assert(type(dest) == \"string\" or not dest)\r\n\r\n   local name = dir.base_name(rock_file):match(\"(.*)%.[^.]*%.rock\")\r\n   \r\n   local rock_file, err, errcode = fetch_url_at_temp_dir(rock_file,\"luarocks-rock-\"..name)\r\n   if not rock_file then\r\n      return nil, \"Could not fetch rock file: \" .. err, errcode\r\n   end\r\n\r\n   rock_file = fs.absolute_name(rock_file)\r\n   local unpack_dir\r\n   if dest then\r\n      unpack_dir = dest\r\n      local ok, err = fs.make_dir(unpack_dir)\r\n      if not ok then\r\n         return nil, \"Failed unpacking rock file: \" .. err\r\n      end\r\n   else\r\n      unpack_dir = fs.make_temp_dir(name)\r\n   end\r\n   if not dest then\r\n      util.schedule_function(fs.delete, unpack_dir)\r\n   end\r\n   local ok, err = fs.change_dir(unpack_dir)\r\n   if not ok then return nil, err end\r\n   ok = fs.unzip(rock_file)\r\n   if not ok then\r\n      return nil, \"Failed unpacking rock file: \" .. rock_file\r\n   end\r\n   fs.pop_dir()\r\n   return unpack_dir\r\nend",
    "type": "function"
  }, {
    "id": 7,
    "text": "function load_rockspec(filename, location)\r\n   assert(type(filename) == \"string\")\r\n\r\n   local name\r\n   local basename = dir.base_name(filename)\r\n   if basename == \"rockspec\" then\r\n      name = \"rockspec\"\r\n   else\r\n      name = basename:match(\"(.*)%.rockspec\")\r\n      if not name then\r\n         return nil, \"Filename '\"..filename..\"' does not look like a rockspec.\"\r\n      end\r\n   end\r\n   \r\n   local err, errcode\r\n   if location then\r\n      local ok, err = fs.change_dir(location)\r\n      if not ok then return nil, err end\r\n      filename, err = fetch_url(filename)\r\n      fs.pop_dir()\r\n   else\r\n      filename, err, errcode = fetch_url_at_temp_dir(filename,\"luarocks-rockspec-\"..name)\r\n   end\r\n   if not filename then\r\n      return nil, err, errcode\r\n   end\r\n\r\n   return load_local_rockspec(filename)\r\nend",
    "type": "function"
  }, {
    "id": 8,
    "text": "function remove_dir_if_empty(d)\r\n   assert(d)\r\n   d = dir.normalize(d)\r\n   lfs.rmdir(d)\r\nend",
    "type": "function"
  }, {
    "id": 9,
    "text": "function delete(name)\r\n   name = dir.normalize(name)\r\n   recursive_delete(name)\r\nend",
    "type": "function"
  }, {
    "id": 10,
    "text": "function exists(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   return type(lfs.attributes(file)) == \"table\"\r\nend",
    "type": "function"
  }, {
    "id": 11,
    "text": "function check_command_permissions(flags)\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   local ok = true\r\n   local err = \"\"\r\n   for _, dir in ipairs { cfg.rocks_dir, root_dir } do\r\n      if fs.exists(dir) and not fs.is_writable(dir) then\r\n         ok = false\r\n         err = \"Your user does not have write permissions in \" .. dir\r\n         break\r\n      end\r\n   end\r\n   local root_parent = dir.dir_name(root_dir)\r\n   if ok and not fs.exists(root_dir) and not fs.is_writable(root_parent) then\r\n      ok = false\r\n      err = root_dir..\" does not exist and your user does not have write permissions in \" .. root_parent\r\n   end\r\n   if ok then\r\n      return true\r\n   else\r\n      if flags[\"local\"] then\r\n         err = err .. \" \\n-- please check your permissions.\"\r\n      else\r\n         err = err .. \" \\n-- you may want to run as a privileged user or use your local tree with --local.\"\r\n      end\r\n      return nil, err\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 12,
    "text": "function install_binary_rock(rock_file, deps_mode)\r\n   assert(type(rock_file) == \"string\")\r\n\r\n   local name, version, arch = path.parse_name(rock_file)\r\n   if not name then\r\n      return nil, \"Filename \"..rock_file..\" does not match format 'name-version-revision.arch.rock'.\"\r\n   end\r\n   \r\n   if arch ~= \"all\" and arch ~= cfg.arch then\r\n      return nil, \"Incompatible architecture \"..arch, \"arch\"\r\n   end\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n   \r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n   \r\n   local ok, err, errcode = fetch.fetch_and_unpack_rock(rock_file, path.install_dir(name, version))\r\n   if not ok then return nil, err, errcode end\r\n   \r\n   local rockspec, err, errcode = fetch.load_rockspec(path.rockspec_file(name, version))\r\n   if err then\r\n      return nil, \"Failed loading rockspec for installed package: \"..err, errcode\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      ok, err, errcode = deps.check_external_deps(rockspec, \"install\")\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   -- For compatibility with .rock files built with LuaRocks 1\r\n   if not fs.exists(path.rock_manifest_file(name, version)) then\r\n      ok, err = manif.make_rock_manifest(name, version)\r\n      if err then return nil, err end\r\n   end\r\n\r\n   if deps_mode ~= \"none\" then\r\n      ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   local wrap_bin_scripts = true\r\n   if rockspec.deploy and rockspec.deploy.wrap_bin_scripts == false then\r\n      wrap_bin_scripts = false\r\n   end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n\r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n   \r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n   \r\n   local license = \"\"\r\n   if rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 13,
    "text": "assert(type(rock_file) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 14,
    "text": "local name, version, arch = path.parse_name(rock_file)",
    "type": "statement:localassign"
  }, {
    "id": 15,
    "text": "if not name then\r\n      return nil, \"Filename \"..rock_file..\" does not match format 'name-version-revision.arch.rock'.\"\r\n   end",
    "type": "statement:if"
  }, {
    "id": 16,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 17,
    "text": "if arch ~= \"all\" and arch ~= cfg.arch then\r\n      return nil, \"Incompatible architecture \"..arch, \"arch\"\r\n   end",
    "type": "statement:if"
  }, {
    "id": 18,
    "text": "if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 19,
    "text": "repos.delete_version(name, version)",
    "type": "statement:functioncall"
  }, {
    "id": 20,
    "text": "local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)",
    "type": "statement:localassign"
  }, {
    "id": 21,
    "text": "fs.delete(path.install_dir(name, version))",
    "type": "statement:functioncall"
  }, {
    "id": 22,
    "text": "fs.remove_dir_if_empty(path.versions_dir(name))",
    "type": "statement:functioncall"
  }, {
    "id": 23,
    "text": "local ok, err, errcode = fetch.fetch_and_unpack_rock(rock_file, path.install_dir(name, version))",
    "type": "statement:localassign"
  }, {
    "id": 24,
    "text": "if not ok then return nil, err, errcode end",
    "type": "statement:if"
  }, {
    "id": 25,
    "text": "local rockspec, err, errcode = fetch.load_rockspec(path.rockspec_file(name, version))",
    "type": "statement:localassign"
  }, {
    "id": 26,
    "text": "if err then\r\n      return nil, \"Failed loading rockspec for installed package: \"..err, errcode\r\n   end",
    "type": "statement:if"
  }, {
    "id": 27,
    "text": "if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      ok, err, errcode = deps.check_external_deps(rockspec, \"install\")\r\n      if err then return nil, err, errcode end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 28,
    "text": "util.printerr(\"Warning: skipping dependency checks.\")",
    "type": "statement:functioncall"
  }, {
    "id": 29,
    "text": "ok, err, errcode = deps.check_external_deps(rockspec, \"install\")",
    "type": "statement:assign"
  }, {
    "id": 30,
    "text": "if err then return nil, err, errcode end",
    "type": "statement:if"
  }, {
    "id": 31,
    "text": "if not fs.exists(path.rock_manifest_file(name, version)) then\r\n      ok, err = manif.make_rock_manifest(name, version)\r\n      if err then return nil, err end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 32,
    "text": "ok, err = manif.make_rock_manifest(name, version)",
    "type": "statement:assign"
  }, {
    "id": 33,
    "text": "if err then return nil, err end",
    "type": "statement:if"
  }, {
    "id": 34,
    "text": "if deps_mode ~= \"none\" then\r\n      ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then return nil, err, errcode end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 35,
    "text": "ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)",
    "type": "statement:assign"
  }, {
    "id": 36,
    "text": "local wrap_bin_scripts = true",
    "type": "statement:localassign"
  }, {
    "id": 37,
    "text": "if rockspec.deploy and rockspec.deploy.wrap_bin_scripts == false then\r\n      wrap_bin_scripts = false\r\n   end",
    "type": "statement:if"
  }, {
    "id": 38,
    "text": "wrap_bin_scripts = false",
    "type": "statement:assign"
  }, {
    "id": 39,
    "text": "ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))",
    "type": "statement:assign"
  }, {
    "id": 40,
    "text": "util.remove_scheduled_function(rollback)",
    "type": "statement:functioncall"
  }, {
    "id": 41,
    "text": "rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)",
    "type": "statement:assign"
  }, {
    "id": 42,
    "text": "ok, err = repos.run_hook(rockspec, \"post_install\")",
    "type": "statement:assign"
  }, {
    "id": 43,
    "text": "ok, err = manif.update_manifest(name, version, nil, deps_mode)",
    "type": "statement:assign"
  }, {
    "id": 44,
    "text": "local license = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 45,
    "text": "if rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end",
    "type": "statement:if"
  }, {
    "id": 46,
    "text": "license = (\"(license: \"..rockspec.description.license..\")\")",
    "type": "statement:assign"
  }, {
    "id": 47,
    "text": "local root_dir = path.root_dir(cfg.rocks_dir)",
    "type": "statement:localassign"
  }, {
    "id": 48,
    "text": "util.printout()",
    "type": "statement:functioncall"
  }, {
    "id": 49,
    "text": "util.printout(name..\" \"..version..\" is now installed in \"..root_dir..\" \"..license)",
    "type": "statement:functioncall"
  }, {
    "id": 50,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 51,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"install\")\r\n   end\r\n\r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n\r\n   if name:match(\"%.rockspec$\") or name:match(\"%.src%.rock$\") then\r\n      util.printout(\"Using \"..name..\"... switching to 'build' mode\")\r\n      local build = require(\"luarocks.build\")\r\n      return build.run(name, util.forward_flags(flags, \"local\", \"keep\", \"deps-mode\"))\r\n   elseif name:match(\"%.rock$\") then\r\n      ok, err = install_binary_rock(name, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   else\r\n      local search = require(\"luarocks.search\")\r\n      local results, err = search.find_suitable_rock(search.make_query(name:lower(), version))\r\n      if err then\r\n         return nil, err\r\n      elseif type(results) == \"string\" then\r\n         local url = results\r\n         util.printout(\"Installing \"..url..\"...\")\r\n         return run(url, util.forward_flags(flags))\r\n      else\r\n         util.printout()\r\n         util.printerr(\"Could not determine which rock to install.\")\r\n         util.title(\"Search results:\")\r\n         search.print_results(results)\r\n         return nil, (next(results) and \"Please narrow your query.\" or \"No results found.\")\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 52,
    "text": "local flags, name, version = util.parse_flags(...)",
    "type": "statement:localassign"
  }, {
    "id": 53,
    "text": "if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"install\")\r\n   end",
    "type": "statement:if"
  }, {
    "id": 54,
    "text": "local ok, err = fs.check_command_permissions(flags)",
    "type": "statement:localassign"
  }, {
    "id": 55,
    "text": "if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end",
    "type": "statement:if"
  }, {
    "id": 56,
    "text": "if name:match(\"%.rockspec$\") or name:match(\"%.src%.rock$\") then\r\n      util.printout(\"Using \"..name..\"... switching to 'build' mode\")\r\n      local build = require(\"luarocks.build\")\r\n      return build.run(name, util.forward_flags(flags, \"local\", \"keep\", \"deps-mode\"))\r\n   elseif name:match(\"%.rock$\") then\r\n      ok, err = install_binary_rock(name, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   else\r\n      local search = require(\"luarocks.search\")\r\n      local results, err = search.find_suitable_rock(search.make_query(name:lower(), version))\r\n      if err then\r\n         return nil, err\r\n      elseif type(results) == \"string\" then\r\n         local url = results\r\n         util.printout(\"Installing \"..url..\"...\")\r\n         return run(url, util.forward_flags(flags))\r\n      else\r\n         util.printout()\r\n         util.printerr(\"Could not determine which rock to install.\")\r\n         util.title(\"Search results:\")\r\n         search.print_results(results)\r\n         return nil, (next(results) and \"Please narrow your query.\" or \"No results found.\")\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 57,
    "text": "util.printout(\"Using \"..name..\"... switching to 'build' mode\")",
    "type": "statement:functioncall"
  }, {
    "id": 58,
    "text": "local build = require(\"luarocks.build\")",
    "type": "statement:localassign"
  }, {
    "id": 59,
    "text": "ok, err = install_binary_rock(name, deps.get_deps_mode(flags))",
    "type": "statement:assign"
  }, {
    "id": 60,
    "text": "if not ok then return nil, err end",
    "type": "statement:if"
  }, {
    "id": 61,
    "text": "local name, version = ok, err",
    "type": "statement:localassign"
  }, {
    "id": 62,
    "text": "if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 63,
    "text": "local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])",
    "type": "statement:localassign"
  }, {
    "id": 64,
    "text": "if not ok then util.printerr(err) end",
    "type": "statement:if"
  }, {
    "id": 65,
    "text": "util.printerr(err)",
    "type": "statement:functioncall"
  }, {
    "id": 66,
    "text": "local search = require(\"luarocks.search\")",
    "type": "statement:localassign"
  }, {
    "id": 67,
    "text": "local results, err = search.find_suitable_rock(search.make_query(name:lower(), version))",
    "type": "statement:localassign"
  }, {
    "id": 68,
    "text": "if err then\r\n         return nil, err\r\n      elseif type(results) == \"string\" then\r\n         local url = results\r\n         util.printout(\"Installing \"..url..\"...\")\r\n         return run(url, util.forward_flags(flags))\r\n      else\r\n         util.printout()\r\n         util.printerr(\"Could not determine which rock to install.\")\r\n         util.title(\"Search results:\")\r\n         search.print_results(results)\r\n         return nil, (next(results) and \"Please narrow your query.\" or \"No results found.\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 69,
    "text": "local url = results",
    "type": "statement:localassign"
  }, {
    "id": 70,
    "text": "util.printout(\"Installing \"..url..\"...\")",
    "type": "statement:functioncall"
  }, {
    "id": 71,
    "text": "util.printerr(\"Could not determine which rock to install.\")",
    "type": "statement:functioncall"
  }, {
    "id": 72,
    "text": "util.title(\"Search results:\")",
    "type": "statement:functioncall"
  }, {
    "id": 73,
    "text": "search.print_results(results)",
    "type": "statement:functioncall"
  }, {
    "id": 74,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 75,
    "text": "function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end",
    "type": "function"
  }, {
    "id": 76,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 77,
    "text": "function()\r\n      repos.delete_version(name, version)\r\n   end",
    "type": "function"
  }, {
    "id": 78,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 79,
    "text": "",
    "type": "function container"
  }, {
    "id": 80,
    "text": "function make_rock_manifest(name, version)\r\n   local install_dir = path.install_dir(name, version)\r\n   local rock_manifest = path.rock_manifest_file(name, version)\r\n   local tree = {}\r\n   for _, file in ipairs(fs.find(install_dir)) do\r\n      local full_path = dir.path(install_dir, file)\r\n      local walk = tree\r\n      local last\r\n      local last_name\r\n      for name in file:gmatch(\"[^/]+\") do\r\n         local next = walk[name]\r\n         if not next then\r\n            next = {}\r\n            walk[name] = next\r\n         end\r\n         last = walk\r\n         last_name = name\r\n         walk = next\r\n      end\r\n      if fs.is_file(full_path) then\r\n         local sum, err = fs.get_md5(full_path)\r\n         if not sum then\r\n            return nil, \"Failed producing checksum: \"..tostring(err)\r\n         end\r\n         last[last_name] = sum\r\n      end\r\n   end\r\n   local rock_manifest = { rock_manifest=tree }\r\n   rock_manifest_cache[name..\"/\"..version] = rock_manifest\r\n   save_table(install_dir, \"rock_manifest\", rock_manifest )\r\nend",
    "type": "function"
  }, {
    "id": 81,
    "text": "function update_manifest(name, version, repo, deps_mode)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   repo = path.rocks_dir(repo or cfg.root_dir)\r\n   assert(type(deps_mode) == \"string\")\r\n   \r\n   if deps_mode == \"none\" then deps_mode = cfg.deps_mode end\r\n\r\n   util.printout(\"Updating manifest for \"..repo)\r\n\r\n   local manifest, err = load_manifest(repo)\r\n   if not manifest then\r\n      util.printerr(\"No existing manifest. Attempting to rebuild...\")\r\n      local ok, err = make_manifest(repo, deps_mode)\r\n      if not ok then\r\n         return nil, err\r\n      end\r\n      manifest, err = load_manifest(repo)\r\n      if not manifest then\r\n         return nil, err\r\n      end\r\n   end\r\n\r\n   local results = {[name] = {[version] = {{arch = \"installed\", repo = repo}}}}\r\n\r\n   local dep_handler = function(manifest)\r\n      update_dependencies(manifest, deps_mode)\r\n   end\r\n   local ok, err = store_results(results, manifest, dep_handler)\r\n   if not ok then return nil, err end\r\n\r\n   return save_table(repo, \"manifest\", manifest)\r\nend",
    "type": "function"
  }, {
    "id": 82,
    "text": "function root_dir(rocks_dir)\r\n   assert(type(rocks_dir) == \"string\")\r\n   return rocks_dir:match(\"(.*)\" .. util.matchquote(cfg.rocks_subdir) .. \".*$\")\r\nend",
    "type": "function"
  }, {
    "id": 83,
    "text": "function versions_dir(name, tree)\r\n   assert(type(name) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name)\r\nend",
    "type": "function"
  }, {
    "id": 84,
    "text": "function install_dir(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version)\r\nend",
    "type": "function"
  }, {
    "id": 85,
    "text": "function rockspec_file(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, name..\"-\"..version..\".rockspec\")\r\nend",
    "type": "function"
  }, {
    "id": 86,
    "text": "function rock_manifest_file(name, version, tree)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   tree = tree or cfg.root_dir\r\n   return dir.path(rocks_dir(tree), name, version, \"rock_manifest\")\r\nend",
    "type": "function"
  }, {
    "id": 87,
    "text": "function parse_name(file_name)\r\n   assert(type(file_name) == \"string\")\r\n   if file_name:match(\"%.rock$\") then\r\n      return dir.base_name(file_name):match(\"(.*)-([^-]+-%d+)%.([^.]+)%.rock$\")\r\n   else\r\n      return dir.base_name(file_name):match(\"(.*)-([^-]+-%d+)%.(rockspec)\")\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 88,
    "text": "function remove_other_versions(name, version, force)\r\n   local results = {}\r\n   search.manifest_search(results, cfg.rocks_dir, { name = name, exact_name = true, constraints = {{ op = \"~=\", version = version}} })\r\n   if results[name] then\r\n      return remove_search_results(results, name, cfg.deps_mode, force)\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 89,
    "text": "function is_installed(name, version)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n      \r\n   return fs.is_dir(path.install_dir(name, version))\r\nend",
    "type": "function"
  }, {
    "id": 90,
    "text": "function run_hook(rockspec, hook_name)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(hook_name) == \"string\")\r\n\r\n   local hooks = rockspec.hooks\r\n   if not hooks then\r\n      return true\r\n   end\r\n   \r\n   if cfg.hooks_enabled == false then\r\n      return nil, \"This rockspec contains hooks, which are blocked by the 'hooks_enabled' setting in your LuaRocks configuration.\"\r\n   end\r\n   \r\n   if not hooks.substituted_variables then\r\n      util.variable_substitutions(hooks, rockspec.variables)\r\n      hooks.substituted_variables = true\r\n   end\r\n   local hook = hooks[hook_name]\r\n   if hook then\r\n      util.printout(hook)\r\n      if not fs.execute(hook) then\r\n         return nil, \"Failed running \"..hook_name..\" hook.\"\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 91,
    "text": "function should_wrap_bin_scripts(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   if cfg.wrap_bin_scripts ~= nil then\r\n      return cfg.wrap_bin_scripts\r\n   end\r\n   if rockspec.deploy and rockspec.deploy.wrap_bin_scripts == false then\r\n      return false\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 92,
    "text": "function deploy_files(name, version, wrap_bin_scripts)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n   assert(type(wrap_bin_scripts) == \"boolean\")\r\n\r\n   local function deploy_file_tree(file_tree, path_fn, deploy_dir, move_fn)\r\n      local source_dir = path_fn(name, version)\r\n      if not move_fn then\r\n         move_fn = fs.move\r\n      end\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local source = dir.path(source_dir, parent_path, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local ok, err\r\n            if fs.exists(target) then\r\n               local new_target, err = resolve_conflict(target, deploy_dir, name, version)\r\n               if err == \"untracked\" then\r\n                  local backup = target\r\n                  repeat\r\n                     backup = backup..\"~\"\r\n                  until not fs.exists(backup) -- slight race condition here, but shouldn't be a problem.\r\n                  util.printerr(\"Warning: \"..target..\" is not tracked by this installation of LuaRocks. Moving it to \"..backup)\r\n                  fs.move(target, backup)\r\n               elseif err then\r\n                  return nil, err..\" Cannot install new version.\"\r\n               else\r\n                  target = new_target\r\n               end\r\n            end\r\n            ok, err = fs.make_dir(dir.dir_name(target))\r\n            if not ok then return nil, err end\r\n            ok, err = move_fn(source, target, name, version)\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(source))\r\n            if not ok then return nil, err end\r\n            return true\r\n         end\r\n      )\r\n   end\r\n\r\n   local rock_manifest = manif.load_rock_manifest(name, version)\r\n   \r\n   local ok, err = true\r\n   if rock_manifest.bin then\r\n      local move_bin_fn = wrap_bin_scripts and install_binary or fs.copy_binary\r\n      ok, err = deploy_file_tree(rock_manifest.bin, path.bin_dir, cfg.deploy_bin_dir, move_bin_fn)\r\n   end\r\n   if ok and rock_manifest.lua then\r\n      ok, err = deploy_file_tree(rock_manifest.lua, path.lua_dir, cfg.deploy_lua_dir)\r\n   end\r\n   if ok and rock_manifest.lib then\r\n      ok, err = deploy_file_tree(rock_manifest.lib, path.lib_dir, cfg.deploy_lib_dir)\r\n   end\r\n   return ok, err\r\nend",
    "type": "function"
  }, {
    "id": 93,
    "text": "function delete_version(name, version, quick)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local function delete_deployed_file_tree(file_tree, deploy_dir, suffix)\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local versioned = path.versioned_name(target, deploy_dir, name, version)\r\n            local ok, name, err = delete_suffixed(versioned, suffix)\r\n            if ok then\r\n               fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               return true\r\n            end\r\n            if err == \"fail\" then return nil, name end\r\n            ok, name, err = delete_suffixed(target, suffix)\r\n            if err == \"fail\" then return nil, name end\r\n            if not quick then\r\n               local next_name, next_version = manif.find_next_provider(target)\r\n               if next_name then\r\n                  local versioned = path.versioned_name(name, deploy_dir, next_name, next_version)\r\n                  fs.move(versioned, name)\r\n                  fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               end\r\n            end\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(target))\r\n            return true\r\n         end\r\n      )\r\n   end\r\n\r\n   local rock_manifest = manif.load_rock_manifest(name, version)\r\n   if not rock_manifest then\r\n      return nil, \"rock_manifest file not found for \"..name..\" \"..version..\" - not a LuaRocks 2 tree?\"\r\n   end\r\n   \r\n   local ok, err = true\r\n   if rock_manifest.bin then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.bin, cfg.deploy_bin_dir, cfg.wrapper_suffix)\r\n   end\r\n   if ok and rock_manifest.lua then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.lua, cfg.deploy_lua_dir)\r\n   end\r\n   if ok and rock_manifest.lib then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.lib, cfg.deploy_lib_dir)\r\n   end\r\n   if err then return nil, err end\r\n\r\n   fs.delete(path.install_dir(name, version))\r\n   if not get_installed_versions(name) then\r\n      fs.delete(dir.path(cfg.rocks_dir, name))\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 94,
    "text": "function make_query(name, version)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\" or not version)\r\n   \r\n   local query = {\r\n      name = name,\r\n      constraints = {}\r\n   }\r\n   if version then\r\n      table.insert(query.constraints, { op = \"==\", version = deps.parse_version(version)})\r\n   end\r\n   return query\r\nend",
    "type": "function"
  }, {
    "id": 95,
    "text": "function find_suitable_rock(query)\r\n   assert(type(query) == \"table\")\r\n   \r\n   local results = search_repos(query)\r\n   local first = next(results)\r\n   if not first then\r\n      return nil, \"No results matching query were found.\"\r\n   elseif not next(results, first) then\r\n      if cfg.rocks_provided[query.name] ~= nil then\r\n         -- do not install versions that listed in cfg.rocks_provided\r\n         return nil, \"Rock \"..query.name..\r\n                     \" \"..cfg.rocks_provided[query.name]..\r\n                     \" was found but it is provided by VM or 'rocks_provided' in the config file.\"\r\n      end\r\n      return pick_latest_version(query.name, results[first])\r\n   else\r\n      return results\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 96,
    "text": "function print_results(results, porcelain)\r\n   assert(type(results) == \"table\")\r\n   assert(type(porcelain) == \"boolean\" or not porcelain)\r\n   \r\n   for package, versions in util.sortedpairs(results) do\r\n      if not porcelain then\r\n         util.printout(package)\r\n      end\r\n      for version, repos in util.sortedpairs(versions, deps.compare_versions) do\r\n         for _, repo in ipairs(repos) do\r\n            repo.repo = dir.normalize(repo.repo)\r\n            if porcelain then\r\n               util.printout(package, version, repo.arch, repo.repo)\r\n            else\r\n               util.printout(\"   \"..version..\" (\"..repo.arch..\") - \"..repo.repo)\r\n            end\r\n         end\r\n      end\r\n      if not porcelain then\r\n         util.printout()\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 97,
    "text": "function schedule_function(f, ...)\r\n   assert(type(f) == \"function\")\r\n   \r\n   local item = { fn = f, args = {...} }\r\n   table.insert(scheduled_functions, item)\r\n   return item\r\nend",
    "type": "function"
  }, {
    "id": 98,
    "text": "function remove_scheduled_function(item)\r\n   for k, v in pairs(scheduled_functions) do\r\n      if v == item then\r\n         table.remove(scheduled_functions, k)\r\n         return\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 99,
    "text": "function parse_flags(...)\r\n   local args = {...}\r\n   local flags = {}\r\n   for i = #args, 1, -1 do\r\n      local flag = args[i]:match(\"^%-%-(.*)\")\r\n      if flag then\r\n         local var,val = flag:match(\"([a-z_%-]*)=(.*)\")\r\n         if val then\r\n            flags[var] = val\r\n         else\r\n            flags[flag] = true\r\n         end\r\n         table.remove(args, i)\r\n      end\r\n   end\r\n   return flags, unpack(args)\r\nend",
    "type": "function"
  }, {
    "id": 100,
    "text": "function forward_flags(flags, ...)\r\n   assert(type(flags) == \"table\")\r\n   local out = {}\r\n   local filter = select('#', ...)\r\n   local function add_flag(flagname)\r\n      if flags[flagname] then\r\n         if flags[flagname] == true then\r\n            table.insert(out, \"--\"..flagname)\r\n         else\r\n            table.insert(out, \"--\"..flagname..\"=\"..flags[flagname])\r\n         end\r\n      end\r\n   end\r\n   if filter > 0 then\r\n      for i = 1, filter do\r\n         add_flag(select(i, ...))\r\n      end\r\n   else\r\n      for flagname, _ in pairs(flags) do\r\n         add_flag(flagname)\r\n      end\r\n   end\r\n   return unpack(out)\r\nend",
    "type": "function"
  }, {
    "id": 101,
    "text": "function printout(...)\r\n   io.stdout:write(table.concat({...},\"\\t\"))\r\n   io.stdout:write(\"\\n\")\r\nend",
    "type": "function"
  }, {
    "id": 102,
    "text": "function printerr(...)\r\n   io.stderr:write(table.concat({...},\"\\t\"))\r\n   io.stderr:write(\"\\n\")\r\nend",
    "type": "function"
  }, {
    "id": 103,
    "text": "function title(msg, porcelain, underline)\r\n   if porcelain then return end\r\n   printout()\r\n   printout(msg)\r\n   printout((underline or \"-\"):rep(#msg))\r\n   printout()\r\nend",
    "type": "function"
  }, {
    "id": 104,
    "text": "function deps_mode_help(program)\r\n   return [[\r\n--deps-mode=<mode>  How to handle dependencies. Four modes are supported:\r\n                    * all - use all trees from the rocks_trees list\r\n                      for finding dependencies\r\n                    * one - use only the current tree (possibly set\r\n                      with --tree)\r\n                    * order - use trees based on order (use the current\r\n                      tree and all trees below it on the rocks_trees list)\r\n                    * none - ignore dependencies altogether.\r\n                    The default mode may be set with the deps_mode entry\r\n                    in the configuration file.\r\n                    The current default is \"]]..cfg.deps_mode..[[\".\r\n                    Type ']]..this_program(program or \"luarocks\")..[[' with no arguments to see\r\n                    your list of rocks trees.\r\n]]\r\nend",
    "type": "function"
  }, {
    "id": 105,
    "text": "function see_help(command, program)\r\n   return \"See '\"..this_program(program or \"luarocks\")..' help '..command..\"'.\"\r\nend",
    "type": "function"
  }, {
    "id": 106,
    "text": "local function validate_rock(file)\r\n   local ok, err, errcode = install.install_binary_rock(file, \"one\")\r\n   if not ok then\r\n      util.printerr(err)\r\n   end\r\n   return ok, err, errcode\r\nend",
    "type": "function"
  }, {
    "id": 107,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 108,
    "text": "module",
    "type": "global function"
  }, {
    "id": 109,
    "text": "type",
    "type": "global function"
  }, {
    "id": 110,
    "text": "next",
    "type": "global function"
  }, {
    "id": 111,
    "text": "require",
    "type": "global function"
  }, {
    "id": 112,
    "text": "cfg)",
    "type": "module"
  }, {
    "id": 113,
    "text": "util)",
    "type": "module"
  }, {
    "id": 114,
    "text": "fetch)",
    "type": "module"
  }, {
    "id": 115,
    "text": "manif)",
    "type": "module"
  }, {
    "id": 116,
    "text": "fs)",
    "type": "module"
  }, {
    "id": 117,
    "text": "path)",
    "type": "module"
  }, {
    "id": 118,
    "text": "repos)",
    "type": "module"
  }, {
    "id": 119,
    "text": "deps)",
    "type": "module"
  }, {
    "id": 120,
    "text": "search)",
    "type": "module"
  }, {
    "id": 121,
    "text": "remove)",
    "type": "module"
  }, {
    "id": 122,
    "text": "",
    "type": "variable container"
  }, {
    "id": 123,
    "text": "",
    "type": "require container"
  }, {
    "id": 124,
    "text": "",
    "type": "global variable"
  }, {
    "id": 125,
    "text": "",
    "type": "global variable"
  }, {
    "id": 126,
    "text": "",
    "type": "global variable"
  }, {
    "id": 127,
    "text": "",
    "type": "n/a"
  }, {
    "id": 128,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 129,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 130,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 131,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 132,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 133,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 134,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 135,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 136,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 137,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 138,
    "text": "build)",
    "type": "module"
  }, {
    "id": 139,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 140,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 141,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 142,
    "text": "",
    "type": "require local variable"
  } ]
}