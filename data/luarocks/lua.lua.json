{
  "_filename": "lua.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/luarocks/src/luarocks/fs/lua.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "calls",
    "to": 191
  }, {
    "from": 2,
    "label": "calls",
    "to": 115
  }, {
    "from": 2,
    "label": "calls",
    "to": 77
  }, {
    "from": 2,
    "label": "calls",
    "to": 79
  }, {
    "from": 2,
    "label": "calls",
    "to": 79
  }, {
    "from": 2,
    "label": "calls",
    "to": 63
  }, {
    "from": 3,
    "label": "calls",
    "to": 63
  }, {
    "from": 3,
    "label": "calls",
    "to": 191
  }, {
    "from": 3,
    "label": "calls",
    "to": 165
  }, {
    "from": 3,
    "label": "calls",
    "to": 77
  }, {
    "from": 3,
    "label": "calls",
    "to": 79
  }, {
    "from": 3,
    "label": "calls",
    "to": 79
  }, {
    "from": 5,
    "label": "calls",
    "to": 191
  }, {
    "from": 5,
    "label": "calls",
    "to": 191
  }, {
    "from": 5,
    "label": "calls",
    "to": 91
  }, {
    "from": 5,
    "label": "calls",
    "to": 91
  }, {
    "from": 5,
    "label": "calls",
    "to": 115
  }, {
    "from": 5,
    "label": "calls",
    "to": 148
  }, {
    "from": 4,
    "label": "calls",
    "to": 63
  }, {
    "from": 5,
    "label": "calls",
    "to": 77
  }, {
    "from": 5,
    "label": "calls",
    "to": 77
  }, {
    "from": 5,
    "label": "calls",
    "to": 193
  }, {
    "from": 6,
    "label": "calls",
    "to": 77
  }, {
    "from": 6,
    "label": "calls",
    "to": 74
  }, {
    "from": 6,
    "label": "calls",
    "to": 74
  }, {
    "from": 6,
    "label": "calls",
    "to": 74
  }, {
    "from": 6,
    "label": "calls",
    "to": 66
  }, {
    "from": 7,
    "label": "calls",
    "to": 63
  }, {
    "from": 7,
    "label": "calls",
    "to": 63
  }, {
    "from": 8,
    "label": "calls",
    "to": 63
  }, {
    "from": 12,
    "label": "calls",
    "to": 193
  }, {
    "from": 9,
    "label": "calls",
    "to": 91
  }, {
    "from": 9,
    "label": "calls",
    "to": 91
  }, {
    "from": 9,
    "label": "calls",
    "to": 91
  }, {
    "from": 12,
    "label": "calls",
    "to": 91
  }, {
    "from": 12,
    "label": "calls",
    "to": 91
  }, {
    "from": 12,
    "label": "calls",
    "to": 107
  }, {
    "from": 12,
    "label": "calls",
    "to": 107
  }, {
    "from": 11,
    "label": "calls",
    "to": 296
  }, {
    "from": 9,
    "label": "calls",
    "to": 115
  }, {
    "from": 12,
    "label": "calls",
    "to": 115
  }, {
    "from": 12,
    "label": "calls",
    "to": 148
  }, {
    "from": 14,
    "label": "calls",
    "to": 308
  }, {
    "from": 10,
    "label": "calls",
    "to": 77
  }, {
    "from": 12,
    "label": "calls",
    "to": 165
  }, {
    "from": 12,
    "label": "calls",
    "to": 86
  }, {
    "from": 12,
    "label": "calls",
    "to": 86
  }, {
    "from": 13,
    "label": "calls",
    "to": 86
  }, {
    "from": 12,
    "label": "calls",
    "to": 79
  }, {
    "from": 12,
    "label": "calls",
    "to": 79
  }, {
    "from": 13,
    "label": "calls",
    "to": 79
  }, {
    "from": 15,
    "label": "calls",
    "to": 63
  }, {
    "from": 15,
    "label": "calls",
    "to": 63
  }, {
    "from": 15,
    "label": "calls",
    "to": 91
  }, {
    "from": 15,
    "label": "calls",
    "to": 91
  }, {
    "from": 15,
    "label": "calls",
    "to": 51
  }, {
    "from": 15,
    "label": "calls",
    "to": 79
  }, {
    "from": 16,
    "label": "calls",
    "to": 168
  }, {
    "from": 16,
    "label": "calls",
    "to": 195
  }, {
    "from": 22,
    "label": "calls",
    "to": 188
  }, {
    "from": 22,
    "label": "calls",
    "to": 193
  }, {
    "from": 23,
    "label": "calls",
    "to": 77
  }, {
    "from": 23,
    "label": "calls",
    "to": 115
  }, {
    "from": 24,
    "label": "calls",
    "to": 63
  }, {
    "from": 24,
    "label": "calls",
    "to": 79
  }, {
    "from": 24,
    "label": "calls",
    "to": 51
  }, {
    "from": 24,
    "label": "calls",
    "to": 86
  }, {
    "from": 25,
    "label": "calls",
    "to": 63
  }, {
    "from": 25,
    "label": "calls",
    "to": 63
  }, {
    "from": 25,
    "label": "calls",
    "to": 165
  }, {
    "from": 25,
    "label": "calls",
    "to": 165
  }, {
    "from": 25,
    "label": "calls",
    "to": 79
  }, {
    "from": 25,
    "label": "calls",
    "to": 79
  }, {
    "from": 25,
    "label": "calls",
    "to": 86
  }, {
    "from": 25,
    "label": "calls",
    "to": 86
  }, {
    "from": 25,
    "label": "calls",
    "to": 51
  }, {
    "from": 26,
    "label": "calls",
    "to": 63
  }, {
    "from": 26,
    "label": "calls",
    "to": 79
  }, {
    "from": 26,
    "label": "calls",
    "to": 79
  }, {
    "from": 26,
    "label": "calls",
    "to": 165
  }, {
    "from": 26,
    "label": "calls",
    "to": 165
  }, {
    "from": 26,
    "label": "calls",
    "to": 51
  }, {
    "from": 26,
    "label": "calls",
    "to": 86
  }, {
    "from": 26,
    "label": "calls",
    "to": 86
  }, {
    "from": 27,
    "label": "calls",
    "to": 63
  }, {
    "from": 28,
    "label": "calls",
    "to": 63
  }, {
    "from": 28,
    "label": "calls",
    "to": 79
  }, {
    "from": 28,
    "label": "calls",
    "to": 79
  }, {
    "from": 28,
    "label": "calls",
    "to": 86
  }, {
    "from": 28,
    "label": "calls",
    "to": 86
  }, {
    "from": 28,
    "label": "calls",
    "to": 165
  }, {
    "from": 28,
    "label": "calls",
    "to": 51
  }, {
    "from": 28,
    "label": "calls",
    "to": 188
  }, {
    "from": 30,
    "label": "calls",
    "to": 191
  }, {
    "from": 33,
    "label": "calls",
    "to": 191
  }, {
    "from": 31,
    "label": "calls",
    "to": 91
  }, {
    "from": 29,
    "label": "calls",
    "to": 260
  }, {
    "from": 30,
    "label": "calls",
    "to": 86
  }, {
    "from": 31,
    "label": "calls",
    "to": 86
  }, {
    "from": 32,
    "label": "calls",
    "to": 86
  }, {
    "from": 33,
    "label": "calls",
    "to": 86
  }, {
    "from": 33,
    "label": "calls",
    "to": 86
  }, {
    "from": 30,
    "label": "calls",
    "to": 51
  }, {
    "from": 31,
    "label": "calls",
    "to": 51
  }, {
    "from": 33,
    "label": "calls",
    "to": 69
  }, {
    "from": 30,
    "label": "calls",
    "to": 79
  }, {
    "from": 31,
    "label": "calls",
    "to": 79
  }, {
    "from": 32,
    "label": "calls",
    "to": 79
  }, {
    "from": 33,
    "label": "calls",
    "to": 79
  }, {
    "from": 33,
    "label": "calls",
    "to": 79
  }, {
    "from": 31,
    "label": "calls",
    "to": 201
  }, {
    "from": 34,
    "label": "has",
    "to": 35
  }, {
    "from": 34,
    "label": "has",
    "to": 36
  }, {
    "from": 34,
    "label": "has",
    "to": 37
  }, {
    "from": 38,
    "label": "has",
    "to": 39
  }, {
    "from": 38,
    "label": "has",
    "to": 40
  }, {
    "from": 38,
    "label": "has",
    "to": 41
  }, {
    "from": 38,
    "label": "has",
    "to": 42
  }, {
    "from": 42,
    "label": "has",
    "to": 43
  }, {
    "from": 42,
    "label": "has",
    "to": 44
  }, {
    "from": 42,
    "label": "has",
    "to": 45
  }, {
    "from": 42,
    "label": "has",
    "to": 46
  }, {
    "from": 46,
    "label": "has",
    "to": 47
  }, {
    "from": 42,
    "label": "has",
    "to": 48
  }, {
    "from": 42,
    "label": "has",
    "to": 49
  }, {
    "from": 42,
    "label": "has",
    "to": 45
  }, {
    "from": 42,
    "label": "has",
    "to": 46
  }, {
    "from": 46,
    "label": "has",
    "to": 47
  }, {
    "from": 38,
    "label": "has",
    "to": 36
  }, {
    "from": 38,
    "label": "has",
    "to": 50
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 51,
    "label": "has",
    "to": 53
  }, {
    "from": 51,
    "label": "has",
    "to": 54
  }, {
    "from": 51,
    "label": "has",
    "to": 55
  }, {
    "from": 51,
    "label": "has",
    "to": 56
  }, {
    "from": 51,
    "label": "has",
    "to": 36
  }, {
    "from": 51,
    "label": "has",
    "to": 36
  }, {
    "from": 51,
    "label": "has",
    "to": 57
  }, {
    "from": 58,
    "label": "has",
    "to": 59
  }, {
    "from": 58,
    "label": "has",
    "to": 60
  }, {
    "from": 60,
    "label": "has",
    "to": 35
  }, {
    "from": 60,
    "label": "has",
    "to": 61
  }, {
    "from": 58,
    "label": "has",
    "to": 36
  }, {
    "from": 58,
    "label": "has",
    "to": 62
  }, {
    "from": 63,
    "label": "has",
    "to": 64
  }, {
    "from": 63,
    "label": "has",
    "to": 36
  }, {
    "from": 63,
    "label": "has",
    "to": 65
  }, {
    "from": 66,
    "label": "has",
    "to": 64
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 66,
    "label": "has",
    "to": 36
  }, {
    "from": 66,
    "label": "has",
    "to": 36
  }, {
    "from": 66,
    "label": "has",
    "to": 68
  }, {
    "from": 69,
    "label": "has",
    "to": 40
  }, {
    "from": 69,
    "label": "has",
    "to": 70
  }, {
    "from": 69,
    "label": "has",
    "to": 71
  }, {
    "from": 69,
    "label": "has",
    "to": 36
  }, {
    "from": 69,
    "label": "has",
    "to": 72
  }, {
    "from": 69,
    "label": "has",
    "to": 36
  }, {
    "from": 69,
    "label": "has",
    "to": 36
  }, {
    "from": 69,
    "label": "has",
    "to": 73
  }, {
    "from": 74,
    "label": "has",
    "to": 75
  }, {
    "from": 74,
    "label": "has",
    "to": 36
  }, {
    "from": 74,
    "label": "has",
    "to": 76
  }, {
    "from": 77,
    "label": "has",
    "to": 36
  }, {
    "from": 77,
    "label": "has",
    "to": 78
  }, {
    "from": 79,
    "label": "has",
    "to": 80
  }, {
    "from": 79,
    "label": "has",
    "to": 81
  }, {
    "from": 79,
    "label": "has",
    "to": 36
  }, {
    "from": 79,
    "label": "has",
    "to": 82
  }, {
    "from": 83,
    "label": "has",
    "to": 80
  }, {
    "from": 83,
    "label": "has",
    "to": 84
  }, {
    "from": 83,
    "label": "has",
    "to": 85
  }, {
    "from": 86,
    "label": "has",
    "to": 87
  }, {
    "from": 86,
    "label": "has",
    "to": 88
  }, {
    "from": 88,
    "label": "has",
    "to": 89
  }, {
    "from": 86,
    "label": "has",
    "to": 36
  }, {
    "from": 86,
    "label": "has",
    "to": 36
  }, {
    "from": 86,
    "label": "has",
    "to": 90
  }, {
    "from": 91,
    "label": "has",
    "to": 92
  }, {
    "from": 91,
    "label": "has",
    "to": 93
  }, {
    "from": 91,
    "label": "has",
    "to": 94
  }, {
    "from": 91,
    "label": "has",
    "to": 95
  }, {
    "from": 95,
    "label": "has",
    "to": 96
  }, {
    "from": 95,
    "label": "has",
    "to": 97
  }, {
    "from": 95,
    "label": "has",
    "to": 98
  }, {
    "from": 98,
    "label": "has",
    "to": 99
  }, {
    "from": 91,
    "label": "has",
    "to": 100
  }, {
    "from": 100,
    "label": "has",
    "to": 101
  }, {
    "from": 100,
    "label": "has",
    "to": 102
  }, {
    "from": 100,
    "label": "has",
    "to": 103
  }, {
    "from": 103,
    "label": "has",
    "to": 104
  }, {
    "from": 103,
    "label": "has",
    "to": 105
  }, {
    "from": 91,
    "label": "has",
    "to": 36
  }, {
    "from": 91,
    "label": "has",
    "to": 36
  }, {
    "from": 91,
    "label": "has",
    "to": 36
  }, {
    "from": 91,
    "label": "has",
    "to": 106
  }, {
    "from": 107,
    "label": "has",
    "to": 108
  }, {
    "from": 107,
    "label": "has",
    "to": 81
  }, {
    "from": 107,
    "label": "has",
    "to": 109
  }, {
    "from": 107,
    "label": "has",
    "to": 110
  }, {
    "from": 111,
    "label": "has",
    "to": 108
  }, {
    "from": 111,
    "label": "has",
    "to": 81
  }, {
    "from": 111,
    "label": "has",
    "to": 112
  }, {
    "from": 112,
    "label": "has",
    "to": 109
  }, {
    "from": 112,
    "label": "has",
    "to": 113
  }, {
    "from": 111,
    "label": "has",
    "to": 114
  }, {
    "from": 115,
    "label": "has",
    "to": 116
  }, {
    "from": 115,
    "label": "has",
    "to": 117
  }, {
    "from": 115,
    "label": "has",
    "to": 118
  }, {
    "from": 115,
    "label": "has",
    "to": 119
  }, {
    "from": 115,
    "label": "has",
    "to": 120
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 115,
    "label": "has",
    "to": 122
  }, {
    "from": 122,
    "label": "has",
    "to": 123
  }, {
    "from": 115,
    "label": "has",
    "to": 124
  }, {
    "from": 115,
    "label": "has",
    "to": 125
  }, {
    "from": 115,
    "label": "has",
    "to": 36
  }, {
    "from": 115,
    "label": "has",
    "to": 126
  }, {
    "from": 115,
    "label": "has",
    "to": 127
  }, {
    "from": 127,
    "label": "has",
    "to": 128
  }, {
    "from": 115,
    "label": "has",
    "to": 36
  }, {
    "from": 115,
    "label": "has",
    "to": 129
  }, {
    "from": 129,
    "label": "has",
    "to": 130
  }, {
    "from": 129,
    "label": "has",
    "to": 131
  }, {
    "from": 129,
    "label": "has",
    "to": 132
  }, {
    "from": 115,
    "label": "has",
    "to": 128
  }, {
    "from": 115,
    "label": "has",
    "to": 133
  }, {
    "from": 115,
    "label": "has",
    "to": 134
  }, {
    "from": 115,
    "label": "has",
    "to": 36
  }, {
    "from": 115,
    "label": "has",
    "to": 135
  }, {
    "from": 136,
    "label": "has",
    "to": 137
  }, {
    "from": 136,
    "label": "has",
    "to": 138
  }, {
    "from": 138,
    "label": "has",
    "to": 139
  }, {
    "from": 138,
    "label": "has",
    "to": 140
  }, {
    "from": 138,
    "label": "has",
    "to": 141
  }, {
    "from": 138,
    "label": "has",
    "to": 142
  }, {
    "from": 138,
    "label": "has",
    "to": 143
  }, {
    "from": 138,
    "label": "has",
    "to": 144
  }, {
    "from": 144,
    "label": "has",
    "to": 145
  }, {
    "from": 145,
    "label": "has",
    "to": 146
  }, {
    "from": 145,
    "label": "has",
    "to": 140
  }, {
    "from": 136,
    "label": "has",
    "to": 36
  }, {
    "from": 136,
    "label": "has",
    "to": 36
  }, {
    "from": 136,
    "label": "has",
    "to": 36
  }, {
    "from": 136,
    "label": "has",
    "to": 36
  }, {
    "from": 136,
    "label": "has",
    "to": 147
  }, {
    "from": 148,
    "label": "has",
    "to": 116
  }, {
    "from": 148,
    "label": "has",
    "to": 117
  }, {
    "from": 148,
    "label": "has",
    "to": 118
  }, {
    "from": 148,
    "label": "has",
    "to": 149
  }, {
    "from": 148,
    "label": "has",
    "to": 150
  }, {
    "from": 150,
    "label": "has",
    "to": 151
  }, {
    "from": 151,
    "label": "has",
    "to": 152
  }, {
    "from": 151,
    "label": "has",
    "to": 153
  }, {
    "from": 148,
    "label": "has",
    "to": 36
  }, {
    "from": 148,
    "label": "has",
    "to": 36
  }, {
    "from": 148,
    "label": "has",
    "to": 154
  }, {
    "from": 155,
    "label": "has",
    "to": 156
  }, {
    "from": 155,
    "label": "has",
    "to": 157
  }, {
    "from": 155,
    "label": "has",
    "to": 36
  }, {
    "from": 155,
    "label": "has",
    "to": 158
  }, {
    "from": 158,
    "label": "has",
    "to": 159
  }, {
    "from": 159,
    "label": "has",
    "to": 160
  }, {
    "from": 160,
    "label": "has",
    "to": 161
  }, {
    "from": 160,
    "label": "has",
    "to": 143
  }, {
    "from": 158,
    "label": "has",
    "to": 36
  }, {
    "from": 158,
    "label": "has",
    "to": 162
  }, {
    "from": 158,
    "label": "has",
    "to": 36
  }, {
    "from": 155,
    "label": "has",
    "to": 163
  }, {
    "from": 155,
    "label": "has",
    "to": 36
  }, {
    "from": 155,
    "label": "has",
    "to": 36
  }, {
    "from": 155,
    "label": "has",
    "to": 164
  }, {
    "from": 165,
    "label": "has",
    "to": 53
  }, {
    "from": 165,
    "label": "has",
    "to": 166
  }, {
    "from": 165,
    "label": "has",
    "to": 167
  }, {
    "from": 168,
    "label": "has",
    "to": 169
  }, {
    "from": 168,
    "label": "has",
    "to": 170
  }, {
    "from": 170,
    "label": "has",
    "to": 171
  }, {
    "from": 168,
    "label": "has",
    "to": 172
  }, {
    "from": 168,
    "label": "has",
    "to": 173
  }, {
    "from": 168,
    "label": "has",
    "to": 36
  }, {
    "from": 168,
    "label": "has",
    "to": 174
  }, {
    "from": 168,
    "label": "has",
    "to": 175
  }, {
    "from": 175,
    "label": "has",
    "to": 176
  }, {
    "from": 176,
    "label": "has",
    "to": 177
  }, {
    "from": 168,
    "label": "has",
    "to": 36
  }, {
    "from": 168,
    "label": "has",
    "to": 178
  }, {
    "from": 179,
    "label": "has",
    "to": 180
  }, {
    "from": 180,
    "label": "has",
    "to": 181
  }, {
    "from": 181,
    "label": "has",
    "to": 182
  }, {
    "from": 181,
    "label": "has",
    "to": 183
  }, {
    "from": 181,
    "label": "has",
    "to": 184
  }, {
    "from": 181,
    "label": "has",
    "to": 185
  }, {
    "from": 185,
    "label": "has",
    "to": 186
  }, {
    "from": 179,
    "label": "has",
    "to": 187
  }, {
    "from": 188,
    "label": "has",
    "to": 169
  }, {
    "from": 188,
    "label": "has",
    "to": 170
  }, {
    "from": 170,
    "label": "has",
    "to": 171
  }, {
    "from": 188,
    "label": "has",
    "to": 172
  }, {
    "from": 188,
    "label": "has",
    "to": 173
  }, {
    "from": 188,
    "label": "has",
    "to": 36
  }, {
    "from": 188,
    "label": "has",
    "to": 174
  }, {
    "from": 188,
    "label": "has",
    "to": 189
  }, {
    "from": 188,
    "label": "has",
    "to": 36
  }, {
    "from": 188,
    "label": "has",
    "to": 190
  }, {
    "from": 191,
    "label": "has",
    "to": 39
  }, {
    "from": 191,
    "label": "has",
    "to": 40
  }, {
    "from": 191,
    "label": "has",
    "to": 36
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 193,
    "label": "has",
    "to": 39
  }, {
    "from": 193,
    "label": "has",
    "to": 40
  }, {
    "from": 193,
    "label": "has",
    "to": 36
  }, {
    "from": 193,
    "label": "has",
    "to": 194
  }, {
    "from": 195,
    "label": "has",
    "to": 39
  }, {
    "from": 195,
    "label": "has",
    "to": 40
  }, {
    "from": 195,
    "label": "has",
    "to": 36
  }, {
    "from": 195,
    "label": "has",
    "to": 196
  }, {
    "from": 197,
    "label": "has",
    "to": 40
  }, {
    "from": 197,
    "label": "has",
    "to": 36
  }, {
    "from": 197,
    "label": "has",
    "to": 198
  }, {
    "from": 199,
    "label": "has",
    "to": 36
  }, {
    "from": 199,
    "label": "has",
    "to": 200
  }, {
    "from": 201,
    "label": "has",
    "to": 202
  }, {
    "from": 201,
    "label": "has",
    "to": 203
  }, {
    "from": 201,
    "label": "has",
    "to": 36
  }, {
    "from": 201,
    "label": "has",
    "to": 204
  }, {
    "from": 201,
    "label": "has",
    "to": 205
  }, {
    "from": 201,
    "label": "has",
    "to": 206
  }, {
    "from": 206,
    "label": "has",
    "to": 207
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 207,
    "label": "has",
    "to": 143
  }, {
    "from": 207,
    "label": "has",
    "to": 209
  }, {
    "from": 207,
    "label": "has",
    "to": 210
  }, {
    "from": 210,
    "label": "has",
    "to": 211
  }, {
    "from": 207,
    "label": "has",
    "to": 212
  }, {
    "from": 207,
    "label": "has",
    "to": 213
  }, {
    "from": 207,
    "label": "has",
    "to": 214
  }, {
    "from": 207,
    "label": "has",
    "to": 215
  }, {
    "from": 215,
    "label": "has",
    "to": 211
  }, {
    "from": 207,
    "label": "has",
    "to": 216
  }, {
    "from": 207,
    "label": "has",
    "to": 217
  }, {
    "from": 206,
    "label": "has",
    "to": 218
  }, {
    "from": 201,
    "label": "has",
    "to": 36
  }, {
    "from": 201,
    "label": "has",
    "to": 36
  }, {
    "from": 201,
    "label": "has",
    "to": 36
  }, {
    "from": 201,
    "label": "has",
    "to": 211
  }, {
    "from": 201,
    "label": "has",
    "to": 36
  }, {
    "from": 201,
    "label": "has",
    "to": 219
  }, {
    "from": 220,
    "label": "has",
    "to": 174
  }, {
    "from": 220,
    "label": "has",
    "to": 221
  }, {
    "from": 220,
    "label": "has",
    "to": 222
  }, {
    "from": 222,
    "label": "has",
    "to": 223
  }, {
    "from": 220,
    "label": "has",
    "to": 224
  }, {
    "from": 224,
    "label": "has",
    "to": 225
  }, {
    "from": 220,
    "label": "has",
    "to": 226
  }, {
    "from": 226,
    "label": "has",
    "to": 227
  }, {
    "from": 220,
    "label": "has",
    "to": 228
  }, {
    "from": 220,
    "label": "has",
    "to": 229
  }, {
    "from": 229,
    "label": "has",
    "to": 230
  }, {
    "from": 229,
    "label": "has",
    "to": 231
  }, {
    "from": 229,
    "label": "has",
    "to": 232
  }, {
    "from": 229,
    "label": "has",
    "to": 233
  }, {
    "from": 233,
    "label": "has",
    "to": 234
  }, {
    "from": 233,
    "label": "has",
    "to": 235
  }, {
    "from": 229,
    "label": "has",
    "to": 36
  }, {
    "from": 220,
    "label": "has",
    "to": 236
  }, {
    "from": 236,
    "label": "has",
    "to": 234
  }, {
    "from": 220,
    "label": "has",
    "to": 237
  }, {
    "from": 237,
    "label": "has",
    "to": 238
  }, {
    "from": 237,
    "label": "has",
    "to": 239
  }, {
    "from": 239,
    "label": "has",
    "to": 240
  }, {
    "from": 239,
    "label": "has",
    "to": 241
  }, {
    "from": 241,
    "label": "has",
    "to": 242
  }, {
    "from": 242,
    "label": "has",
    "to": 243
  }, {
    "from": 241,
    "label": "has",
    "to": 244
  }, {
    "from": 220,
    "label": "has",
    "to": 36
  }, {
    "from": 220,
    "label": "has",
    "to": 36
  }, {
    "from": 220,
    "label": "has",
    "to": 36
  }, {
    "from": 220,
    "label": "has",
    "to": 36
  }, {
    "from": 220,
    "label": "has",
    "to": 36
  }, {
    "from": 220,
    "label": "has",
    "to": 36
  }, {
    "from": 220,
    "label": "has",
    "to": 36
  }, {
    "from": 220,
    "label": "has",
    "to": 245
  }, {
    "from": 246,
    "label": "has",
    "to": 247
  }, {
    "from": 247,
    "label": "has",
    "to": 248
  }, {
    "from": 247,
    "label": "has",
    "to": 249
  }, {
    "from": 249,
    "label": "has",
    "to": 250
  }, {
    "from": 249,
    "label": "has",
    "to": 251
  }, {
    "from": 249,
    "label": "has",
    "to": 252
  }, {
    "from": 249,
    "label": "has",
    "to": 253
  }, {
    "from": 246,
    "label": "has",
    "to": 36
  }, {
    "from": 246,
    "label": "has",
    "to": 254
  }, {
    "from": 246,
    "label": "has",
    "to": 255
  }, {
    "from": 255,
    "label": "has",
    "to": 256
  }, {
    "from": 256,
    "label": "has",
    "to": 257
  }, {
    "from": 256,
    "label": "has",
    "to": 258
  }, {
    "from": 256,
    "label": "has",
    "to": 251
  }, {
    "from": 246,
    "label": "has",
    "to": 36
  }, {
    "from": 246,
    "label": "has",
    "to": 36
  }, {
    "from": 246,
    "label": "has",
    "to": 259
  }, {
    "from": 260,
    "label": "has",
    "to": 261
  }, {
    "from": 260,
    "label": "has",
    "to": 262
  }, {
    "from": 260,
    "label": "has",
    "to": 263
  }, {
    "from": 260,
    "label": "has",
    "to": 264
  }, {
    "from": 260,
    "label": "has",
    "to": 265
  }, {
    "from": 265,
    "label": "has",
    "to": 266
  }, {
    "from": 265,
    "label": "has",
    "to": 267
  }, {
    "from": 265,
    "label": "has",
    "to": 268
  }, {
    "from": 268,
    "label": "has",
    "to": 269
  }, {
    "from": 268,
    "label": "has",
    "to": 270
  }, {
    "from": 265,
    "label": "has",
    "to": 271
  }, {
    "from": 260,
    "label": "has",
    "to": 272
  }, {
    "from": 260,
    "label": "has",
    "to": 36
  }, {
    "from": 260,
    "label": "has",
    "to": 273
  }, {
    "from": 260,
    "label": "has",
    "to": 36
  }, {
    "from": 260,
    "label": "has",
    "to": 274
  }, {
    "from": 260,
    "label": "has",
    "to": 275
  }, {
    "from": 260,
    "label": "has",
    "to": 36
  }, {
    "from": 260,
    "label": "has",
    "to": 276
  }, {
    "from": 260,
    "label": "has",
    "to": 277
  }, {
    "from": 260,
    "label": "has",
    "to": 36
  }, {
    "from": 260,
    "label": "has",
    "to": 278
  }, {
    "from": 279,
    "label": "has",
    "to": 280
  }, {
    "from": 279,
    "label": "has",
    "to": 281
  }, {
    "from": 279,
    "label": "has",
    "to": 282
  }, {
    "from": 279,
    "label": "has",
    "to": 36
  }, {
    "from": 279,
    "label": "has",
    "to": 283
  }, {
    "from": 279,
    "label": "has",
    "to": 277
  }, {
    "from": 279,
    "label": "has",
    "to": 284
  }, {
    "from": 279,
    "label": "has",
    "to": 36
  }, {
    "from": 279,
    "label": "has",
    "to": 36
  }, {
    "from": 279,
    "label": "has",
    "to": 285
  }, {
    "from": 286,
    "label": "has",
    "to": 287
  }, {
    "from": 287,
    "label": "has",
    "to": 288
  }, {
    "from": 287,
    "label": "has",
    "to": 289
  }, {
    "from": 289,
    "label": "has",
    "to": 290
  }, {
    "from": 287,
    "label": "has",
    "to": 291
  }, {
    "from": 286,
    "label": "has",
    "to": 292
  }, {
    "from": 286,
    "label": "has",
    "to": 36
  }, {
    "from": 286,
    "label": "has",
    "to": 293
  }, {
    "from": 294,
    "label": "has",
    "to": 36
  }, {
    "from": 294,
    "label": "has",
    "to": 295
  }, {
    "from": 296,
    "label": "has",
    "to": 297
  }, {
    "from": 296,
    "label": "has",
    "to": 298
  }, {
    "from": 296,
    "label": "has",
    "to": 36
  }, {
    "from": 296,
    "label": "has",
    "to": 299
  }, {
    "from": 296,
    "label": "has",
    "to": 36
  }, {
    "from": 296,
    "label": "has",
    "to": 300
  }, {
    "from": 301,
    "label": "has",
    "to": 116
  }, {
    "from": 301,
    "label": "has",
    "to": 302
  }, {
    "from": 301,
    "label": "has",
    "to": 36
  }, {
    "from": 301,
    "label": "has",
    "to": 303
  }, {
    "from": 301,
    "label": "has",
    "to": 304
  }, {
    "from": 301,
    "label": "has",
    "to": 36
  }, {
    "from": 301,
    "label": "has",
    "to": 305
  }, {
    "from": 301,
    "label": "has",
    "to": 306
  }, {
    "from": 301,
    "label": "has",
    "to": 36
  }, {
    "from": 301,
    "label": "has",
    "to": 36
  }, {
    "from": 301,
    "label": "has",
    "to": 307
  }, {
    "from": 308,
    "label": "has",
    "to": 309
  }, {
    "from": 308,
    "label": "has",
    "to": 310
  }, {
    "from": 308,
    "label": "has",
    "to": 311
  }, {
    "from": 308,
    "label": "has",
    "to": 312
  }, {
    "from": 312,
    "label": "has",
    "to": 313
  }, {
    "from": 313,
    "label": "has",
    "to": 314
  }, {
    "from": 313,
    "label": "has",
    "to": 315
  }, {
    "from": 308,
    "label": "has",
    "to": 316
  }, {
    "from": 308,
    "label": "has",
    "to": 317
  }, {
    "from": 317,
    "label": "has",
    "to": 314
  }, {
    "from": 317,
    "label": "has",
    "to": 318
  }, {
    "from": 308,
    "label": "has",
    "to": 319
  }, {
    "from": 319,
    "label": "has",
    "to": 320
  }, {
    "from": 320,
    "label": "has",
    "to": 321
  }, {
    "from": 320,
    "label": "has",
    "to": 322
  }, {
    "from": 308,
    "label": "has",
    "to": 36
  }, {
    "from": 308,
    "label": "has",
    "to": 36
  }, {
    "from": 308,
    "label": "has",
    "to": 323
  }, {
    "from": 324,
    "label": "has",
    "to": 159
  }, {
    "from": 159,
    "label": "has",
    "to": 160
  }, {
    "from": 160,
    "label": "has",
    "to": 161
  }, {
    "from": 160,
    "label": "has",
    "to": 143
  }, {
    "from": 324,
    "label": "has",
    "to": 36
  }, {
    "from": 324,
    "label": "has",
    "to": 162
  }, {
    "from": 324,
    "label": "has",
    "to": 36
  }, {
    "from": 324,
    "label": "has",
    "to": 325
  }, {
    "from": 326,
    "label": "has",
    "to": 230
  }, {
    "from": 326,
    "label": "has",
    "to": 231
  }, {
    "from": 326,
    "label": "has",
    "to": 232
  }, {
    "from": 326,
    "label": "has",
    "to": 233
  }, {
    "from": 233,
    "label": "has",
    "to": 234
  }, {
    "from": 233,
    "label": "has",
    "to": 235
  }, {
    "from": 326,
    "label": "has",
    "to": 36
  }, {
    "from": 326,
    "label": "has",
    "to": 327
  }, {
    "from": 220,
    "label": "calls",
    "to": 435
  }, {
    "from": 220,
    "label": "calls",
    "to": 435
  }, {
    "from": 220,
    "label": "calls",
    "to": 435
  }, {
    "from": 220,
    "label": "calls",
    "to": 435
  }, {
    "from": 38,
    "label": "calls",
    "to": 193
  }, {
    "from": 168,
    "label": "calls",
    "to": 193
  }, {
    "from": 188,
    "label": "calls",
    "to": 193
  }, {
    "from": 301,
    "label": "calls",
    "to": 193
  }, {
    "from": 34,
    "label": "calls",
    "to": 436
  }, {
    "from": 38,
    "label": "calls",
    "to": 436
  }, {
    "from": 51,
    "label": "calls",
    "to": 436
  }, {
    "from": 58,
    "label": "calls",
    "to": 436
  }, {
    "from": 63,
    "label": "calls",
    "to": 436
  }, {
    "from": 66,
    "label": "calls",
    "to": 436
  }, {
    "from": 91,
    "label": "calls",
    "to": 436
  }, {
    "from": 107,
    "label": "calls",
    "to": 436
  }, {
    "from": 111,
    "label": "calls",
    "to": 436
  }, {
    "from": 115,
    "label": "calls",
    "to": 436
  }, {
    "from": 148,
    "label": "calls",
    "to": 436
  }, {
    "from": 148,
    "label": "calls",
    "to": 436
  }, {
    "from": 168,
    "label": "calls",
    "to": 436
  }, {
    "from": 188,
    "label": "calls",
    "to": 436
  }, {
    "from": 191,
    "label": "calls",
    "to": 436
  }, {
    "from": 193,
    "label": "calls",
    "to": 436
  }, {
    "from": 195,
    "label": "calls",
    "to": 436
  }, {
    "from": 260,
    "label": "calls",
    "to": 436
  }, {
    "from": 260,
    "label": "calls",
    "to": 436
  }, {
    "from": 301,
    "label": "calls",
    "to": 436
  }, {
    "from": 51,
    "label": "calls",
    "to": 91
  }, {
    "from": 136,
    "label": "calls",
    "to": 91
  }, {
    "from": 201,
    "label": "calls",
    "to": 91
  }, {
    "from": 51,
    "label": "calls",
    "to": 437
  }, {
    "from": 51,
    "label": "calls",
    "to": 438
  }, {
    "from": 260,
    "label": "calls",
    "to": 438
  }, {
    "from": 66,
    "label": "calls",
    "to": 428
  }, {
    "from": 220,
    "label": "calls",
    "to": 439
  }, {
    "from": 107,
    "label": "calls",
    "to": 426
  }, {
    "from": 111,
    "label": "calls",
    "to": 426
  }, {
    "from": 155,
    "label": "calls",
    "to": 426
  }, {
    "from": 220,
    "label": "calls",
    "to": 441
  }, {
    "from": 115,
    "label": "calls",
    "to": 17
  }, {
    "from": 136,
    "label": "calls",
    "to": 17
  }, {
    "from": 260,
    "label": "calls",
    "to": 17
  }, {
    "from": 328,
    "label": "calls",
    "to": 443
  }, {
    "from": 197,
    "label": "calls",
    "to": 425
  }, {
    "from": 220,
    "label": "calls",
    "to": 220
  }, {
    "from": 246,
    "label": "calls",
    "to": 220
  }, {
    "from": 246,
    "label": "calls",
    "to": 220
  }, {
    "from": 77,
    "label": "calls",
    "to": 427
  }, {
    "from": 79,
    "label": "calls",
    "to": 427
  }, {
    "from": 83,
    "label": "calls",
    "to": 427
  }, {
    "from": 294,
    "label": "calls",
    "to": 459
  }, {
    "from": 136,
    "label": "calls",
    "to": 432
  }, {
    "from": 148,
    "label": "calls",
    "to": 432
  }, {
    "from": 155,
    "label": "calls",
    "to": 432
  }, {
    "from": 168,
    "label": "calls",
    "to": 432
  }, {
    "from": 179,
    "label": "calls",
    "to": 432
  }, {
    "from": 201,
    "label": "calls",
    "to": 445
  }, {
    "from": 79,
    "label": "calls",
    "to": 446
  }, {
    "from": 83,
    "label": "calls",
    "to": 446
  }, {
    "from": 168,
    "label": "calls",
    "to": 446
  }, {
    "from": 179,
    "label": "calls",
    "to": 446
  }, {
    "from": 286,
    "label": "calls",
    "to": 446
  }, {
    "from": 86,
    "label": "calls",
    "to": 447
  }, {
    "from": 199,
    "label": "calls",
    "to": 448
  }, {
    "from": 296,
    "label": "calls",
    "to": 410
  }, {
    "from": 220,
    "label": "calls",
    "to": 433
  }, {
    "from": 34,
    "label": "calls",
    "to": 458
  }, {
    "from": 51,
    "label": "calls",
    "to": 458
  }, {
    "from": 58,
    "label": "calls",
    "to": 458
  }, {
    "from": 63,
    "label": "calls",
    "to": 458
  }, {
    "from": 66,
    "label": "calls",
    "to": 458
  }, {
    "from": 91,
    "label": "calls",
    "to": 458
  }, {
    "from": 168,
    "label": "calls",
    "to": 458
  }, {
    "from": 188,
    "label": "calls",
    "to": 458
  }, {
    "from": 191,
    "label": "calls",
    "to": 458
  }, {
    "from": 220,
    "label": "calls",
    "to": 458
  }, {
    "from": 260,
    "label": "calls",
    "to": 458
  }, {
    "from": 260,
    "label": "calls",
    "to": 458
  }, {
    "from": 201,
    "label": "calls",
    "to": 450
  }, {
    "from": 201,
    "label": "calls",
    "to": 450
  }, {
    "from": 296,
    "label": "calls",
    "to": 296
  }, {
    "from": 115,
    "label": "calls",
    "to": 286
  }, {
    "from": 301,
    "label": "calls",
    "to": 191
  }, {
    "from": 301,
    "label": "calls",
    "to": 191
  }, {
    "from": 308,
    "label": "calls",
    "to": 191
  }, {
    "from": 308,
    "label": "calls",
    "to": 191
  }, {
    "from": 136,
    "label": "calls",
    "to": 115
  }, {
    "from": 301,
    "label": "calls",
    "to": 115
  }, {
    "from": 51,
    "label": "calls",
    "to": 452
  }, {
    "from": 38,
    "label": "calls",
    "to": 19
  }, {
    "from": 115,
    "label": "calls",
    "to": 19
  }, {
    "from": 136,
    "label": "calls",
    "to": 19
  }, {
    "from": 136,
    "label": "calls",
    "to": 19
  }, {
    "from": 148,
    "label": "calls",
    "to": 19
  }, {
    "from": 155,
    "label": "calls",
    "to": 19
  }, {
    "from": 179,
    "label": "calls",
    "to": 19
  }, {
    "from": 201,
    "label": "calls",
    "to": 19
  }, {
    "from": 201,
    "label": "calls",
    "to": 19
  }, {
    "from": 179,
    "label": "calls",
    "to": 179
  }, {
    "from": 188,
    "label": "calls",
    "to": 179
  }, {
    "from": 38,
    "label": "calls",
    "to": 21
  }, {
    "from": 51,
    "label": "calls",
    "to": 21
  }, {
    "from": 69,
    "label": "calls",
    "to": 21
  }, {
    "from": 79,
    "label": "calls",
    "to": 21
  }, {
    "from": 91,
    "label": "calls",
    "to": 21
  }, {
    "from": 107,
    "label": "calls",
    "to": 21
  }, {
    "from": 111,
    "label": "calls",
    "to": 21
  }, {
    "from": 115,
    "label": "calls",
    "to": 21
  }, {
    "from": 115,
    "label": "calls",
    "to": 21
  }, {
    "from": 148,
    "label": "calls",
    "to": 21
  }, {
    "from": 148,
    "label": "calls",
    "to": 21
  }, {
    "from": 165,
    "label": "calls",
    "to": 21
  }, {
    "from": 168,
    "label": "calls",
    "to": 21
  }, {
    "from": 188,
    "label": "calls",
    "to": 21
  }, {
    "from": 191,
    "label": "calls",
    "to": 21
  }, {
    "from": 193,
    "label": "calls",
    "to": 21
  }, {
    "from": 195,
    "label": "calls",
    "to": 21
  }, {
    "from": 197,
    "label": "calls",
    "to": 21
  }, {
    "from": 260,
    "label": "calls",
    "to": 453
  }, {
    "from": 79,
    "label": "calls",
    "to": 431
  }, {
    "from": 83,
    "label": "calls",
    "to": 431
  }, {
    "from": 86,
    "label": "calls",
    "to": 431
  }, {
    "from": 69,
    "label": "calls",
    "to": 279
  }, {
    "from": 38,
    "label": "calls",
    "to": 454
  }, {
    "from": 155,
    "label": "calls",
    "to": 454
  }, {
    "from": 74,
    "label": "calls",
    "to": 455
  }, {
    "from": 91,
    "label": "calls",
    "to": 430
  }, {
    "from": 115,
    "label": "calls",
    "to": 430
  }, {
    "from": 136,
    "label": "calls",
    "to": 430
  }, {
    "from": 148,
    "label": "calls",
    "to": 430
  }, {
    "from": 179,
    "label": "calls",
    "to": 430
  }, {
    "from": 191,
    "label": "calls",
    "to": 430
  }, {
    "from": 193,
    "label": "calls",
    "to": 430
  }, {
    "from": 195,
    "label": "calls",
    "to": 430
  }, {
    "from": 58,
    "label": "calls",
    "to": 34
  }, {
    "from": 260,
    "label": "calls",
    "to": 424
  }, {
    "from": 279,
    "label": "calls",
    "to": 424
  }, {
    "from": 38,
    "label": "calls",
    "to": 456
  }, {
    "from": 38,
    "label": "calls",
    "to": 456
  }, {
    "from": 115,
    "label": "calls",
    "to": 456
  }, {
    "from": 115,
    "label": "calls",
    "to": 456
  }, {
    "from": 201,
    "label": "calls",
    "to": 456
  }, {
    "from": 246,
    "label": "calls",
    "to": 456
  }, {
    "from": 246,
    "label": "calls",
    "to": 456
  }, {
    "from": 260,
    "label": "calls",
    "to": 456
  }, {
    "from": 279,
    "label": "calls",
    "to": 456
  }, {
    "from": 328,
    "label": "calls",
    "to": 460
  }, {
    "from": 220,
    "label": "calls",
    "to": 20
  }, {
    "from": 63,
    "label": "calls",
    "to": 74
  }, {
    "from": 66,
    "label": "calls",
    "to": 74
  }, {
    "from": 66,
    "label": "calls",
    "to": 74
  }, {
    "from": 168,
    "label": "calls",
    "to": 77
  }, {
    "from": 188,
    "label": "calls",
    "to": 77
  }, {
    "from": 201,
    "label": "calls",
    "to": 77
  }, {
    "from": 201,
    "label": "calls",
    "to": 77
  }, {
    "from": 308,
    "label": "calls",
    "to": 398
  }, {
    "from": 115,
    "label": "calls",
    "to": 294
  }, {
    "from": 279,
    "label": "calls",
    "to": 449
  }, {
    "from": 328,
    "label": "calls",
    "to": 457
  }, {
    "from": 58,
    "label": "calls",
    "to": 451
  }, {
    "from": 246,
    "label": "calls",
    "to": 451
  }, {
    "from": 286,
    "label": "calls",
    "to": 451
  }, {
    "from": 63,
    "label": "calls",
    "to": 58
  }, {
    "from": 66,
    "label": "calls",
    "to": 58
  }, {
    "from": 66,
    "label": "calls",
    "to": 58
  }, {
    "from": 220,
    "label": "calls",
    "to": 434
  }, {
    "from": 308,
    "label": "calls",
    "to": 38
  }, {
    "from": 308,
    "label": "calls",
    "to": 38
  }, {
    "from": 286,
    "label": "calls",
    "to": 461
  }, {
    "from": 91,
    "label": "calls",
    "to": 429
  }, {
    "from": 301,
    "label": "calls",
    "to": 165
  }, {
    "from": 51,
    "label": "calls",
    "to": 444
  }, {
    "from": 260,
    "label": "calls",
    "to": 246
  }, {
    "from": 260,
    "label": "calls",
    "to": 246
  }, {
    "from": 58,
    "label": "calls",
    "to": 440
  }, {
    "from": 308,
    "label": "calls",
    "to": 440
  }, {
    "from": 111,
    "label": "calls",
    "to": 18
  }, {
    "from": 308,
    "label": "calls",
    "to": 18
  }, {
    "from": 260,
    "label": "calls",
    "to": 417
  }, {
    "from": 260,
    "label": "calls",
    "to": 417
  }, {
    "from": 260,
    "label": "calls",
    "to": 417
  }, {
    "from": 328,
    "label": "calls",
    "to": 442
  }, {
    "from": 328,
    "label": "calls",
    "to": 442
  }, {
    "from": 328,
    "label": "calls",
    "to": 442
  }, {
    "from": 328,
    "label": "calls",
    "to": 442
  }, {
    "from": 328,
    "label": "calls",
    "to": 442
  }, {
    "from": 328,
    "label": "calls",
    "to": 442
  }, {
    "from": 328,
    "label": "calls",
    "to": 442
  }, {
    "from": 155,
    "label": "calls",
    "to": 442
  }, {
    "from": 328,
    "label": "calls",
    "to": 442
  }, {
    "from": 328,
    "label": "calls",
    "to": 462
  }, {
    "from": 328,
    "label": "calls",
    "to": 462
  }, {
    "from": 328,
    "label": "calls",
    "to": 462
  }, {
    "from": 328,
    "label": "calls",
    "to": 462
  }, {
    "from": 328,
    "label": "calls",
    "to": 462
  }, {
    "from": 328,
    "label": "calls",
    "to": 462
  }, {
    "from": 328,
    "label": "calls",
    "to": 462
  }, {
    "from": 136,
    "label": "calls",
    "to": 136
  }, {
    "from": 148,
    "label": "calls",
    "to": 136
  }, {
    "from": 155,
    "label": "calls",
    "to": 155
  }, {
    "from": 165,
    "label": "calls",
    "to": 155
  }, {
    "from": 1,
    "label": "contains",
    "to": 328
  }, {
    "from": 328,
    "label": "declares",
    "to": 34
  }, {
    "from": 328,
    "label": "declares",
    "to": 38
  }, {
    "from": 328,
    "label": "declares",
    "to": 51
  }, {
    "from": 328,
    "label": "declares",
    "to": 58
  }, {
    "from": 328,
    "label": "declares",
    "to": 63
  }, {
    "from": 328,
    "label": "declares",
    "to": 66
  }, {
    "from": 328,
    "label": "declares",
    "to": 69
  }, {
    "from": 328,
    "label": "declares",
    "to": 74
  }, {
    "from": 328,
    "label": "declares",
    "to": 77
  }, {
    "from": 328,
    "label": "declares",
    "to": 79
  }, {
    "from": 328,
    "label": "declares",
    "to": 83
  }, {
    "from": 328,
    "label": "declares",
    "to": 86
  }, {
    "from": 328,
    "label": "declares",
    "to": 91
  }, {
    "from": 328,
    "label": "declares",
    "to": 107
  }, {
    "from": 328,
    "label": "declares",
    "to": 111
  }, {
    "from": 328,
    "label": "declares",
    "to": 115
  }, {
    "from": 328,
    "label": "declares",
    "to": 136
  }, {
    "from": 328,
    "label": "declares",
    "to": 148
  }, {
    "from": 328,
    "label": "declares",
    "to": 155
  }, {
    "from": 328,
    "label": "declares",
    "to": 165
  }, {
    "from": 328,
    "label": "declares",
    "to": 168
  }, {
    "from": 328,
    "label": "declares",
    "to": 179
  }, {
    "from": 328,
    "label": "declares",
    "to": 188
  }, {
    "from": 328,
    "label": "declares",
    "to": 191
  }, {
    "from": 328,
    "label": "declares",
    "to": 193
  }, {
    "from": 328,
    "label": "declares",
    "to": 195
  }, {
    "from": 328,
    "label": "declares",
    "to": 197
  }, {
    "from": 328,
    "label": "declares",
    "to": 199
  }, {
    "from": 328,
    "label": "declares",
    "to": 201
  }, {
    "from": 328,
    "label": "declares",
    "to": 220
  }, {
    "from": 328,
    "label": "declares",
    "to": 246
  }, {
    "from": 328,
    "label": "declares",
    "to": 260
  }, {
    "from": 328,
    "label": "declares",
    "to": 279
  }, {
    "from": 328,
    "label": "declares",
    "to": 286
  }, {
    "from": 328,
    "label": "declares",
    "to": 294
  }, {
    "from": 328,
    "label": "declares",
    "to": 296
  }, {
    "from": 328,
    "label": "declares",
    "to": 301
  }, {
    "from": 328,
    "label": "declares",
    "to": 308
  }, {
    "from": 328,
    "label": "declares",
    "to": 324
  }, {
    "from": 328,
    "label": "declares",
    "to": 326
  }, {
    "from": 332,
    "label": "calls",
    "to": 63
  }, {
    "from": 335,
    "label": "calls",
    "to": 63
  }, {
    "from": 340,
    "label": "calls",
    "to": 63
  }, {
    "from": 342,
    "label": "calls",
    "to": 63
  }, {
    "from": 343,
    "label": "calls",
    "to": 63
  }, {
    "from": 344,
    "label": "calls",
    "to": 63
  }, {
    "from": 345,
    "label": "calls",
    "to": 63
  }, {
    "from": 345,
    "label": "calls",
    "to": 63
  }, {
    "from": 345,
    "label": "calls",
    "to": 63
  }, {
    "from": 346,
    "label": "calls",
    "to": 63
  }, {
    "from": 347,
    "label": "calls",
    "to": 63
  }, {
    "from": 348,
    "label": "calls",
    "to": 63
  }, {
    "from": 350,
    "label": "calls",
    "to": 63
  }, {
    "from": 331,
    "label": "calls",
    "to": 193
  }, {
    "from": 335,
    "label": "calls",
    "to": 193
  }, {
    "from": 338,
    "label": "calls",
    "to": 193
  }, {
    "from": 339,
    "label": "calls",
    "to": 193
  }, {
    "from": 330,
    "label": "calls",
    "to": 77
  }, {
    "from": 338,
    "label": "calls",
    "to": 77
  }, {
    "from": 339,
    "label": "calls",
    "to": 77
  }, {
    "from": 333,
    "label": "calls",
    "to": 66
  }, {
    "from": 334,
    "label": "calls",
    "to": 66
  }, {
    "from": 336,
    "label": "calls",
    "to": 66
  }, {
    "from": 337,
    "label": "calls",
    "to": 66
  }, {
    "from": 341,
    "label": "calls",
    "to": 66
  }, {
    "from": 345,
    "label": "calls",
    "to": 79
  }, {
    "from": 335,
    "label": "calls",
    "to": 286
  }, {
    "from": 329,
    "label": "calls",
    "to": 34
  }, {
    "from": 336,
    "label": "calls",
    "to": 34
  }, {
    "from": 336,
    "label": "calls",
    "to": 34
  }, {
    "from": 345,
    "label": "calls",
    "to": 34
  }, {
    "from": 345,
    "label": "calls",
    "to": 34
  }, {
    "from": 345,
    "label": "calls",
    "to": 34
  }, {
    "from": 349,
    "label": "calls",
    "to": 34
  }, {
    "from": 345,
    "label": "calls",
    "to": 86
  }, {
    "from": 345,
    "label": "calls",
    "to": 74
  }, {
    "from": 348,
    "label": "calls",
    "to": 74
  }, {
    "from": 348,
    "label": "calls",
    "to": 74
  }, {
    "from": 353,
    "label": "calls",
    "to": 286
  }, {
    "from": 353,
    "label": "calls",
    "to": 193
  }, {
    "from": 354,
    "label": "calls",
    "to": 115
  }, {
    "from": 352,
    "label": "calls",
    "to": 77
  }, {
    "from": 353,
    "label": "calls",
    "to": 34
  }, {
    "from": 353,
    "label": "calls",
    "to": 34
  }, {
    "from": 353,
    "label": "calls",
    "to": 34
  }, {
    "from": 353,
    "label": "calls",
    "to": 34
  }, {
    "from": 362,
    "label": "calls",
    "to": 63
  }, {
    "from": 370,
    "label": "calls",
    "to": 63
  }, {
    "from": 371,
    "label": "calls",
    "to": 63
  }, {
    "from": 371,
    "label": "calls",
    "to": 63
  }, {
    "from": 371,
    "label": "calls",
    "to": 63
  }, {
    "from": 376,
    "label": "calls",
    "to": 63
  }, {
    "from": 357,
    "label": "calls",
    "to": 77
  }, {
    "from": 365,
    "label": "calls",
    "to": 77
  }, {
    "from": 366,
    "label": "calls",
    "to": 77
  }, {
    "from": 359,
    "label": "calls",
    "to": 66
  }, {
    "from": 360,
    "label": "calls",
    "to": 66
  }, {
    "from": 361,
    "label": "calls",
    "to": 66
  }, {
    "from": 363,
    "label": "calls",
    "to": 66
  }, {
    "from": 364,
    "label": "calls",
    "to": 66
  }, {
    "from": 367,
    "label": "calls",
    "to": 66
  }, {
    "from": 368,
    "label": "calls",
    "to": 66
  }, {
    "from": 369,
    "label": "calls",
    "to": 66
  }, {
    "from": 372,
    "label": "calls",
    "to": 66
  }, {
    "from": 373,
    "label": "calls",
    "to": 66
  }, {
    "from": 373,
    "label": "calls",
    "to": 66
  }, {
    "from": 373,
    "label": "calls",
    "to": 66
  }, {
    "from": 373,
    "label": "calls",
    "to": 66
  }, {
    "from": 373,
    "label": "calls",
    "to": 66
  }, {
    "from": 375,
    "label": "calls",
    "to": 66
  }, {
    "from": 371,
    "label": "calls",
    "to": 79
  }, {
    "from": 355,
    "label": "calls",
    "to": 34
  }, {
    "from": 356,
    "label": "calls",
    "to": 34
  }, {
    "from": 359,
    "label": "calls",
    "to": 34
  }, {
    "from": 360,
    "label": "calls",
    "to": 34
  }, {
    "from": 361,
    "label": "calls",
    "to": 34
  }, {
    "from": 362,
    "label": "calls",
    "to": 34
  }, {
    "from": 363,
    "label": "calls",
    "to": 34
  }, {
    "from": 363,
    "label": "calls",
    "to": 34
  }, {
    "from": 364,
    "label": "calls",
    "to": 34
  }, {
    "from": 364,
    "label": "calls",
    "to": 34
  }, {
    "from": 364,
    "label": "calls",
    "to": 34
  }, {
    "from": 365,
    "label": "calls",
    "to": 34
  }, {
    "from": 366,
    "label": "calls",
    "to": 34
  }, {
    "from": 367,
    "label": "calls",
    "to": 34
  }, {
    "from": 368,
    "label": "calls",
    "to": 34
  }, {
    "from": 369,
    "label": "calls",
    "to": 34
  }, {
    "from": 370,
    "label": "calls",
    "to": 34
  }, {
    "from": 371,
    "label": "calls",
    "to": 34
  }, {
    "from": 371,
    "label": "calls",
    "to": 34
  }, {
    "from": 371,
    "label": "calls",
    "to": 34
  }, {
    "from": 371,
    "label": "calls",
    "to": 34
  }, {
    "from": 371,
    "label": "calls",
    "to": 34
  }, {
    "from": 371,
    "label": "calls",
    "to": 34
  }, {
    "from": 371,
    "label": "calls",
    "to": 34
  }, {
    "from": 371,
    "label": "calls",
    "to": 34
  }, {
    "from": 372,
    "label": "calls",
    "to": 34
  }, {
    "from": 373,
    "label": "calls",
    "to": 34
  }, {
    "from": 351,
    "label": "calls",
    "to": 34
  }, {
    "from": 351,
    "label": "calls",
    "to": 34
  }, {
    "from": 351,
    "label": "calls",
    "to": 34
  }, {
    "from": 374,
    "label": "calls",
    "to": 34
  }, {
    "from": 375,
    "label": "calls",
    "to": 34
  }, {
    "from": 371,
    "label": "calls",
    "to": 86
  }, {
    "from": 371,
    "label": "calls",
    "to": 74
  }, {
    "from": 358,
    "label": "calls",
    "to": 193
  }, {
    "from": 359,
    "label": "calls",
    "to": 193
  }, {
    "from": 365,
    "label": "calls",
    "to": 193
  }, {
    "from": 366,
    "label": "calls",
    "to": 193
  }, {
    "from": 378,
    "label": "calls",
    "to": 193
  }, {
    "from": 380,
    "label": "calls",
    "to": 193
  }, {
    "from": 379,
    "label": "calls",
    "to": 115
  }, {
    "from": 377,
    "label": "calls",
    "to": 77
  }, {
    "from": 380,
    "label": "calls",
    "to": 191
  }, {
    "from": 381,
    "label": "calls",
    "to": 193
  }, {
    "from": 382,
    "label": "calls",
    "to": 191
  }, {
    "from": 382,
    "label": "calls",
    "to": 107
  }, {
    "from": 383,
    "label": "calls",
    "to": 308
  }, {
    "from": 382,
    "label": "calls",
    "to": 165
  }, {
    "from": 384,
    "label": "calls",
    "to": 260
  }, {
    "from": 385,
    "label": "calls",
    "to": 168
  }, {
    "from": 385,
    "label": "calls",
    "to": 308
  }, {
    "from": 385,
    "label": "calls",
    "to": 77
  }, {
    "from": 386,
    "label": "calls",
    "to": 165
  }, {
    "from": 389,
    "label": "calls",
    "to": 191
  }, {
    "from": 388,
    "label": "calls",
    "to": 91
  }, {
    "from": 387,
    "label": "calls",
    "to": 195
  }, {
    "from": 389,
    "label": "calls",
    "to": 201
  }, {
    "from": 389,
    "label": "calls",
    "to": 86
  }, {
    "from": 389,
    "label": "calls",
    "to": 79
  }, {
    "from": 387,
    "label": "calls",
    "to": 279
  }, {
    "from": 389,
    "label": "calls",
    "to": 165
  }, {
    "from": 389,
    "label": "calls",
    "to": 165
  }, {
    "from": 389,
    "label": "calls",
    "to": 165
  }, {
    "from": 391,
    "label": "calls",
    "to": 165
  }, {
    "from": 391,
    "label": "calls",
    "to": 77
  }, {
    "from": 387,
    "label": "calls",
    "to": 188
  }, {
    "from": 390,
    "label": "calls",
    "to": 193
  }, {
    "from": 391,
    "label": "calls",
    "to": 199
  }, {
    "from": 392,
    "label": "calls",
    "to": 191
  }, {
    "from": 392,
    "label": "calls",
    "to": 193
  }, {
    "from": 392,
    "label": "calls",
    "to": 168
  }, {
    "from": 392,
    "label": "calls",
    "to": 86
  }, {
    "from": 392,
    "label": "calls",
    "to": 79
  }, {
    "from": 392,
    "label": "calls",
    "to": 279
  }, {
    "from": 393,
    "label": "calls",
    "to": 260
  }, {
    "from": 395,
    "label": "calls",
    "to": 191
  }, {
    "from": 396,
    "label": "calls",
    "to": 191
  }, {
    "from": 395,
    "label": "calls",
    "to": 91
  }, {
    "from": 394,
    "label": "calls",
    "to": 115
  }, {
    "from": 395,
    "label": "calls",
    "to": 115
  }, {
    "from": 395,
    "label": "calls",
    "to": 115
  }, {
    "from": 396,
    "label": "calls",
    "to": 148
  }, {
    "from": 394,
    "label": "calls",
    "to": 165
  }, {
    "from": 396,
    "label": "calls",
    "to": 165
  }, {
    "from": 396,
    "label": "calls",
    "to": 165
  }, {
    "from": 394,
    "label": "calls",
    "to": 79
  }, {
    "from": 396,
    "label": "calls",
    "to": 79
  }, {
    "from": 396,
    "label": "calls",
    "to": 168
  }, {
    "from": 394,
    "label": "calls",
    "to": 199
  }, {
    "from": 396,
    "label": "calls",
    "to": 199
  }, {
    "from": 396,
    "label": "calls",
    "to": 51
  }, {
    "from": 397,
    "label": "calls",
    "to": 51
  }, {
    "from": 394,
    "label": "calls",
    "to": 86
  }, {
    "from": 396,
    "label": "calls",
    "to": 86
  }, {
    "from": 399,
    "label": "calls",
    "to": 193
  }, {
    "from": 399,
    "label": "calls",
    "to": 308
  }, {
    "from": 400,
    "label": "calls",
    "to": 308
  }, {
    "from": 402,
    "label": "calls",
    "to": 193
  }, {
    "from": 404,
    "label": "calls",
    "to": 91
  }, {
    "from": 405,
    "label": "calls",
    "to": 91
  }, {
    "from": 405,
    "label": "calls",
    "to": 111
  }, {
    "from": 408,
    "label": "calls",
    "to": 111
  }, {
    "from": 408,
    "label": "calls",
    "to": 111
  }, {
    "from": 408,
    "label": "calls",
    "to": 111
  }, {
    "from": 403,
    "label": "calls",
    "to": 63
  }, {
    "from": 401,
    "label": "calls",
    "to": 168
  }, {
    "from": 404,
    "label": "calls",
    "to": 301
  }, {
    "from": 405,
    "label": "calls",
    "to": 301
  }, {
    "from": 408,
    "label": "calls",
    "to": 301
  }, {
    "from": 405,
    "label": "calls",
    "to": 191
  }, {
    "from": 405,
    "label": "calls",
    "to": 191
  }, {
    "from": 406,
    "label": "calls",
    "to": 191
  }, {
    "from": 406,
    "label": "calls",
    "to": 191
  }, {
    "from": 406,
    "label": "calls",
    "to": 165
  }, {
    "from": 407,
    "label": "calls",
    "to": 165
  }, {
    "from": 407,
    "label": "calls",
    "to": 165
  }, {
    "from": 409,
    "label": "calls",
    "to": 193
  }, {
    "from": 409,
    "label": "calls",
    "to": 168
  }, {
    "from": 409,
    "label": "calls",
    "to": 168
  }, {
    "from": 411,
    "label": "calls",
    "to": 286
  }, {
    "from": 411,
    "label": "calls",
    "to": 91
  }, {
    "from": 411,
    "label": "calls",
    "to": 91
  }, {
    "from": 411,
    "label": "calls",
    "to": 197
  }, {
    "from": 412,
    "label": "calls",
    "to": 193
  }, {
    "from": 412,
    "label": "calls",
    "to": 188
  }, {
    "from": 412,
    "label": "calls",
    "to": 195
  }, {
    "from": 415,
    "label": "calls",
    "to": 191
  }, {
    "from": 415,
    "label": "calls",
    "to": 91
  }, {
    "from": 415,
    "label": "calls",
    "to": 115
  }, {
    "from": 413,
    "label": "calls",
    "to": 79
  }, {
    "from": 413,
    "label": "calls",
    "to": 79
  }, {
    "from": 414,
    "label": "calls",
    "to": 79
  }, {
    "from": 414,
    "label": "calls",
    "to": 79
  }, {
    "from": 413,
    "label": "calls",
    "to": 86
  }, {
    "from": 413,
    "label": "calls",
    "to": 86
  }, {
    "from": 414,
    "label": "calls",
    "to": 86
  }, {
    "from": 416,
    "label": "calls",
    "to": 83
  }, {
    "from": 419,
    "label": "calls",
    "to": 191
  }, {
    "from": 419,
    "label": "calls",
    "to": 165
  }, {
    "from": 419,
    "label": "calls",
    "to": 165
  }, {
    "from": 418,
    "label": "calls",
    "to": 51
  }, {
    "from": 419,
    "label": "calls",
    "to": 168
  }, {
    "from": 419,
    "label": "calls",
    "to": 86
  }, {
    "from": 421,
    "label": "calls",
    "to": 191
  }, {
    "from": 421,
    "label": "calls",
    "to": 279
  }, {
    "from": 422,
    "label": "calls",
    "to": 188
  }, {
    "from": 420,
    "label": "calls",
    "to": 77
  }, {
    "from": 423,
    "label": "calls",
    "to": 77
  }, {
    "from": 421,
    "label": "calls",
    "to": 168
  }, {
    "from": 421,
    "label": "calls",
    "to": 193
  }, {
    "from": 422,
    "label": "calls",
    "to": 193
  }, {
    "from": 422,
    "label": "calls",
    "to": 193
  }, {
    "from": 421,
    "label": "calls",
    "to": 86
  }, {
    "from": 422,
    "label": "calls",
    "to": 86
  }, {
    "from": 421,
    "label": "calls",
    "to": 79
  }, {
    "from": 422,
    "label": "calls",
    "to": 79
  }, {
    "from": 423,
    "label": "calls",
    "to": 79
  }, {
    "from": 1,
    "label": "contains",
    "to": 468
  }, {
    "from": 1,
    "label": "contains",
    "to": 469
  }, {
    "from": 468,
    "label": "initializes",
    "to": 470
  }, {
    "from": 468,
    "label": "initializes",
    "to": 471
  }, {
    "from": 468,
    "label": "initializes",
    "to": 472
  }, {
    "from": 468,
    "label": "initializes",
    "to": 473
  }, {
    "from": 468,
    "label": "initializes",
    "to": 474
  }, {
    "from": 468,
    "label": "initializes",
    "to": 475
  }, {
    "from": 468,
    "label": "initializes",
    "to": 476
  }, {
    "from": 468,
    "label": "initializes",
    "to": 477
  }, {
    "from": 468,
    "label": "initializes",
    "to": 478
  }, {
    "from": 468,
    "label": "initializes",
    "to": 479
  }, {
    "from": 468,
    "label": "initializes",
    "to": 480
  }, {
    "from": 468,
    "label": "initializes",
    "to": 481
  }, {
    "from": 468,
    "label": "initializes",
    "to": 482
  }, {
    "from": 468,
    "label": "initializes",
    "to": 483
  }, {
    "from": 468,
    "label": "initializes",
    "to": 484
  }, {
    "from": 484,
    "label": "assigns",
    "to": 485
  }, {
    "from": 468,
    "label": "initializes",
    "to": 486
  }, {
    "from": 469,
    "label": "initializes",
    "to": 487
  }, {
    "from": 487,
    "label": "requires",
    "to": 466
  }, {
    "from": 469,
    "label": "initializes",
    "to": 488
  }, {
    "from": 488,
    "label": "requires",
    "to": 463
  }, {
    "from": 469,
    "label": "initializes",
    "to": 489
  }, {
    "from": 489,
    "label": "requires",
    "to": 465
  }, {
    "from": 469,
    "label": "initializes",
    "to": 490
  }, {
    "from": 490,
    "label": "requires",
    "to": 464
  }, {
    "from": 469,
    "label": "initializes",
    "to": 491
  }, {
    "from": 491,
    "label": "requires",
    "to": 467
  }, {
    "from": 469,
    "label": "initializes",
    "to": 492
  }, {
    "from": 492,
    "label": "requires",
    "to": 493
  }, {
    "from": 469,
    "label": "initializes",
    "to": 494
  }, {
    "from": 494,
    "label": "requires",
    "to": 495
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "lua",
    "type": "module"
  }, {
    "id": 2,
    "text": "local function add_files_to_server(refresh, rockfiles, server, upload_server)\r\n   assert(type(refresh) == \"boolean\" or not refresh)\r\n   assert(type(rockfiles) == \"table\")\r\n   assert(type(server) == \"string\")\r\n   assert(type(upload_server) == \"table\" or not upload_server)\r\n   \r\n   local download_url, login_url = cache.get_server_urls(server, upload_server)\r\n   local at = fs.current_dir()\r\n   local refresh_fn = refresh and cache.refresh_local_cache or cache.split_server_url\r\n   \r\n   local local_cache, protocol, server_path, user, password = refresh_fn(server, download_url, cfg.upload_user, cfg.upload_password)\r\n   if not local_cache then\r\n      return nil, protocol\r\n   end\r\n   if protocol == \"file\" then\r\n      return nil, \"Server \"..server..\" is not recognized, check your configuration.\"\r\n   end\r\n   \r\n   if not login_url then\r\n      login_url = protocol..\"://\"..server_path\r\n   end\r\n   \r\n   local ok, err = fs.change_dir(at)\r\n   if not ok then return nil, err end\r\n   \r\n   local files = {}\r\n   for i, rockfile in ipairs(rockfiles) do\r\n      if fs.exists(rockfile) then\r\n         util.printout(\"Copying file \"..rockfile..\" to \"..local_cache..\"...\")\r\n         local absolute = fs.absolute_name(rockfile)\r\n         fs.copy(absolute, local_cache)\r\n         table.insert(files, dir.base_name(absolute))\r\n      else\r\n         util.printerr(\"File \"..rockfile..\" not found\")\r\n      end\r\n   end\r\n   if #files == 0 then\r\n      return nil, \"No files found\"\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_cache)\r\n   if not ok then return nil, err end\r\n\r\n   util.printout(\"Updating manifest...\")\r\n   manif.make_manifest(local_cache, \"one\", true)\r\n   \r\n   manif.zip_manifests()\r\n   \r\n   util.printout(\"Updating index.html...\")\r\n   index.make_index(local_cache)\r\n\r\n   local login_info = \"\"\r\n   if user then login_info = \" -u \"..user end\r\n   if password then login_info = login_info..\":\"..password end\r\n   if not login_url:match(\"/$\") then\r\n      login_url = login_url .. \"/\"\r\n   end\r\n\r\n   table.insert(files, \"index.html\")\r\n   table.insert(files, \"manifest\")\r\n   for ver in util.lua_versions() do\r\n      table.insert(files, \"manifest-\"..ver)\r\n      table.insert(files, \"manifest-\"..ver..\".zip\")\r\n   end\r\n\r\n   -- TODO abstract away explicit 'curl' call\r\n\r\n   local cmd\r\n   if protocol == \"rsync\" then\r\n      local srv, path = server_path:match(\"([^/]+)(/.+)\")\r\n      cmd = cfg.variables.RSYNC..\" \"..cfg.variables.RSYNCFLAGS..\" -e ssh \"..local_cache..\"/ \"..user..\"@\"..srv..\":\"..path..\"/\"\r\n   elseif upload_server and upload_server.sftp then\r\n      local part1, part2 = upload_server.sftp:match(\"^([^/]*)/(.*)$\")\r\n      cmd = cfg.variables.SCP..\" \"..table.concat(files, \" \")..\" \"..user..\"@\"..part1..\":/\"..part2\r\n   else\r\n      cmd = cfg.variables.CURL..\" \"..login_info..\" -T '{\"..table.concat(files, \",\")..\"}' \"..login_url\r\n   end\r\n\r\n   util.printout(cmd)\r\n   fs.execute(cmd)\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "local function remove_files_from_server(refresh, rockfiles, server, upload_server)\r\n   assert(type(refresh) == \"boolean\" or not refresh)\r\n   assert(type(rockfiles) == \"table\")\r\n   assert(type(server) == \"string\")\r\n   assert(type(upload_server) == \"table\" or not upload_server)\r\n\r\n   local download_url, login_url = cache.get_server_urls(server, upload_server)\r\n   local at = fs.current_dir()\r\n   local refresh_fn = refresh and cache.refresh_local_cache or cache.split_server_url\r\n   \r\n   local local_cache, protocol, server_path, user, password = refresh_fn(server, download_url, cfg.upload_user, cfg.upload_password)\r\n   if not local_cache then\r\n      return nil, protocol\r\n   end\r\n   if protocol ~= \"rsync\" then\r\n      return nil, \"This command requires 'rsync', check your configuration.\"\r\n   end\r\n   \r\n   local ok, err = fs.change_dir(at)\r\n   if not ok then return nil, err end\r\n   \r\n   local nr_files = 0\r\n   for i, rockfile in ipairs(rockfiles) do\r\n      local basename = dir.base_name(rockfile)\r\n      local file = dir.path(local_cache, basename)\r\n      util.printout(\"Removing file \"..file..\"...\")\r\n      fs.delete(file)\r\n      if not fs.exists(file) then\r\n         nr_files = nr_files + 1\r\n      else\r\n         util.printerr(\"Failed removing \"..file)\r\n      end\r\n   end\r\n   if nr_files == 0 then\r\n      return nil, \"No files removed.\"\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_cache)\r\n   if not ok then return nil, err end\r\n\r\n   util.printout(\"Updating manifest...\")\r\n   manif.make_manifest(local_cache, \"one\", true)\r\n   util.printout(\"Updating index.html...\")\r\n   index.make_index(local_cache)\r\n\r\n   local srv, path = server_path:match(\"([^/]+)(/.+)\")\r\n   local cmd = cfg.variables.RSYNC..\" \"..cfg.variables.RSYNCFLAGS..\" --delete -e ssh \"..local_cache..\"/ \"..user..\"@\"..srv..\":\"..path..\"/\"\r\n\r\n   util.printout(cmd)\r\n   fs.execute(cmd)\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 4,
    "text": "local function execute(...)\r\n   io.stdout:write(table.concat({...}, \" \")..\"\\n\")\r\n   return fs.execute(...)\r\nend",
    "type": "function"
  }, {
    "id": 5,
    "text": "function run(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n   local compile_object, compile_library, compile_wrapper_binary\r\n\r\n   local build = rockspec.build\r\n   local variables = rockspec.variables\r\n\r\n   local function add_flags(extras, flag, flags)\r\n      if flags then\r\n         if type(flags) ~= \"table\" then\r\n            flags = { tostring(flags) }\r\n         end\r\n         util.variable_substitutions(flags, variables)\r\n         for _, v in ipairs(flags) do\r\n            table.insert(extras, flag:format(v))\r\n         end\r\n      end\r\n   end\r\n\r\n   -- MinGW basically behaves the same as Unix\r\n   if cfg.is_platform(\"mingw32\") then\r\n         compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR, \"-c\", source, \"-o\", object, unpack(extras))\r\n      end\r\n      compile_library = function (library, objects, libraries, libdirs)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-L%s\", libdirs)\r\n         add_flags(extras, \"-l%s\", libraries)\r\n         extras[#extras+1] = dir.path(variables.LUA_LIBDIR, variables.LUALIB)\r\n         extras[#extras+1] = \"-l\" .. (variables.MSVCRT or \"m\")\r\n         local ok = execute(variables.LD..\" \"..variables.LIBFLAG, \"-o\", library, unpack(extras))\r\n         return ok\r\n      end\r\n      compile_wrapper_binary = function(fullname, name)\r\n         local fullbasename = fullname:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local basename = name:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local rcname = basename..\".rc\"\r\n         local resname = basename..\".o\"\r\n         local wrapname = basename..\".exe\"\r\n         make_rc(fullname, fullbasename..\".rc\")\r\n         local ok = execute(variables.RC, \"-o\", resname, rcname)\r\n         if not ok then return ok end\r\n         ok = execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR,\r\n                      \"-o\", wrapname, resname, variables.WRAPPER,\r\n                      dir.path(variables.LUA_LIBDIR, variables.LUALIB),\r\n                      \"-l\" .. (variables.MSVCRT or \"m\"), \"-luser32\")\r\n         return ok, wrapname\r\n      end\r\n      compile_wrapper_binary = function(fullname, name) return true, name end\r\n\t-- MSVC specific commands\r\n\telseif cfg.is_platform(\"win32\") then\r\n      compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-c\", \"-Fo\"..object, \"-I\"..variables.LUA_INCDIR, source, unpack(extras))\r\n      end\r\n      compile_library = function(library, objects, libraries, libdirs, name)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-libpath:%s\", libdirs)\r\n         add_flags(extras, \"%s.lib\", libraries)\r\n         local basename = dir.base_name(library):gsub(\".[^.]*$\", \"\")\r\n         local deffile = basename .. \".def\"\r\n         local def = io.open(dir.path(fs.current_dir(), deffile), \"w+\")\r\n         def:write(\"EXPORTS\\n\")\r\n         def:write(\"luaopen_\"..name:gsub(\"%.\", \"_\")..\"\\n\")\r\n         def:close()\r\n         local ok = execute(variables.LD, \"-dll\", \"-def:\"..deffile, \"-out:\"..library, dir.path(variables.LUA_LIBDIR, variables.LUALIB), unpack(extras))\r\n         local basedir = \"\"\r\n         if name:find(\"%.\") ~= nil then\r\n            basedir = name:gsub(\"%.%w+$\", \"\\\\\")\r\n            basedir = basedir:gsub(\"%.\", \"\\\\\")\r\n         end\r\n         local manifestfile = basedir .. basename..\".dll.manifest\"\r\n\r\n         if ok and fs.exists(manifestfile) then\r\n            ok = execute(variables.MT, \"-manifest\", manifestfile, \"-outputresource:\"..basedir..basename..\".dll;2\")\r\n         end\r\n         return ok\r\n      end\r\n      compile_wrapper_binary = function(fullname, name)\r\n         local fullbasename = fullname:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local basename = name:gsub(\"%.lua$\", \"\"):gsub(\"/\", \"\\\\\")\r\n         local object = basename..\".obj\"\r\n         local rcname = basename..\".rc\"\r\n         local resname = basename..\".res\"\r\n         local wrapname = basename..\".exe\"\r\n         make_rc(fullname, fullbasename..\".rc\")\r\n         local ok = execute(variables.RC, \"-r\", \"-fo\"..resname, rcname)\r\n         if not ok then return ok end\r\n         ok = execute(variables.CC..\" \"..variables.CFLAGS, \"-c\", \"-Fo\"..object,\r\n                      \"-I\"..variables.LUA_INCDIR, variables.WRAPPER)\r\n         if not ok then return ok end\r\n         ok = execute(variables.LD, \"-out:\"..wrapname, resname, object,\r\n                      dir.path(variables.LUA_LIBDIR, variables.LUALIB), \"user32.lib\")\r\n         local manifestfile = wrapname..\".manifest\"\r\n         if ok and fs.exists(manifestfile) then\r\n            ok = execute(variables.MT, \"-manifest\", manifestfile, \"-outputresource:\"..wrapname..\";1\")\r\n         end\r\n         return ok, wrapname\r\n      end\r\n   else\r\n\t-- Unix, Linux, Cygwin\r\n      compile_object = function(object, source, defines, incdirs)\r\n         local extras = {}\r\n         add_flags(extras, \"-D%s\", defines)\r\n         add_flags(extras, \"-I%s\", incdirs)\r\n         return execute(variables.CC..\" \"..variables.CFLAGS, \"-I\"..variables.LUA_INCDIR, \"-c\", source, \"-o\", object, unpack(extras))\r\n      end\r\n      compile_library = function (library, objects, libraries, libdirs)\r\n         local extras = { unpack(objects) }\r\n         add_flags(extras, \"-L%s\", libdirs)\r\n         if cfg.gcc_rpath then\r\n            add_flags(extras, \"-Wl,-rpath,%s:\", libdirs)\r\n         end\r\n         add_flags(extras, \"-l%s\", libraries)\r\n\t\t -- Link to Lua\r\n         add_flags(extras, \"-l%s\", variables.LUA_LIB)\r\n         return execute(variables.LD..\" \"..variables.LIBFLAG, \"-o\", library, \"-L\"..variables.LUA_LIBDIR, unpack(extras))\r\n      end\r\n      compile_wrapper_binary = function(fullname, name) return true, name end\r\n   end\r\n\r\n   local ok = true\r\n   local err = \"Build error\"\r\n   local built_modules = {}\r\n   local luadir = path.lua_dir(rockspec.name, rockspec.version)\r\n   local libdir = path.lib_dir(rockspec.name, rockspec.version)\r\n   local docdir = path.doc_dir(rockspec.name, rockspec.version)\r\n   -- On Windows, compiles an .exe for each Lua file in build.install.bin, and\r\n   -- replaces the filename with the .exe name. Strips the .lua extension if it exists,\r\n   -- otherwise just appends .exe to the name\r\n   if build.install and build.install.bin then\r\n     for i, name in ipairs(build.install.bin) do\r\n       local fullname = dir.path(fs.current_dir(), name)\r\n       local match = name:match(\"%.lua$\")\r\n       local basename = name:gsub(\"%.lua$\", \"\")\r\n       local file\r\n       if not match then\r\n          file = io.open(fullname)\r\n       end\r\n       if match or (file and file:read():match(\"#!.*lua.*\")) then\r\n          ok, name = compile_wrapper_binary(fullname, name)\r\n          if ok then\r\n             build.install.bin[i] = name\r\n          else\r\n             if file then file:close() end\r\n             return nil, \"Build error in wrapper binaries\"\r\n          end\r\n       end\r\n       if file then file:close() end\r\n     end\r\n   end\r\n   for name, info in pairs(build.modules) do\r\n      local moddir = path.module_to_path(name)\r\n      if type(info) == \"string\" then\r\n         local ext = info:match(\".([^.]+)$\")\r\n         if ext == \"lua\" then\r\n            local filename = dir.base_name(info)\r\n            if info:match(\"init%.lua$\") and not name:match(\"%.init$\") then\r\n               moddir = path.module_to_path(name..\".init\")\r\n            else\r\n               local basename = name:match(\"([^.]+)$\")\r\n               local baseinfo = filename:gsub(\"%.lua$\", \"\")\r\n               if basename ~= baseinfo then\r\n                  filename = basename..\".lua\"\r\n               end\r\n            end\r\n            local dest = dir.path(luadir, moddir, filename)\r\n            built_modules[info] = dest\r\n         else\r\n            info = {info}\r\n         end\r\n      end\r\n      if type(info) == \"table\" then\r\n         local objects = {}\r\n         local sources = info.sources\r\n         if info[1] then sources = info end\r\n         if type(sources) == \"string\" then sources = {sources} end\r\n         for _, source in ipairs(sources) do\r\n            local object = source:gsub(\".[^.]*$\", \".\"..cfg.obj_extension)\r\n            if not object then\r\n               object = source..\".\"..cfg.obj_extension\r\n            end\r\n            ok = compile_object(object, source, info.defines, info.incdirs)\r\n            if not ok then\r\n               return nil, \"Failed compiling object \"..object\r\n            end\r\n            table.insert(objects, object)\r\n         end\r\n         if not ok then break end\r\n         local module_name = name:match(\"([^.]*)$\")..\".\"..util.matchquote(cfg.lib_extension)\r\n         if moddir ~= \"\" then\r\n            module_name = dir.path(moddir, module_name)\r\n            local ok, err = fs.make_dir(moddir)\r\n            if not ok then return nil, err end\r\n         end\r\n         built_modules[module_name] = dir.path(libdir, module_name)\r\n         ok = compile_library(module_name, objects, info.libraries, info.libdirs, name)\r\n         if not ok then\r\n            return nil, \"Failed compiling module \"..module_name\r\n         end\r\n      end\r\n   end\r\n   for name, dest in pairs(built_modules) do\r\n      fs.make_dir(dir.dir_name(dest))\r\n      ok = fs.copy(name, dest)\r\n      if not ok then\r\n         return nil, \"Failed installing \"..name..\" in \"..dest\r\n      end\r\n   end\r\n   if fs.is_dir(\"lua\") then\r\n      local ok, err = fs.copy_contents(\"lua\", luadir)\r\n      if not ok then\r\n         return nil, \"Failed copying contents of 'lua' directory: \"..err\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 6,
    "text": "function run(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n   local build = rockspec.build\r\n   local variables = build.variables or {}\r\n   \r\n   -- Pass Env variables\r\n   variables.CMAKE_MODULE_PATH=os.getenv(\"CMAKE_MODULE_PATH\")\r\n   variables.CMAKE_LIBRARY_PATH=os.getenv(\"CMAKE_LIBRARY_PATH\")\r\n   variables.CMAKE_INCLUDE_PATH=os.getenv(\"CMAKE_INCLUDE_PATH\")\r\n\r\n   util.variable_substitutions(variables, rockspec.variables)\r\n\r\n   if not fs.execute_quiet(rockspec.variables.CMAKE, \"--help\") then\r\n      return nil, \"'\"..rockspec.variables.CMAKE..\"' program not found. Is cmake installed? You may want to edit variables.CMAKE\"\r\n   end\r\n   \r\n   -- If inline cmake is present create CMakeLists.txt from it.\r\n   if type(build.cmake) == \"string\" then\r\n      local cmake = assert(io.open(fs.current_dir()..\"/CMakeLists.txt\", \"w\"))\r\n      cmake:write(build.cmake)\r\n      cmake:close()\r\n   end\r\n\r\n\r\n   -- Execute cmake with variables.\r\n   local args = \"\"\r\n   if cfg.cmake_generator then\r\n      args = args .. ' -G\"'..cfg.cmake_generator.. '\"'\r\n   end\r\n   for k,v in pairs(variables) do\r\n      args = args .. ' -D' ..k.. '=\"' ..v.. '\"'\r\n   end\r\n\r\n   if not fs.execute_string(rockspec.variables.CMAKE..\" . \" ..args) then\r\n      return nil, \"Failed cmake.\"\r\n   end\r\n   \r\n   if not fs.execute_string(rockspec.variables.MAKE..\" -fMakefile\") then\r\n      return nil, \"Failed building.\"\r\n   end\r\n\r\n   if not fs.execute_string(rockspec.variables.MAKE..\" -fMakefile install\") then\r\n      return nil, \"Failed installing.\"\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 7,
    "text": "function run(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   local build = rockspec.build\r\n   \r\n   util.variable_substitutions(build, rockspec.variables)\r\n   \r\n   if build.build_command then\r\n      util.printout(build.build_command)\r\n      if not fs.execute(build.build_command) then\r\n         return nil, \"Failed building.\"\r\n      end\r\n   end\r\n   if build.install_command then\r\n      util.printout(build.install_command)\r\n      if not fs.execute(build.install_command) then\r\n         return nil, \"Failed installing.\"\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 8,
    "text": "local function make_pass(make_cmd, pass, target, variables)\r\n   assert(type(pass) == \"boolean\")\r\n   assert(type(target) == \"string\")\r\n   assert(type(variables) == \"table\")\r\n\r\n   local assignments = {}\r\n   for k,v in pairs(variables) do\r\n      table.insert(assignments, k..\"=\"..v)\r\n   end\r\n   if pass then\r\n      return fs.execute(make_cmd..\" \"..target, unpack(assignments))\r\n   else\r\n      return true\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 9,
    "text": "local function install_files(files, location, is_module_path)\r\n   assert(type(files) == \"table\" or not files)\r\n   assert(type(location) == \"string\")\r\n   if files then\r\n      for k, file in pairs(files) do\r\n         local dest = location\r\n         local filename = dir.base_name(file)\r\n         if type(k) == \"string\" then\r\n            local modname = k\r\n            if is_module_path then\r\n               dest = dir.path(location, path.module_to_path(modname))\r\n               local ok, err = fs.make_dir(dest)\r\n               if not ok then return nil, err end\r\n               if filename:match(\"%.lua$\") then\r\n                  local basename = modname:match(\"([^.]+)$\")\r\n                  local baseinfo = filename:gsub(\"%.lua$\", \"\")\r\n                  if basename ~= baseinfo then\r\n                     filename = basename..\".lua\"\r\n                  end\r\n               end\r\n            else\r\n               dest = dir.path(location, dir.dir_name(modname))\r\n               local ok, err = fs.make_dir(dest)\r\n               if not ok then return nil, err end\r\n               filename = dir.base_name(modname)\r\n            end\r\n         else\r\n            local ok, err = fs.make_dir(dest)\r\n            if not ok then return nil, err end\r\n         end\r\n         local ok = fs.copy(dir.path(file), dir.path(dest, filename))\r\n         if not ok then\r\n            return nil, \"Failed copying \"..file\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 10,
    "text": "local function extract_from_rockspec(files)\r\n   for name, content in pairs(files) do\r\n      local fd = io.open(dir.path(fs.current_dir(), name), \"w+\")\r\n      fd:write(content)\r\n      fd:close()\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 11,
    "text": "function apply_patches(rockspec)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   local build = rockspec.build\r\n   if build.extra_files then\r\n      extract_from_rockspec(build.extra_files)\r\n   end\r\n   if build.patches then\r\n      extract_from_rockspec(build.patches)\r\n      for patch, patchdata in util.sortedpairs(build.patches) do\r\n         util.printout(\"Applying patch \"..patch..\"...\")\r\n         local ok, err = fs.apply_patch(tostring(patch), patchdata)\r\n         if not ok then\r\n            return nil, \"Failed applying patch \"..patch\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 12,
    "text": "function build_rockspec(rockspec_file, need_to_fetch, minimal_mode, deps_mode)\r\n   assert(type(rockspec_file) == \"string\")\r\n   assert(type(need_to_fetch) == \"boolean\")\r\n\r\n   local rockspec, err, errcode = fetch.load_rockspec(rockspec_file)\r\n   if err then\r\n      return nil, err, errcode\r\n   elseif not rockspec.build then\r\n      return nil, \"Rockspec error: build table not specified\"\r\n   elseif not rockspec.build.type then\r\n      return nil, \"Rockspec error: build type not specified\"\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      local ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then\r\n         return nil, err, errcode\r\n      end\r\n   end\r\n\r\n   local ok, err, errcode = deps.check_external_deps(rockspec, \"build\")\r\n   if err then\r\n      return nil, err, errcode\r\n   end\r\n\r\n   local name, version = rockspec.name, rockspec.version\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n\r\n   if not minimal_mode then\r\n      local _, source_dir\r\n      if need_to_fetch then\r\n         ok, source_dir, errcode = fetch.fetch_sources(rockspec, true)\r\n         if not ok then\r\n            return nil, source_dir, errcode\r\n         end\r\n         local ok, err = fs.change_dir(source_dir)\r\n         if not ok then return nil, err end\r\n      elseif rockspec.source.file then\r\n         local ok, err = fs.unpack_archive(rockspec.source.file)\r\n         if not ok then\r\n            return nil, err\r\n         end\r\n      end\r\n      fs.change_dir(rockspec.source.dir)\r\n   end\r\n   \r\n   local dirs = {\r\n      lua = { name = path.lua_dir(name, version), is_module_path = true },\r\n      lib = { name = path.lib_dir(name, version), is_module_path = true },\r\n      conf = { name = path.conf_dir(name, version), is_module_path = false },\r\n      bin = { name = path.bin_dir(name, version), is_module_path = false },\r\n   }\r\n   \r\n   for _, d in pairs(dirs) do\r\n      local ok, err = fs.make_dir(d.name)\r\n      if not ok then return nil, err end\r\n   end\r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n\r\n   local build = rockspec.build\r\n   \r\n   if not minimal_mode then\r\n      ok, err = apply_patches(rockspec)\r\n      if err then\r\n         return nil, err\r\n      end\r\n   end\r\n   \r\n   if build.type ~= \"none\" then\r\n\r\n      -- Temporary compatibility\r\n      if build.type == \"module\" then\r\n         util.printout(\"Do not use 'module' as a build type. Use 'builtin' instead.\")\r\n         build.type = \"builtin\"\r\n      end\r\n\r\n      if cfg.accepted_build_types and util.array_contains(cfg.accepted_build_types, build.type) then\r\n         return nil, \"This rockspec uses the '\"..build.type..\"' build type, which is blocked by the 'accepted_build_types' setting in your LuaRocks configuration.\"\r\n      end\r\n\r\n      local build_type\r\n      ok, build_type = pcall(require, \"luarocks.build.\" .. build.type)\r\n      if not ok or not type(build_type) == \"table\" then\r\n         return nil, \"Failed initializing build back-end for build type '\"..build.type..\"': \"..build_type\r\n      end\r\n  \r\n      ok, err = build_type.run(rockspec)\r\n      if not ok then\r\n         return nil, \"Build error: \" .. err\r\n      end\r\n   end\r\n\r\n   if build.install then\r\n      for id, install_dir in pairs(dirs) do\r\n         ok, err = install_files(build.install[id], install_dir.name, install_dir.is_module_path)\r\n         if not ok then \r\n            return nil, err\r\n         end\r\n      end\r\n   end\r\n   \r\n   local copy_directories = build.copy_directories\r\n   local copying_default = false\r\n   if not copy_directories then\r\n      copy_directories = {\"doc\"}\r\n      copying_default = true\r\n   end\r\n\r\n   for _, copy_dir in pairs(copy_directories) do\r\n      if fs.is_dir(copy_dir) then\r\n         local dest = dir.path(path.install_dir(name, version), copy_dir)\r\n         fs.make_dir(dest)\r\n         fs.copy_contents(copy_dir, dest)\r\n      else\r\n         if not copying_default then\r\n            return nil, \"Directory '\"..copy_dir..\"' not found\"\r\n         end\r\n      end\r\n   end\r\n\r\n   for _, d in pairs(dirs) do\r\n      fs.remove_dir_if_empty(d.name)\r\n   end\r\n\r\n   fs.pop_dir()\r\n   \r\n   fs.copy(rockspec.local_filename, path.rockspec_file(name, version))\r\n   if need_to_fetch then\r\n      fs.pop_dir()\r\n   end\r\n\r\n   ok, err = manif.make_rock_manifest(name, version)\r\n   if err then return nil, err end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n\r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n\r\n   local license = \"\"\r\n   if rockspec.description and rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now built and installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 13,
    "text": "function build_rock(rock_file, need_to_fetch, deps_mode)\r\n   assert(type(rock_file) == \"string\")\r\n   assert(type(need_to_fetch) == \"boolean\")\r\n  \r\n   local unpack_dir, err, errcode = fetch.fetch_and_unpack_rock(rock_file)\r\n   if not unpack_dir then\r\n      return nil, err, errcode\r\n   end\r\n   local rockspec_file = path.rockspec_name_from_rock(rock_file)\r\n   local ok, err = fs.change_dir(unpack_dir)\r\n   if not ok then return nil, err end\r\n   local ok, err, errcode = build_rockspec(rockspec_file, need_to_fetch, false, deps_mode)\r\n   fs.pop_dir()\r\n   return ok, err, errcode\r\nend",
    "type": "function"
  }, {
    "id": 14,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"build\")\r\n   end\r\n   assert(type(version) == \"string\" or not version)\r\n\r\n   if flags[\"pack-binary-rock\"] then\r\n      return pack.pack_binary_rock(name, version, do_build, name, version, deps.get_deps_mode(flags))\r\n   else\r\n      local ok, err = fs.check_command_permissions(flags)\r\n      if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n      ok, err = do_build(name, version, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 15,
    "text": "function refresh_local_cache(server, url, user, password)\r\n   local local_cache, protocol, server_path, user, password = split_server_url(server, url, user, password)\r\n\r\n   local ok, err = fs.make_dir(cfg.local_cache)\r\n   if not ok then return nil, err end\r\n\r\n   local tmp_cache = false\r\n   if not local_cache then\r\n      local err\r\n      local_cache, err = fs.make_temp_dir(\"local_cache\")\r\n      tmp_cache = true\r\n   end\r\n   local ok, err = fs.make_dir(local_cache)\r\n   if not ok then\r\n      return nil, \"Failed creating local cache dir: \"..err\r\n   end\r\n   fs.change_dir(local_cache)\r\n   if not ok then return nil, err end\r\n   util.printout(\"Refreshing cache \"..local_cache..\"...\")\r\n\r\n   -- TODO abstract away explicit 'wget' call\r\n   local ok = false\r\n   if protocol == \"rsync\" then\r\n      local srv, path = server_path:match(\"([^/]+)(/.+)\")\r\n      ok = fs.execute(cfg.variables.RSYNC..\" \"..cfg.variables.RSYNCFLAGS..\" -e ssh \"..user..\"@\"..srv..\":\"..path..\"/ \"..local_cache..\"/\")\r\n   else \r\n      local login_info = \"\"\r\n      if user then login_info = \" --user=\"..user end\r\n      if password then login_info = login_info .. \" --password=\"..password end\r\n      ok = fs.execute(cfg.variables.WGET..\" --no-cache -q -m -np -nd \"..protocol..\"://\"..server_path..login_info)\r\n   end\r\n   if not ok then\r\n      return nil, \"Failed downloading cache.\"\r\n   end\r\n   return local_cache, protocol, server_path, user, password\r\nend",
    "type": "function"
  }, {
    "id": 16,
    "text": "function check_external_deps(rockspec, mode)\r\n   assert(type(rockspec) == \"table\")\r\n\r\n   local fs = require(\"luarocks.fs\")\r\n   \r\n   local vars = rockspec.variables\r\n   local patterns = cfg.external_deps_patterns\r\n   local subdirs = cfg.external_deps_subdirs\r\n   if mode == \"install\" then\r\n      patterns = cfg.runtime_external_deps_patterns\r\n      subdirs = cfg.runtime_external_deps_subdirs\r\n   end\r\n   if rockspec.external_dependencies then\r\n      for name, files in pairs(rockspec.external_dependencies) do\r\n         local ok = true\r\n         local failed_file = nil\r\n         local failed_dirname = nil\r\n         for _, extdir in ipairs(cfg.external_deps_dirs) do\r\n            ok = true\r\n            local prefix = vars[name..\"_DIR\"]\r\n            local dirs = {\r\n               BINDIR = { subdir = subdirs.bin, testfile = \"program\", pattern = patterns.bin },\r\n               INCDIR = { subdir = subdirs.include, testfile = \"header\", pattern = patterns.include },\r\n               LIBDIR = { subdir = subdirs.lib, testfile = \"library\", pattern = patterns.lib }\r\n            }\r\n            if mode == \"install\" then\r\n               dirs.INCDIR = nil\r\n            end\r\n            if not prefix then\r\n               prefix = extdir\r\n            end\r\n            if type(prefix) == \"table\" then\r\n               if prefix.bin then\r\n                  dirs.BINDIR.subdir = prefix.bin\r\n               end\r\n               if prefix.include then\r\n                  if dirs.INCDIR then\r\n                     dirs.INCDIR.subdir = prefix.include\r\n                  end\r\n               end\r\n               if prefix.lib then\r\n                  dirs.LIBDIR.subdir = prefix.lib\r\n               end\r\n               prefix = prefix.prefix\r\n            end\r\n            for dirname, dirdata in pairs(dirs) do\r\n               local paths\r\n               local path_var_value = vars[name..\"_\"..dirname]\r\n               if path_var_value then\r\n                  paths = { path_var_value }\r\n               elseif type(dirdata.subdir) == \"table\" then\r\n                  paths = {}\r\n                  for i,v in ipairs(dirdata.subdir) do\r\n                     paths[i] = dir.path(prefix, v)\r\n                  end\r\n               else\r\n                  paths = { dir.path(prefix, dirdata.subdir) }\r\n               end\r\n               dirdata.dir = paths[1]\r\n               local file = files[dirdata.testfile]\r\n               if file then\r\n                  local files = {}\r\n                  if not file:match(\"%.\") then\r\n                     add_all_patterns(file, dirdata.pattern, files)\r\n                  else\r\n                     for _, pattern in ipairs(dirdata.pattern) do\r\n                        local matched = deconstruct_pattern(file, pattern)\r\n                        if matched then\r\n                           add_all_patterns(matched, dirdata.pattern, files)\r\n                        end\r\n                     end\r\n                     table.insert(files, file)\r\n                  end\r\n                  local found = false\r\n                  failed_file = nil\r\n                  for _, f in pairs(files) do\r\n                     -- small convenience hack\r\n                     if f:match(\"%.so$\") or f:match(\"%.dylib$\") or f:match(\"%.dll$\") then\r\n                        f = f:gsub(\"%.[^.]+$\", \".\"..cfg.external_lib_extension)\r\n                     end\r\n                     for _, d in ipairs(paths) do\r\n                        if f:match(\"%*\") then\r\n                           local replaced = f:gsub(\"%.\", \"%%.\"):gsub(\"%*\", \".*\")\r\n                           for _, entry in ipairs(fs.list_dir(d)) do\r\n                              if entry:match(replaced) then\r\n                                 found = true\r\n                                 break\r\n                              end\r\n                           end\r\n                        else\r\n                           found = fs.is_file(dir.path(d, f))\r\n                        end\r\n                        if found then\r\n                           dirdata.dir = d\r\n                           break\r\n                        end\r\n                     end\r\n                     if found then\r\n                        break\r\n                     else\r\n                        if failed_file then\r\n                           failed_file = failed_file .. \", or \" .. f\r\n                        else\r\n                           failed_file = f\r\n                        end\r\n                     end\r\n                  end\r\n                  if not found then\r\n                     ok = false\r\n                     failed_dirname = dirname\r\n                     break\r\n                  end\r\n               end\r\n            end\r\n            if ok then\r\n               for dirname, dirdata in pairs(dirs) do\r\n                  vars[name..\"_\"..dirname] = dirdata.dir\r\n               end\r\n               vars[name..\"_DIR\"] = prefix\r\n               break\r\n            end\r\n         end\r\n         if not ok then\r\n            return nil, \"Could not find expected file \"..failed_file..\" for \"..name..\" -- you may have to install \"..name..\" in your system and/or pass \"..name..\"_DIR or \"..name..\"_\"..failed_dirname..\" to the luarocks command. Example: luarocks install \"..rockspec.name..\" \"..name..\"_DIR=/usr/local\", \"dependency\"\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 17,
    "text": "function base_name(pathname)\r\n   assert(type(pathname) == \"string\")\r\n\r\n   local base = pathname:gsub(\"[/\\\\]*$\", \"\"):match(\".*[/\\\\]([^/\\\\]*)\")\r\n   return base or pathname\r\nend",
    "type": "function"
  }, {
    "id": 18,
    "text": "function dir_name(pathname)\r\n   assert(type(pathname) == \"string\")\r\n   return (pathname:gsub(\"/*$\", \"\"):match(\"(.*)[/]+[^/]*\")) or \"\"\r\nend",
    "type": "function"
  }, {
    "id": 19,
    "text": "function path(...)\r\n   local t = {...}\r\n   while t[1] == \"\" do\r\n      table.remove(t, 1)\r\n   end\r\n   return (table.concat(t, \"/\"):gsub(\"([^:])/+\", \"%1/\"):gsub(\"^/+\", \"/\"):gsub(\"/*$\", \"\"))\r\nend",
    "type": "function"
  }, {
    "id": 20,
    "text": "function split_url(url)\r\n   assert(type(url) == \"string\")\r\n   \r\n   local protocol, pathname = url:match(\"^([^:]*)://(.*)\")\r\n   if not protocol then\r\n      protocol = \"file\"\r\n      pathname = url\r\n   end\r\n   return protocol, pathname\r\nend",
    "type": "function"
  }, {
    "id": 21,
    "text": "function normalize(name)\r\n   local protocol, pathname = split_url(name)\r\n   pathname = pathname:gsub(\"\\\\\", \"/\"):gsub(\"(.)/*$\", \"%1\"):gsub(\"//\", \"/\")\r\n   if protocol ~= \"file\" then pathname = protocol ..\"://\"..pathname end\r\n   return pathname\r\nend",
    "type": "function"
  }, {
    "id": 22,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if not name then\r\n      return nil, \"Argument missing. \"..util.see_help(\"doc\")\r\n   end\r\n\r\n   local repo\r\n   name, version, repo = show.pick_installed_rock(name, version, flags[\"tree\"])\r\n   if not name then\r\n      return nil, version\r\n   end\r\n   \r\n   local rockspec, err = fetch.load_local_rockspec(path.rockspec_file(name, version, repo))\r\n   if not rockspec then return nil,err end\r\n   local descript = rockspec.description or {}\r\n\r\n   if flags[\"homepage\"] then\r\n      if not descript.homepage then\r\n         return nil, \"No 'homepage' field in rockspec for \"..name..\" \"..version\r\n      end\r\n      util.printout(\"Opening \"..descript.homepage..\" ...\")\r\n      fs.browser(descript.homepage)\r\n      return true\r\n   end\r\n\r\n   local directory = path.install_dir(name,version,repo)\r\n   \r\n   local docdir\r\n   local directories = { \"doc\", \"docs\" }\r\n   for _, d in ipairs(directories) do\r\n      local dirname = dir.path(directory, d)\r\n      if fs.is_dir(dirname) then\r\n         docdir = dirname\r\n         break\r\n      end\r\n   end\r\n   if not docdir then\r\n      if descript.homepage and not flags[\"list\"] then\r\n         util.printout(\"Local documentation directory not found -- opening \"..descript.homepage..\" ...\")\r\n         fs.browser(descript.homepage)\r\n         return true\r\n      end\r\n      return nil, \"Documentation directory not found for \"..name..\" \"..version\r\n   end\r\n\r\n   docdir = dir.normalize(docdir):gsub(\"/+\", \"/\")\r\n   local files = fs.find(docdir)\r\n   local htmlpatt = \"%.html?$\"\r\n   local extensions = { htmlpatt, \"%.md$\", \"%.txt$\",  \"%.textile$\", \"\" }\r\n   local basenames = { \"index\", \"readme\", \"manual\" }\r\n   \r\n   local porcelain = flags[\"porcelain\"]\r\n   if #files > 0 then\r\n      util.title(\"Documentation files for \"..name..\" \"..version, porcelain)\r\n      if porcelain then\r\n         for _, file in ipairs(files) do\r\n            util.printout(docdir..\"/\"..file)\r\n         end\r\n      else\r\n         util.printout(docdir..\"/\")\r\n         for _, file in ipairs(files) do\r\n            util.printout(\"\\t\"..file)\r\n         end\r\n      end\r\n   end\r\n   \r\n   if flags[\"list\"] then\r\n      return true\r\n   end\r\n   \r\n   for _, extension in ipairs(extensions) do\r\n      for _, basename in ipairs(basenames) do\r\n         local filename = basename..extension\r\n         local found\r\n         for _, file in ipairs(files) do\r\n            if file:lower():match(filename) and ((not found) or #file < #found) then\r\n               found = file\r\n            end\r\n         end\r\n         if found then\r\n            local pathname = dir.path(docdir, found)\r\n            util.printout()\r\n            util.printout(\"Opening \"..pathname..\" ...\")\r\n            util.printout()\r\n            local ok = fs.browser(pathname)\r\n            if not ok and not pathname:match(htmlpatt) then\r\n               local fd = io.open(pathname, \"r\")\r\n               util.printout(fd:read(\"*a\"))\r\n               fd:close()\r\n            end\r\n            return true\r\n         end\r\n      end\r\n   end\r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 23,
    "text": "local function get_file(filename)\r\n   local protocol, pathname = dir.split_url(filename)\r\n   if protocol == \"file\" then\r\n      local ok, err = fs.copy(pathname, fs.current_dir())\r\n      if ok then\r\n         return pathname\r\n      else\r\n         return nil, err\r\n      end\r\n   else\r\n      return fetch.fetch_url(filename)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 24,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local module = rockspec.source.module or dir.base_name(rockspec.source.url)\r\n   local command = {rockspec.variables.CVS, \"-d\"..rockspec.source.pathname, \"export\", module}\r\n   if rockspec.source.tag then\r\n      table.insert(command, 4, \"-r\")\r\n      table.insert(command, 5, rockspec.source.tag)\r\n   end\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed fetching files from CVS.\"\r\n   end\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 25,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local git_cmd = rockspec.variables.GIT\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local module = dir.base_name(rockspec.source.url)\r\n   -- Strip off .git from base name if present\r\n   module = module:gsub(\"%.git$\", \"\")\r\n\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   store_dir = fs.absolute_name(store_dir)\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n\r\n   local command = {git_cmd, \"clone\", \"--depth=1\", rockspec.source.url, module}\r\n   local tag_or_branch = rockspec.source.tag or rockspec.source.branch\r\n   -- If the tag or branch is explicitly set to \"master\" in the rockspec, then\r\n   -- we can avoid passing it to Git since it's the default.\r\n   if tag_or_branch == \"master\" then tag_or_branch = nil end\r\n   if tag_or_branch then\r\n      if git_can_clone_by_tag(git_cmd) then\r\n         -- The argument to `--branch` can actually be a branch or a tag as of\r\n         -- Git 1.7.10.\r\n         table.insert(command, 4, \"--branch=\" .. tag_or_branch)\r\n      end\r\n   end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed cloning git repository.\"\r\n   end\r\n   local ok, err = fs.change_dir(module)\r\n   if not ok then return nil, err end\r\n   if tag_or_branch and not git_can_clone_by_tag() then\r\n      local checkout_command = {git_cmd, \"checkout\", tag_or_branch}\r\n      if not fs.execute(unpack(checkout_command)) then\r\n         return nil, 'Failed to check out the \"' .. tag_or_branch ..'\" tag or branch.'\r\n      end\r\n   end\r\n\r\n   fs.delete(dir.path(store_dir, module, \".git\"))\r\n   fs.delete(dir.path(store_dir, module, \".gitignore\"))\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 26,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local hg_cmd = rockspec.variables.HG\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   -- Strip off special hg:// protocol type\r\n   local url = rockspec.source.url:gsub(\"^hg://\", \"\") \r\n\r\n   local module = dir.base_name(url)\r\n\r\n   local command = {hg_cmd, \"clone\", url, module}\r\n   local tag_or_branch = rockspec.source.tag or rockspec.source.branch\r\n   if tag_or_branch then\r\n      command = {hg_cmd, \"clone\", \"--rev\", url, module}\r\n   end\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed cloning hg repository.\"\r\n   end\r\n   local ok, err = fs.change_dir(module)\r\n   if not ok then return nil, err end\r\n\r\n   fs.delete(dir.path(store_dir, module, \".hg\"))\r\n   fs.delete(dir.path(store_dir, module, \".hgignore\"))\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 27,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local sscm_cmd = rockspec.variables.SSCM\r\n   local module = rockspec.source.module or dir.base_name(rockspec.source.url)\r\n   local branch, repository = string.match(rockspec.source.pathname, \"^([^/]*)/(.*)\")\r\n   if not branch or not repository then\r\n      return nil, \"Error retrieving branch and repository from rockspec.\"\r\n   end\r\n   -- Search for working directory.\r\n   local working_dir\r\n   local tmp = io.popen(string.format(sscm_cmd..[[ property \"/\" -d -b%s -p%s]], branch, repository))\r\n   for line in tmp:lines() do\r\n      --%c because a chr(13) comes in the end.\r\n      working_dir = string.match(line, \"Working directory:[%s]*(.*)%c$\")\r\n      if working_dir then break end\r\n   end\r\n   tmp:close()\r\n   if not working_dir then\r\n      return nil, \"Error retrieving working directory from SSCM.\"\r\n   end\r\n   if not fs.execute(sscm_cmd, \"get\", \"*\", \"-e\" , \"-r\", \"-b\"..branch, \"-p\"..repository, \"-tmodify\", \"-wreplace\") then\r\n      return nil, \"Failed fetching files from SSCM.\"\r\n   end\r\n   -- FIXME: This function does not honor the dest_dir parameter.\r\n   return module, working_dir\r\nend",
    "type": "function"
  }, {
    "id": 28,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local svn_cmd = rockspec.variables.SVN\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local module = rockspec.source.module or dir.base_name(rockspec.source.url)\r\n   local url = rockspec.source.url:gsub(\"^svn://\", \"\")\r\n   local command = {svn_cmd, \"checkout\", url, module}\r\n   if rockspec.source.tag then\r\n      table.insert(command, 5, \"-r\")\r\n      table.insert(command, 6, rockspec.source.tag)\r\n   end\r\n   local store_dir\r\n   if not dest_dir then\r\n      store_dir = fs.make_temp_dir(name_version)\r\n      if not store_dir then\r\n         return nil, \"Failed creating temporary directory.\"\r\n      end\r\n      util.schedule_function(fs.delete, store_dir)\r\n   else\r\n      store_dir = dest_dir\r\n   end\r\n   local ok, err = fs.change_dir(store_dir)\r\n   if not ok then return nil, err end\r\n   if not fs.execute(unpack(command)) then\r\n      return nil, \"Failed fetching files from Subversion.\"\r\n   end\r\n   ok, err = fs.change_dir(module)\r\n   if not ok then return nil, err end\r\n   for _, d in ipairs(fs.find(\".\")) do\r\n      if dir.base_name(d) == \".svn\" then\r\n         fs.delete(dir.path(store_dir, module, d))\r\n      end\r\n   end\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return module, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 29,
    "text": "function fetch_url(url, filename, cache)\r\n   assert(type(url) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n\r\n   local protocol, pathname = dir.split_url(url)\r\n   if protocol == \"file\" then\r\n      return fs.absolute_name(pathname)\r\n   elseif is_basic_protocol(protocol, true) then\r\n      local ok, filename = fs.download(url, filename, cache)\r\n      if not ok then\r\n         return nil, \"Failed downloading \"..url..(filename and \" - \"..filename or \"\"), \"network\"\r\n      end\r\n      return filename\r\n   else\r\n      return nil, \"Unsupported protocol \"..protocol\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 30,
    "text": "function fetch_url_at_temp_dir(url, tmpname, filename)\r\n   assert(type(url) == \"string\")\r\n   assert(type(tmpname) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n   filename = filename or dir.base_name(url)\r\n\r\n   local protocol, pathname = dir.split_url(url)\r\n   if protocol == \"file\" then\r\n      if fs.exists(pathname) then\r\n         return pathname, dir.dir_name(fs.absolute_name(pathname))\r\n      else\r\n         return nil, \"File not found: \"..pathname\r\n      end\r\n   else\r\n      local temp_dir, err = fs.make_temp_dir(tmpname)\r\n      if not temp_dir then\r\n         return nil, \"Failed creating temporary directory \"..tmpname..\": \"..err\r\n      end\r\n      util.schedule_function(fs.delete, temp_dir)\r\n      local ok, err = fs.change_dir(temp_dir)\r\n      if not ok then return nil, err end\r\n      local file, err, errcode = fetch_url(url, filename)\r\n      fs.pop_dir()\r\n      if not file then\r\n         return nil, \"Error fetching file: \"..err, errcode\r\n      end\r\n      return file, temp_dir\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 31,
    "text": "function fetch_and_unpack_rock(rock_file, dest)\r\n   assert(type(rock_file) == \"string\")\r\n   assert(type(dest) == \"string\" or not dest)\r\n\r\n   local name = dir.base_name(rock_file):match(\"(.*)%.[^.]*%.rock\")\r\n   \r\n   local rock_file, err, errcode = fetch_url_at_temp_dir(rock_file,\"luarocks-rock-\"..name)\r\n   if not rock_file then\r\n      return nil, \"Could not fetch rock file: \" .. err, errcode\r\n   end\r\n\r\n   rock_file = fs.absolute_name(rock_file)\r\n   local unpack_dir\r\n   if dest then\r\n      unpack_dir = dest\r\n      local ok, err = fs.make_dir(unpack_dir)\r\n      if not ok then\r\n         return nil, \"Failed unpacking rock file: \" .. err\r\n      end\r\n   else\r\n      unpack_dir = fs.make_temp_dir(name)\r\n   end\r\n   if not dest then\r\n      util.schedule_function(fs.delete, unpack_dir)\r\n   end\r\n   local ok, err = fs.change_dir(unpack_dir)\r\n   if not ok then return nil, err end\r\n   ok = fs.unzip(rock_file)\r\n   if not ok then\r\n      return nil, \"Failed unpacking rock file: \" .. rock_file\r\n   end\r\n   fs.pop_dir()\r\n   return unpack_dir\r\nend",
    "type": "function"
  }, {
    "id": 32,
    "text": "function load_rockspec(filename, location)\r\n   assert(type(filename) == \"string\")\r\n\r\n   local name\r\n   local basename = dir.base_name(filename)\r\n   if basename == \"rockspec\" then\r\n      name = \"rockspec\"\r\n   else\r\n      name = basename:match(\"(.*)%.rockspec\")\r\n      if not name then\r\n         return nil, \"Filename '\"..filename..\"' does not look like a rockspec.\"\r\n      end\r\n   end\r\n   \r\n   local err, errcode\r\n   if location then\r\n      local ok, err = fs.change_dir(location)\r\n      if not ok then return nil, err end\r\n      filename, err = fetch_url(filename)\r\n      fs.pop_dir()\r\n   else\r\n      filename, err, errcode = fetch_url_at_temp_dir(filename,\"luarocks-rockspec-\"..name)\r\n   end\r\n   if not filename then\r\n      return nil, err, errcode\r\n   end\r\n\r\n   return load_local_rockspec(filename)\r\nend",
    "type": "function"
  }, {
    "id": 33,
    "text": "function get_sources(rockspec, extract, dest_dir)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(extract) == \"boolean\")\r\n   assert(type(dest_dir) == \"string\" or not dest_dir)\r\n\r\n   local url = rockspec.source.url\r\n   local name = rockspec.name..\"-\"..rockspec.version\r\n   local filename = rockspec.source.file\r\n   local source_file, store_dir, err, errcode\r\n   if dest_dir then\r\n      local ok, err = fs.change_dir(dest_dir)\r\n      if not ok then return nil, err, \"dest_dir\" end\r\n      source_file, err, errcode = fetch_url(url, filename)\r\n      fs.pop_dir()\r\n      store_dir = dest_dir\r\n   else\r\n      source_file, store_dir, errcode = fetch_url_at_temp_dir(url, \"luarocks-source-\"..name, filename)\r\n   end\r\n   if not source_file then\r\n      return nil, err or store_dir, errcode\r\n   end\r\n   if rockspec.source.md5 then\r\n      if not fs.check_md5(source_file, rockspec.source.md5) then\r\n         return nil, \"MD5 check for \"..filename..\" has failed.\", \"md5\"\r\n      end\r\n   end\r\n   if extract then\r\n      local ok, err = fs.change_dir(store_dir)\r\n      if not ok then return nil, err end\r\n      fs.unpack_archive(rockspec.source.file)\r\n      if not fs.exists(rockspec.source.dir) then\r\n         return nil, \"Directory \"..rockspec.source.dir..\" not found inside archive \"..rockspec.source.file, \"source.dir\", source_file, store_dir\r\n      end\r\n      fs.pop_dir()\r\n   end\r\n   return source_file, store_dir\r\nend",
    "type": "function"
  }, {
    "id": 34,
    "text": "function Q(arg)\r\n   assert(type(arg) == \"string\")\r\n\r\n   -- FIXME Unix-specific\r\n   return \"'\" .. arg:gsub(\"'\", \"'\\\\''\") .. \"'\"\r\nend",
    "type": "function"
  }, {
    "id": 35,
    "text": "assert(type(arg) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 36,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 37,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 38,
    "text": "function is_writable(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   local result\r\n   if fs.is_dir(file) then\r\n      local file2 = dir.path(file, '.tmpluarockstestwritable')\r\n      local fh = io.open(file2, 'wb')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n      os.remove(file2)\r\n   else\r\n      local fh = io.open(file, 'r+b')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 39,
    "text": "assert(file)",
    "type": "statement:functioncall"
  }, {
    "id": 40,
    "text": "file = dir.normalize(file)",
    "type": "statement:assign"
  }, {
    "id": 41,
    "text": "local result",
    "type": "statement:localassign"
  }, {
    "id": 42,
    "text": "if fs.is_dir(file) then\r\n      local file2 = dir.path(file, '.tmpluarockstestwritable')\r\n      local fh = io.open(file2, 'wb')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n      os.remove(file2)\r\n   else\r\n      local fh = io.open(file, 'r+b')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 43,
    "text": "local file2 = dir.path(file, '.tmpluarockstestwritable')",
    "type": "statement:localassign"
  }, {
    "id": 44,
    "text": "local fh = io.open(file2, 'wb')",
    "type": "statement:localassign"
  }, {
    "id": 45,
    "text": "result = fh ~= nil",
    "type": "statement:assign"
  }, {
    "id": 46,
    "text": "if fh then fh:close() end",
    "type": "statement:if"
  }, {
    "id": 47,
    "text": "fh:close()",
    "type": "statement:functioncall"
  }, {
    "id": 48,
    "text": "os.remove(file2)",
    "type": "statement:functioncall"
  }, {
    "id": 49,
    "text": "local fh = io.open(file, 'r+b')",
    "type": "statement:localassign"
  }, {
    "id": 50,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 51,
    "text": "function make_temp_dir(name)\r\n   assert(type(name) == \"string\")\r\n   name = dir.normalize(name)\r\n\r\n   local temp_dir = (os.getenv(\"TMP\") or \"/tmp\") .. \"/luarocks_\" .. name:gsub(dir.separator, \"_\") .. \"-\" .. tostring(math.floor(math.random() * 10000))\r\n   local ok, err = fs.make_dir(temp_dir)\r\n   if ok then\r\n      return temp_dir\r\n   else\r\n      return nil, err\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 52,
    "text": "assert(type(name) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 53,
    "text": "name = dir.normalize(name)",
    "type": "statement:assign"
  }, {
    "id": 54,
    "text": "local temp_dir = (os.getenv(\"TMP\") or \"/tmp\") .. \"/luarocks_\" .. name:gsub(dir.separator, \"_\") .. \"-\" .. tostring(math.floor(math.random() * 10000))",
    "type": "statement:localassign"
  }, {
    "id": 55,
    "text": "local ok, err = fs.make_dir(temp_dir)",
    "type": "statement:localassign"
  }, {
    "id": 56,
    "text": "if ok then\r\n      return temp_dir\r\n   else\r\n      return nil, err\r\n   end",
    "type": "statement:if"
  }, {
    "id": 57,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 58,
    "text": "local function quote_args(command, ...)\r\n   local out = { command }\r\n   for _, arg in ipairs({...}) do\r\n      assert(type(arg) == \"string\")\r\n      out[#out+1] = fs.Q(arg)\r\n   end\r\n   return table.concat(out, \" \")\r\nend",
    "type": "function"
  }, {
    "id": 59,
    "text": "local out = { command }",
    "type": "statement:localassign"
  }, {
    "id": 60,
    "text": "for _, arg in ipairs({...}) do\r\n      assert(type(arg) == \"string\")\r\n      out[#out+1] = fs.Q(arg)\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 61,
    "text": "out[#out+1] = fs.Q(arg)",
    "type": "statement:assign"
  }, {
    "id": 62,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 63,
    "text": "function execute(command, ...)\r\n   assert(type(command) == \"string\")\r\n   return fs.execute_string(quote_args(command, ...))\r\nend",
    "type": "function"
  }, {
    "id": 64,
    "text": "assert(type(command) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 65,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 66,
    "text": "function execute_quiet(command, ...)\r\n   assert(type(command) == \"string\")\r\n   if cfg.verbose then -- omit silencing output\r\n      return fs.execute_string(quote_args(command, ...))\r\n   else\r\n      return fs.execute_string(fs.quiet(quote_args(command, ...)))\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 67,
    "text": "if cfg.verbose then -- omit silencing output\r\n      return fs.execute_string(quote_args(command, ...))\r\n   else\r\n      return fs.execute_string(fs.quiet(quote_args(command, ...)))\r\n   end",
    "type": "statement:if"
  }, {
    "id": 68,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 69,
    "text": "function check_md5(file, md5sum)\r\n   file = dir.normalize(file)\r\n   local computed, msg = fs.get_md5(file)\r\n   if not computed then\r\n      return false, msg\r\n   end\r\n   if computed:match(\"^\"..md5sum) then\r\n      return true\r\n   else\r\n      return false, \"Mismatch MD5 hash for file \"..file\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 70,
    "text": "local computed, msg = fs.get_md5(file)",
    "type": "statement:localassign"
  }, {
    "id": 71,
    "text": "if not computed then\r\n      return false, msg\r\n   end",
    "type": "statement:if"
  }, {
    "id": 72,
    "text": "if computed:match(\"^\"..md5sum) then\r\n      return true\r\n   else\r\n      return false, \"Mismatch MD5 hash for file \"..file\r\n   end",
    "type": "statement:if"
  }, {
    "id": 73,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 74,
    "text": "function execute_string(cmd)\r\n   local code = os.execute(cmd)\r\n   return (code == 0 or code == true)\r\nend",
    "type": "function"
  }, {
    "id": 75,
    "text": "local code = os.execute(cmd)",
    "type": "statement:localassign"
  }, {
    "id": 76,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 77,
    "text": "function current_dir()\r\n   return lfs.currentdir()\r\nend",
    "type": "function"
  }, {
    "id": 78,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 79,
    "text": "function change_dir(d)\r\n   table.insert(dir_stack, lfs.currentdir())\r\n   d = dir.normalize(d)\r\n   return lfs.chdir(d)\r\nend",
    "type": "function"
  }, {
    "id": 80,
    "text": "table.insert(dir_stack, lfs.currentdir())",
    "type": "statement:functioncall"
  }, {
    "id": 81,
    "text": "d = dir.normalize(d)",
    "type": "statement:assign"
  }, {
    "id": 82,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 83,
    "text": "function change_dir_to_root()\r\n   table.insert(dir_stack, lfs.currentdir())\r\n   lfs.chdir(\"/\") -- works on Windows too\r\nend",
    "type": "function"
  }, {
    "id": 84,
    "text": "lfs.chdir(\"/\")",
    "type": "statement:functioncall"
  }, {
    "id": 85,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 86,
    "text": "function pop_dir()\r\n   local d = table.remove(dir_stack)\r\n   if d then\r\n      lfs.chdir(d)\r\n      return true\r\n   else\r\n      return false\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 87,
    "text": "local d = table.remove(dir_stack)",
    "type": "statement:localassign"
  }, {
    "id": 88,
    "text": "if d then\r\n      lfs.chdir(d)\r\n      return true\r\n   else\r\n      return false\r\n   end",
    "type": "statement:if"
  }, {
    "id": 89,
    "text": "lfs.chdir(d)",
    "type": "statement:functioncall"
  }, {
    "id": 90,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 91,
    "text": "function make_dir(directory)\r\n   assert(type(directory) == \"string\")\r\n   directory = dir.normalize(directory)\r\n   local path = nil\r\n   if directory:sub(2, 2) == \":\" then\r\n     path = directory:sub(1, 2)\r\n     directory = directory:sub(4)\r\n   else\r\n     if directory:match(\"^/\") then\r\n        path = \"\"\r\n     end\r\n   end\r\n   for d in directory:gmatch(\"([^\"..dir.separator..\"]+)\"..dir.separator..\"*\") do\r\n      path = path and path .. dir.separator .. d or d\r\n      local mode = lfs.attributes(path, \"mode\")\r\n      if not mode then\r\n         local ok, err = lfs.mkdir(path)\r\n         if not ok then\r\n            return false, err\r\n         end\r\n      elseif mode ~= \"directory\" then\r\n         return false, path..\" is not a directory\"\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 92,
    "text": "assert(type(directory) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 93,
    "text": "directory = dir.normalize(directory)",
    "type": "statement:assign"
  }, {
    "id": 94,
    "text": "local path = nil",
    "type": "statement:localassign"
  }, {
    "id": 95,
    "text": "if directory:sub(2, 2) == \":\" then\r\n     path = directory:sub(1, 2)\r\n     directory = directory:sub(4)\r\n   else\r\n     if directory:match(\"^/\") then\r\n        path = \"\"\r\n     end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 96,
    "text": "path = directory:sub(1, 2)",
    "type": "statement:assign"
  }, {
    "id": 97,
    "text": "directory = directory:sub(4)",
    "type": "statement:assign"
  }, {
    "id": 98,
    "text": "if directory:match(\"^/\") then\r\n        path = \"\"\r\n     end",
    "type": "statement:if"
  }, {
    "id": 99,
    "text": "path = \"\"",
    "type": "statement:assign"
  }, {
    "id": 100,
    "text": "for d in directory:gmatch(\"([^\"..dir.separator..\"]+)\"..dir.separator..\"*\") do\r\n      path = path and path .. dir.separator .. d or d\r\n      local mode = lfs.attributes(path, \"mode\")\r\n      if not mode then\r\n         local ok, err = lfs.mkdir(path)\r\n         if not ok then\r\n            return false, err\r\n         end\r\n      elseif mode ~= \"directory\" then\r\n         return false, path..\" is not a directory\"\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 101,
    "text": "path = path and path .. dir.separator .. d or d",
    "type": "statement:assign"
  }, {
    "id": 102,
    "text": "local mode = lfs.attributes(path, \"mode\")",
    "type": "statement:localassign"
  }, {
    "id": 103,
    "text": "if not mode then\r\n         local ok, err = lfs.mkdir(path)\r\n         if not ok then\r\n            return false, err\r\n         end\r\n      elseif mode ~= \"directory\" then\r\n         return false, path..\" is not a directory\"\r\n      end",
    "type": "statement:if"
  }, {
    "id": 104,
    "text": "local ok, err = lfs.mkdir(path)",
    "type": "statement:localassign"
  }, {
    "id": 105,
    "text": "if not ok then\r\n            return false, err\r\n         end",
    "type": "statement:if"
  }, {
    "id": 106,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 107,
    "text": "function remove_dir_if_empty(d)\r\n   assert(d)\r\n   d = dir.normalize(d)\r\n   lfs.rmdir(d)\r\nend",
    "type": "function"
  }, {
    "id": 108,
    "text": "assert(d)",
    "type": "statement:functioncall"
  }, {
    "id": 109,
    "text": "lfs.rmdir(d)",
    "type": "statement:functioncall"
  }, {
    "id": 110,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 111,
    "text": "function remove_dir_tree_if_empty(d)\r\n   assert(d)\r\n   d = dir.normalize(d)\r\n   for i=1,10 do\r\n      lfs.rmdir(d)\r\n      d = dir.dir_name(d)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 112,
    "text": "for i=1,10 do\r\n      lfs.rmdir(d)\r\n      d = dir.dir_name(d)\r\n   end",
    "type": "statement:numericfor"
  }, {
    "id": 113,
    "text": "d = dir.dir_name(d)",
    "type": "statement:assign"
  }, {
    "id": 114,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 115,
    "text": "function copy(src, dest, perms)\r\n   assert(src and dest)\r\n   src = dir.normalize(src)\r\n   dest = dir.normalize(dest)\r\n   local destmode = lfs.attributes(dest, \"mode\")\r\n   if destmode == \"directory\" then\r\n      dest = dir.path(dest, dir.base_name(src))\r\n   end\r\n   if not perms then perms = fs.get_permissions(src) end\r\n   local src_h, err = io.open(src, \"rb\")\r\n   if not src_h then return nil, err end\r\n   local dest_h, err = io.open(dest, \"w+b\")\r\n   if not dest_h then src_h:close() return nil, err end\r\n   while true do\r\n      local block = src_h:read(8192)\r\n      if not block then break end\r\n      dest_h:write(block)\r\n   end\r\n   src_h:close()\r\n   dest_h:close()\r\n   fs.chmod(dest, perms)\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 116,
    "text": "assert(src and dest)",
    "type": "statement:functioncall"
  }, {
    "id": 117,
    "text": "src = dir.normalize(src)",
    "type": "statement:assign"
  }, {
    "id": 118,
    "text": "dest = dir.normalize(dest)",
    "type": "statement:assign"
  }, {
    "id": 119,
    "text": "local destmode = lfs.attributes(dest, \"mode\")",
    "type": "statement:localassign"
  }, {
    "id": 120,
    "text": "if destmode == \"directory\" then\r\n      dest = dir.path(dest, dir.base_name(src))\r\n   end",
    "type": "statement:if"
  }, {
    "id": 121,
    "text": "dest = dir.path(dest, dir.base_name(src))",
    "type": "statement:assign"
  }, {
    "id": 122,
    "text": "if not perms then perms = fs.get_permissions(src) end",
    "type": "statement:if"
  }, {
    "id": 123,
    "text": "perms = fs.get_permissions(src)",
    "type": "statement:assign"
  }, {
    "id": 124,
    "text": "local src_h, err = io.open(src, \"rb\")",
    "type": "statement:localassign"
  }, {
    "id": 125,
    "text": "if not src_h then return nil, err end",
    "type": "statement:if"
  }, {
    "id": 126,
    "text": "local dest_h, err = io.open(dest, \"w+b\")",
    "type": "statement:localassign"
  }, {
    "id": 127,
    "text": "if not dest_h then src_h:close() return nil, err end",
    "type": "statement:if"
  }, {
    "id": 128,
    "text": "src_h:close()",
    "type": "statement:functioncall"
  }, {
    "id": 129,
    "text": "while true do\r\n      local block = src_h:read(8192)\r\n      if not block then break end\r\n      dest_h:write(block)\r\n   end",
    "type": "statement:while"
  }, {
    "id": 130,
    "text": "local block = src_h:read(8192)",
    "type": "statement:localassign"
  }, {
    "id": 131,
    "text": "if not block then break end",
    "type": "statement:if"
  }, {
    "id": 132,
    "text": "dest_h:write(block)",
    "type": "statement:functioncall"
  }, {
    "id": 133,
    "text": "dest_h:close()",
    "type": "statement:functioncall"
  }, {
    "id": 134,
    "text": "fs.chmod(dest, perms)",
    "type": "statement:functioncall"
  }, {
    "id": 135,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 136,
    "text": "local function recursive_copy(src, dest)\r\n   local srcmode = lfs.attributes(src, \"mode\")\r\n\r\n   if srcmode == \"file\" then\r\n      local ok = fs.copy(src, dest)\r\n      if not ok then return false end\r\n   elseif srcmode == \"directory\" then\r\n      local subdir = dir.path(dest, dir.base_name(src))\r\n      local ok, err = fs.make_dir(subdir)\r\n      if not ok then return nil, err end\r\n      for file in lfs.dir(src) do\r\n         if file ~= \".\" and file ~= \"..\" then\r\n            local ok = recursive_copy(dir.path(src, file), subdir)\r\n            if not ok then return false end\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 137,
    "text": "local srcmode = lfs.attributes(src, \"mode\")",
    "type": "statement:localassign"
  }, {
    "id": 138,
    "text": "if srcmode == \"file\" then\r\n      local ok = fs.copy(src, dest)\r\n      if not ok then return false end\r\n   elseif srcmode == \"directory\" then\r\n      local subdir = dir.path(dest, dir.base_name(src))\r\n      local ok, err = fs.make_dir(subdir)\r\n      if not ok then return nil, err end\r\n      for file in lfs.dir(src) do\r\n         if file ~= \".\" and file ~= \"..\" then\r\n            local ok = recursive_copy(dir.path(src, file), subdir)\r\n            if not ok then return false end\r\n         end\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 139,
    "text": "local ok = fs.copy(src, dest)",
    "type": "statement:localassign"
  }, {
    "id": 140,
    "text": "if not ok then return false end",
    "type": "statement:if"
  }, {
    "id": 141,
    "text": "local subdir = dir.path(dest, dir.base_name(src))",
    "type": "statement:localassign"
  }, {
    "id": 142,
    "text": "local ok, err = fs.make_dir(subdir)",
    "type": "statement:localassign"
  }, {
    "id": 143,
    "text": "if not ok then return nil, err end",
    "type": "statement:if"
  }, {
    "id": 144,
    "text": "for file in lfs.dir(src) do\r\n         if file ~= \".\" and file ~= \"..\" then\r\n            local ok = recursive_copy(dir.path(src, file), subdir)\r\n            if not ok then return false end\r\n         end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 145,
    "text": "if file ~= \".\" and file ~= \"..\" then\r\n            local ok = recursive_copy(dir.path(src, file), subdir)\r\n            if not ok then return false end\r\n         end",
    "type": "statement:if"
  }, {
    "id": 146,
    "text": "local ok = recursive_copy(dir.path(src, file), subdir)",
    "type": "statement:localassign"
  }, {
    "id": 147,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 148,
    "text": "function copy_contents(src, dest)\r\n   assert(src and dest)\r\n   src = dir.normalize(src)\r\n   dest = dir.normalize(dest)\r\n   assert(lfs.attributes(src, \"mode\") == \"directory\")\r\n\r\n   for file in lfs.dir(src) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         local ok = recursive_copy(dir.path(src, file), dest)\r\n         if not ok then\r\n            return false, \"Failed copying \"..src..\" to \"..dest\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 149,
    "text": "assert(lfs.attributes(src, \"mode\") == \"directory\")",
    "type": "statement:functioncall"
  }, {
    "id": 150,
    "text": "for file in lfs.dir(src) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         local ok = recursive_copy(dir.path(src, file), dest)\r\n         if not ok then\r\n            return false, \"Failed copying \"..src..\" to \"..dest\r\n         end\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 151,
    "text": "if file ~= \".\" and file ~= \"..\" then\r\n         local ok = recursive_copy(dir.path(src, file), dest)\r\n         if not ok then\r\n            return false, \"Failed copying \"..src..\" to \"..dest\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 152,
    "text": "local ok = recursive_copy(dir.path(src, file), dest)",
    "type": "statement:localassign"
  }, {
    "id": 153,
    "text": "if not ok then\r\n            return false, \"Failed copying \"..src..\" to \"..dest\r\n         end",
    "type": "statement:if"
  }, {
    "id": 154,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 155,
    "text": "local function recursive_delete(name)\r\n   local ok = os.remove(name)\r\n   if ok then return true end\r\n   local pok, ok, err = pcall(function()\r\n      for file in lfs.dir(name) do\r\n         if file ~= \".\" and file ~= \"..\" then\r\n            local ok, err = recursive_delete(dir.path(name, file))\r\n            if not ok then return nil, err end\r\n         end\r\n      end\r\n      local ok, err = lfs.rmdir(name)\r\n      return ok, (not ok) and err\r\n   end)\r\n   if pok then\r\n      return ok, err\r\n   else\r\n      return pok, ok\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 156,
    "text": "local ok = os.remove(name)",
    "type": "statement:localassign"
  }, {
    "id": 157,
    "text": "if ok then return true end",
    "type": "statement:if"
  }, {
    "id": 158,
    "text": "local pok, ok, err = pcall(function()\r\n      for file in lfs.dir(name) do\r\n         if file ~= \".\" and file ~= \"..\" then\r\n            local ok, err = recursive_delete(dir.path(name, file))\r\n            if not ok then return nil, err end\r\n         end\r\n      end\r\n      local ok, err = lfs.rmdir(name)\r\n      return ok, (not ok) and err\r\n   end)",
    "type": "statement:localassign"
  }, {
    "id": 159,
    "text": "for file in lfs.dir(name) do\r\n         if file ~= \".\" and file ~= \"..\" then\r\n            local ok, err = recursive_delete(dir.path(name, file))\r\n            if not ok then return nil, err end\r\n         end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 160,
    "text": "if file ~= \".\" and file ~= \"..\" then\r\n            local ok, err = recursive_delete(dir.path(name, file))\r\n            if not ok then return nil, err end\r\n         end",
    "type": "statement:if"
  }, {
    "id": 161,
    "text": "local ok, err = recursive_delete(dir.path(name, file))",
    "type": "statement:localassign"
  }, {
    "id": 162,
    "text": "local ok, err = lfs.rmdir(name)",
    "type": "statement:localassign"
  }, {
    "id": 163,
    "text": "if pok then\r\n      return ok, err\r\n   else\r\n      return pok, ok\r\n   end",
    "type": "statement:if"
  }, {
    "id": 164,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 165,
    "text": "function delete(name)\r\n   name = dir.normalize(name)\r\n   recursive_delete(name)\r\nend",
    "type": "function"
  }, {
    "id": 166,
    "text": "recursive_delete(name)",
    "type": "statement:functioncall"
  }, {
    "id": 167,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 168,
    "text": "function list_dir(at)\r\n   assert(type(at) == \"string\" or not at)\r\n   if not at then\r\n      at = fs.current_dir()\r\n   end\r\n   at = dir.normalize(at)\r\n   if not fs.is_dir(at) then\r\n      return {}\r\n   end\r\n   local result = {}\r\n   for file in lfs.dir(at) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         table.insert(result, file)\r\n      end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 169,
    "text": "assert(type(at) == \"string\" or not at)",
    "type": "statement:functioncall"
  }, {
    "id": 170,
    "text": "if not at then\r\n      at = fs.current_dir()\r\n   end",
    "type": "statement:if"
  }, {
    "id": 171,
    "text": "at = fs.current_dir()",
    "type": "statement:assign"
  }, {
    "id": 172,
    "text": "at = dir.normalize(at)",
    "type": "statement:assign"
  }, {
    "id": 173,
    "text": "if not fs.is_dir(at) then\r\n      return {}\r\n   end",
    "type": "statement:if"
  }, {
    "id": 174,
    "text": "local result = {}",
    "type": "statement:localassign"
  }, {
    "id": 175,
    "text": "for file in lfs.dir(at) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         table.insert(result, file)\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 176,
    "text": "if file ~= \".\" and file ~= \"..\" then\r\n         table.insert(result, file)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 177,
    "text": "table.insert(result, file)",
    "type": "statement:functioncall"
  }, {
    "id": 178,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 179,
    "text": "local function recursive_find(cwd, prefix, result)\r\n   for file in lfs.dir(cwd) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         local item = prefix .. file\r\n         table.insert(result, item)\r\n         local pathname = dir.path(cwd, file)\r\n         if lfs.attributes(pathname, \"mode\") == \"directory\" then\r\n            recursive_find(pathname, item..dir_separator, result)\r\n         end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 180,
    "text": "for file in lfs.dir(cwd) do\r\n      if file ~= \".\" and file ~= \"..\" then\r\n         local item = prefix .. file\r\n         table.insert(result, item)\r\n         local pathname = dir.path(cwd, file)\r\n         if lfs.attributes(pathname, \"mode\") == \"directory\" then\r\n            recursive_find(pathname, item..dir_separator, result)\r\n         end\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 181,
    "text": "if file ~= \".\" and file ~= \"..\" then\r\n         local item = prefix .. file\r\n         table.insert(result, item)\r\n         local pathname = dir.path(cwd, file)\r\n         if lfs.attributes(pathname, \"mode\") == \"directory\" then\r\n            recursive_find(pathname, item..dir_separator, result)\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 182,
    "text": "local item = prefix .. file",
    "type": "statement:localassign"
  }, {
    "id": 183,
    "text": "table.insert(result, item)",
    "type": "statement:functioncall"
  }, {
    "id": 184,
    "text": "local pathname = dir.path(cwd, file)",
    "type": "statement:localassign"
  }, {
    "id": 185,
    "text": "if lfs.attributes(pathname, \"mode\") == \"directory\" then\r\n            recursive_find(pathname, item..dir_separator, result)\r\n         end",
    "type": "statement:if"
  }, {
    "id": 186,
    "text": "recursive_find(pathname, item..dir_separator, result)",
    "type": "statement:functioncall"
  }, {
    "id": 187,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 188,
    "text": "function find(at)\r\n   assert(type(at) == \"string\" or not at)\r\n   if not at then\r\n      at = fs.current_dir()\r\n   end\r\n   at = dir.normalize(at)\r\n   if not fs.is_dir(at) then\r\n      return {}\r\n   end\r\n   local result = {}\r\n   recursive_find(at, \"\", result)\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 189,
    "text": "recursive_find(at, \"\", result)",
    "type": "statement:functioncall"
  }, {
    "id": 190,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 191,
    "text": "function exists(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   return type(lfs.attributes(file)) == \"table\"\r\nend",
    "type": "function"
  }, {
    "id": 192,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 193,
    "text": "function is_dir(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   return lfs.attributes(file, \"mode\") == \"directory\"\r\nend",
    "type": "function"
  }, {
    "id": 194,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 195,
    "text": "function is_file(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   return lfs.attributes(file, \"mode\") == \"file\"\r\nend",
    "type": "function"
  }, {
    "id": 196,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 197,
    "text": "function set_time(file, time)\r\n   file = dir.normalize(file)\r\n   return lfs.touch(file, time)\r\nend",
    "type": "function"
  }, {
    "id": 198,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 199,
    "text": "function zip(zipfile, ...)\r\n   return lrzip.zip(zipfile, ...)\r\nend",
    "type": "function"
  }, {
    "id": 200,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 201,
    "text": "function unzip(zipfile)\r\n   local zipfile, err = luazip.open(zipfile)\r\n   if not zipfile then return nil, err end\r\n   local files = zipfile:files()\r\n   local file = files()\r\n   repeat\r\n      if file.filename:sub(#file.filename) == \"/\" then\r\n         local ok, err = fs.make_dir(dir.path(fs.current_dir(), file.filename))\r\n         if not ok then return nil, err end\r\n      else\r\n         local rf, err = zipfile:open(file.filename)\r\n         if not rf then zipfile:close(); return nil, err end\r\n         local contents = rf:read(\"*a\")\r\n         rf:close()\r\n         local wf, err = io.open(dir.path(fs.current_dir(), file.filename), \"wb\")\r\n         if not wf then zipfile:close(); return nil, err end\r\n         wf:write(contents)\r\n         wf:close()\r\n      end\r\n      file = files()\r\n   until not file\r\n   zipfile:close()\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 202,
    "text": "local zipfile, err = luazip.open(zipfile)",
    "type": "statement:localassign"
  }, {
    "id": 203,
    "text": "if not zipfile then return nil, err end",
    "type": "statement:if"
  }, {
    "id": 204,
    "text": "local files = zipfile:files()",
    "type": "statement:localassign"
  }, {
    "id": 205,
    "text": "local file = files()",
    "type": "statement:localassign"
  }, {
    "id": 206,
    "text": "repeat\r\n      if file.filename:sub(#file.filename) == \"/\" then\r\n         local ok, err = fs.make_dir(dir.path(fs.current_dir(), file.filename))\r\n         if not ok then return nil, err end\r\n      else\r\n         local rf, err = zipfile:open(file.filename)\r\n         if not rf then zipfile:close(); return nil, err end\r\n         local contents = rf:read(\"*a\")\r\n         rf:close()\r\n         local wf, err = io.open(dir.path(fs.current_dir(), file.filename), \"wb\")\r\n         if not wf then zipfile:close(); return nil, err end\r\n         wf:write(contents)\r\n         wf:close()\r\n      end\r\n      file = files()\r\n   until not file",
    "type": "statement:repeat"
  }, {
    "id": 207,
    "text": "if file.filename:sub(#file.filename) == \"/\" then\r\n         local ok, err = fs.make_dir(dir.path(fs.current_dir(), file.filename))\r\n         if not ok then return nil, err end\r\n      else\r\n         local rf, err = zipfile:open(file.filename)\r\n         if not rf then zipfile:close(); return nil, err end\r\n         local contents = rf:read(\"*a\")\r\n         rf:close()\r\n         local wf, err = io.open(dir.path(fs.current_dir(), file.filename), \"wb\")\r\n         if not wf then zipfile:close(); return nil, err end\r\n         wf:write(contents)\r\n         wf:close()\r\n      end",
    "type": "statement:if"
  }, {
    "id": 208,
    "text": "local ok, err = fs.make_dir(dir.path(fs.current_dir(), file.filename))",
    "type": "statement:localassign"
  }, {
    "id": 209,
    "text": "local rf, err = zipfile:open(file.filename)",
    "type": "statement:localassign"
  }, {
    "id": 210,
    "text": "if not rf then zipfile:close(); return nil, err end",
    "type": "statement:if"
  }, {
    "id": 211,
    "text": "zipfile:close()",
    "type": "statement:functioncall"
  }, {
    "id": 212,
    "text": "local contents = rf:read(\"*a\")",
    "type": "statement:localassign"
  }, {
    "id": 213,
    "text": "rf:close()",
    "type": "statement:functioncall"
  }, {
    "id": 214,
    "text": "local wf, err = io.open(dir.path(fs.current_dir(), file.filename), \"wb\")",
    "type": "statement:localassign"
  }, {
    "id": 215,
    "text": "if not wf then zipfile:close(); return nil, err end",
    "type": "statement:if"
  }, {
    "id": 216,
    "text": "wf:write(contents)",
    "type": "statement:functioncall"
  }, {
    "id": 217,
    "text": "wf:close()",
    "type": "statement:functioncall"
  }, {
    "id": 218,
    "text": "file = files()",
    "type": "statement:assign"
  }, {
    "id": 219,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 220,
    "text": "local function request(url, method, http, loop_control)\r\n   local result = {}\r\n   \r\n   local proxy = cfg.proxy\r\n   if type(proxy) ~= \"string\" then proxy = nil end\r\n   -- LuaSocket's http.request crashes when given URLs missing the scheme part.\r\n   if proxy and not proxy:find(\"://\") then\r\n      proxy = \"http://\" .. proxy\r\n   end\r\n   \r\n   if cfg.show_downloads then\r\n      io.write(method..\" \"..url..\" ...\\n\")\r\n   end\r\n   local dots = 0\r\n   local res, status, headers, err = http.request {\r\n      url = url,\r\n      proxy = proxy,\r\n      method = method,\r\n      redirect = false,\r\n      sink = ltn12.sink.table(result),\r\n      step = cfg.show_downloads and function(...)\r\n         io.write(\".\")\r\n         io.flush()\r\n         dots = dots + 1\r\n         if dots == 70 then\r\n            io.write(\"\\n\")\r\n            dots = 0\r\n         end\r\n         return ltn12.pump.step(...)\r\n      end,\r\n      headers = {\r\n         [\"user-agent\"] = cfg.user_agent..\" via LuaSocket\"\r\n      },\r\n   }\r\n   if cfg.show_downloads then\r\n      io.write(\"\\n\")\r\n   end\r\n   if not res then\r\n      return nil, status\r\n   elseif status == 301 or status == 302 then\r\n      local location = headers.location\r\n      if location then\r\n         local protocol, rest = dir.split_url(location)\r\n         if redirect_protocols[protocol] then\r\n            if not loop_control then\r\n               loop_control = {}\r\n            elseif loop_control[location] then\r\n               return nil, \"Redirection loop -- broken URL?\"\r\n            end\r\n            loop_control[url] = true\r\n            return request(location, method, redirect_protocols[protocol], loop_control)\r\n         else\r\n            return nil, \"URL redirected to unsupported protocol - install luasec to get HTTPS support.\"\r\n         end\r\n      end\r\n      return nil, err\r\n   elseif status ~= 200 then\r\n      return nil, err\r\n   else\r\n      return result, status, headers, err\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 221,
    "text": "local proxy = cfg.proxy",
    "type": "statement:localassign"
  }, {
    "id": 222,
    "text": "if type(proxy) ~= \"string\" then proxy = nil end",
    "type": "statement:if"
  }, {
    "id": 223,
    "text": "proxy = nil",
    "type": "statement:assign"
  }, {
    "id": 224,
    "text": "if proxy and not proxy:find(\"://\") then\r\n      proxy = \"http://\" .. proxy\r\n   end",
    "type": "statement:if"
  }, {
    "id": 225,
    "text": "proxy = \"http://\" .. proxy",
    "type": "statement:assign"
  }, {
    "id": 226,
    "text": "if cfg.show_downloads then\r\n      io.write(method..\" \"..url..\" ...\\n\")\r\n   end",
    "type": "statement:if"
  }, {
    "id": 227,
    "text": "io.write(method..\" \"..url..\" ...\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 228,
    "text": "local dots = 0",
    "type": "statement:localassign"
  }, {
    "id": 229,
    "text": "local res, status, headers, err = http.request {\r\n      url = url,\r\n      proxy = proxy,\r\n      method = method,\r\n      redirect = false,\r\n      sink = ltn12.sink.table(result),\r\n      step = cfg.show_downloads and function(...)\r\n         io.write(\".\")\r\n         io.flush()\r\n         dots = dots + 1\r\n         if dots == 70 then\r\n            io.write(\"\\n\")\r\n            dots = 0\r\n         end\r\n         return ltn12.pump.step(...)\r\n      end,\r\n      headers = {\r\n         [\"user-agent\"] = cfg.user_agent..\" via LuaSocket\"\r\n      },\r\n   }",
    "type": "statement:localassign"
  }, {
    "id": 230,
    "text": "io.write(\".\")",
    "type": "statement:functioncall"
  }, {
    "id": 231,
    "text": "io.flush()",
    "type": "statement:functioncall"
  }, {
    "id": 232,
    "text": "dots = dots + 1",
    "type": "statement:assign"
  }, {
    "id": 233,
    "text": "if dots == 70 then\r\n            io.write(\"\\n\")\r\n            dots = 0\r\n         end",
    "type": "statement:if"
  }, {
    "id": 234,
    "text": "io.write(\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 235,
    "text": "dots = 0",
    "type": "statement:assign"
  }, {
    "id": 236,
    "text": "if cfg.show_downloads then\r\n      io.write(\"\\n\")\r\n   end",
    "type": "statement:if"
  }, {
    "id": 237,
    "text": "if not res then\r\n      return nil, status\r\n   elseif status == 301 or status == 302 then\r\n      local location = headers.location\r\n      if location then\r\n         local protocol, rest = dir.split_url(location)\r\n         if redirect_protocols[protocol] then\r\n            if not loop_control then\r\n               loop_control = {}\r\n            elseif loop_control[location] then\r\n               return nil, \"Redirection loop -- broken URL?\"\r\n            end\r\n            loop_control[url] = true\r\n            return request(location, method, redirect_protocols[protocol], loop_control)\r\n         else\r\n            return nil, \"URL redirected to unsupported protocol - install luasec to get HTTPS support.\"\r\n         end\r\n      end\r\n      return nil, err\r\n   elseif status ~= 200 then\r\n      return nil, err\r\n   else\r\n      return result, status, headers, err\r\n   end",
    "type": "statement:if"
  }, {
    "id": 238,
    "text": "local location = headers.location",
    "type": "statement:localassign"
  }, {
    "id": 239,
    "text": "if location then\r\n         local protocol, rest = dir.split_url(location)\r\n         if redirect_protocols[protocol] then\r\n            if not loop_control then\r\n               loop_control = {}\r\n            elseif loop_control[location] then\r\n               return nil, \"Redirection loop -- broken URL?\"\r\n            end\r\n            loop_control[url] = true\r\n            return request(location, method, redirect_protocols[protocol], loop_control)\r\n         else\r\n            return nil, \"URL redirected to unsupported protocol - install luasec to get HTTPS support.\"\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 240,
    "text": "local protocol, rest = dir.split_url(location)",
    "type": "statement:localassign"
  }, {
    "id": 241,
    "text": "if redirect_protocols[protocol] then\r\n            if not loop_control then\r\n               loop_control = {}\r\n            elseif loop_control[location] then\r\n               return nil, \"Redirection loop -- broken URL?\"\r\n            end\r\n            loop_control[url] = true\r\n            return request(location, method, redirect_protocols[protocol], loop_control)\r\n         else\r\n            return nil, \"URL redirected to unsupported protocol - install luasec to get HTTPS support.\"\r\n         end",
    "type": "statement:if"
  }, {
    "id": 242,
    "text": "if not loop_control then\r\n               loop_control = {}\r\n            elseif loop_control[location] then\r\n               return nil, \"Redirection loop -- broken URL?\"\r\n            end",
    "type": "statement:if"
  }, {
    "id": 243,
    "text": "loop_control = {}",
    "type": "statement:assign"
  }, {
    "id": 244,
    "text": "loop_control[url] = true",
    "type": "statement:assign"
  }, {
    "id": 245,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 246,
    "text": "local function http_request(url, http, cached)\r\n   if cached then\r\n      local tsfd = io.open(cached..\".timestamp\", \"r\")\r\n      if tsfd then\r\n         local timestamp = tsfd:read(\"*a\")\r\n         tsfd:close()\r\n         local result, status, headers, err = request(url, \"HEAD\", http)\r\n         if status == 200 and headers[\"last-modified\"] == timestamp then\r\n            return true\r\n         end\r\n      end\r\n   end\r\n   local result, status, headers, err = request(url, \"GET\", http)\r\n   if result then\r\n      if cached and headers[\"last-modified\"] then\r\n         local tsfd = io.open(cached..\".timestamp\", \"w\")\r\n         tsfd:write(headers[\"last-modified\"])\r\n         tsfd:close()\r\n      end\r\n      return table.concat(result)\r\n   else\r\n      return nil, status\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 247,
    "text": "if cached then\r\n      local tsfd = io.open(cached..\".timestamp\", \"r\")\r\n      if tsfd then\r\n         local timestamp = tsfd:read(\"*a\")\r\n         tsfd:close()\r\n         local result, status, headers, err = request(url, \"HEAD\", http)\r\n         if status == 200 and headers[\"last-modified\"] == timestamp then\r\n            return true\r\n         end\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 248,
    "text": "local tsfd = io.open(cached..\".timestamp\", \"r\")",
    "type": "statement:localassign"
  }, {
    "id": 249,
    "text": "if tsfd then\r\n         local timestamp = tsfd:read(\"*a\")\r\n         tsfd:close()\r\n         local result, status, headers, err = request(url, \"HEAD\", http)\r\n         if status == 200 and headers[\"last-modified\"] == timestamp then\r\n            return true\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 250,
    "text": "local timestamp = tsfd:read(\"*a\")",
    "type": "statement:localassign"
  }, {
    "id": 251,
    "text": "tsfd:close()",
    "type": "statement:functioncall"
  }, {
    "id": 252,
    "text": "local result, status, headers, err = request(url, \"HEAD\", http)",
    "type": "statement:localassign"
  }, {
    "id": 253,
    "text": "if status == 200 and headers[\"last-modified\"] == timestamp then\r\n            return true\r\n         end",
    "type": "statement:if"
  }, {
    "id": 254,
    "text": "local result, status, headers, err = request(url, \"GET\", http)",
    "type": "statement:localassign"
  }, {
    "id": 255,
    "text": "if result then\r\n      if cached and headers[\"last-modified\"] then\r\n         local tsfd = io.open(cached..\".timestamp\", \"w\")\r\n         tsfd:write(headers[\"last-modified\"])\r\n         tsfd:close()\r\n      end\r\n      return table.concat(result)\r\n   else\r\n      return nil, status\r\n   end",
    "type": "statement:if"
  }, {
    "id": 256,
    "text": "if cached and headers[\"last-modified\"] then\r\n         local tsfd = io.open(cached..\".timestamp\", \"w\")\r\n         tsfd:write(headers[\"last-modified\"])\r\n         tsfd:close()\r\n      end",
    "type": "statement:if"
  }, {
    "id": 257,
    "text": "local tsfd = io.open(cached..\".timestamp\", \"w\")",
    "type": "statement:localassign"
  }, {
    "id": 258,
    "text": "tsfd:write(headers[\"last-modified\"])",
    "type": "statement:functioncall"
  }, {
    "id": 259,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 260,
    "text": "function download(url, filename, cache)\r\n   assert(type(url) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n\r\n   filename = fs.absolute_name(filename or dir.base_name(url))\r\n   \r\n   local content, err\r\n   if util.starts_with(url, \"http:\") then\r\n      content, err = http_request(url, http, cache and filename)\r\n   elseif util.starts_with(url, \"ftp:\") then\r\n      content, err = ftp.get(url)\r\n   elseif util.starts_with(url, \"https:\") then\r\n      if luasec_ok then\r\n         content, err = http_request(url, https, cache and filename)\r\n      else\r\n         err = \"Unsupported protocol - install luasec to get HTTPS support.\"\r\n      end\r\n   else\r\n      err = \"Unsupported protocol\"\r\n   end\r\n   if cache and content == true then\r\n      return true, filename\r\n   end\r\n   if not content then\r\n      return false, tostring(err)\r\n   end\r\n   local file = io.open(filename, \"wb\")\r\n   if not file then return false end\r\n   file:write(content)\r\n   file:close()\r\n   return true, filename\r\nend",
    "type": "function"
  }, {
    "id": 261,
    "text": "assert(type(url) == \"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 262,
    "text": "assert(type(filename) == \"string\" or not filename)",
    "type": "statement:functioncall"
  }, {
    "id": 263,
    "text": "filename = fs.absolute_name(filename or dir.base_name(url))",
    "type": "statement:assign"
  }, {
    "id": 264,
    "text": "local content, err",
    "type": "statement:localassign"
  }, {
    "id": 265,
    "text": "if util.starts_with(url, \"http:\") then\r\n      content, err = http_request(url, http, cache and filename)\r\n   elseif util.starts_with(url, \"ftp:\") then\r\n      content, err = ftp.get(url)\r\n   elseif util.starts_with(url, \"https:\") then\r\n      if luasec_ok then\r\n         content, err = http_request(url, https, cache and filename)\r\n      else\r\n         err = \"Unsupported protocol - install luasec to get HTTPS support.\"\r\n      end\r\n   else\r\n      err = \"Unsupported protocol\"\r\n   end",
    "type": "statement:if"
  }, {
    "id": 266,
    "text": "content, err = http_request(url, http, cache and filename)",
    "type": "statement:assign"
  }, {
    "id": 267,
    "text": "content, err = ftp.get(url)",
    "type": "statement:assign"
  }, {
    "id": 268,
    "text": "if luasec_ok then\r\n         content, err = http_request(url, https, cache and filename)\r\n      else\r\n         err = \"Unsupported protocol - install luasec to get HTTPS support.\"\r\n      end",
    "type": "statement:if"
  }, {
    "id": 269,
    "text": "content, err = http_request(url, https, cache and filename)",
    "type": "statement:assign"
  }, {
    "id": 270,
    "text": "err = \"Unsupported protocol - install luasec to get HTTPS support.\"",
    "type": "statement:assign"
  }, {
    "id": 271,
    "text": "err = \"Unsupported protocol\"",
    "type": "statement:assign"
  }, {
    "id": 272,
    "text": "if cache and content == true then\r\n      return true, filename\r\n   end",
    "type": "statement:if"
  }, {
    "id": 273,
    "text": "if not content then\r\n      return false, tostring(err)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 274,
    "text": "local file = io.open(filename, \"wb\")",
    "type": "statement:localassign"
  }, {
    "id": 275,
    "text": "if not file then return false end",
    "type": "statement:if"
  }, {
    "id": 276,
    "text": "file:write(content)",
    "type": "statement:functioncall"
  }, {
    "id": 277,
    "text": "file:close()",
    "type": "statement:functioncall"
  }, {
    "id": 278,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 279,
    "text": "function get_md5(file)\r\n   file = fs.absolute_name(file)\r\n   local file = io.open(file, \"rb\")\r\n   if not file then return nil, \"Failed to open file for reading: \"..file end\r\n   local computed = md5.sumhexa(file:read(\"*a\"))\r\n   file:close()\r\n   if computed then return computed end\r\n   return nil, \"Failed to compute MD5 hash for file \"..file\r\nend",
    "type": "function"
  }, {
    "id": 280,
    "text": "file = fs.absolute_name(file)",
    "type": "statement:assign"
  }, {
    "id": 281,
    "text": "local file = io.open(file, \"rb\")",
    "type": "statement:localassign"
  }, {
    "id": 282,
    "text": "if not file then return nil, \"Failed to open file for reading: \"..file end",
    "type": "statement:if"
  }, {
    "id": 283,
    "text": "local computed = md5.sumhexa(file:read(\"*a\"))",
    "type": "statement:localassign"
  }, {
    "id": 284,
    "text": "if computed then return computed end",
    "type": "statement:if"
  }, {
    "id": 285,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 286,
    "text": "function chmod(file, mode)\r\n   -- LuaPosix (as of 5.1.15) does not support octal notation...\r\n   if mode:sub(1,1) == \"0\" then\r\n      local new_mode = {}\r\n      for c in mode:sub(2):gmatch(\".\") do\r\n         table.insert(new_mode, octal_to_rwx[c])\r\n      end\r\n      mode = table.concat(new_mode)\r\n   end\r\n   local err = posix.chmod(file, mode)\r\n   return err == 0\r\nend",
    "type": "function"
  }, {
    "id": 287,
    "text": "if mode:sub(1,1) == \"0\" then\r\n      local new_mode = {}\r\n      for c in mode:sub(2):gmatch(\".\") do\r\n         table.insert(new_mode, octal_to_rwx[c])\r\n      end\r\n      mode = table.concat(new_mode)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 288,
    "text": "local new_mode = {}",
    "type": "statement:localassign"
  }, {
    "id": 289,
    "text": "for c in mode:sub(2):gmatch(\".\") do\r\n         table.insert(new_mode, octal_to_rwx[c])\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 290,
    "text": "table.insert(new_mode, octal_to_rwx[c])",
    "type": "statement:functioncall"
  }, {
    "id": 291,
    "text": "mode = table.concat(new_mode)",
    "type": "statement:assign"
  }, {
    "id": 292,
    "text": "local err = posix.chmod(file, mode)",
    "type": "statement:localassign"
  }, {
    "id": 293,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 294,
    "text": "function get_permissions(file)\r\n   return posix.stat(file, \"mode\")\r\nend",
    "type": "function"
  }, {
    "id": 295,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 296,
    "text": "function apply_patch(patchname, patchdata)\r\n   local p, all_ok = patch.read_patch(patchname, patchdata)\r\n   if not all_ok then\r\n      return nil, \"Failed reading patch \"..patchname\r\n   end\r\n   if p then\r\n      return patch.apply_patch(p, 1)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 297,
    "text": "local p, all_ok = patch.read_patch(patchname, patchdata)",
    "type": "statement:localassign"
  }, {
    "id": 298,
    "text": "if not all_ok then\r\n      return nil, \"Failed reading patch \"..patchname\r\n   end",
    "type": "statement:if"
  }, {
    "id": 299,
    "text": "if p then\r\n      return patch.apply_patch(p, 1)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 300,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 301,
    "text": "function move(src, dest)\r\n   assert(src and dest)\r\n   if fs.exists(dest) and not fs.is_dir(dest) then\r\n      return false, \"File already exists: \"..dest\r\n   end\r\n   local ok, err = fs.copy(src, dest)\r\n   if not ok then\r\n      return false, err\r\n   end\r\n   fs.delete(src)\r\n   if fs.exists(src) then\r\n      return false, \"Failed move: could not delete \"..src..\" after copy.\"\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 302,
    "text": "if fs.exists(dest) and not fs.is_dir(dest) then\r\n      return false, \"File already exists: \"..dest\r\n   end",
    "type": "statement:if"
  }, {
    "id": 303,
    "text": "local ok, err = fs.copy(src, dest)",
    "type": "statement:localassign"
  }, {
    "id": 304,
    "text": "if not ok then\r\n      return false, err\r\n   end",
    "type": "statement:if"
  }, {
    "id": 305,
    "text": "fs.delete(src)",
    "type": "statement:functioncall"
  }, {
    "id": 306,
    "text": "if fs.exists(src) then\r\n      return false, \"Failed move: could not delete \"..src..\" after copy.\"\r\n   end",
    "type": "statement:if"
  }, {
    "id": 307,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 308,
    "text": "function check_command_permissions(flags)\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   local ok = true\r\n   local err = \"\"\r\n   for _, dir in ipairs { cfg.rocks_dir, root_dir } do\r\n      if fs.exists(dir) and not fs.is_writable(dir) then\r\n         ok = false\r\n         err = \"Your user does not have write permissions in \" .. dir\r\n         break\r\n      end\r\n   end\r\n   local root_parent = dir.dir_name(root_dir)\r\n   if ok and not fs.exists(root_dir) and not fs.is_writable(root_parent) then\r\n      ok = false\r\n      err = root_dir..\" does not exist and your user does not have write permissions in \" .. root_parent\r\n   end\r\n   if ok then\r\n      return true\r\n   else\r\n      if flags[\"local\"] then\r\n         err = err .. \" \\n-- please check your permissions.\"\r\n      else\r\n         err = err .. \" \\n-- you may want to run as a privileged user or use your local tree with --local.\"\r\n      end\r\n      return nil, err\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 309,
    "text": "local root_dir = path.root_dir(cfg.rocks_dir)",
    "type": "statement:localassign"
  }, {
    "id": 310,
    "text": "local ok = true",
    "type": "statement:localassign"
  }, {
    "id": 311,
    "text": "local err = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 312,
    "text": "for _, dir in ipairs { cfg.rocks_dir, root_dir } do\r\n      if fs.exists(dir) and not fs.is_writable(dir) then\r\n         ok = false\r\n         err = \"Your user does not have write permissions in \" .. dir\r\n         break\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 313,
    "text": "if fs.exists(dir) and not fs.is_writable(dir) then\r\n         ok = false\r\n         err = \"Your user does not have write permissions in \" .. dir\r\n         break\r\n      end",
    "type": "statement:if"
  }, {
    "id": 314,
    "text": "ok = false",
    "type": "statement:assign"
  }, {
    "id": 315,
    "text": "err = \"Your user does not have write permissions in \" .. dir",
    "type": "statement:assign"
  }, {
    "id": 316,
    "text": "local root_parent = dir.dir_name(root_dir)",
    "type": "statement:localassign"
  }, {
    "id": 317,
    "text": "if ok and not fs.exists(root_dir) and not fs.is_writable(root_parent) then\r\n      ok = false\r\n      err = root_dir..\" does not exist and your user does not have write permissions in \" .. root_parent\r\n   end",
    "type": "statement:if"
  }, {
    "id": 318,
    "text": "err = root_dir..\" does not exist and your user does not have write permissions in \" .. root_parent",
    "type": "statement:assign"
  }, {
    "id": 319,
    "text": "if ok then\r\n      return true\r\n   else\r\n      if flags[\"local\"] then\r\n         err = err .. \" \\n-- please check your permissions.\"\r\n      else\r\n         err = err .. \" \\n-- you may want to run as a privileged user or use your local tree with --local.\"\r\n      end\r\n      return nil, err\r\n   end",
    "type": "statement:if"
  }, {
    "id": 320,
    "text": "if flags[\"local\"] then\r\n         err = err .. \" \\n-- please check your permissions.\"\r\n      else\r\n         err = err .. \" \\n-- you may want to run as a privileged user or use your local tree with --local.\"\r\n      end",
    "type": "statement:if"
  }, {
    "id": 321,
    "text": "err = err .. \" \\n-- please check your permissions.\"",
    "type": "statement:assign"
  }, {
    "id": 322,
    "text": "err = err .. \" \\n-- you may want to run as a privileged user or use your local tree with --local.\"",
    "type": "statement:assign"
  }, {
    "id": 323,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 324,
    "text": "function()\r\n      for file in lfs.dir(name) do\r\n         if file ~= \".\" and file ~= \"..\" then\r\n            local ok, err = recursive_delete(dir.path(name, file))\r\n            if not ok then return nil, err end\r\n         end\r\n      end\r\n      local ok, err = lfs.rmdir(name)\r\n      return ok, (not ok) and err\r\n   end",
    "type": "function"
  }, {
    "id": 325,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 326,
    "text": "function(...)\r\n         io.write(\".\")\r\n         io.flush()\r\n         dots = dots + 1\r\n         if dots == 70 then\r\n            io.write(\"\\n\")\r\n            dots = 0\r\n         end\r\n         return ltn12.pump.step(...)\r\n      end",
    "type": "function"
  }, {
    "id": 327,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 328,
    "text": "",
    "type": "function container"
  }, {
    "id": 329,
    "text": "local function command_at(directory, cmd)\r\n   return \"cd \" .. fs.Q(directory) .. \" && \" .. cmd\r\nend",
    "type": "function"
  }, {
    "id": 330,
    "text": "function execute_string(cmd)\r\n   local code = os.execute(command_at(fs.current_dir(), cmd))\r\n   if code == 0 or code == true then\r\n      return true\r\n   else\r\n      return false\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 331,
    "text": "function change_dir(directory)\r\n   assert(type(directory) == \"string\")\r\n   if fs.is_dir(directory) then\r\n      table.insert(dir_stack, directory)\r\n      return true\r\n   end\r\n   return nil, \"directory not found: \"..directory\r\nend",
    "type": "function"
  }, {
    "id": 332,
    "text": "function make_dir(directory)\r\n   assert(directory)\r\n   local ok, err = fs.execute(vars.MKDIR..\" -p\", directory)\r\n   if not ok then\r\n      err = \"failed making directory \"..directory\r\n   end\r\n   return ok, err\r\nend",
    "type": "function"
  }, {
    "id": 333,
    "text": "function remove_dir_if_empty(directory)\r\n   assert(directory)\r\n   fs.execute_quiet(vars.RMDIR, directory)\r\nend",
    "type": "function"
  }, {
    "id": 334,
    "text": "function remove_dir_tree_if_empty(directory)\r\n   assert(directory)\r\n   fs.execute_quiet(vars.RMDIR, \"-p\", directory)\r\nend",
    "type": "function"
  }, {
    "id": 335,
    "text": "function copy(src, dest, perm)\r\n   assert(src and dest)\r\n   if fs.execute(vars.CP, src, dest) then\r\n      if perm then\r\n         if fs.is_dir(dest) then\r\n            dest = dir.path(dest, dir.base_name(src))\r\n         end\r\n         if fs.chmod(dest, perm) then\r\n            return true\r\n         else\r\n            return false, \"Failed setting permissions of \"..dest\r\n         end\r\n      end\r\n      return true\r\n   else\r\n      return false, \"Failed copying \"..src..\" to \"..dest\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 336,
    "text": "function copy_contents(src, dest)\r\n   assert(src and dest)\r\n   if fs.execute_quiet(vars.CP..\" -pPR \"..fs.Q(src)..\"/* \"..fs.Q(dest)) then\r\n      return true\r\n   else\r\n      return false, \"Failed copying \"..src..\" to \"..dest\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 337,
    "text": "function delete(arg)\r\n   assert(arg)\r\n   assert(arg:sub(1,1) == \"/\")\r\n   fs.execute_quiet(vars.RM, \"-rf\", arg)\r\nend",
    "type": "function"
  }, {
    "id": 338,
    "text": "function list_dir(at)\r\n   assert(type(at) == \"string\" or not at)\r\n   if not at then\r\n      at = fs.current_dir()\r\n   end\r\n   if not fs.is_dir(at) then\r\n      return {}\r\n   end\r\n   local result = {}\r\n   local pipe = io.popen(command_at(at, vars.LS))\r\n   for file in pipe:lines() do\r\n      table.insert(result, file)\r\n   end\r\n   pipe:close()\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 339,
    "text": "function find(at)\r\n   assert(type(at) == \"string\" or not at)\r\n   if not at then\r\n      at = fs.current_dir()\r\n   end\r\n   if not fs.is_dir(at) then\r\n      return {}\r\n   end\r\n   local result = {}\r\n   local pipe = io.popen(command_at(at, vars.FIND..\" * 2>/dev/null\"))\r\n   for file in pipe:lines() do\r\n      table.insert(result, file)\r\n   end\r\n   pipe:close()\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 340,
    "text": "function zip(zipfile, ...)\r\n   return fs.execute(vars.ZIP..\" -r\", zipfile, ...)\r\nend",
    "type": "function"
  }, {
    "id": 341,
    "text": "function unzip(zipfile)\r\n   assert(zipfile)\r\n   return fs.execute_quiet(vars.UNZIP, zipfile)\r\nend",
    "type": "function"
  }, {
    "id": 342,
    "text": "function exists(file)\r\n   assert(file)\r\n   return fs.execute(vars.TEST, \"-e\", file)\r\nend",
    "type": "function"
  }, {
    "id": 343,
    "text": "function is_dir(file)\r\n   assert(file)\r\n   return fs.execute(vars.TEST, \"-d\", file)\r\nend",
    "type": "function"
  }, {
    "id": 344,
    "text": "function is_file(file)\r\n   assert(file)\r\n   return fs.execute(vars.TEST, \"-f\", file)\r\nend",
    "type": "function"
  }, {
    "id": 345,
    "text": "function download(url, filename, cache)\r\n   assert(type(url) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n\r\n   filename = fs.absolute_name(filename or dir.base_name(url))\r\n\r\n   local ok\r\n   if cfg.downloader == \"wget\" then\r\n      local wget_cmd = vars.WGET..\" --no-check-certificate --no-cache --user-agent='\"..cfg.user_agent..\" via wget' --quiet \"\r\n      if cache then\r\n         -- --timestamping is incompatible with --output-document,\r\n         -- but that's not a problem for our use cases.\r\n         fs.change_dir(dir.dir_name(filename))\r\n         ok = fs.execute(wget_cmd..\" --timestamping \", url)\r\n         fs.pop_dir()\r\n      elseif filename then\r\n         ok = fs.execute(wget_cmd..\" --output-document \"..fs.Q(filename), url)\r\n      else\r\n         ok = fs.execute(wget_cmd, url)\r\n      end\r\n   elseif cfg.downloader == \"curl\" then\r\n      ok = fs.execute_string(vars.CURL..\" -L --user-agent '\"..cfg.user_agent..\" via curl' \"..fs.Q(url)..\" 2> /dev/null 1> \"..fs.Q(filename))\r\n   end\r\n   if ok then\r\n      return true, filename\r\n   else\r\n      return false\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 346,
    "text": "function chmod(pathname, mode)\r\n   if mode then \r\n      return fs.execute(vars.CHMOD, mode, pathname)\r\n   else\r\n      return false\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 347,
    "text": "function apply_patch(patchname)\r\n   return fs.execute(vars.PATCH..\" -p1 -f -i \", patchname)\r\nend",
    "type": "function"
  }, {
    "id": 348,
    "text": "function unpack_archive(archive)\r\n   assert(type(archive) == \"string\")\r\n\r\n   local ok\r\n   if archive:match(\"%.tar%.gz$\") or archive:match(\"%.tgz$\") then\r\n         ok = fs.execute_string(vars.GUNZIP..\" -c \"..archive..\"|\"..vars.TAR..\" -xf -\")\r\n   elseif archive:match(\"%.tar%.bz2$\") then\r\n         ok = fs.execute_string(vars.BUNZIP2..\" -c \"..archive..\"|tar -xf -\")\r\n   elseif archive:match(\"%.zip$\") then\r\n      ok = fs.execute(vars.UNZIP, archive)\r\n   elseif archive:match(\"%.lua$\") or archive:match(\"%.c$\") then\r\n      -- Ignore .lua and .c files; they don't need to be extracted.\r\n      return true\r\n   else\r\n      local ext = archive:match(\".*(%..*)\")\r\n      return false, \"Unrecognized filename extension \"..(ext or \"\")\r\n   end\r\n   if not ok then\r\n      return false, \"Failed extracting \"..archive\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 349,
    "text": "function get_permissions(filename)\r\n   local pipe = io.popen(vars.STAT..\" \"..vars.STATFLAG..\" \"..fs.Q(filename))\r\n   local ret = pipe:read(\"*l\")\r\n   pipe:close()\r\n   return ret\r\nend",
    "type": "function"
  }, {
    "id": 350,
    "text": "function browser(url)\r\n   return fs.execute(cfg.web_browser, url)\r\nend",
    "type": "function"
  }, {
    "id": 351,
    "text": "",
    "type": "function container"
  }, {
    "id": 352,
    "text": "function absolute_name(pathname, relative_to)\r\n   assert(type(pathname) == \"string\")\r\n   assert(type(relative_to) == \"string\" or not relative_to)\r\n\r\n   relative_to = relative_to or fs.current_dir()\r\n   if pathname:sub(1,1) == \"/\" then\r\n      return pathname\r\n   else\r\n      return relative_to .. \"/\" .. pathname\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 353,
    "text": "function wrap_script(file, dest, name, version)\r\n   assert(type(file) == \"string\")\r\n   assert(type(dest) == \"string\")\r\n   \r\n   local base = dir.base_name(file)\r\n   local wrapname = fs.is_dir(dest) and dest..\"/\"..base or dest\r\n   local lpath, lcpath = cfg.package_paths()\r\n   local wrapper = io.open(wrapname, \"w\")\r\n   if not wrapper then\r\n      return nil, \"Could not open \"..wrapname..\" for writing.\"\r\n   end\r\n   wrapper:write(\"#!/bin/sh\\n\\n\")\r\n   local lua = dir.path(cfg.variables[\"LUA_BINDIR\"], cfg.lua_interpreter)\r\n   local ppaths = \"package.path=\"..util.LQ(lpath..\";\")..\"..package.path; package.cpath=\"..util.LQ(lcpath..\";\")..\"..package.cpath\"\r\n   local addctx = \"local k,l,_=pcall(require,\"..util.LQ(\"luarocks.loader\")..\") _=k and l.add_context(\"..util.LQ(name)..\",\"..util.LQ(version)..\")\"\r\n   wrapper:write('exec '..fs.Q(lua)..' -e '..fs.Q(ppaths)..' -e '..fs.Q(addctx)..' '..fs.Q(file)..' \"$@\"\\n')\r\n   wrapper:close()\r\n   if fs.chmod(wrapname, \"0755\") then\r\n      return true\r\n   else\r\n      return nil, \"Could not make \"..wrapname..\" executable.\"\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 354,
    "text": "function copy_binary(filename, dest) \r\n   return fs.copy(filename, dest, \"0755\")\r\nend",
    "type": "function"
  }, {
    "id": 355,
    "text": "local function command_at(directory, cmd)\r\n   local drive = directory:match(\"^([A-Za-z]:)\")\r\n   cmd = \"cd \" .. fs.Q(directory) .. \" & \" .. cmd\r\n   if drive then\r\n      cmd = drive .. \" & \" .. cmd\r\n   end\r\n   return cmd\r\nend",
    "type": "function"
  }, {
    "id": 356,
    "text": "function current_dir()\r\n   local current = cfg.cache_pwd\r\n   if not current then\r\n      local pipe = io.popen(fs.Q(vars.PWD))\r\n      current = pipe:read(\"*l\")\r\n      pipe:close()\r\n      cfg.cache_pwd = current\r\n   end\r\n   for _, directory in ipairs(dir_stack) do\r\n      current = fs.absolute_name(directory, current)\r\n   end\r\n   return current\r\nend",
    "type": "function"
  }, {
    "id": 357,
    "text": "function execute_string(cmd)\r\n   cmd = command_at(fs.current_dir(), cmd)\r\n   local code = os.execute(cmd)\r\n   if code == 0 or code == true then\r\n      return true\r\n   else\r\n      return false\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 358,
    "text": "function change_dir(directory)\r\n   assert(type(directory) == \"string\")\r\n   if fs.is_dir(directory) then\r\n      table.insert(dir_stack, directory)\r\n      return true\r\n   end\r\n   return nil, \"directory not found: \"..directory\r\nend",
    "type": "function"
  }, {
    "id": 359,
    "text": "function make_dir(directory)\r\n   assert(directory)\r\n   directory = dir.normalize(directory)\r\n   fs.execute_quiet(fs.Q(vars.MKDIR)..\" -p \", directory)\r\n   if not fs.is_dir(directory) then\r\n      return false, \"failed making directory \"..directory\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 360,
    "text": "function remove_dir_if_empty(directory)\r\n   assert(directory)\r\n   fs.execute_quiet(fs.Q(vars.RMDIR), directory)\r\nend",
    "type": "function"
  }, {
    "id": 361,
    "text": "function remove_dir_tree_if_empty(directory)\r\n   assert(directory)\r\n   fs.execute_quiet(fs.Q(vars.RMDIR), directory)\r\nend",
    "type": "function"
  }, {
    "id": 362,
    "text": "function copy(src, dest)\r\n   assert(src and dest)\r\n   if dest:match(\"[/\\\\]$\") then dest = dest:sub(1, -2) end\r\n   local ok = fs.execute(fs.Q(vars.CP), src, dest)\r\n   if ok then\r\n      return true\r\n   else\r\n      return false, \"Failed copying \"..src..\" to \"..dest\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 363,
    "text": "function copy_contents(src, dest)\r\n   assert(src and dest)\r\n   if fs.execute_quiet(fs.Q(vars.CP)..\" -dR \"..src..\"\\\\*.* \"..fs.Q(dest)) then\r\n      return true\r\n   else\r\n      return false, \"Failed copying \"..src..\" to \"..dest\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 364,
    "text": "function delete(arg)\r\n   assert(arg)\r\n   assert(arg:match(\"^[a-zA-Z]?:?[\\\\/]\"))\r\n   fs.execute_quiet(\"if exist \"..fs.Q(arg..\"\\\\\")..\" ( RMDIR /S /Q \"..fs.Q(arg)..\" ) else ( DEL /Q /F \"..fs.Q(arg)..\" )\")\r\nend",
    "type": "function"
  }, {
    "id": 365,
    "text": "function list_dir(at)\r\n   assert(type(at) == \"string\" or not at)\r\n   if not at then\r\n      at = fs.current_dir()\r\n   end\r\n   if not fs.is_dir(at) then\r\n      return {}\r\n   end\r\n   local result = {}\r\n   local pipe = io.popen(command_at(at, fs.Q(vars.LS)))\r\n   for file in pipe:lines() do\r\n      table.insert(result, file)\r\n   end\r\n   pipe:close()\r\n\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 366,
    "text": "function find(at)\r\n   assert(type(at) == \"string\" or not at)\r\n   if not at then\r\n      at = fs.current_dir()\r\n   end\r\n   if not fs.is_dir(at) then\r\n      return {}\r\n   end\r\n   local result = {}\r\n   local pipe = io.popen(command_at(at, fs.Q(vars.FIND)..\" 2> NUL\"))\r\n   for file in pipe:lines() do\r\n      -- Windows find is a bit different\r\n      local first_two = file:sub(1,2)\r\n      if first_two == \".\\\\\" or first_two == \"./\" then file=file:sub(3) end\r\n      if file ~= \".\" then\r\n         table.insert(result, (file:gsub(\"\\\\\", \"/\")))\r\n      end\r\n   end\r\n   pipe:close()\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 367,
    "text": "function zip(zipfile, ...)\r\n   return fs.execute_quiet(fs.Q(vars.SEVENZ)..\" -aoa a -tzip\", zipfile, ...)\r\nend",
    "type": "function"
  }, {
    "id": 368,
    "text": "function unzip(zipfile)\r\n   assert(zipfile)\r\n   return fs.execute_quiet(fs.Q(vars.SEVENZ)..\" -aoa x\", zipfile)\r\nend",
    "type": "function"
  }, {
    "id": 369,
    "text": "function is_dir(file)\r\n   assert(file)\r\n   return fs.execute_quiet(\"if not exist \" .. fs.Q(file..\"\\\\\")..\" invalidcommandname\")\r\nend",
    "type": "function"
  }, {
    "id": 370,
    "text": "function is_file(file)\r\n   assert(file)\r\n   return fs.execute(fs.Q(vars.TEST)..\" -f\", file)\r\nend",
    "type": "function"
  }, {
    "id": 371,
    "text": "function download(url, filename, cache)\r\n   assert(type(url) == \"string\")\r\n   assert(type(filename) == \"string\" or not filename)\r\n\r\n   filename = fs.absolute_name(filename or dir.base_name(url))\r\n\r\n   local ok   \r\n   if cfg.downloader == \"wget\" then\r\n      local wget_cmd = fs.Q(vars.WGET)..\" --no-check-certificate --no-cache --user-agent=\\\"\"..cfg.user_agent..\" via wget\\\" --quiet \"\r\n      if cache then\r\n         -- --timestamping is incompatible with --output-document,\r\n         -- but that's not a problem for our use cases.\r\n         fs.change_dir(dir.dir_name(filename))\r\n         ok = fs.execute(wget_cmd..\" --timestamping \"..fs.Q(url)..\" 2> NUL 1> NUL\")\r\n         fs.pop_dir()\r\n      elseif filename then\r\n         ok = fs.execute(wget_cmd..\" --output-document \"..fs.Q(filename)..\" \"..fs.Q(url)..\" 2> NUL 1> NUL\")\r\n      else\r\n         ok = fs.execute(wget_cmd..fs.Q(url)..\" 2> NUL 1> NUL\")\r\n      end\r\n   elseif cfg.downloader == \"curl\" then\r\n      ok = fs.execute_string(fs.Q(vars.CURL)..\" -L --user-agent \\\"\"..cfg.user_agent..\" via curl\\\" \"..fs.Q(url)..\" 2> NUL 1> \"..fs.Q(filename))\r\n   end\r\n   if ok then\r\n      return true, filename\r\n   else\r\n      return false\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 372,
    "text": "local function gunzip(archive)\r\n  return fs.execute_quiet(fs.Q(vars.SEVENZ)..\" -aoa x\", archive)\r\nend",
    "type": "function"
  }, {
    "id": 373,
    "text": "function unpack_archive(archive)\r\n   assert(type(archive) == \"string\")\r\n\r\n   local ok\r\n   local sevenzx = fs.Q(vars.SEVENZ)..\" -aoa x\"\r\n   if archive:match(\"%.tar%.gz$\") then\r\n      ok = gunzip(archive)\r\n      if ok then\r\n         ok = fs.execute_quiet(sevenzx, strip_extension(archive))\r\n      end\r\n   elseif archive:match(\"%.tgz$\") then\r\n      ok = gunzip(archive)\r\n      if ok then\r\n         ok = fs.execute_quiet(sevenzx, strip_extension(archive)..\".tar\")\r\n      end\r\n   elseif archive:match(\"%.tar%.bz2$\") then\r\n      ok = fs.execute_quiet(sevenzx, archive)\r\n      if ok then\r\n         ok = fs.execute_quiet(sevenzx, strip_extension(archive))\r\n      end\r\n   elseif archive:match(\"%.zip$\") then\r\n      ok = fs.execute_quiet(sevenzx, archive)\r\n   elseif archive:match(\"%.lua$\") or archive:match(\"%.c$\") then\r\n      -- Ignore .lua and .c files; they don't need to be extracted.\r\n      return true\r\n   else\r\n      local ext = archive:match(\".*(%..*)\")\r\n      return false, \"Unrecognized filename extension \"..(ext or \"\")\r\n   end\r\n   if not ok then\r\n      return false, \"Failed extracting \"..archive\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 374,
    "text": "function get_md5(file)\r\n   local cmd = md5_cmd[cfg.md5checker]\r\n   if not cmd then return nil, \"no MD5 checker command configured\" end\r\n   local pipe = io.popen(cmd..\" \"..fs.Q(fs.absolute_name(file)))\r\n   local computed = pipe:read(\"*a\")\r\n   pipe:close()\r\n   if computed then\r\n      computed = computed:match(\"(\"..(\"%x\"):rep(32)..\")\")\r\n   end\r\n   if computed then return computed end\r\n   return nil, \"Failed to compute MD5 hash for file \"..tostring(fs.absolute_name(file))\r\nend",
    "type": "function"
  }, {
    "id": 375,
    "text": "function exists(file)\r\n   assert(file)\r\n   return fs.execute_quiet(\"if not exist \" .. fs.Q(file) .. \" invalidcommandname\")\r\nend",
    "type": "function"
  }, {
    "id": 376,
    "text": "function browser(url)\r\n   return fs.execute(cfg.web_browser..\" \"..url)\r\nend",
    "type": "function"
  }, {
    "id": 377,
    "text": "function absolute_name(pathname, relative_to)\r\n   assert(type(pathname) == \"string\")\r\n   assert(type(relative_to) == \"string\" or not relative_to)\r\n\r\n   relative_to = relative_to or fs.current_dir()\r\n   -- FIXME I'm not sure this first \\\\ should be there at all.\r\n   -- What are the Windows rules for drive letters?\r\n   if pathname:match(\"^[\\\\.a-zA-Z]?:?[\\\\/]\") then\r\n      return pathname\r\n   else\r\n      return relative_to .. \"/\" .. pathname\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 378,
    "text": "function wrap_script(file, dest, name, version)\r\n   assert(type(file) == \"string\")\r\n   assert(type(dest) == \"string\")\r\n\r\n   local base = dir.base_name(file)\r\n   local wrapname = fs.is_dir(dest) and dest..\"/\"..base or dest\r\n   wrapname = wrapname..\".bat\"\r\n   local lpath, lcpath = cfg.package_paths()\r\n   local wrapper = io.open(wrapname, \"w\")\r\n   if not wrapper then\r\n      return nil, \"Could not open \"..wrapname..\" for writing.\"\r\n   end\r\n   wrapper:write(\"@echo off\\n\")\r\n   local lua = dir.path(cfg.variables[\"LUA_BINDIR\"], cfg.lua_interpreter)\r\n   local ppaths = \"package.path=\"..util.LQ(lpath..\";\")..\"..package.path; package.cpath=\"..util.LQ(lcpath..\";\")..\"..package.cpath\"\r\n   local addctx = \"local k,l,_=pcall(require,\"..util.LQ(\"luarocks.loader\")..\") _=k and l.add_context(\"..util.LQ(name)..\",\"..util.LQ(version)..\")\"\r\n   wrapper:write(fs.Qb(lua)..' -e '..fs.Qb(ppaths)..' -e '..fs.Qb(addctx)..' '..fs.Qb(file)..' %*\\n')\r\n   wrapper:close()\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 379,
    "text": "function copy_binary(filename, dest) \r\n   local ok, err = fs.copy(filename, dest)\r\n   if not ok then\r\n      return nil, err\r\n   end\r\n   local exe_pattern = \"%.[Ee][Xx][Ee]$\"\r\n   local base = dir.base_name(filename)\r\n   local dest = dir.dir_name(dest)\r\n   if base:match(exe_pattern) then\r\n      base = base:gsub(exe_pattern, \".lua\")\r\n      local helpname = dest..\"/\"..base\r\n      local helper = io.open(helpname, \"w\")\r\n      if not helper then\r\n         return nil, \"Could not open \"..helpname..\" for writing.\"\r\n      end\r\n      helper:write('package.path=\\\"'..package.path:gsub(\"\\\\\",\"\\\\\\\\\")..';\\\"..package.path\\n')\r\n      helper:write('package.cpath=\\\"'..package.path:gsub(\"\\\\\",\"\\\\\\\\\")..';\\\"..package.cpath\\n')\r\n      helper:close()\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 380,
    "text": "function is_writable(file)\r\n   assert(file)\r\n   file = dir.normalize(file)\r\n   local result\r\n   local tmpname = 'tmpluarockstestwritable.deleteme'\r\n   if fs.is_dir(file) then\r\n      local file2 = dir.path(file, tmpname)\r\n      local fh = io.open(file2, 'wb')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n      if result then\r\n         -- the above test might give a false positive when writing to\r\n         -- c:\\program files\\ because of VirtualStore redirection on Vista and up\r\n         -- So check whether it's really there\r\n         result = fs.exists(file2)\r\n      end\r\n      os.remove(file2)\r\n   else\r\n      local fh = io.open(file, 'r+b')\r\n      result = fh ~= nil\r\n      if fh then fh:close() end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 381,
    "text": "function make_index(repo)\r\n   if not fs.is_dir(repo) then\r\n      return nil, \"Cannot access repository at \"..repo\r\n   end\r\n   local manifest = manif.load_manifest(repo)\r\n   local out = io.open(dir.path(repo, \"index.html\"), \"w\")\r\n   \r\n   out:write(index_header)\r\n   for package, version_list in util.sortedpairs(manifest.repository) do\r\n      local latest_rockspec = nil\r\n      local output = index_package_begin\r\n      for version, data in util.sortedpairs(version_list, deps.compare_versions) do\r\n         local versions = {}\r\n         output = output..version..':&nbsp;'\r\n         table.sort(data, function(a,b) return a.arch < b.arch end)\r\n         for _, item in ipairs(data) do\r\n            local file\r\n            if item.arch == 'rockspec' then\r\n               file = (\"%s-%s.rockspec\"):format(package, version)\r\n               if not latest_rockspec then latest_rockspec = file end\r\n            else\r\n               file = (\"%s-%s.%s.rock\"):format(package, version, item.arch)\r\n            end\r\n            table.insert(versions, '<a href=\"'..file..'\">'..item.arch..'</a>')\r\n         end\r\n         output = output .. table.concat(versions, ',&nbsp;') .. '<br/>'\r\n      end\r\n      output = output .. index_package_end\r\n      if latest_rockspec then\r\n         local rockspec = persist.load_into_table(dir.path(repo, latest_rockspec))\r\n         local descript = rockspec.description or {}\r\n         local vars = {\r\n            anchor = package,\r\n            package = rockspec.package,\r\n            original = rockspec.source.url,\r\n            summary = descript.summary or \"\",\r\n            detailed = descript.detailed or \"\",\r\n            license = descript.license or \"N/A\",\r\n            homepage = descript.homepage and ('| <a href=\"'..descript.homepage..'\"'..ext_url_target..'>project homepage</a>') or \"\",\r\n            externaldependencies = format_external_dependencies(rockspec)\r\n         }\r\n         vars.detailed = vars.detailed:gsub(\"\\n\\n\", \"</p><p>\"):gsub(\"%s+\", \" \")\r\n         vars.detailed = vars.detailed:gsub(\"(https?://[a-zA-Z0-9%.%%-_%+%[%]=%?&/$@;:]+)\", '<a href=\"%1\"'..ext_url_target..'>%1</a>')\r\n         output = output:gsub(\"$(%w+)\", vars)\r\n      else\r\n         output = output:gsub(\"$anchor\", package)\r\n         output = output:gsub(\"$package\", package)\r\n         output = output:gsub(\"$(%w+)\", \"\")\r\n      end\r\n      out:write(output)\r\n   end\r\n   out:write(index_footer_begin)\r\n   for ver in util.lua_versions() do\r\n      out:write((index_manifest_ver:gsub(\"$VER\", ver)))\r\n   end\r\n   out:write(index_footer_end)\r\n   out:close()\r\nend",
    "type": "function"
  }, {
    "id": 382,
    "text": "function install_binary_rock(rock_file, deps_mode)\r\n   assert(type(rock_file) == \"string\")\r\n\r\n   local name, version, arch = path.parse_name(rock_file)\r\n   if not name then\r\n      return nil, \"Filename \"..rock_file..\" does not match format 'name-version-revision.arch.rock'.\"\r\n   end\r\n   \r\n   if arch ~= \"all\" and arch ~= cfg.arch then\r\n      return nil, \"Incompatible architecture \"..arch, \"arch\"\r\n   end\r\n   if repos.is_installed(name, version) then\r\n      repos.delete_version(name, version)\r\n   end\r\n   \r\n   local rollback = util.schedule_function(function()\r\n      fs.delete(path.install_dir(name, version))\r\n      fs.remove_dir_if_empty(path.versions_dir(name))\r\n   end)\r\n   \r\n   local ok, err, errcode = fetch.fetch_and_unpack_rock(rock_file, path.install_dir(name, version))\r\n   if not ok then return nil, err, errcode end\r\n   \r\n   local rockspec, err, errcode = fetch.load_rockspec(path.rockspec_file(name, version))\r\n   if err then\r\n      return nil, \"Failed loading rockspec for installed package: \"..err, errcode\r\n   end\r\n\r\n   if deps_mode == \"none\" then\r\n      util.printerr(\"Warning: skipping dependency checks.\")\r\n   else\r\n      ok, err, errcode = deps.check_external_deps(rockspec, \"install\")\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   -- For compatibility with .rock files built with LuaRocks 1\r\n   if not fs.exists(path.rock_manifest_file(name, version)) then\r\n      ok, err = manif.make_rock_manifest(name, version)\r\n      if err then return nil, err end\r\n   end\r\n\r\n   if deps_mode ~= \"none\" then\r\n      ok, err, errcode = deps.fulfill_dependencies(rockspec, deps_mode)\r\n      if err then return nil, err, errcode end\r\n   end\r\n\r\n   local wrap_bin_scripts = true\r\n   if rockspec.deploy and rockspec.deploy.wrap_bin_scripts == false then\r\n      wrap_bin_scripts = false\r\n   end\r\n\r\n   ok, err = repos.deploy_files(name, version, repos.should_wrap_bin_scripts(rockspec))\r\n   if err then return nil, err end\r\n\r\n   util.remove_scheduled_function(rollback)\r\n   rollback = util.schedule_function(function()\r\n      repos.delete_version(name, version)\r\n   end)\r\n\r\n   ok, err = repos.run_hook(rockspec, \"post_install\")\r\n   if err then return nil, err end\r\n   \r\n   ok, err = manif.update_manifest(name, version, nil, deps_mode)\r\n   if err then return nil, err end\r\n   \r\n   local license = \"\"\r\n   if rockspec.description.license then\r\n      license = (\"(license: \"..rockspec.description.license..\")\")\r\n   end\r\n\r\n   local root_dir = path.root_dir(cfg.rocks_dir)\r\n   util.printout()\r\n   util.printout(name..\" \"..version..\" is now installed in \"..root_dir..\" \"..license)\r\n   \r\n   util.remove_scheduled_function(rollback)\r\n   return name, version\r\nend",
    "type": "function"
  }, {
    "id": 383,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing. \"..util.see_help(\"install\")\r\n   end\r\n\r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n\r\n   if name:match(\"%.rockspec$\") or name:match(\"%.src%.rock$\") then\r\n      util.printout(\"Using \"..name..\"... switching to 'build' mode\")\r\n      local build = require(\"luarocks.build\")\r\n      return build.run(name, util.forward_flags(flags, \"local\", \"keep\", \"deps-mode\"))\r\n   elseif name:match(\"%.rock$\") then\r\n      ok, err = install_binary_rock(name, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   else\r\n      local search = require(\"luarocks.search\")\r\n      local results, err = search.find_suitable_rock(search.make_query(name:lower(), version))\r\n      if err then\r\n         return nil, err\r\n      elseif type(results) == \"string\" then\r\n         local url = results\r\n         util.printout(\"Installing \"..url..\"...\")\r\n         return run(url, util.forward_flags(flags))\r\n      else\r\n         util.printout()\r\n         util.printerr(\"Could not determine which rock to install.\")\r\n         util.title(\"Search results:\")\r\n         search.print_results(results)\r\n         return nil, (next(results) and \"Please narrow your query.\" or \"No results found.\")\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 384,
    "text": "function run(...)\r\n   local flags, input = util.parse_flags(...)\r\n   \r\n   if not input then\r\n      return nil, \"Argument missing. \"..util.see_help(\"lint\")\r\n   end\r\n   \r\n   local filename = input\r\n   if not input:match(\".rockspec$\") then\r\n      local err\r\n      filename, err = download.download(\"rockspec\", input)\r\n      if not filename then\r\n         return nil, err\r\n      end\r\n   end\r\n\r\n   local rs, err = fetch.load_local_rockspec(filename)\r\n   if not rs then\r\n      return nil, \"Failed loading rockspec: \"..err\r\n   end\r\n\r\n   local ok = true\r\n   \r\n   -- This should have been done in the type checker, \r\n   -- but it would break compatibility of other commands.\r\n   -- Making 'lint' alone be stricter shouldn't be a problem,\r\n   -- because extra-strict checks is what lint-type commands\r\n   -- are all about.\r\n   if not rs.description.license then\r\n      util.printerr(\"Rockspec has no license field.\")\r\n      ok = false\r\n   end\r\n\r\n   return ok, ok or filename..\" failed consistency checks.\"\r\nend",
    "type": "function"
  }, {
    "id": 385,
    "text": "function run(...)\r\n   local flags, rockspec = util.parse_flags(...)\r\n   assert(type(rockspec) == \"string\" or not rockspec)\r\n   \r\n   if not rockspec then\r\n      local files = fs.list_dir(fs.current_dir())\r\n      for _, file in pairs(files) do\r\n         if file:match(\"rockspec$\") then\r\n            if rockspec then\r\n               return nil, \"Please specify which rockspec file to use.\"\r\n            else\r\n               rockspec = file\r\n            end\r\n         end\r\n      end\r\n      if not rockspec then\r\n         return nil, \"Argument missing: please specify a rockspec to use on current directory.\"\r\n      end\r\n   end\r\n   if not rockspec:match(\"rockspec$\") then\r\n      return nil, \"Invalid argument: 'make' takes a rockspec as a parameter. \"..util.see_help(\"make\")\r\n   end\r\n\r\n   if flags[\"pack-binary-rock\"] then\r\n      local rspec, err, errcode = fetch.load_rockspec(rockspec)\r\n      if not rspec then\r\n         return nil, err\r\n      end\r\n      return pack.pack_binary_rock(rspec.name, rspec.version, build.build_rockspec, rockspec, false, true, deps.get_deps_mode(flags))\r\n   else\r\n      local ok, err = fs.check_command_permissions(flags)\r\n      if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n      ok, err = build.build_rockspec(rockspec, false, true, deps.get_deps_mode(flags))\r\n      if not ok then return nil, err end\r\n      local name, version = ok, err\r\n      if (not flags[\"keep\"]) and not cfg.keep_other_versions then\r\n         local ok, err = remove.remove_other_versions(name, version, flags[\"force\"])\r\n         if not ok then util.printerr(err) end\r\n      end\r\n      return name, version\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 386,
    "text": "function run(...)\r\n   local flags, repo = util.parse_flags(...)\r\n\r\n   assert(type(repo) == \"string\" or not repo)\r\n   repo = repo or cfg.rocks_dir\r\n  \r\n   util.printout(\"Making manifest for \"..repo)\r\n   \r\n   if repo:match(\"/lib/luarocks\") and not flags[\"local-tree\"] then\r\n      util.warning(\"This looks like a local rocks tree, but you did not pass --local-tree.\")\r\n   end\r\n   \r\n   local ok, err = manif.make_manifest(repo, deps.get_deps_mode(flags), not flags[\"local-tree\"])\r\n   if ok and not flags[\"local-tree\"] then\r\n      util.printout(\"Generating index.html for \"..repo)\r\n      index.make_index(repo)\r\n   end\r\n   if flags[\"local-tree\"] then\r\n      for luaver in util.lua_versions() do\r\n         fs.delete(dir.path(repo, \"manifest-\"..luaver))\r\n      end\r\n   end\r\n   return ok, err\r\nend",
    "type": "function"
  }, {
    "id": 387,
    "text": "function make_rock_manifest(name, version)\r\n   local install_dir = path.install_dir(name, version)\r\n   local rock_manifest = path.rock_manifest_file(name, version)\r\n   local tree = {}\r\n   for _, file in ipairs(fs.find(install_dir)) do\r\n      local full_path = dir.path(install_dir, file)\r\n      local walk = tree\r\n      local last\r\n      local last_name\r\n      for name in file:gmatch(\"[^/]+\") do\r\n         local next = walk[name]\r\n         if not next then\r\n            next = {}\r\n            walk[name] = next\r\n         end\r\n         last = walk\r\n         last_name = name\r\n         walk = next\r\n      end\r\n      if fs.is_file(full_path) then\r\n         local sum, err = fs.get_md5(full_path)\r\n         if not sum then\r\n            return nil, \"Failed producing checksum: \"..tostring(err)\r\n         end\r\n         last[last_name] = sum\r\n      end\r\n   end\r\n   local rock_manifest = { rock_manifest=tree }\r\n   rock_manifest_cache[name..\"/\"..version] = rock_manifest\r\n   save_table(install_dir, \"rock_manifest\", rock_manifest )\r\nend",
    "type": "function"
  }, {
    "id": 388,
    "text": "local function fetch_manifest_from(repo_url, filename)\r\n   local url = dir.path(repo_url, filename)\r\n   local name = repo_url:gsub(\"[/:]\",\"_\")\r\n   local cache_dir = dir.path(cfg.local_cache, name)\r\n   local ok = fs.make_dir(cache_dir)\r\n   if not ok then\r\n      return nil, \"Failed creating temporary cache directory \"..cache_dir\r\n   end\r\n   local file, err, errcode = fetch.fetch_url(url, dir.path(cache_dir, filename), true)\r\n   if not file then\r\n      return nil, \"Failed fetching manifest for \"..repo_url..(err and \" - \"..err or \"\"), errcode\r\n   end\r\n   return file\r\nend",
    "type": "function"
  }, {
    "id": 389,
    "text": "function load_manifest(repo_url)\r\n   assert(type(repo_url) == \"string\")\r\n\r\n   if manif_core.manifest_cache[repo_url] then\r\n      return manif_core.manifest_cache[repo_url]\r\n   end\r\n   \r\n   local filenames = {\r\n      \"manifest-\"..cfg.lua_version..\".zip\",\r\n      \"manifest-\"..cfg.lua_version,\r\n      \"manifest\",\r\n   }\r\n\r\n   local protocol, repodir = dir.split_url(repo_url)\r\n   local pathname\r\n   if protocol == \"file\" then\r\n      for _, filename in ipairs(filenames) do\r\n         pathname = dir.path(repodir, filename)\r\n         if fs.exists(pathname) then\r\n            break\r\n         end\r\n      end\r\n   else\r\n      local err\r\n      for _, filename in ipairs(filenames) do\r\n         pathname, err = fetch_manifest_from(repo_url, filename)\r\n         if pathname then\r\n            break\r\n         end\r\n      end\r\n      if not pathname then \r\n         return nil, err\r\n      end\r\n   end\r\n   if pathname:match(\".*%.zip$\") then\r\n      pathname = fs.absolute_name(pathname)\r\n      local dir = dir.dir_name(pathname)\r\n      fs.change_dir(dir)\r\n      local nozip = pathname:match(\"(.*)%.zip$\")\r\n      fs.delete(nozip)\r\n      local ok = fs.unzip(pathname)\r\n      fs.pop_dir()\r\n      if not ok then\r\n         fs.delete(pathname)\r\n         fs.delete(pathname..\".timestamp\")\r\n         return nil, \"Failed extracting manifest file\"\r\n      end\r\n      pathname = nozip\r\n   end\r\n   return manif_core.manifest_loader(pathname, repo_url)\r\nend",
    "type": "function"
  }, {
    "id": 390,
    "text": "function make_manifest(repo, deps_mode, remote)\r\n   assert(type(repo) == \"string\")\r\n   assert(type(deps_mode) == \"string\")\r\n\r\n   if deps_mode == \"none\" then deps_mode = cfg.deps_mode end\r\n\r\n   if not fs.is_dir(repo) then\r\n      return nil, \"Cannot access repository at \"..repo\r\n   end\r\n\r\n   local query = search.make_query(\"\")\r\n   query.exact_name = false\r\n   query.arch = \"any\"\r\n   local results = search.disk_search(repo, query)\r\n   local manifest = { repository = {}, modules = {}, commands = {} }\r\n\r\n   manif_core.manifest_cache[repo] = manifest\r\n\r\n   local dep_handler = nil\r\n   if not remote then\r\n      dep_handler = function(manifest)\r\n         update_dependencies(manifest, deps_mode)\r\n      end\r\n   end\r\n   local ok, err = store_results(results, manifest, dep_handler)\r\n   if not ok then return nil, err end\r\n\r\n   if remote then\r\n      local cache = {}\r\n      for luaver in util.lua_versions() do\r\n         local vmanifest = { repository = {}, modules = {}, commands = {} }\r\n         local dep_handler = function(manifest)\r\n            filter_by_lua_version(manifest, luaver, repo, cache)\r\n         end\r\n         local ok, err = store_results(results, vmanifest, dep_handler)\r\n         save_table(repo, \"manifest-\"..luaver, vmanifest)\r\n      end\r\n   end\r\n\r\n   return save_table(repo, \"manifest\", manifest)\r\nend",
    "type": "function"
  }, {
    "id": 391,
    "text": "function zip_manifests()\r\n   for ver in util.lua_versions() do\r\n      local file = \"manifest-\"..ver\r\n      local zip = file..\".zip\"\r\n      fs.delete(dir.path(fs.current_dir(), zip))\r\n      fs.zip(zip, file)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 392,
    "text": "local function check_url_and_update_md5(out_rs, out_name)\r\n   local old_md5 = out_rs.source.md5\r\n   out_rs.source.md5 = nil\r\n   local file, temp_dir = fetch.fetch_url_at_temp_dir(out_rs.source.url, \"luarocks-new-version-\"..out_name)\r\n   if not file then\r\n      util.printerr(\"Warning: invalid URL - \"..temp_dir)\r\n      return true\r\n   end\r\n   util.printout(\"File successfully downloaded. Updating MD5 checksum...\")\r\n   out_rs.source.md5 = fs.get_md5(file)\r\n   local ok, err = fs.change_dir(temp_dir)\r\n   if not ok then return nil, err end\r\n   fs.unpack_archive(file)\r\n   local base_dir = out_rs.source.dir or fetch.url_to_base_dir(out_rs.source.url)\r\n   if not fs.exists(base_dir) then\r\n      util.printerr(\"Directory \"..base_dir..\" not found\")\r\n      local files = fs.list_dir()\r\n      if files[1] and fs.is_dir(files[1]) then\r\n         util.printerr(\"Found \"..files[1])\r\n         out_rs.source.dir = files[1]\r\n      end\r\n   end\r\n   fs.pop_dir()\r\n   return out_rs.source.md5 ~= old_md5\r\nend",
    "type": "function"
  }, {
    "id": 393,
    "text": "function run(...)\r\n   local flags, input, version, url = util.parse_flags(...)\r\n   if not input then\r\n      return nil, \"Missing arguments: expected program or rockspec. \"..util.see_help(\"new_version\")\r\n   end\r\n   assert(type(input) == \"string\")\r\n   \r\n   local filename = input\r\n   if not input:match(\".rockspec$\") then\r\n      local err\r\n      filename, err = download.download(\"rockspec\", input)\r\n      if not filename then\r\n         return nil, err\r\n      end\r\n   end\r\n   \r\n   local valid_rs, err = fetch.load_rockspec(filename)\r\n   if not valid_rs then\r\n      return nil, err\r\n   end\r\n\r\n   local old_ver, old_rev = valid_rs.version:match(\"(.*)%-(%d+)$\")\r\n   local new_ver, new_rev\r\n   \r\n   if version then\r\n      new_ver, new_rev = version:match(\"(.*)%-(%d+)$\")\r\n      new_rev = tonumber(new_rev)\r\n      if not new_rev then\r\n         new_ver = version\r\n         new_rev = 1\r\n      end\r\n   else\r\n      new_ver = old_ver\r\n      new_rev = tonumber(old_rev) + 1\r\n   end\r\n   local new_rockver = new_ver:gsub(\"-\", \"\")\r\n   \r\n   local out_rs = persist.load_into_table(filename)\r\n   local out_name = out_rs.package:lower()\r\n   out_rs.version = new_rockver..\"-\"..new_rev\r\n\r\n   local ok, err = update_source_section(out_rs, out_name, url, old_ver, new_ver)\r\n   if not ok then return nil, err end\r\n\r\n   if out_rs.build and out_rs.build.type == \"module\" then\r\n      out_rs.build.type = \"builtin\"\r\n   end\r\n   \r\n   local out_filename = out_name..\"-\"..new_rockver..\"-\"..new_rev..\".rockspec\"\r\n   \r\n   persist.save_from_table(out_filename, out_rs, type_check.rockspec_order)\r\n   \r\n   util.printout(\"Wrote \"..out_filename)\r\n\r\n   local valid_out_rs, err = fetch.load_local_rockspec(out_filename)\r\n   if not valid_out_rs then\r\n      return nil, \"Failed loading generated rockspec: \"..err\r\n   end\r\n   \r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 394,
    "text": "local function pack_source_rock(rockspec_file)\r\n   assert(type(rockspec_file) == \"string\")\r\n\r\n   local rockspec, err = fetch.load_rockspec(rockspec_file)\r\n   if err then\r\n      return nil, \"Error loading rockspec: \"..err\r\n   end\r\n   rockspec_file = rockspec.local_filename\r\n\r\n   local name_version = rockspec.name .. \"-\" .. rockspec.version\r\n   local rock_file = fs.absolute_name(name_version .. \".src.rock\")\r\n\r\n   local source_file, source_dir = fetch.fetch_sources(rockspec, false)\r\n   if not source_file then\r\n      return nil, source_dir\r\n   end\r\n   local ok, err = fs.change_dir(source_dir)\r\n   if not ok then return nil, err end\r\n\r\n   fs.delete(rock_file)\r\n   fs.copy(rockspec_file, source_dir)\r\n   if not fs.zip(rock_file, dir.base_name(rockspec_file), dir.base_name(source_file)) then\r\n      return nil, \"Failed packing \"..rock_file\r\n   end\r\n   fs.pop_dir()\r\n\r\n   return rock_file\r\nend",
    "type": "function"
  }, {
    "id": 395,
    "text": "local function copy_back_files(name, version, file_tree, deploy_dir, pack_dir)\r\n   local ok, err = fs.make_dir(pack_dir)\r\n   if not ok then return nil, err end\r\n   for file, sub in pairs(file_tree) do\r\n      local source = dir.path(deploy_dir, file)\r\n      local target = dir.path(pack_dir, file)\r\n      if type(sub) == \"table\" then\r\n         local ok, err = copy_back_files(name, version, sub, source, target)\r\n         if not ok then return nil, err end\r\n      else\r\n         local versioned = path.versioned_name(source, deploy_dir, name, version)\r\n         if fs.exists(versioned) then\r\n            fs.copy(versioned, target)\r\n         else\r\n            fs.copy(source, target)\r\n         end\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 396,
    "text": "local function do_pack_binary_rock(name, version)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\" or not version)\r\n\r\n   local query = search.make_query(name, version)\r\n   query.exact_name = true\r\n   local results = {}\r\n   \r\n   search.manifest_search(results, cfg.rocks_dir, query)\r\n   \r\n   if not next(results) then\r\n      return nil, \"'\"..name..\"' does not seem to be an installed rock.\"\r\n   end\r\n   \r\n   local versions = results[name]\r\n   \r\n   if not version then\r\n      local first = next(versions)\r\n      if next(versions, first) then\r\n         return nil, \"Please specify which version of '\"..name..\"' to pack.\"\r\n      end\r\n      version = first\r\n   end\r\n   if not version:match(\"[^-]+%-%d+\") then\r\n      return nil, \"Expected version \"..version..\" in version-revision format.\"\r\n   end\r\n   \r\n   local info = versions[version][1]\r\n   \r\n   local root = path.root_dir(info.repo)\r\n   local prefix = path.install_dir(name, version, root)\r\n   if not fs.exists(prefix) then\r\n      return nil, \"'\"..name..\" \"..version..\"' does not seem to be an installed rock.\"\r\n   end\r\n   \r\n   local rock_manifest = manif.load_rock_manifest(name, version, root)\r\n   if not rock_manifest then\r\n      return nil, \"rock_manifest file not found for \"..name..\" \"..version..\" - not a LuaRocks 2 tree?\"\r\n   end\r\n\r\n   local name_version = name .. \"-\" .. version\r\n   local rock_file = fs.absolute_name(name_version .. \".\"..cfg.arch..\".rock\")\r\n   \r\n   local temp_dir = fs.make_temp_dir(\"pack\")\r\n   fs.copy_contents(prefix, temp_dir)\r\n\r\n   local is_binary = false\r\n   if rock_manifest.lib then\r\n      local ok, err = copy_back_files(name, version, rock_manifest.lib, path.deploy_lib_dir(root), dir.path(temp_dir, \"lib\"))\r\n      if not ok then return nil, \"Failed copying back files: \" .. err end\r\n      is_binary = true\r\n   end\r\n   if rock_manifest.lua then\r\n      local ok, err = copy_back_files(name, version, rock_manifest.lua, path.deploy_lua_dir(root), dir.path(temp_dir, \"lua\"))\r\n      if not ok then return nil, \"Failed copying back files: \" .. err end\r\n   end\r\n   \r\n   local ok, err = fs.change_dir(temp_dir)\r\n   if not ok then return nil, err end\r\n   if not is_binary and not repos.has_binaries(name, version) then\r\n      rock_file = rock_file:gsub(\"%.\"..cfg.arch:gsub(\"%-\",\"%%-\")..\"%.\", \".all.\")\r\n   end\r\n   fs.delete(rock_file)\r\n   if not fs.zip(rock_file, unpack(fs.list_dir())) then\r\n      return nil, \"Failed packing \"..rock_file\r\n   end\r\n   fs.pop_dir()\r\n   fs.delete(temp_dir)\r\n   return rock_file\r\nend",
    "type": "function"
  }, {
    "id": 397,
    "text": "function pack_binary_rock(name, version, cmd, ...)\r\n\r\n   -- The --pack-binary-rock option for \"luarocks build\" basically performs\r\n   -- \"luarocks build\" on a temporary tree and then \"luarocks pack\". The\r\n   -- alternative would require refactoring parts of luarocks.build and\r\n   -- luarocks.pack, which would save a few file operations: the idea would be\r\n   -- to shave off the final deploy steps from the build phase and the initial\r\n   -- collect steps from the pack phase.\r\n\r\n   local temp_dir, err = fs.make_temp_dir(\"luarocks-build-pack-\"..dir.base_name(name))\r\n   if not temp_dir then\r\n      return nil, \"Failed creating temporary directory: \"..err\r\n   end\r\n   util.schedule_function(fs.delete, temp_dir)\r\n\r\n   path.use_tree(temp_dir)\r\n   local ok, err = cmd(...)\r\n   if not ok then\r\n      return nil, err\r\n   end\r\n   local rname, rversion = path.parse_name(name)\r\n   if not rname then\r\n      rname, rversion = name, version\r\n   end\r\n   return do_pack_binary_rock(rname, rversion)\r\nend",
    "type": "function"
  }, {
    "id": 398,
    "text": "function root_dir(rocks_dir)\r\n   assert(type(rocks_dir) == \"string\")\r\n   return rocks_dir:match(\"(.*)\" .. util.matchquote(cfg.rocks_subdir) .. \".*$\")\r\nend",
    "type": "function"
  }, {
    "id": 399,
    "text": "function run(...)\r\n   local flags = util.parse_flags(...)\r\n   \r\n   local tree = flags[\"tree\"]\r\n\r\n   if type(tree) ~= \"string\" then\r\n      return nil, \"The --tree argument is mandatory. \"..util.see_help(\"purge\")\r\n   end\r\n   \r\n   local results = {}\r\n   local query = search.make_query(\"\")\r\n   query.exact_name = false\r\n   if not fs.is_dir(tree) then\r\n      return nil, \"Directory not found: \"..tree\r\n   end\r\n\r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n\r\n   search.manifest_search(results, path.rocks_dir(tree), query)\r\n\r\n   local sort = function(a,b) return deps.compare_versions(b,a) end\r\n   if flags[\"old-versions\"] then\r\n      sort = deps.compare_versions\r\n   end\r\n\r\n   for package, versions in util.sortedpairs(results) do\r\n      for version, repositories in util.sortedpairs(versions, sort) do\r\n         if flags[\"old-versions\"] then\r\n            util.printout(\"Keeping \"..package..\" \"..version..\"...\")\r\n            local ok, err = remove.remove_other_versions(package, version, flags[\"force\"])\r\n            if not ok then\r\n               util.printerr(err)\r\n            end\r\n            break\r\n         else\r\n            util.printout(\"Removing \"..package..\" \"..version..\"...\")\r\n            local ok, err = repos.delete_version(package, version, true)\r\n            if not ok then\r\n               util.printerr(err)\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return manif.make_manifest(cfg.rocks_dir, \"one\")\r\nend",
    "type": "function"
  }, {
    "id": 400,
    "text": "function run(...)\r\n   local flags, name, version = util.parse_flags(...)\r\n   \r\n   if type(name) ~= \"string\" then\r\n      return nil, \"Argument missing, see help.\"\r\n   end\r\n   \r\n   local deps_mode = flags[\"deps-mode\"] or cfg.deps_mode\r\n   \r\n   local ok, err = fs.check_command_permissions(flags)\r\n   if not ok then return nil, err, cfg.errorcodes.PERMISSIONDENIED end\r\n   \r\n   local rock_type = name:match(\"%.(rock)$\") or name:match(\"%.(rockspec)$\")\r\n   local filename = name\r\n   if rock_type then\r\n      name, version = path.parse_name(filename)\r\n      if not name then return nil, \"Invalid \"..rock_type..\" filename: \"..filename end\r\n   end\r\n\r\n   local results = {}\r\n   search.manifest_search(results, cfg.rocks_dir, search.make_query(name, version))\r\n   if not results[name] then\r\n      return nil, \"Could not find rock '\"..name..(version and \" \"..version or \"\")..\"' in local tree.\"\r\n   end\r\n\r\n   return remove_search_results(results, name, deps_mode, flags[\"force\"])\r\nend",
    "type": "function"
  }, {
    "id": 401,
    "text": "local function get_installed_versions(name)\r\n   assert(type(name) == \"string\")\r\n   \r\n   local dirs = fs.list_dir(path.versions_dir(name))\r\n   return (dirs and #dirs > 0) and dirs or nil\r\nend",
    "type": "function"
  }, {
    "id": 402,
    "text": "function is_installed(name, version)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n      \r\n   return fs.is_dir(path.install_dir(name, version))\r\nend",
    "type": "function"
  }, {
    "id": 403,
    "text": "function run_hook(rockspec, hook_name)\r\n   assert(type(rockspec) == \"table\")\r\n   assert(type(hook_name) == \"string\")\r\n\r\n   local hooks = rockspec.hooks\r\n   if not hooks then\r\n      return true\r\n   end\r\n   \r\n   if cfg.hooks_enabled == false then\r\n      return nil, \"This rockspec contains hooks, which are blocked by the 'hooks_enabled' setting in your LuaRocks configuration.\"\r\n   end\r\n   \r\n   if not hooks.substituted_variables then\r\n      util.variable_substitutions(hooks, rockspec.variables)\r\n      hooks.substituted_variables = true\r\n   end\r\n   local hook = hooks[hook_name]\r\n   if hook then\r\n      util.printout(hook)\r\n      if not fs.execute(hook) then\r\n         return nil, \"Failed running \"..hook_name..\" hook.\"\r\n      end\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 404,
    "text": "local function resolve_conflict(target, deploy_dir, name, version)\r\n   local cname, cversion = manif.find_current_provider(target)\r\n   if not cname then\r\n      return nil, cversion\r\n   end\r\n   if name ~= cname or deps.compare_versions(version, cversion) then\r\n      local versioned = path.versioned_name(target, deploy_dir, cname, cversion)\r\n      local ok, err = fs.make_dir(dir.dir_name(versioned))\r\n      if not ok then return nil, err end\r\n      fs.move(target, versioned)\r\n      return target\r\n   else\r\n      return path.versioned_name(target, deploy_dir, name, version)\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 405,
    "text": "local function deploy_file_tree(file_tree, path_fn, deploy_dir, move_fn)\r\n      local source_dir = path_fn(name, version)\r\n      if not move_fn then\r\n         move_fn = fs.move\r\n      end\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local source = dir.path(source_dir, parent_path, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local ok, err\r\n            if fs.exists(target) then\r\n               local new_target, err = resolve_conflict(target, deploy_dir, name, version)\r\n               if err == \"untracked\" then\r\n                  local backup = target\r\n                  repeat\r\n                     backup = backup..\"~\"\r\n                  until not fs.exists(backup) -- slight race condition here, but shouldn't be a problem.\r\n                  util.printerr(\"Warning: \"..target..\" is not tracked by this installation of LuaRocks. Moving it to \"..backup)\r\n                  fs.move(target, backup)\r\n               elseif err then\r\n                  return nil, err..\" Cannot install new version.\"\r\n               else\r\n                  target = new_target\r\n               end\r\n            end\r\n            ok, err = fs.make_dir(dir.dir_name(target))\r\n            if not ok then return nil, err end\r\n            ok, err = move_fn(source, target, name, version)\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(source))\r\n            if not ok then return nil, err end\r\n            return true\r\n         end\r\n      )\r\n   end",
    "type": "function"
  }, {
    "id": 406,
    "text": "local function delete_suffixed(filename, suffix)\r\n   local filenames = { filename }\r\n   if suffix and suffix ~= \"\" then filenames = { filename..suffix, filename } end\r\n   for _, name in ipairs(filenames) do\r\n      if fs.exists(name) then\r\n         fs.delete(name)\r\n         if fs.exists(name) then\r\n            return nil, \"Failed deleting \"..name, \"fail\"\r\n         end\r\n         return true, name\r\n      end\r\n   end\r\n   return false, \"File not found\", \"not found\"\r\nend",
    "type": "function"
  }, {
    "id": 407,
    "text": "function delete_version(name, version, quick)\r\n   assert(type(name) == \"string\")\r\n   assert(type(version) == \"string\")\r\n\r\n   local function delete_deployed_file_tree(file_tree, deploy_dir, suffix)\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local versioned = path.versioned_name(target, deploy_dir, name, version)\r\n            local ok, name, err = delete_suffixed(versioned, suffix)\r\n            if ok then\r\n               fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               return true\r\n            end\r\n            if err == \"fail\" then return nil, name end\r\n            ok, name, err = delete_suffixed(target, suffix)\r\n            if err == \"fail\" then return nil, name end\r\n            if not quick then\r\n               local next_name, next_version = manif.find_next_provider(target)\r\n               if next_name then\r\n                  local versioned = path.versioned_name(name, deploy_dir, next_name, next_version)\r\n                  fs.move(versioned, name)\r\n                  fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               end\r\n            end\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(target))\r\n            return true\r\n         end\r\n      )\r\n   end\r\n\r\n   local rock_manifest = manif.load_rock_manifest(name, version)\r\n   if not rock_manifest then\r\n      return nil, \"rock_manifest file not found for \"..name..\" \"..version..\" - not a LuaRocks 2 tree?\"\r\n   end\r\n   \r\n   local ok, err = true\r\n   if rock_manifest.bin then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.bin, cfg.deploy_bin_dir, cfg.wrapper_suffix)\r\n   end\r\n   if ok and rock_manifest.lua then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.lua, cfg.deploy_lua_dir)\r\n   end\r\n   if ok and rock_manifest.lib then\r\n      ok, err = delete_deployed_file_tree(rock_manifest.lib, cfg.deploy_lib_dir)\r\n   end\r\n   if err then return nil, err end\r\n\r\n   fs.delete(path.install_dir(name, version))\r\n   if not get_installed_versions(name) then\r\n      fs.delete(dir.path(cfg.rocks_dir, name))\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 408,
    "text": "local function delete_deployed_file_tree(file_tree, deploy_dir, suffix)\r\n      return recurse_rock_manifest_tree(file_tree, \r\n         function(parent_path, parent_module, file)\r\n            local target = dir.path(deploy_dir, parent_path, file)\r\n            local versioned = path.versioned_name(target, deploy_dir, name, version)\r\n            local ok, name, err = delete_suffixed(versioned, suffix)\r\n            if ok then\r\n               fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               return true\r\n            end\r\n            if err == \"fail\" then return nil, name end\r\n            ok, name, err = delete_suffixed(target, suffix)\r\n            if err == \"fail\" then return nil, name end\r\n            if not quick then\r\n               local next_name, next_version = manif.find_next_provider(target)\r\n               if next_name then\r\n                  local versioned = path.versioned_name(name, deploy_dir, next_name, next_version)\r\n                  fs.move(versioned, name)\r\n                  fs.remove_dir_tree_if_empty(dir.dir_name(versioned))\r\n               end\r\n            end\r\n            fs.remove_dir_tree_if_empty(dir.dir_name(target))\r\n            return true\r\n         end\r\n      )\r\n   end",
    "type": "function"
  }, {
    "id": 409,
    "text": "function disk_search(repo, query, results)\r\n   assert(type(repo) == \"string\")\r\n   assert(type(query) == \"table\")\r\n   assert(type(results) == \"table\" or not results)\r\n   \r\n   local fs = require(\"luarocks.fs\")\r\n     \r\n   if not results then\r\n      results = {}\r\n   end\r\n   query_arch_as_table(query)\r\n   \r\n   for _, name in pairs(fs.list_dir(repo)) do\r\n      local pathname = dir.path(repo, name)\r\n      local rname, rversion, rarch = path.parse_name(name)\r\n\r\n      if rname and (pathname:match(\".rockspec$\") or pathname:match(\".rock$\")) then\r\n         store_if_match(results, repo, rname, rversion, rarch, query)\r\n      elseif fs.is_dir(pathname) then\r\n         for _, version in pairs(fs.list_dir(pathname)) do\r\n            if version:match(\"-%d+$\") then\r\n               store_if_match(results, repo, name, version, \"installed\", query)\r\n            end\r\n         end\r\n      end\r\n   end\r\n   return results\r\nend",
    "type": "function"
  }, {
    "id": 410,
    "text": "function read_patch(filename, data)\r\n  -- define possible file regions that will direct the parser flow\r\n  local state = 'header'\r\n    -- 'header'    - comments before the patch body\r\n    -- 'filenames' - lines starting with --- and +++\r\n    -- 'hunkhead'  - @@ -R +R @@ sequence\r\n    -- 'hunkbody'\r\n    -- 'hunkskip'  - skipping invalid hunk mode\r\n\r\n  local all_ok = true\r\n  local lineends = {lf=0, crlf=0, cr=0}\r\n  local files = {source={}, target={}, hunks={}, fileends={}, hunkends={}}\r\n  local nextfileno = 0\r\n  local nexthunkno = 0    --: even if index starts with 0 user messages\r\n                          --  number hunks from 1\r\n\r\n  -- hunkinfo holds parsed values, hunkactual - calculated\r\n  local hunkinfo = {\r\n    startsrc=nil, linessrc=nil, starttgt=nil, linestgt=nil,\r\n    invalid=false, text={}\r\n  }\r\n  local hunkactual = {linessrc=nil, linestgt=nil}\r\n\r\n  info(format(\"reading patch %s\", filename))\r\n\r\n  local fp\r\n  if data then\r\n    fp = string_as_file(data)\r\n  else\r\n    fp = filename == '-' and io.stdin or assert(io.open(filename, \"rb\"))\r\n  end\r\n  local lineno = 0\r\n\r\n  for line in file_lines(fp) do\r\n    lineno = lineno + 1\r\n    if state == 'header' then\r\n      if startswith(line, \"--- \") then\r\n        state = 'filenames'\r\n      end\r\n      -- state is 'header' or 'filenames'\r\n    end\r\n    if state == 'hunkbody' then\r\n      -- skip hunkskip and hunkbody code until definition of hunkhead read\r\n\r\n      -- process line first\r\n      if line:match\"^[- +\\\\]\" or line:match\"^[\\r\\n]*$\" then\r\n          -- gather stats about line endings\r\n          local he = files.hunkends[nextfileno]\r\n          if endswith(line, \"\\r\\n\") then\r\n            he.crlf = he.crlf + 1\r\n          elseif endswith(line, \"\\n\") then\r\n            he.lf = he.lf + 1\r\n          elseif endswith(line, \"\\r\") then\r\n            he.cr = he.cr + 1\r\n          end\r\n          if startswith(line, \"-\") then\r\n            hunkactual.linessrc = hunkactual.linessrc + 1\r\n          elseif startswith(line, \"+\") then\r\n            hunkactual.linestgt = hunkactual.linestgt + 1\r\n          elseif startswith(line, \"\\\\\") then\r\n            -- nothing\r\n          else\r\n            hunkactual.linessrc = hunkactual.linessrc + 1\r\n            hunkactual.linestgt = hunkactual.linestgt + 1\r\n          end\r\n          table.insert(hunkinfo.text, line)\r\n          -- todo: handle \\ No newline cases\r\n      else\r\n          warning(format(\"invalid hunk no.%d at %d for target file %s\",\r\n                         nexthunkno, lineno, files.target[nextfileno]))\r\n          -- add hunk status node\r\n          table.insert(files.hunks[nextfileno], table_copy(hunkinfo))\r\n          files.hunks[nextfileno][nexthunkno].invalid = true\r\n          all_ok = false\r\n          state = 'hunkskip'\r\n      end\r\n\r\n      -- check exit conditions\r\n      if hunkactual.linessrc > hunkinfo.linessrc or\r\n         hunkactual.linestgt > hunkinfo.linestgt\r\n      then\r\n          warning(format(\"extra hunk no.%d lines at %d for target %s\",\r\n                         nexthunkno, lineno, files.target[nextfileno]))\r\n          -- add hunk status node\r\n          table.insert(files.hunks[nextfileno], table_copy(hunkinfo))\r\n          files.hunks[nextfileno][nexthunkno].invalid = true\r\n          state = 'hunkskip'\r\n      elseif hunkinfo.linessrc == hunkactual.linessrc and\r\n             hunkinfo.linestgt == hunkactual.linestgt\r\n      then\r\n          table.insert(files.hunks[nextfileno], table_copy(hunkinfo))\r\n          state = 'hunkskip'\r\n\r\n          -- detect mixed window/unix line ends\r\n          local ends = files.hunkends[nextfileno]\r\n          if (ends.cr~=0 and 1 or 0) + (ends.crlf~=0 and 1 or 0) +\r\n             (ends.lf~=0 and 1 or 0) > 1\r\n          then\r\n            warning(format(\"inconsistent line ends in patch hunks for %s\",\r\n                    files.source[nextfileno]))\r\n          end\r\n          if debugmode then\r\n            local debuglines = {crlf=ends.crlf, lf=ends.lf, cr=ends.cr,\r\n                  file=files.target[nextfileno], hunk=nexthunkno}\r\n            debug(format(\"crlf: %(crlf)d  lf: %(lf)d  cr: %(cr)d\\t \" ..\r\n                         \"- file: %(file)s hunk: %(hunk)d\", debuglines))\r\n          end\r\n      end\r\n      -- state is 'hunkbody' or 'hunkskip'\r\n    end\r\n\r\n    if state == 'hunkskip' then\r\n      if match_linerange(line) then\r\n        state = 'hunkhead'\r\n      elseif startswith(line, \"--- \") then\r\n        state = 'filenames'\r\n        if debugmode and #files.source > 0 then\r\n            debug(format(\"- %2d hunks for %s\", #files.hunks[nextfileno],\r\n                         files.source[nextfileno]))\r\n        end\r\n      end\r\n      -- state is 'hunkskip', 'hunkhead', or 'filenames'\r\n    end\r\n    local advance\r\n    if state == 'filenames' then\r\n      if startswith(line, \"--- \") then\r\n        if util.array_contains(files.source, nextfileno) then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid patch for %s\",\r\n                         files.source[nextfileno+1]))\r\n          table.remove(files.source, nextfileno+1)\r\n          -- double source filename line is encountered\r\n          -- attempt to restart from this second line\r\n        end\r\n        -- Accept a space as a terminator, like GNU patch does.\r\n        -- Breaks patches containing filenames with spaces...\r\n        -- FIXME Figure out what does GNU patch do in those cases.\r\n        local match = line:match(\"^%-%-%- ([^ \\t\\r\\n]+)\")\r\n        if not match then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid filename at line %d\", lineno+1))\r\n          state = 'header'\r\n        else\r\n          table.insert(files.source, match)\r\n        end\r\n      elseif not startswith(line, \"+++ \") then\r\n        if util.array_contains(files.source, nextfileno) then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid patch with no target for %s\",\r\n                         files.source[nextfileno+1]))\r\n          table.remove(files.source, nextfileno+1)\r\n        else\r\n          -- this should be unreachable\r\n          warning(\"skipping invalid target patch\")\r\n        end\r\n        state = 'header'\r\n      else\r\n        if util.array_contains(files.target, nextfileno) then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid patch - double target at line %d\",\r\n                         lineno+1))\r\n          table.remove(files.source, nextfileno+1)\r\n          table.remove(files.target, nextfileno+1)\r\n          nextfileno = nextfileno - 1\r\n          -- double target filename line is encountered\r\n          -- switch back to header state\r\n          state = 'header'\r\n        else\r\n          -- Accept a space as a terminator, like GNU patch does.\r\n          -- Breaks patches containing filenames with spaces...\r\n          -- FIXME Figure out what does GNU patch do in those cases.\r\n          local re_filename = \"^%+%+%+ ([^ \\t\\r\\n]+)\"\r\n          local match = line:match(re_filename)\r\n          if not match then\r\n            all_ok = false\r\n            warning(format(\r\n              \"skipping invalid patch - no target filename at line %d\",\r\n              lineno+1))\r\n            state = 'header'\r\n          else\r\n            table.insert(files.target, match)\r\n            nextfileno = nextfileno + 1\r\n            nexthunkno = 0\r\n            table.insert(files.hunks, {})\r\n            table.insert(files.hunkends, table_copy(lineends))\r\n            table.insert(files.fileends, table_copy(lineends))\r\n            state = 'hunkhead'\r\n            advance = true\r\n          end\r\n        end\r\n      end\r\n      -- state is 'filenames', 'header', or ('hunkhead' with advance)\r\n    end\r\n    if not advance and state == 'hunkhead' then\r\n      local m1, m2, m3, m4 = match_linerange(line)\r\n      if not m1 then\r\n        if not util.array_contains(files.hunks, nextfileno-1) then\r\n          all_ok = false\r\n          warning(format(\"skipping invalid patch with no hunks for file %s\",\r\n                         files.target[nextfileno]))\r\n        end\r\n        state = 'header'\r\n      else\r\n        hunkinfo.startsrc = tonumber(m1)\r\n        hunkinfo.linessrc = tonumber(m2 or 1)\r\n        hunkinfo.starttgt = tonumber(m3)\r\n        hunkinfo.linestgt = tonumber(m4 or 1)\r\n        hunkinfo.invalid = false\r\n        hunkinfo.text = {}\r\n\r\n        hunkactual.linessrc = 0\r\n        hunkactual.linestgt = 0\r\n\r\n        state = 'hunkbody'\r\n        nexthunkno = nexthunkno + 1\r\n      end\r\n      -- state is 'header' or 'hunkbody'\r\n    end\r\n  end\r\n  if state ~= 'hunkskip' then\r\n    warning(format(\"patch file incomplete - %s\", filename))\r\n    all_ok = false\r\n    -- os.exit(?)\r\n  else\r\n    -- duplicated message when an eof is reached\r\n    if debugmode and #files.source > 0 then\r\n      debug(format(\"- %2d hunks for %s\", #files.hunks[nextfileno],\r\n                   files.source[nextfileno]))\r\n    end\r\n  end\r\n\r\n  local sum = 0; for _,hset in ipairs(files.hunks) do sum = sum + #hset end\r\n  info(format(\"total files: %d  total hunks: %d\", #files.source, sum))\r\n  fp:close()\r\n  return files, all_ok\r\nend",
    "type": "function"
  }, {
    "id": 411,
    "text": "function untar(filename, destdir)\r\n   assert(type(filename) == \"string\")\r\n   assert(type(destdir) == \"string\")\r\n\r\n   local tar_handle = io.open(filename, \"r\")\r\n   if not tar_handle then return nil, \"Error opening file \"..filename end\r\n   \r\n   local long_name, long_link_name\r\n   while true do\r\n      local block\r\n      repeat \r\n         block = tar_handle:read(blocksize)\r\n      until (not block) or checksum_header(block) > 256\r\n      if not block then break end\r\n      local header, err = read_header_block(block)\r\n      if not header then\r\n         util.printerr(err)\r\n      end\r\n\r\n      local file_data = tar_handle:read(math.ceil(header.size / blocksize) * blocksize):sub(1,header.size)\r\n\r\n      if header.typeflag == \"long name\" then\r\n         long_name = nullterm(file_data)\r\n      elseif header.typeflag == \"long link name\" then\r\n         long_link_name = nullterm(file_data)\r\n      else\r\n         if long_name then\r\n            header.name = long_name\r\n            long_name = nil\r\n         end\r\n         if long_link_name then\r\n            header.name = long_link_name\r\n            long_link_name = nil\r\n         end\r\n      end\r\n      local pathname = dir.path(destdir, header.name)\r\n      if header.typeflag == \"directory\" then\r\n         local ok, err = fs.make_dir(pathname)\r\n         if not ok then return nil, err end\r\n      elseif header.typeflag == \"file\" then\r\n         local dirname = dir.dir_name(pathname)\r\n         if dirname ~= \"\" then\r\n            local ok, err = fs.make_dir(dirname)\r\n            if not ok then return nil, err end\r\n         end\r\n         local file_handle = io.open(pathname, \"wb\")\r\n         file_handle:write(file_data)\r\n         file_handle:close()\r\n         fs.set_time(pathname, header.mtime)\r\n         if fs.chmod then\r\n            fs.chmod(pathname, header.mode)\r\n         end\r\n      end\r\n      --[[\r\n      for k,v in pairs(header) do\r\n         util.printout(\"[\\\"\"..tostring(k)..\"\\\"] = \"..(type(v)==\"number\" and v or \"\\\"\"..v:gsub(\"%z\", \"\\\\0\")..\"\\\"\"))\r\n      end\r\n      util.printout()\r\n      --]]\r\n   end\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 412,
    "text": "function zip(zipfile, ...)\r\n   local zw = new_zipwriter(zipfile)\r\n   if not zw then\r\n      return nil, \"error opening \"..zipfile\r\n   end\r\n\r\n   local ok, err\r\n   for _, file in pairs({...}) do\r\n      if fs.is_dir(file) then\r\n         for _, entry in pairs(fs.find(file)) do\r\n            local fullname = dir.path(file, entry)\r\n            if fs.is_file(fullname) then\r\n               ok, err = zw:add(fullname)\r\n               if not ok then break end\r\n            end\r\n         end\r\n      else\r\n         ok, err = zw:add(file)\r\n         if not ok then break end\r\n      end\r\n   end\r\n\r\n   local ok = zw:close()\r\n   if not ok then\r\n      return false, \"error closing \"..zipfile\r\n   end\r\n   return ok, err\r\nend",
    "type": "function"
  }, {
    "id": 413,
    "text": "local function unpack_rockspec(rockspec_file, dir_name)\r\n   assert(type(rockspec_file) == \"string\")\r\n   assert(type(dir_name) == \"string\")\r\n\r\n   local rockspec, err = fetch.load_rockspec(rockspec_file)\r\n   if not rockspec then\r\n      return nil, \"Failed loading rockspec \"..rockspec_file..\": \"..err\r\n   end\r\n   local ok, err = fs.change_dir(dir_name)\r\n   if not ok then return nil, err end\r\n   local ok, sources_dir = fetch.fetch_sources(rockspec, true, \".\")\r\n   if not ok then\r\n      return nil, sources_dir\r\n   end\r\n   ok, err = fs.change_dir(sources_dir)\r\n   if not ok then return nil, err end\r\n   build.apply_patches(rockspec)\r\n   fs.pop_dir()\r\n   fs.pop_dir()\r\n   return rockspec\r\nend",
    "type": "function"
  }, {
    "id": 414,
    "text": "local function unpack_rock(rock_file, dir_name, kind)\r\n   assert(type(rock_file) == \"string\")\r\n   assert(type(dir_name) == \"string\")\r\n\r\n   local ok, err, errcode = fetch.fetch_and_unpack_rock(rock_file, dir_name)\r\n   if not ok then\r\n      return nil, \"Failed unzipping rock \"..rock_file, errcode\r\n   end\r\n   ok, err = fs.change_dir(dir_name)\r\n   if not ok then return nil, err end\r\n   local rockspec_file = dir_name..\".rockspec\"\r\n   local rockspec, err = fetch.load_rockspec(rockspec_file)\r\n   if not rockspec then\r\n      return nil, \"Failed loading rockspec \"..rockspec_file..\": \"..err\r\n   end\r\n   if kind == \"src\" then\r\n      if rockspec.source.file then\r\n         local ok, err = fs.unpack_archive(rockspec.source.file)\r\n         if not ok then\r\n            return nil, err\r\n         end\r\n         ok, err = fs.change_dir(rockspec.source.dir)\r\n         if not ok then return nil, err end\r\n         build.apply_patches(rockspec)\r\n         fs.pop_dir()\r\n      end\r\n   end\r\n   return rockspec\r\nend",
    "type": "function"
  }, {
    "id": 415,
    "text": "local function run_unpacker(file, force)\r\n   assert(type(file) == \"string\")\r\n   \r\n   local base_name = dir.base_name(file)\r\n   local dir_name, kind, extension = base_name:match(\"(.*)%.([^.]+)%.(rock)$\")\r\n   if not extension then\r\n      dir_name, extension = base_name:match(\"(.*)%.(rockspec)$\")\r\n      kind = \"rockspec\"\r\n   end\r\n   if not extension then\r\n      return nil, file..\" does not seem to be a valid filename.\"\r\n   end\r\n\r\n   local exists = fs.exists(dir_name)\r\n   if exists and not force then\r\n      return nil, \"Directory \"..dir_name..\" already exists.\"\r\n   end\r\n   if not exists then\r\n      local ok, err = fs.make_dir(dir_name)\r\n      if not ok then return nil, err end\r\n   end\r\n   local rollback = util.schedule_function(fs.delete, fs.absolute_name(dir_name))\r\n\r\n   local rockspec, err\r\n   if extension == \"rock\" then\r\n      rockspec, err = unpack_rock(file, dir_name, kind)\r\n   elseif extension == \"rockspec\" then\r\n      rockspec, err = unpack_rockspec(file, dir_name)\r\n   end\r\n   if not rockspec then\r\n      return nil, err\r\n   end\r\n   if kind == \"src\" or kind == \"rockspec\" then\r\n      if rockspec.source.dir ~= \".\" then\r\n         local ok = fs.copy(rockspec.local_filename, rockspec.source.dir)\r\n         if not ok then\r\n            return nil, \"Failed copying unpacked rockspec into unpacked source directory.\"\r\n         end\r\n      end\r\n      util.printout()   \r\n      util.printout(\"Done. You may now enter directory \")\r\n      util.printout(dir.path(dir_name, rockspec.source.dir))\r\n      util.printout(\"and type 'luarocks make' to build.\")\r\n   end\r\n   util.remove_scheduled_function(rollback)\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 416,
    "text": "function run_scheduled_functions()\r\n   local fs = require(\"luarocks.fs\")\r\n   fs.change_dir_to_root()\r\n   for i = #scheduled_functions, 1, -1 do\r\n      local item = scheduled_functions[i]\r\n      item.fn(unpack(item.args))\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 417,
    "text": "function starts_with(s, prefix)\r\n   return s:sub(1,#prefix) == prefix\r\nend",
    "type": "function"
  }, {
    "id": 418,
    "text": "local function prepare_sandbox(file)\r\n   local root_dir = fs.make_temp_dir(file):gsub(\"/+$\", \"\")\r\n   cfg.root_dir = root_dir\r\n   cfg.rocks_dir = path.rocks_dir(root_dir)\r\n   cfg.deploy_bin_dir = path.deploy_bin_dir(root_dir)\r\n   cfg.variables.ROCKS_TREE = cfg.rocks_dir\r\n   cfg.variables.SCRIPTS_DIR = cfg.deploy_bin_dir\r\n   return root_dir\r\nend",
    "type": "function"
  }, {
    "id": 419,
    "text": "local function validate(repo, flags)\r\n   local results = {\r\n      ok = {}\r\n   }\r\n   local settings = save_settings(repo)\r\n   local sandbox\r\n   if flags[\"quick\"] then\r\n      sandbox = prepare_sandbox(\"luarocks_validate\")\r\n   end\r\n   if not fs.exists(repo) then\r\n      return nil, repo..\" is not a local repository.\"\r\n   end\r\n   for _, file in pairs(fs.list_dir(repo)) do for _=1,1 do\r\n      if file == \"manifest\" or file == \"index.html\" then\r\n         break -- continue for\r\n      end\r\n      local pathname = fs.absolute_name(dir.path(repo, file))\r\n      if not flags[\"quick\"] then\r\n         sandbox = prepare_sandbox(file)\r\n      end\r\n      local ok, err, errcode\r\n      util.printout()\r\n      util.printout(\"Verifying \"..pathname)\r\n      if file:match(\"%.rockspec$\") then\r\n         ok, err, errcode = validate_rockspec(pathname, \"one\")\r\n      elseif file:match(\"%.src%.rock$\") then\r\n         ok, err, errcode = validate_src_rock(pathname)\r\n      elseif file:match(\"%.rock$\") then\r\n         ok, err, errcode = validate_rock(pathname)\r\n      end\r\n      if ok then\r\n         table.insert(results.ok, {file=file} )\r\n      else\r\n         if not errcode then\r\n            errcode = \"misc\"\r\n         end\r\n         if not results[errcode] then\r\n            results[errcode] = {}\r\n         end\r\n         table.insert(results[errcode], {file=file, err=err} )\r\n      end\r\n      util.run_scheduled_functions()\r\n      if not flags[\"quick\"] then\r\n         fs.delete(sandbox)\r\n      end\r\n      repeat until not fs.pop_dir()\r\n   end end\r\n   if flags[\"quick\"] then\r\n      fs.delete(sandbox)\r\n   end\r\n   restore_settings(settings)\r\n   util.title(\"Results:\")\r\n   util.printout(\"OK: \"..tostring(#results.ok))\r\n   for _, entry in ipairs(results.ok) do\r\n      util.printout(entry.file)\r\n   end\r\n   for errcode, errors in pairs(results) do\r\n      if errcode ~= \"ok\" then\r\n         util.printout()\r\n         util.printout(errcode..\" errors: \"..tostring(#errors))\r\n         for _, entry in ipairs(errors) do\r\n            util.printout(entry.file, entry.err)\r\n         end\r\n      end\r\n   end\r\n\r\n   util.title(\"Summary:\")\r\n   local total = 0\r\n   for errcode, errors in pairs(results) do\r\n      util.printout(errcode..\": \"..tostring(#errors))\r\n      total = total + #errors\r\n   end\r\n   util.printout(\"Total: \"..total)\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 420,
    "text": "local function open_file(name)\r\n   return io.open(dir.path(fs.current_dir(), name), \"r\")\r\nend",
    "type": "function"
  }, {
    "id": 421,
    "text": "local function get_url(rockspec)\r\n   local url = rockspec.source.url\r\n   local file, temp_dir, err_code, err_file, err_temp_dir = fetch.fetch_sources(rockspec, false)\r\n   if err_code == \"source.dir\" then\r\n      file, temp_dir = err_file, err_temp_dir\r\n   elseif not file then\r\n      util.warning(\"Could not fetch sources - \"..temp_dir)\r\n      return false\r\n   end\r\n   util.printout(\"File successfully downloaded. Making checksum and checking base dir...\")\r\n   local md5 = nil\r\n   if fetch.is_basic_protocol(rockspec.source.protocol) then\r\n      rockspec.source.md5 = fs.get_md5(file)\r\n   end\r\n   local ok, err = fs.change_dir(temp_dir)\r\n   if not ok then return false end\r\n   fs.unpack_archive(file)\r\n   local base_dir = fetch.url_to_base_dir(url)\r\n   if not fs.exists(base_dir) then\r\n      util.printerr(\"Directory \"..base_dir..\" not found\")\r\n      local files = fs.list_dir()\r\n      if files[1] and fs.is_dir(files[1]) then\r\n         util.printerr(\"Found \"..files[1])\r\n         base_dir = files[1]\r\n      end\r\n   end\r\n   fs.pop_dir()\r\n   return true, base_dir, temp_dir\r\nend",
    "type": "function"
  }, {
    "id": 422,
    "text": "local function fill_as_builtin(rockspec, libs)\r\n   rockspec.build.type = \"builtin\"\r\n   rockspec.build.modules = {}\r\n   local prefix = \"\"\r\n\r\n   for _, parent in ipairs({\"src\", \"lua\"}) do\r\n      if fs.is_dir(parent) then\r\n         fs.change_dir(parent)\r\n         prefix = parent..\"/\"\r\n         break\r\n      end\r\n   end\r\n   \r\n   local incdirs, libdirs\r\n   if libs then\r\n      incdirs, libdirs = {}, {}\r\n      for _, lib in ipairs(libs) do\r\n         local upper = lib:upper()\r\n         incdirs[#incdirs+1] = \"$(\"..upper..\"_INCDIR)\"\r\n         libdirs[#libdirs+1] = \"$(\"..upper..\"_LIBDIR)\"\r\n      end\r\n   end\r\n\r\n   for _, file in ipairs(fs.find()) do\r\n      local luamod = file:match(\"(.*)%.lua$\")\r\n      if luamod and not luamod_blacklist[luamod] then\r\n         rockspec.build.modules[path.path_to_module(file)] = prefix..file\r\n      else\r\n         local cmod = file:match(\"(.*)%.c$\")\r\n         if cmod then\r\n            local modname = get_cmod_name(file) or path.path_to_module(file:gsub(\"%.c$\", \".lua\"))\r\n            rockspec.build.modules[modname] = {\r\n               sources = prefix..file,\r\n               libraries = libs,\r\n               incdirs = incdirs,\r\n               libdirs = libdirs,\r\n            }\r\n         end\r\n      end\r\n   end\r\n   \r\n   for _, directory in ipairs({ \"doc\", \"docs\", \"samples\", \"tests\" }) do\r\n      if fs.is_dir(directory) then\r\n         if not rockspec.build.copy_directories then\r\n            rockspec.build.copy_directories = {}\r\n         end\r\n         table.insert(rockspec.build.copy_directories, directory)\r\n      end\r\n   end\r\n   \r\n   if prefix ~= \"\" then\r\n      fs.pop_dir()\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 423,
    "text": "function run(...)\r\n   local flags, name, version, url_or_dir = util.parse_flags(...)\r\n   \r\n   if not name then\r\n      return nil, \"Missing arguments. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n\r\n   if name and not version then\r\n      url_or_dir = name\r\n      name = nil\r\n   elseif not url_or_dir then\r\n      url_or_dir = version\r\n   end\r\n\r\n   if flags[\"tag\"] == true then\r\n      return nil, \"Incorrect usage: --tag requires an argument. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n   \r\n   if flags[\"tag\"] then\r\n      if not version then\r\n         version = flags[\"tag\"]:gsub(\"^v\", \"\")\r\n      end\r\n   end\r\n   \r\n   local protocol, pathname = dir.split_url(url_or_dir)\r\n   if not fetch.is_basic_protocol(protocol) then\r\n      if not name then\r\n         name = dir.base_name(url_or_dir):gsub(\"%.[^.]+$\", \"\")\r\n      end\r\n      if not version then\r\n         version = \"scm\"\r\n      end\r\n   elseif protocol ~= \"file\" then\r\n      local filename = dir.base_name(url_or_dir)\r\n      local newname, newversion = filename:match(\"(.*)-([^-]+)\")\r\n      if (not name) and newname then\r\n         name = newname\r\n      end\r\n      if (not version) and newversion then\r\n         version = newversion:gsub(\".[a-z]+$\", \"\"):gsub(\".tar$\", \"\")\r\n      end\r\n      if not (name and version) then\r\n         return nil, \"Missing name and version arguments. \"..util.see_help(\"write_rockspec\")\r\n      end\r\n   elseif not version then\r\n      return nil, \"Missing name and version arguments. \"..util.see_help(\"write_rockspec\")\r\n   end\r\n\r\n   local filename = flags[\"output\"] or dir.path(fs.current_dir(), name:lower()..\"-\"..version..\"-1.rockspec\")\r\n   \r\n   if not flags[\"homepage\"] and url_or_dir:match(\"^git://github.com\") then\r\n      flags[\"homepage\"] = \"http://\"..url_or_dir:match(\"^[^:]+://(.*)\")\r\n   end\r\n\r\n   local rockspec = {\r\n      package = name,\r\n      name = name:lower(),\r\n      version = version..\"-1\",\r\n      source = {\r\n         url = \"*** please add URL for source tarball, zip or repository here ***\",\r\n         tag = flags[\"tag\"],\r\n      },\r\n      description = {\r\n         summary = flags[\"summary\"] or \"*** please specify description summary ***\",\r\n         detailed = flags[\"detailed\"] or \"*** please enter a detailed description ***\",\r\n         homepage = flags[\"homepage\"] or \"*** please enter a project homepage ***\",\r\n         license = flags[\"license\"] or \"*** please specify a license ***\",\r\n      },\r\n      dependencies = {},\r\n      build = {},\r\n   }\r\n   path.configure_paths(rockspec)\r\n   rockspec.source.protocol = protocol\r\n   \r\n   configure_lua_version(rockspec, flags[\"lua-version\"])\r\n   \r\n   local local_dir = url_or_dir\r\n\r\n   if url_or_dir:match(\"://\") then\r\n      rockspec.source.url = url_or_dir\r\n      rockspec.source.file = dir.base_name(url_or_dir)\r\n      rockspec.source.dir = \"dummy\"\r\n      if not fetch.is_basic_protocol(rockspec.source.protocol) then\r\n         if version ~= \"scm\" then\r\n            rockspec.source.tag = flags[\"tag\"] or \"v\" .. version\r\n         end\r\n      end\r\n      rockspec.source.dir = nil\r\n      local ok, base_dir, temp_dir = get_url(rockspec)\r\n      if ok then\r\n         if base_dir ~= dir.base_name(url_or_dir) then\r\n            rockspec.source.dir = base_dir\r\n         end\r\n      end\r\n      if base_dir then\r\n         local_dir = dir.path(temp_dir, base_dir)\r\n      else\r\n         local_dir = nil\r\n      end\r\n   end\r\n   \r\n   if not local_dir then\r\n      local_dir = \".\"\r\n   end\r\n   \r\n   local libs = nil\r\n   if flags[\"lib\"] then\r\n      libs = {}\r\n      rockspec.external_dependencies = {}\r\n      for lib in flags[\"lib\"]:gmatch(\"([^,]+)\") do\r\n         table.insert(libs, lib)\r\n         rockspec.external_dependencies[lib:upper()] = {\r\n            library = lib\r\n         }\r\n      end\r\n   end\r\n\r\n   local ok, err = fs.change_dir(local_dir)\r\n   if not ok then return nil, \"Failed reaching files from project - error entering directory \"..local_dir end\r\n\r\n   detect_description(rockspec)\r\n\r\n   local is_mit = show_license(rockspec)\r\n   \r\n   if is_mit and not flags[\"license\"] then\r\n      rockspec.description.license = \"MIT\"\r\n   end\r\n   \r\n   fill_as_builtin(rockspec, libs)\r\n      \r\n   rockspec_cleanup(rockspec)\r\n   \r\n   persist.save_from_table(filename, rockspec, type_check.rockspec_order)\r\n\r\n   util.printout()   \r\n   util.printout(\"Wrote template at \"..filename..\" -- you should now edit and finish it.\")\r\n   util.printout()   \r\n\r\n   return true\r\nend",
    "type": "function"
  }, {
    "id": 424,
    "text": "absolute_name",
    "type": "global function"
  }, {
    "id": 425,
    "text": "touch",
    "type": "global function"
  }, {
    "id": 426,
    "text": "rmdir",
    "type": "global function"
  }, {
    "id": 427,
    "text": "currentdir",
    "type": "global function"
  }, {
    "id": 428,
    "text": "quiet",
    "type": "global function"
  }, {
    "id": 429,
    "text": "mkdir",
    "type": "global function"
  }, {
    "id": 430,
    "text": "attributes",
    "type": "global function"
  }, {
    "id": 431,
    "text": "chdir",
    "type": "global function"
  }, {
    "id": 432,
    "text": "dir",
    "type": "global function"
  }, {
    "id": 433,
    "text": "sink.table",
    "type": "global function"
  }, {
    "id": 434,
    "text": "pump.step",
    "type": "global function"
  }, {
    "id": 435,
    "text": "write",
    "type": "global function"
  }, {
    "id": 436,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 437,
    "text": "getenv",
    "type": "global function"
  }, {
    "id": 438,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 439,
    "text": "flush",
    "type": "global function"
  }, {
    "id": 440,
    "text": "ipairs",
    "type": "global function"
  }, {
    "id": 441,
    "text": "request",
    "type": "global function"
  }, {
    "id": 442,
    "text": "pcall",
    "type": "global function"
  }, {
    "id": 443,
    "text": "module",
    "type": "global function"
  }, {
    "id": 444,
    "text": "random",
    "type": "global function"
  }, {
    "id": 445,
    "text": "open",
    "type": "global function"
  }, {
    "id": 446,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 447,
    "text": "remove",
    "type": "global function"
  }, {
    "id": 448,
    "text": "zip",
    "type": "global function"
  }, {
    "id": 449,
    "text": "sumhexa",
    "type": "global function"
  }, {
    "id": 450,
    "text": "files",
    "type": "global function"
  }, {
    "id": 451,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 452,
    "text": "floor",
    "type": "global function"
  }, {
    "id": 453,
    "text": "get",
    "type": "global function"
  }, {
    "id": 454,
    "text": "remove",
    "type": "global function"
  }, {
    "id": 455,
    "text": "execute",
    "type": "global function"
  }, {
    "id": 456,
    "text": "open",
    "type": "global function"
  }, {
    "id": 457,
    "text": "randomseed",
    "type": "global function"
  }, {
    "id": 458,
    "text": "type",
    "type": "global function"
  }, {
    "id": 459,
    "text": "stat",
    "type": "global function"
  }, {
    "id": 460,
    "text": "time",
    "type": "global function"
  }, {
    "id": 461,
    "text": "chmod",
    "type": "global function"
  }, {
    "id": 462,
    "text": "require",
    "type": "global function"
  }, {
    "id": 463,
    "text": "cfg)",
    "type": "module"
  }, {
    "id": 464,
    "text": "util)",
    "type": "module"
  }, {
    "id": 465,
    "text": "dir)",
    "type": "module"
  }, {
    "id": 466,
    "text": "fs)",
    "type": "module"
  }, {
    "id": 467,
    "text": "path)",
    "type": "module"
  }, {
    "id": 468,
    "text": "",
    "type": "variable container"
  }, {
    "id": 469,
    "text": "",
    "type": "require container"
  }, {
    "id": 470,
    "text": "",
    "type": "local variable"
  }, {
    "id": 471,
    "text": "",
    "type": "local variable"
  }, {
    "id": 472,
    "text": "",
    "type": "local variable"
  }, {
    "id": 473,
    "text": "",
    "type": "local variable"
  }, {
    "id": 474,
    "text": "",
    "type": "local variable"
  }, {
    "id": 475,
    "text": "",
    "type": "local variable"
  }, {
    "id": 476,
    "text": "",
    "type": "local variable"
  }, {
    "id": 477,
    "text": "",
    "type": "local variable"
  }, {
    "id": 478,
    "text": "",
    "type": "local variable"
  }, {
    "id": 479,
    "text": "",
    "type": "local variable"
  }, {
    "id": 480,
    "text": "",
    "type": "local variable"
  }, {
    "id": 481,
    "text": "",
    "type": "local variable"
  }, {
    "id": 482,
    "text": "",
    "type": "local variable"
  }, {
    "id": 483,
    "text": "",
    "type": "local variable"
  }, {
    "id": 484,
    "text": "",
    "type": "local variable"
  }, {
    "id": 485,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 486,
    "text": "",
    "type": "global variable"
  }, {
    "id": 487,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 488,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 489,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 490,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 491,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 492,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 493,
    "text": "patch)",
    "type": "module"
  }, {
    "id": 494,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 495,
    "text": "(ltn12)",
    "type": "module"
  } ]
}