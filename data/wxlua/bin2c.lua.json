{
  "_filename": "bin2c.lua",
  "_isShebang": true,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/wxlua/util/bin2c/bin2c.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "has",
    "to": 3
  }, {
    "from": 2,
    "label": "has",
    "to": 4
  }, {
    "from": 5,
    "label": "has",
    "to": 6
  }, {
    "from": 5,
    "label": "has",
    "to": 7
  }, {
    "from": 5,
    "label": "has",
    "to": 8
  }, {
    "from": 5,
    "label": "has",
    "to": 9
  }, {
    "from": 5,
    "label": "has",
    "to": 8
  }, {
    "from": 5,
    "label": "has",
    "to": 10
  }, {
    "from": 11,
    "label": "has",
    "to": 12
  }, {
    "from": 11,
    "label": "has",
    "to": 13
  }, {
    "from": 11,
    "label": "has",
    "to": 8
  }, {
    "from": 11,
    "label": "has",
    "to": 14
  }, {
    "from": 14,
    "label": "has",
    "to": 15
  }, {
    "from": 14,
    "label": "has",
    "to": 16
  }, {
    "from": 14,
    "label": "has",
    "to": 17
  }, {
    "from": 14,
    "label": "has",
    "to": 18
  }, {
    "from": 18,
    "label": "has",
    "to": 19
  }, {
    "from": 11,
    "label": "has",
    "to": 8
  }, {
    "from": 11,
    "label": "has",
    "to": 20
  }, {
    "from": 11,
    "label": "has",
    "to": 21
  }, {
    "from": 11,
    "label": "has",
    "to": 19
  }, {
    "from": 11,
    "label": "has",
    "to": 22
  }, {
    "from": 11,
    "label": "has",
    "to": 8
  }, {
    "from": 11,
    "label": "has",
    "to": 8
  }, {
    "from": 11,
    "label": "has",
    "to": 23
  }, {
    "from": 24,
    "label": "has",
    "to": 25
  }, {
    "from": 24,
    "label": "has",
    "to": 26
  }, {
    "from": 26,
    "label": "has",
    "to": 27
  }, {
    "from": 24,
    "label": "has",
    "to": 8
  }, {
    "from": 24,
    "label": "has",
    "to": 28
  }, {
    "from": 24,
    "label": "has",
    "to": 29
  }, {
    "from": 24,
    "label": "has",
    "to": 30
  }, {
    "from": 30,
    "label": "has",
    "to": 31
  }, {
    "from": 24,
    "label": "has",
    "to": 8
  }, {
    "from": 24,
    "label": "has",
    "to": 32
  }, {
    "from": 32,
    "label": "has",
    "to": 33
  }, {
    "from": 24,
    "label": "has",
    "to": 34
  }, {
    "from": 24,
    "label": "has",
    "to": 35
  }, {
    "from": 24,
    "label": "has",
    "to": 8
  }, {
    "from": 24,
    "label": "has",
    "to": 36
  }, {
    "from": 37,
    "label": "has",
    "to": 38
  }, {
    "from": 37,
    "label": "has",
    "to": 39
  }, {
    "from": 37,
    "label": "has",
    "to": 9
  }, {
    "from": 37,
    "label": "has",
    "to": 8
  }, {
    "from": 37,
    "label": "has",
    "to": 40
  }, {
    "from": 41,
    "label": "has",
    "to": 42
  }, {
    "from": 41,
    "label": "has",
    "to": 43
  }, {
    "from": 41,
    "label": "has",
    "to": 44
  }, {
    "from": 41,
    "label": "has",
    "to": 45
  }, {
    "from": 41,
    "label": "has",
    "to": 46
  }, {
    "from": 41,
    "label": "has",
    "to": 47
  }, {
    "from": 41,
    "label": "has",
    "to": 48
  }, {
    "from": 41,
    "label": "has",
    "to": 49
  }, {
    "from": 41,
    "label": "has",
    "to": 50
  }, {
    "from": 41,
    "label": "has",
    "to": 51
  }, {
    "from": 41,
    "label": "has",
    "to": 52
  }, {
    "from": 41,
    "label": "has",
    "to": 53
  }, {
    "from": 53,
    "label": "has",
    "to": 54
  }, {
    "from": 41,
    "label": "has",
    "to": 8
  }, {
    "from": 41,
    "label": "has",
    "to": 55
  }, {
    "from": 56,
    "label": "has",
    "to": 57
  }, {
    "from": 56,
    "label": "has",
    "to": 58
  }, {
    "from": 56,
    "label": "has",
    "to": 59
  }, {
    "from": 56,
    "label": "has",
    "to": 60
  }, {
    "from": 56,
    "label": "has",
    "to": 61
  }, {
    "from": 56,
    "label": "has",
    "to": 62
  }, {
    "from": 56,
    "label": "has",
    "to": 63
  }, {
    "from": 63,
    "label": "has",
    "to": 64
  }, {
    "from": 63,
    "label": "has",
    "to": 65
  }, {
    "from": 56,
    "label": "has",
    "to": 66
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 66,
    "label": "has",
    "to": 68
  }, {
    "from": 68,
    "label": "has",
    "to": 69
  }, {
    "from": 68,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 70,
    "label": "has",
    "to": 72
  }, {
    "from": 68,
    "label": "has",
    "to": 73
  }, {
    "from": 73,
    "label": "has",
    "to": 74
  }, {
    "from": 68,
    "label": "has",
    "to": 75
  }, {
    "from": 68,
    "label": "has",
    "to": 76
  }, {
    "from": 68,
    "label": "has",
    "to": 77
  }, {
    "from": 68,
    "label": "has",
    "to": 78
  }, {
    "from": 66,
    "label": "has",
    "to": 79
  }, {
    "from": 79,
    "label": "has",
    "to": 80
  }, {
    "from": 79,
    "label": "has",
    "to": 81
  }, {
    "from": 66,
    "label": "has",
    "to": 71
  }, {
    "from": 56,
    "label": "has",
    "to": 82
  }, {
    "from": 56,
    "label": "has",
    "to": 8
  }, {
    "from": 56,
    "label": "has",
    "to": 83
  }, {
    "from": 84,
    "label": "has",
    "to": 85
  }, {
    "from": 84,
    "label": "has",
    "to": 60
  }, {
    "from": 84,
    "label": "has",
    "to": 62
  }, {
    "from": 84,
    "label": "has",
    "to": 86
  }, {
    "from": 86,
    "label": "has",
    "to": 87
  }, {
    "from": 86,
    "label": "has",
    "to": 78
  }, {
    "from": 86,
    "label": "has",
    "to": 88
  }, {
    "from": 86,
    "label": "has",
    "to": 89
  }, {
    "from": 89,
    "label": "has",
    "to": 80
  }, {
    "from": 89,
    "label": "has",
    "to": 81
  }, {
    "from": 89,
    "label": "has",
    "to": 90
  }, {
    "from": 84,
    "label": "has",
    "to": 91
  }, {
    "from": 84,
    "label": "has",
    "to": 8
  }, {
    "from": 84,
    "label": "has",
    "to": 92
  }, {
    "from": 93,
    "label": "has",
    "to": 94
  }, {
    "from": 93,
    "label": "has",
    "to": 95
  }, {
    "from": 93,
    "label": "has",
    "to": 96
  }, {
    "from": 93,
    "label": "has",
    "to": 97
  }, {
    "from": 93,
    "label": "has",
    "to": 98
  }, {
    "from": 93,
    "label": "has",
    "to": 99
  }, {
    "from": 93,
    "label": "has",
    "to": 100
  }, {
    "from": 93,
    "label": "has",
    "to": 101
  }, {
    "from": 93,
    "label": "has",
    "to": 102
  }, {
    "from": 93,
    "label": "has",
    "to": 103
  }, {
    "from": 93,
    "label": "has",
    "to": 104
  }, {
    "from": 93,
    "label": "has",
    "to": 105
  }, {
    "from": 93,
    "label": "has",
    "to": 106
  }, {
    "from": 93,
    "label": "has",
    "to": 107
  }, {
    "from": 93,
    "label": "has",
    "to": 108
  }, {
    "from": 93,
    "label": "has",
    "to": 109
  }, {
    "from": 93,
    "label": "has",
    "to": 110
  }, {
    "from": 93,
    "label": "has",
    "to": 111
  }, {
    "from": 93,
    "label": "has",
    "to": 112
  }, {
    "from": 93,
    "label": "has",
    "to": 113
  }, {
    "from": 93,
    "label": "has",
    "to": 114
  }, {
    "from": 93,
    "label": "has",
    "to": 115
  }, {
    "from": 116,
    "label": "has",
    "to": 117
  }, {
    "from": 116,
    "label": "has",
    "to": 118
  }, {
    "from": 116,
    "label": "has",
    "to": 119
  }, {
    "from": 116,
    "label": "has",
    "to": 120
  }, {
    "from": 116,
    "label": "has",
    "to": 121
  }, {
    "from": 116,
    "label": "has",
    "to": 122
  }, {
    "from": 116,
    "label": "has",
    "to": 123
  }, {
    "from": 116,
    "label": "has",
    "to": 124
  }, {
    "from": 116,
    "label": "has",
    "to": 125
  }, {
    "from": 116,
    "label": "has",
    "to": 126
  }, {
    "from": 116,
    "label": "has",
    "to": 127
  }, {
    "from": 127,
    "label": "has",
    "to": 128
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 128,
    "label": "has",
    "to": 130
  }, {
    "from": 128,
    "label": "has",
    "to": 131
  }, {
    "from": 128,
    "label": "has",
    "to": 132
  }, {
    "from": 128,
    "label": "has",
    "to": 133
  }, {
    "from": 128,
    "label": "has",
    "to": 134
  }, {
    "from": 128,
    "label": "has",
    "to": 135
  }, {
    "from": 128,
    "label": "has",
    "to": 71
  }, {
    "from": 128,
    "label": "has",
    "to": 136
  }, {
    "from": 128,
    "label": "has",
    "to": 137
  }, {
    "from": 128,
    "label": "has",
    "to": 71
  }, {
    "from": 128,
    "label": "has",
    "to": 138
  }, {
    "from": 128,
    "label": "has",
    "to": 139
  }, {
    "from": 127,
    "label": "has",
    "to": 71
  }, {
    "from": 116,
    "label": "has",
    "to": 140
  }, {
    "from": 140,
    "label": "has",
    "to": 141
  }, {
    "from": 116,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 142
  }, {
    "from": 142,
    "label": "has",
    "to": 143
  }, {
    "from": 142,
    "label": "has",
    "to": 141
  }, {
    "from": 116,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 144
  }, {
    "from": 144,
    "label": "has",
    "to": 145
  }, {
    "from": 144,
    "label": "has",
    "to": 141
  }, {
    "from": 116,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 146
  }, {
    "from": 146,
    "label": "has",
    "to": 147
  }, {
    "from": 146,
    "label": "has",
    "to": 141
  }, {
    "from": 116,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 148
  }, {
    "from": 148,
    "label": "has",
    "to": 149
  }, {
    "from": 148,
    "label": "has",
    "to": 141
  }, {
    "from": 116,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 150
  }, {
    "from": 150,
    "label": "has",
    "to": 151
  }, {
    "from": 150,
    "label": "has",
    "to": 141
  }, {
    "from": 116,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 152
  }, {
    "from": 152,
    "label": "has",
    "to": 153
  }, {
    "from": 152,
    "label": "has",
    "to": 141
  }, {
    "from": 116,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 154
  }, {
    "from": 154,
    "label": "has",
    "to": 155
  }, {
    "from": 154,
    "label": "has",
    "to": 156
  }, {
    "from": 154,
    "label": "has",
    "to": 157
  }, {
    "from": 157,
    "label": "has",
    "to": 158
  }, {
    "from": 157,
    "label": "has",
    "to": 159
  }, {
    "from": 154,
    "label": "has",
    "to": 160
  }, {
    "from": 154,
    "label": "has",
    "to": 161
  }, {
    "from": 161,
    "label": "has",
    "to": 158
  }, {
    "from": 161,
    "label": "has",
    "to": 162
  }, {
    "from": 116,
    "label": "has",
    "to": 163
  }, {
    "from": 116,
    "label": "has",
    "to": 164
  }, {
    "from": 116,
    "label": "has",
    "to": 60
  }, {
    "from": 116,
    "label": "has",
    "to": 165
  }, {
    "from": 165,
    "label": "has",
    "to": 166
  }, {
    "from": 165,
    "label": "has",
    "to": 167
  }, {
    "from": 116,
    "label": "has",
    "to": 168
  }, {
    "from": 116,
    "label": "has",
    "to": 169
  }, {
    "from": 169,
    "label": "has",
    "to": 170
  }, {
    "from": 170,
    "label": "has",
    "to": 171
  }, {
    "from": 169,
    "label": "has",
    "to": 172
  }, {
    "from": 116,
    "label": "has",
    "to": 173
  }, {
    "from": 2,
    "label": "calls",
    "to": 185
  }, {
    "from": 41,
    "label": "calls",
    "to": 185
  }, {
    "from": 41,
    "label": "calls",
    "to": 185
  }, {
    "from": 41,
    "label": "calls",
    "to": 185
  }, {
    "from": 41,
    "label": "calls",
    "to": 185
  }, {
    "from": 41,
    "label": "calls",
    "to": 185
  }, {
    "from": 56,
    "label": "calls",
    "to": 185
  }, {
    "from": 56,
    "label": "calls",
    "to": 185
  }, {
    "from": 56,
    "label": "calls",
    "to": 185
  }, {
    "from": 56,
    "label": "calls",
    "to": 185
  }, {
    "from": 56,
    "label": "calls",
    "to": 185
  }, {
    "from": 56,
    "label": "calls",
    "to": 185
  }, {
    "from": 84,
    "label": "calls",
    "to": 185
  }, {
    "from": 24,
    "label": "calls",
    "to": 182
  }, {
    "from": 37,
    "label": "calls",
    "to": 182
  }, {
    "from": 5,
    "label": "calls",
    "to": 183
  }, {
    "from": 11,
    "label": "calls",
    "to": 183
  }, {
    "from": 11,
    "label": "calls",
    "to": 183
  }, {
    "from": 37,
    "label": "calls",
    "to": 183
  }, {
    "from": 5,
    "label": "calls",
    "to": 188
  }, {
    "from": 11,
    "label": "calls",
    "to": 188
  }, {
    "from": 24,
    "label": "calls",
    "to": 188
  }, {
    "from": 37,
    "label": "calls",
    "to": 188
  }, {
    "from": 116,
    "label": "calls",
    "to": 37
  }, {
    "from": 116,
    "label": "calls",
    "to": 187
  }, {
    "from": 116,
    "label": "calls",
    "to": 187
  }, {
    "from": 116,
    "label": "calls",
    "to": 187
  }, {
    "from": 116,
    "label": "calls",
    "to": 187
  }, {
    "from": 174,
    "label": "calls",
    "to": 116
  }, {
    "from": 56,
    "label": "calls",
    "to": 178
  }, {
    "from": 116,
    "label": "calls",
    "to": 178
  }, {
    "from": 116,
    "label": "calls",
    "to": 178
  }, {
    "from": 56,
    "label": "calls",
    "to": 180
  }, {
    "from": 116,
    "label": "calls",
    "to": 56
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 41,
    "label": "calls",
    "to": 179
  }, {
    "from": 56,
    "label": "calls",
    "to": 179
  }, {
    "from": 56,
    "label": "calls",
    "to": 179
  }, {
    "from": 84,
    "label": "calls",
    "to": 179
  }, {
    "from": 84,
    "label": "calls",
    "to": 179
  }, {
    "from": 116,
    "label": "calls",
    "to": 186
  }, {
    "from": 11,
    "label": "calls",
    "to": 181
  }, {
    "from": 56,
    "label": "calls",
    "to": 181
  }, {
    "from": 56,
    "label": "calls",
    "to": 181
  }, {
    "from": 84,
    "label": "calls",
    "to": 181
  }, {
    "from": 116,
    "label": "calls",
    "to": 84
  }, {
    "from": 24,
    "label": "calls",
    "to": 177
  }, {
    "from": 24,
    "label": "calls",
    "to": 177
  }, {
    "from": 24,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 93,
    "label": "calls",
    "to": 177
  }, {
    "from": 116,
    "label": "calls",
    "to": 177
  }, {
    "from": 116,
    "label": "calls",
    "to": 177
  }, {
    "from": 116,
    "label": "calls",
    "to": 177
  }, {
    "from": 116,
    "label": "calls",
    "to": 177
  }, {
    "from": 116,
    "label": "calls",
    "to": 177
  }, {
    "from": 116,
    "label": "calls",
    "to": 177
  }, {
    "from": 116,
    "label": "calls",
    "to": 2
  }, {
    "from": 2,
    "label": "calls",
    "to": 175
  }, {
    "from": 2,
    "label": "calls",
    "to": 184
  }, {
    "from": 24,
    "label": "calls",
    "to": 11
  }, {
    "from": 56,
    "label": "calls",
    "to": 189
  }, {
    "from": 56,
    "label": "calls",
    "to": 189
  }, {
    "from": 56,
    "label": "calls",
    "to": 189
  }, {
    "from": 56,
    "label": "calls",
    "to": 189
  }, {
    "from": 84,
    "label": "calls",
    "to": 189
  }, {
    "from": 116,
    "label": "calls",
    "to": 93
  }, {
    "from": 116,
    "label": "calls",
    "to": 93
  }, {
    "from": 116,
    "label": "calls",
    "to": 93
  }, {
    "from": 116,
    "label": "calls",
    "to": 93
  }, {
    "from": 116,
    "label": "calls",
    "to": 93
  }, {
    "from": 116,
    "label": "calls",
    "to": 93
  }, {
    "from": 116,
    "label": "calls",
    "to": 93
  }, {
    "from": 116,
    "label": "calls",
    "to": 5
  }, {
    "from": 116,
    "label": "calls",
    "to": 24
  }, {
    "from": 116,
    "label": "calls",
    "to": 41
  }, {
    "from": 37,
    "label": "calls",
    "to": 176
  }, {
    "from": 116,
    "label": "calls",
    "to": 176
  }, {
    "from": 1,
    "label": "contains",
    "to": 174
  }, {
    "from": 174,
    "label": "declares",
    "to": 2
  }, {
    "from": 174,
    "label": "declares",
    "to": 5
  }, {
    "from": 174,
    "label": "declares",
    "to": 11
  }, {
    "from": 174,
    "label": "declares",
    "to": 24
  }, {
    "from": 174,
    "label": "declares",
    "to": 37
  }, {
    "from": 174,
    "label": "declares",
    "to": 41
  }, {
    "from": 174,
    "label": "declares",
    "to": 56
  }, {
    "from": 174,
    "label": "declares",
    "to": 84
  }, {
    "from": 174,
    "label": "declares",
    "to": 93
  }, {
    "from": 174,
    "label": "declares",
    "to": 116
  }, {
    "from": 1,
    "label": "contains",
    "to": 190
  }, {
    "from": 1,
    "label": "contains",
    "to": 191
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "bin2c",
    "type": "module"
  }, {
    "id": 2,
    "text": "function printf(...)\r\n    io.write(string.format(unpack(arg)))\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "io.write(string.format(unpack(arg)))",
    "type": "statement:functioncall"
  }, {
    "id": 4,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 5,
    "text": "function FileExists(filename)\r\n    local file = io.open(filename, \"r\")\r\n    if (file == nil) then return false end\r\n    io.close(file)\r\n    return true\r\nend",
    "type": "function"
  }, {
    "id": 6,
    "text": "local file = io.open(filename, \"r\")",
    "type": "statement:localassign"
  }, {
    "id": 7,
    "text": "if (file == nil) then return false end",
    "type": "statement:if"
  }, {
    "id": 8,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 9,
    "text": "io.close(file)",
    "type": "statement:functioncall"
  }, {
    "id": 10,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 11,
    "text": "function FileDataIsTableData(filename, fileData)\r\n    local file_handle = io.open(filename)\r\n    if not file_handle then return false end -- ok if it doesn't exist\r\n\r\n    for n = 1, #fileData do\r\n        local line = fileData[n]\r\n        local len = string.len(line)\r\n        local file_line = file_handle:read(len)\r\n\r\n        if line ~= file_line then\r\n            io.close(file_handle)\r\n            return false\r\n        end\r\n    end\r\n\r\n    local cur_file_pos = file_handle:seek(\"cur\")\r\n    local end_file_pos = file_handle:seek(\"end\")\r\n    io.close(file_handle)\r\n\r\n    if cur_file_pos ~= end_file_pos then return false end -- file is bigger\r\n\r\n    return true\r\nend",
    "type": "function"
  }, {
    "id": 12,
    "text": "local file_handle = io.open(filename)",
    "type": "statement:localassign"
  }, {
    "id": 13,
    "text": "if not file_handle then return false end",
    "type": "statement:if"
  }, {
    "id": 14,
    "text": "for n = 1, #fileData do\r\n        local line = fileData[n]\r\n        local len = string.len(line)\r\n        local file_line = file_handle:read(len)\r\n\r\n        if line ~= file_line then\r\n            io.close(file_handle)\r\n            return false\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 15,
    "text": "local line = fileData[n]",
    "type": "statement:localassign"
  }, {
    "id": 16,
    "text": "local len = string.len(line)",
    "type": "statement:localassign"
  }, {
    "id": 17,
    "text": "local file_line = file_handle:read(len)",
    "type": "statement:localassign"
  }, {
    "id": 18,
    "text": "if line ~= file_line then\r\n            io.close(file_handle)\r\n            return false\r\n        end",
    "type": "statement:if"
  }, {
    "id": 19,
    "text": "io.close(file_handle)",
    "type": "statement:functioncall"
  }, {
    "id": 20,
    "text": "local cur_file_pos = file_handle:seek(\"cur\")",
    "type": "statement:localassign"
  }, {
    "id": 21,
    "text": "local end_file_pos = file_handle:seek(\"end\")",
    "type": "statement:localassign"
  }, {
    "id": 22,
    "text": "if cur_file_pos ~= end_file_pos then return false end",
    "type": "statement:if"
  }, {
    "id": 23,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 24,
    "text": "function WriteTableToFile(filename, fileData, overwrite_always)\r\n    assert(filename and fileData, \"Invalid filename or fileData in WriteTableToFile\")\r\n\r\n    if (not overwrite_always) and FileDataIsTableData(filename, fileData) then\r\n        print(\"bin2c.lua - No changes to file : '\"..filename..\"'\")\r\n        return false\r\n    end\r\n\r\n    print(\"bin2c.lua - Updating file : '\"..filename..\"'\")\r\n\r\n    local outfile = io.open(filename, \"w+\")\r\n    if not outfile then\r\n        print(\"Unable to open file for writing '\"..filename..\"'.\")\r\n        return false\r\n    end\r\n\r\n    for n = 1, #fileData do\r\n        outfile:write(fileData[n])\r\n    end\r\n\r\n    outfile:flush()\r\n    outfile:close()\r\n    return true\r\nend",
    "type": "function"
  }, {
    "id": 25,
    "text": "assert(filename and fileData, \"Invalid filename or fileData in WriteTableToFile\")",
    "type": "statement:functioncall"
  }, {
    "id": 26,
    "text": "if (not overwrite_always) and FileDataIsTableData(filename, fileData) then\r\n        print(\"bin2c.lua - No changes to file : '\"..filename..\"'\")\r\n        return false\r\n    end",
    "type": "statement:if"
  }, {
    "id": 27,
    "text": "print(\"bin2c.lua - No changes to file : '\"..filename..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 28,
    "text": "print(\"bin2c.lua - Updating file : '\"..filename..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 29,
    "text": "local outfile = io.open(filename, \"w+\")",
    "type": "statement:localassign"
  }, {
    "id": 30,
    "text": "if not outfile then\r\n        print(\"Unable to open file for writing '\"..filename..\"'.\")\r\n        return false\r\n    end",
    "type": "statement:if"
  }, {
    "id": 31,
    "text": "print(\"Unable to open file for writing '\"..filename..\"'.\")",
    "type": "statement:functioncall"
  }, {
    "id": 32,
    "text": "for n = 1, #fileData do\r\n        outfile:write(fileData[n])\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 33,
    "text": "outfile:write(fileData[n])",
    "type": "statement:functioncall"
  }, {
    "id": 34,
    "text": "outfile:flush()",
    "type": "statement:functioncall"
  }, {
    "id": 35,
    "text": "outfile:close()",
    "type": "statement:functioncall"
  }, {
    "id": 36,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 37,
    "text": "function ReadBinaryFile(fileName)\r\n    local file = assert(io.open(fileName, \"rb\"),\r\n                        \"Invalid input file : '\"..tostring(fileName)..\"'\\n\")\r\n    local fileData = file:read(\"*all\")\r\n    io.close(file)\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 38,
    "text": "local file = assert(io.open(fileName, \"rb\"),\r\n                        \"Invalid input file : '\"..tostring(fileName)..\"'\\n\")",
    "type": "statement:localassign"
  }, {
    "id": 39,
    "text": "local fileData = file:read(\"*all\")",
    "type": "statement:localassign"
  }, {
    "id": 40,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 41,
    "text": "function CreateHeader(stringName, fileName, fileSize, outTable)\r\n    local headerTable = {}\r\n\r\n    table.insert(headerTable, \"/* Generated by bin2c.lua and should be compiled with your program. */\\n\")\r\n    table.insert(headerTable, \"/* Access with :                                                    */\\n\")\r\n    table.insert(headerTable, \"/*   extern const size_t stringname_len; (excludes teminating NULL) */\\n\")\r\n    table.insert(headerTable, \"/*   extern const unsigned char stringname[];                       */\\n\\n\")\r\n    table.insert(headerTable, \"#include <stdio.h>   /* for size_t */\\n\\n\")\r\n\r\n    table.insert(headerTable, string.format(\"/* Original filename: '%s' */\\n\", fileName))\r\n    table.insert(headerTable, string.format(\"extern const size_t %s_len;\\n\", stringName))\r\n    table.insert(headerTable, string.format(\"extern const unsigned char %s[];\\n\\n\", stringName))\r\n\r\n    table.insert(headerTable, string.format(\"const size_t %s_len = %d;\\n\", stringName, fileSize))\r\n    table.insert(headerTable, string.format(\"const unsigned char %s[%d] = {\\n\", stringName, fileSize+1))\r\n\r\n    -- prepend the header to the outTable in reverse order\r\n    for n = #headerTable, 1, -1 do\r\n        table.insert(outTable, 1, headerTable[n])\r\n    end\r\n\r\n    return outTable\r\nend",
    "type": "function"
  }, {
    "id": 42,
    "text": "local headerTable = {}",
    "type": "statement:localassign"
  }, {
    "id": 43,
    "text": "table.insert(headerTable, \"/* Generated by bin2c.lua and should be compiled with your program. */\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 44,
    "text": "table.insert(headerTable, \"/* Access with :                                                    */\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 45,
    "text": "table.insert(headerTable, \"/*   extern const size_t stringname_len; (excludes teminating NULL) */\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 46,
    "text": "table.insert(headerTable, \"/*   extern const unsigned char stringname[];                       */\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 47,
    "text": "table.insert(headerTable, \"#include <stdio.h>   /* for size_t */\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 48,
    "text": "table.insert(headerTable, string.format(\"/* Original filename: '%s' */\\n\", fileName))",
    "type": "statement:functioncall"
  }, {
    "id": 49,
    "text": "table.insert(headerTable, string.format(\"extern const size_t %s_len;\\n\", stringName))",
    "type": "statement:functioncall"
  }, {
    "id": 50,
    "text": "table.insert(headerTable, string.format(\"extern const unsigned char %s[];\\n\\n\", stringName))",
    "type": "statement:functioncall"
  }, {
    "id": 51,
    "text": "table.insert(headerTable, string.format(\"const size_t %s_len = %d;\\n\", stringName, fileSize))",
    "type": "statement:functioncall"
  }, {
    "id": 52,
    "text": "table.insert(headerTable, string.format(\"const unsigned char %s[%d] = {\\n\", stringName, fileSize+1))",
    "type": "statement:functioncall"
  }, {
    "id": 53,
    "text": "for n = #headerTable, 1, -1 do\r\n        table.insert(outTable, 1, headerTable[n])\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 54,
    "text": "table.insert(outTable, 1, headerTable[n])",
    "type": "statement:functioncall"
  }, {
    "id": 55,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 56,
    "text": "function CreateTextData(fileData, outTable, line_ending)\r\n    local CR  = string.byte(\"\\r\") -- DOS = CRLF, Unix = LF, Mac = CR\r\n    local LF  = string.byte(\"\\n\")\r\n    local file_len = string.len(fileData)\r\n    local len = 0\r\n    local n   = 1\r\n    local str = \"\"\r\n\r\n    if line_ending then\r\n        local switch = {\r\n            cr   = string.format(\"%3u,\", CR),\r\n            lf   = string.format(\"%3u,\", LF),\r\n            crlf = string.format(\"%3u,%3u,\", CR, LF) }\r\n\r\n        line_ending = switch[string.sub(line_ending, 2)] -- remove leading '-'\r\n    end\r\n\r\n    while ( n <= file_len ) do\r\n        local byte = string.byte(fileData, n)\r\n\r\n        if (byte == CR) or (byte == LF) then\r\n            local line_end_str = string.format(\"%3u,\", byte)\r\n\r\n            -- handle DOS CRLF line endings by adding the LF before new line\r\n            if (byte == CR) and (n < file_len) and (string.byte(fileData, n+1) == LF) then\r\n                n = n + 1\r\n                line_end_str = line_end_str..string.format(\"%3u,\", LF)\r\n            end\r\n\r\n            -- replace with user specified line ending\r\n            if line_ending ~= nil then\r\n                line_end_str = line_ending\r\n            end\r\n\r\n            str = str..line_end_str\r\n            len = len + math.floor(string.len(line_end_str)/4)\r\n        else\r\n            str = str..string.format(\"%3u,\", byte)\r\n            len = len + 1\r\n        end\r\n\r\n        -- add a real \\n to text file, will be appropriate for platform\r\n        if (byte == CR) or (byte == LF) or (n >= file_len) then\r\n            table.insert(outTable, str..\"\\n\")\r\n            str = \"\"\r\n        end\r\n\r\n        n = n + 1\r\n    end\r\n\r\n    table.insert(outTable, \"  0 };\\n\\n\")\r\n    return outTable, len\r\nend",
    "type": "function"
  }, {
    "id": 57,
    "text": "local CR  = string.byte(\"\\r\")",
    "type": "statement:localassign"
  }, {
    "id": 58,
    "text": "local LF  = string.byte(\"\\n\")",
    "type": "statement:localassign"
  }, {
    "id": 59,
    "text": "local file_len = string.len(fileData)",
    "type": "statement:localassign"
  }, {
    "id": 60,
    "text": "local len = 0",
    "type": "statement:localassign"
  }, {
    "id": 61,
    "text": "local n   = 1",
    "type": "statement:localassign"
  }, {
    "id": 62,
    "text": "local str = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 63,
    "text": "if line_ending then\r\n        local switch = {\r\n            cr   = string.format(\"%3u,\", CR),\r\n            lf   = string.format(\"%3u,\", LF),\r\n            crlf = string.format(\"%3u,%3u,\", CR, LF) }\r\n\r\n        line_ending = switch[string.sub(line_ending, 2)] -- remove leading '-'\r\n    end",
    "type": "statement:if"
  }, {
    "id": 64,
    "text": "local switch = {\r\n            cr   = string.format(\"%3u,\", CR),\r\n            lf   = string.format(\"%3u,\", LF),\r\n            crlf = string.format(\"%3u,%3u,\", CR, LF) }",
    "type": "statement:localassign"
  }, {
    "id": 65,
    "text": "line_ending = switch[string.sub(line_ending, 2)]",
    "type": "statement:assign"
  }, {
    "id": 66,
    "text": "while ( n <= file_len ) do\r\n        local byte = string.byte(fileData, n)\r\n\r\n        if (byte == CR) or (byte == LF) then\r\n            local line_end_str = string.format(\"%3u,\", byte)\r\n\r\n            -- handle DOS CRLF line endings by adding the LF before new line\r\n            if (byte == CR) and (n < file_len) and (string.byte(fileData, n+1) == LF) then\r\n                n = n + 1\r\n                line_end_str = line_end_str..string.format(\"%3u,\", LF)\r\n            end\r\n\r\n            -- replace with user specified line ending\r\n            if line_ending ~= nil then\r\n                line_end_str = line_ending\r\n            end\r\n\r\n            str = str..line_end_str\r\n            len = len + math.floor(string.len(line_end_str)/4)\r\n        else\r\n            str = str..string.format(\"%3u,\", byte)\r\n            len = len + 1\r\n        end\r\n\r\n        -- add a real \\n to text file, will be appropriate for platform\r\n        if (byte == CR) or (byte == LF) or (n >= file_len) then\r\n            table.insert(outTable, str..\"\\n\")\r\n            str = \"\"\r\n        end\r\n\r\n        n = n + 1\r\n    end",
    "type": "statement:while"
  }, {
    "id": 67,
    "text": "local byte = string.byte(fileData, n)",
    "type": "statement:localassign"
  }, {
    "id": 68,
    "text": "if (byte == CR) or (byte == LF) then\r\n            local line_end_str = string.format(\"%3u,\", byte)\r\n\r\n            -- handle DOS CRLF line endings by adding the LF before new line\r\n            if (byte == CR) and (n < file_len) and (string.byte(fileData, n+1) == LF) then\r\n                n = n + 1\r\n                line_end_str = line_end_str..string.format(\"%3u,\", LF)\r\n            end\r\n\r\n            -- replace with user specified line ending\r\n            if line_ending ~= nil then\r\n                line_end_str = line_ending\r\n            end\r\n\r\n            str = str..line_end_str\r\n            len = len + math.floor(string.len(line_end_str)/4)\r\n        else\r\n            str = str..string.format(\"%3u,\", byte)\r\n            len = len + 1\r\n        end",
    "type": "statement:if"
  }, {
    "id": 69,
    "text": "local line_end_str = string.format(\"%3u,\", byte)",
    "type": "statement:localassign"
  }, {
    "id": 70,
    "text": "if (byte == CR) and (n < file_len) and (string.byte(fileData, n+1) == LF) then\r\n                n = n + 1\r\n                line_end_str = line_end_str..string.format(\"%3u,\", LF)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 71,
    "text": "n = n + 1",
    "type": "statement:assign"
  }, {
    "id": 72,
    "text": "line_end_str = line_end_str..string.format(\"%3u,\", LF)",
    "type": "statement:assign"
  }, {
    "id": 73,
    "text": "if line_ending ~= nil then\r\n                line_end_str = line_ending\r\n            end",
    "type": "statement:if"
  }, {
    "id": 74,
    "text": "line_end_str = line_ending",
    "type": "statement:assign"
  }, {
    "id": 75,
    "text": "str = str..line_end_str",
    "type": "statement:assign"
  }, {
    "id": 76,
    "text": "len = len + math.floor(string.len(line_end_str)/4)",
    "type": "statement:assign"
  }, {
    "id": 77,
    "text": "str = str..string.format(\"%3u,\", byte)",
    "type": "statement:assign"
  }, {
    "id": 78,
    "text": "len = len + 1",
    "type": "statement:assign"
  }, {
    "id": 79,
    "text": "if (byte == CR) or (byte == LF) or (n >= file_len) then\r\n            table.insert(outTable, str..\"\\n\")\r\n            str = \"\"\r\n        end",
    "type": "statement:if"
  }, {
    "id": 80,
    "text": "table.insert(outTable, str..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 81,
    "text": "str = \"\"",
    "type": "statement:assign"
  }, {
    "id": 82,
    "text": "table.insert(outTable, \"  0 };\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 83,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 84,
    "text": "function CreateBinaryData(fileData, outTable)\r\n    local count = 0\r\n    local len = 0\r\n    local str = \"\"\r\n    for n = 1, string.len(fileData) do\r\n        str = str..string.format(\"%3u,\", string.byte(fileData, n))\r\n        len = len + 1\r\n        count = count + 1\r\n        if (count == 20) then\r\n            table.insert(outTable, str..\"\\n\")\r\n            str = \"\"\r\n            count = 0\r\n        end\r\n    end\r\n\r\n    table.insert(outTable, str..\"\\n  0 };\\n\\n\")\r\n    return outTable, len\r\nend",
    "type": "function"
  }, {
    "id": 85,
    "text": "local count = 0",
    "type": "statement:localassign"
  }, {
    "id": 86,
    "text": "for n = 1, string.len(fileData) do\r\n        str = str..string.format(\"%3u,\", string.byte(fileData, n))\r\n        len = len + 1\r\n        count = count + 1\r\n        if (count == 20) then\r\n            table.insert(outTable, str..\"\\n\")\r\n            str = \"\"\r\n            count = 0\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 87,
    "text": "str = str..string.format(\"%3u,\", string.byte(fileData, n))",
    "type": "statement:assign"
  }, {
    "id": 88,
    "text": "count = count + 1",
    "type": "statement:assign"
  }, {
    "id": 89,
    "text": "if (count == 20) then\r\n            table.insert(outTable, str..\"\\n\")\r\n            str = \"\"\r\n            count = 0\r\n        end",
    "type": "statement:if"
  }, {
    "id": 90,
    "text": "count = 0",
    "type": "statement:assign"
  }, {
    "id": 91,
    "text": "table.insert(outTable, str..\"\\n  0 };\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 92,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 93,
    "text": "function Usage()                                                                     -- | 80 col\r\n  print(\"bin2c.lua converts a file to const unsigned char byte array for loading with\")\r\n  print(\"  lua_dobuffer or for general use by any C/C++ program.\\n\")\r\n  print(\"The output contains two variables, the data size and the data itself.\")\r\n  print(\"  const size_t stringname_len; // string length - 1 (excludes terminating NULL)\")\r\n  print(\"  const unsigned char stringname[] = { 123, 232, ... , 0 }; \")\r\n  print(\"When converting text files you may want to use the -lf switch since many\")\r\n  print(\"  programs can easily parse Unix line endings and the output will be the same\")\r\n  print(\"  no matter what line endings the original file has. This is useful for\")\r\n  print(\"  files checked out using CVS on both Unix and DOS platforms.\")\r\n  print(\"Switches :\")\r\n  print(\"  -b    Binary dump for binary files, 80 columns wide (default)\")\r\n  print(\"  -t    Text dump where the original line structure is maintained\")\r\n  print(\"  -cr   Convert line endings to carriage returns CR='\\\\r' for Mac (use with -t)\")\r\n  print(\"  -lf   Convert line endings to line feeds LF='\\\\n' for Unix (use with -t)\")\r\n  print(\"  -crlf Convert line endings to CRLF='\\\\r\\\\n' for DOS (use with -t)\")\r\n  print(\"  -n    Name of the c string to create, else derive name from input file\")\r\n  print(\"  -o    Filename to output to, else output to stdout\")\r\n  print(\"  -w    When used with -o always overwrite the output file\")\r\n  print(\"Usage : \")\r\n  print(\"  $lua.exe bin2c.lua [-b or -t] [-cr or -lf or -crlf] [-n cstringname]\")\r\n  print(\"                     [-o outputfile.c] [-w] inputfile\")\r\nend",
    "type": "function"
  }, {
    "id": 94,
    "text": "print(\"bin2c.lua converts a file to const unsigned char byte array for loading with\")",
    "type": "statement:functioncall"
  }, {
    "id": 95,
    "text": "print(\"  lua_dobuffer or for general use by any C/C++ program.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 96,
    "text": "print(\"The output contains two variables, the data size and the data itself.\")",
    "type": "statement:functioncall"
  }, {
    "id": 97,
    "text": "print(\"  const size_t stringname_len; // string length - 1 (excludes terminating NULL)\")",
    "type": "statement:functioncall"
  }, {
    "id": 98,
    "text": "print(\"  const unsigned char stringname[] = { 123, 232, ... , 0 }; \")",
    "type": "statement:functioncall"
  }, {
    "id": 99,
    "text": "print(\"When converting text files you may want to use the -lf switch since many\")",
    "type": "statement:functioncall"
  }, {
    "id": 100,
    "text": "print(\"  programs can easily parse Unix line endings and the output will be the same\")",
    "type": "statement:functioncall"
  }, {
    "id": 101,
    "text": "print(\"  no matter what line endings the original file has. This is useful for\")",
    "type": "statement:functioncall"
  }, {
    "id": 102,
    "text": "print(\"  files checked out using CVS on both Unix and DOS platforms.\")",
    "type": "statement:functioncall"
  }, {
    "id": 103,
    "text": "print(\"Switches :\")",
    "type": "statement:functioncall"
  }, {
    "id": 104,
    "text": "print(\"  -b    Binary dump for binary files, 80 columns wide (default)\")",
    "type": "statement:functioncall"
  }, {
    "id": 105,
    "text": "print(\"  -t    Text dump where the original line structure is maintained\")",
    "type": "statement:functioncall"
  }, {
    "id": 106,
    "text": "print(\"  -cr   Convert line endings to carriage returns CR='\\\\r' for Mac (use with -t)\")",
    "type": "statement:functioncall"
  }, {
    "id": 107,
    "text": "print(\"  -lf   Convert line endings to line feeds LF='\\\\n' for Unix (use with -t)\")",
    "type": "statement:functioncall"
  }, {
    "id": 108,
    "text": "print(\"  -crlf Convert line endings to CRLF='\\\\r\\\\n' for DOS (use with -t)\")",
    "type": "statement:functioncall"
  }, {
    "id": 109,
    "text": "print(\"  -n    Name of the c string to create, else derive name from input file\")",
    "type": "statement:functioncall"
  }, {
    "id": 110,
    "text": "print(\"  -o    Filename to output to, else output to stdout\")",
    "type": "statement:functioncall"
  }, {
    "id": 111,
    "text": "print(\"  -w    When used with -o always overwrite the output file\")",
    "type": "statement:functioncall"
  }, {
    "id": 112,
    "text": "print(\"Usage : \")",
    "type": "statement:functioncall"
  }, {
    "id": 113,
    "text": "print(\"  $lua.exe bin2c.lua [-b or -t] [-cr or -lf or -crlf] [-n cstringname]\")",
    "type": "statement:functioncall"
  }, {
    "id": 114,
    "text": "print(\"                     [-o outputfile.c] [-w] inputfile\")",
    "type": "statement:functioncall"
  }, {
    "id": 115,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 116,
    "text": "function main()\r\n\r\n    local is_text     = false  -- -t switch set\r\n    local is_binary   = false  -- -b switch set\r\n    local line_ending = nil    -- -cr, -lf, -crlf switches\r\n    local set_string  = false  -- -n switch set\r\n    local stringName  = nil    -- -n stringName\r\n    local output_file = false  -- -o switch set\r\n    local outFileName = nil    -- -o fileName\r\n    local overwrite   = false  -- -w\r\n    local inFileName  = nil    -- input filename\r\n\r\n    local n = 1\r\n    while n <= #arg do\r\n        if (arg[n] == \"-t\") or (arg[n] == \"/t\") then\r\n            is_text   = true\r\n        elseif (arg[n] == \"-b\") or (arg[n] == \"/b\") then\r\n            is_binary = true\r\n        elseif (arg[n] == \"-cr\") or (arg[n] == \"/cr\") then\r\n            line_ending = (line_ending or \"\")..\"-cr\" -- to check errors\r\n        elseif (arg[n] == \"-lf\") or (arg[n] == \"/lf\") then\r\n            line_ending = (line_ending or \"\")..\"-lf\"\r\n        elseif (arg[n] == \"-crlf\") or (arg[n] == \"/crlf\") then\r\n            line_ending = (line_ending or \"\")..\"-crlf\"\r\n        elseif (arg[n] == \"-w\") or (arg[n] == \"/w\") then\r\n            overwrite = true\r\n        elseif (arg[n] == \"-n\") or (arg[n] == \"/n\") then\r\n            set_string = true\r\n            n = n + 1\r\n            stringName = arg[n]\r\n        elseif (arg[n] == \"-o\") or (arg[n] == \"/o\") then\r\n            output_file = true\r\n            n = n + 1\r\n            outFileName = arg[n]\r\n        elseif n == #arg then\r\n            -- input filename is always the last parameter\r\n            inFileName = arg[n]\r\n        end\r\n\r\n        n = n + 1\r\n    end\r\n\r\n    -- check for simple errors, like missing or extra parameters\r\n    if #arg < 1 then\r\n        Usage()\r\n        return\r\n    end\r\n    if (is_text and is_binary) then\r\n        print(\"Error: Only use -b or -t flags, not both.\\n\")\r\n        Usage()\r\n        return\r\n    end\r\n    if (is_binary and line_ending) then\r\n        print(\"Error: Only use -cr, -lf, -crlf with text file -t flag, not -b binary.\\n\")\r\n        Usage()\r\n        return\r\n    end\r\n    if not ((line_ending == nil) or (line_ending == \"-cr\") or\r\n            (line_ending == \"-lf\") or (line_ending == \"-crlf\")) then\r\n        print(\"Error: Only use one of -cr, -lf, -crlf at a time.\\n\")\r\n        Usage()\r\n        return\r\n    end\r\n    if (set_string and (not stringName)) then\r\n        print(\"Error: Missing name of the string to use for -n flag.\\n\")\r\n        Usage()\r\n        return\r\n    end\r\n    if (output_file and (not outFileName)) then\r\n        print(\"Error: Missing output filename to use for -o flag.\\n\")\r\n        Usage()\r\n        return\r\n    end\r\n\r\n    if (not inFileName) or (not FileExists(inFileName)) then\r\n        print(\"Error: Invalid or missing input filename : '\"..tostring(inFileName)..\"'\\n\")\r\n        Usage()\r\n        return\r\n    end\r\n\r\n    -- handle the name to use for the char buffer if not set on command line\r\n    if stringName == nil then\r\n        -- replace all '.' with '_' for the string name based on the filename\r\n        stringName = string.gsub(inFileName, \"[.]\", \"_\")\r\n\r\n        -- remove unix path, if any, of the input filename\r\n        --   note: string.find only can search forward\r\n        local n = string.find(stringName, \"/\", 1, 1)\r\n        while n do\r\n            stringName = string.sub(stringName, n+1)\r\n            n = string.find(stringName, \"/\", 1, 1)\r\n        end\r\n        -- remove DOS path, if any, of the input filename\r\n        local n = string.find(stringName, \"\\\\\", 1, 1)\r\n        while n do\r\n            stringName = string.sub(stringName, n+1)\r\n            n = string.find(stringName, \"\\\\\", 1, 1)\r\n        end\r\n    end\r\n\r\n    local fileData = ReadBinaryFile(inFileName)\r\n    local outTable = {}\r\n    local len = 0\r\n\r\n    if is_text then\r\n        outTable, len = CreateTextData(fileData, outTable, line_ending)\r\n    else -- default is binary\r\n        outTable, len = CreateBinaryData(fileData, outTable)\r\n    end\r\n\r\n    outTable = CreateHeader(stringName, inFileName, len, outTable)\r\n\r\n    if not output_file then\r\n        for n = 1, #outTable do\r\n            printf(outTable[n])\r\n        end\r\n    else\r\n        WriteTableToFile(outFileName, outTable, overwrite)\r\n    end\r\n\r\nend",
    "type": "function"
  }, {
    "id": 117,
    "text": "local is_text     = false",
    "type": "statement:localassign"
  }, {
    "id": 118,
    "text": "local is_binary   = false",
    "type": "statement:localassign"
  }, {
    "id": 119,
    "text": "local line_ending = nil",
    "type": "statement:localassign"
  }, {
    "id": 120,
    "text": "local set_string  = false",
    "type": "statement:localassign"
  }, {
    "id": 121,
    "text": "local stringName  = nil",
    "type": "statement:localassign"
  }, {
    "id": 122,
    "text": "local output_file = false",
    "type": "statement:localassign"
  }, {
    "id": 123,
    "text": "local outFileName = nil",
    "type": "statement:localassign"
  }, {
    "id": 124,
    "text": "local overwrite   = false",
    "type": "statement:localassign"
  }, {
    "id": 125,
    "text": "local inFileName  = nil",
    "type": "statement:localassign"
  }, {
    "id": 126,
    "text": "local n = 1",
    "type": "statement:localassign"
  }, {
    "id": 127,
    "text": "while n <= #arg do\r\n        if (arg[n] == \"-t\") or (arg[n] == \"/t\") then\r\n            is_text   = true\r\n        elseif (arg[n] == \"-b\") or (arg[n] == \"/b\") then\r\n            is_binary = true\r\n        elseif (arg[n] == \"-cr\") or (arg[n] == \"/cr\") then\r\n            line_ending = (line_ending or \"\")..\"-cr\" -- to check errors\r\n        elseif (arg[n] == \"-lf\") or (arg[n] == \"/lf\") then\r\n            line_ending = (line_ending or \"\")..\"-lf\"\r\n        elseif (arg[n] == \"-crlf\") or (arg[n] == \"/crlf\") then\r\n            line_ending = (line_ending or \"\")..\"-crlf\"\r\n        elseif (arg[n] == \"-w\") or (arg[n] == \"/w\") then\r\n            overwrite = true\r\n        elseif (arg[n] == \"-n\") or (arg[n] == \"/n\") then\r\n            set_string = true\r\n            n = n + 1\r\n            stringName = arg[n]\r\n        elseif (arg[n] == \"-o\") or (arg[n] == \"/o\") then\r\n            output_file = true\r\n            n = n + 1\r\n            outFileName = arg[n]\r\n        elseif n == #arg then\r\n            -- input filename is always the last parameter\r\n            inFileName = arg[n]\r\n        end\r\n\r\n        n = n + 1\r\n    end",
    "type": "statement:while"
  }, {
    "id": 128,
    "text": "if (arg[n] == \"-t\") or (arg[n] == \"/t\") then\r\n            is_text   = true\r\n        elseif (arg[n] == \"-b\") or (arg[n] == \"/b\") then\r\n            is_binary = true\r\n        elseif (arg[n] == \"-cr\") or (arg[n] == \"/cr\") then\r\n            line_ending = (line_ending or \"\")..\"-cr\" -- to check errors\r\n        elseif (arg[n] == \"-lf\") or (arg[n] == \"/lf\") then\r\n            line_ending = (line_ending or \"\")..\"-lf\"\r\n        elseif (arg[n] == \"-crlf\") or (arg[n] == \"/crlf\") then\r\n            line_ending = (line_ending or \"\")..\"-crlf\"\r\n        elseif (arg[n] == \"-w\") or (arg[n] == \"/w\") then\r\n            overwrite = true\r\n        elseif (arg[n] == \"-n\") or (arg[n] == \"/n\") then\r\n            set_string = true\r\n            n = n + 1\r\n            stringName = arg[n]\r\n        elseif (arg[n] == \"-o\") or (arg[n] == \"/o\") then\r\n            output_file = true\r\n            n = n + 1\r\n            outFileName = arg[n]\r\n        elseif n == #arg then\r\n            -- input filename is always the last parameter\r\n            inFileName = arg[n]\r\n        end",
    "type": "statement:if"
  }, {
    "id": 129,
    "text": "is_text   = true",
    "type": "statement:assign"
  }, {
    "id": 130,
    "text": "is_binary = true",
    "type": "statement:assign"
  }, {
    "id": 131,
    "text": "line_ending = (line_ending or \"\")..\"-cr\"",
    "type": "statement:assign"
  }, {
    "id": 132,
    "text": "line_ending = (line_ending or \"\")..\"-lf\"",
    "type": "statement:assign"
  }, {
    "id": 133,
    "text": "line_ending = (line_ending or \"\")..\"-crlf\"",
    "type": "statement:assign"
  }, {
    "id": 134,
    "text": "overwrite = true",
    "type": "statement:assign"
  }, {
    "id": 135,
    "text": "set_string = true",
    "type": "statement:assign"
  }, {
    "id": 136,
    "text": "stringName = arg[n]",
    "type": "statement:assign"
  }, {
    "id": 137,
    "text": "output_file = true",
    "type": "statement:assign"
  }, {
    "id": 138,
    "text": "outFileName = arg[n]",
    "type": "statement:assign"
  }, {
    "id": 139,
    "text": "inFileName = arg[n]",
    "type": "statement:assign"
  }, {
    "id": 140,
    "text": "if #arg < 1 then\r\n        Usage()\r\n        return\r\n    end",
    "type": "statement:if"
  }, {
    "id": 141,
    "text": "Usage()",
    "type": "statement:functioncall"
  }, {
    "id": 142,
    "text": "if (is_text and is_binary) then\r\n        print(\"Error: Only use -b or -t flags, not both.\\n\")\r\n        Usage()\r\n        return\r\n    end",
    "type": "statement:if"
  }, {
    "id": 143,
    "text": "print(\"Error: Only use -b or -t flags, not both.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 144,
    "text": "if (is_binary and line_ending) then\r\n        print(\"Error: Only use -cr, -lf, -crlf with text file -t flag, not -b binary.\\n\")\r\n        Usage()\r\n        return\r\n    end",
    "type": "statement:if"
  }, {
    "id": 145,
    "text": "print(\"Error: Only use -cr, -lf, -crlf with text file -t flag, not -b binary.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 146,
    "text": "if not ((line_ending == nil) or (line_ending == \"-cr\") or\r\n            (line_ending == \"-lf\") or (line_ending == \"-crlf\")) then\r\n        print(\"Error: Only use one of -cr, -lf, -crlf at a time.\\n\")\r\n        Usage()\r\n        return\r\n    end",
    "type": "statement:if"
  }, {
    "id": 147,
    "text": "print(\"Error: Only use one of -cr, -lf, -crlf at a time.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 148,
    "text": "if (set_string and (not stringName)) then\r\n        print(\"Error: Missing name of the string to use for -n flag.\\n\")\r\n        Usage()\r\n        return\r\n    end",
    "type": "statement:if"
  }, {
    "id": 149,
    "text": "print(\"Error: Missing name of the string to use for -n flag.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 150,
    "text": "if (output_file and (not outFileName)) then\r\n        print(\"Error: Missing output filename to use for -o flag.\\n\")\r\n        Usage()\r\n        return\r\n    end",
    "type": "statement:if"
  }, {
    "id": 151,
    "text": "print(\"Error: Missing output filename to use for -o flag.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 152,
    "text": "if (not inFileName) or (not FileExists(inFileName)) then\r\n        print(\"Error: Invalid or missing input filename : '\"..tostring(inFileName)..\"'\\n\")\r\n        Usage()\r\n        return\r\n    end",
    "type": "statement:if"
  }, {
    "id": 153,
    "text": "print(\"Error: Invalid or missing input filename : '\"..tostring(inFileName)..\"'\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 154,
    "text": "if stringName == nil then\r\n        -- replace all '.' with '_' for the string name based on the filename\r\n        stringName = string.gsub(inFileName, \"[.]\", \"_\")\r\n\r\n        -- remove unix path, if any, of the input filename\r\n        --   note: string.find only can search forward\r\n        local n = string.find(stringName, \"/\", 1, 1)\r\n        while n do\r\n            stringName = string.sub(stringName, n+1)\r\n            n = string.find(stringName, \"/\", 1, 1)\r\n        end\r\n        -- remove DOS path, if any, of the input filename\r\n        local n = string.find(stringName, \"\\\\\", 1, 1)\r\n        while n do\r\n            stringName = string.sub(stringName, n+1)\r\n            n = string.find(stringName, \"\\\\\", 1, 1)\r\n        end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 155,
    "text": "stringName = string.gsub(inFileName, \"[.]\", \"_\")",
    "type": "statement:assign"
  }, {
    "id": 156,
    "text": "local n = string.find(stringName, \"/\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 157,
    "text": "while n do\r\n            stringName = string.sub(stringName, n+1)\r\n            n = string.find(stringName, \"/\", 1, 1)\r\n        end",
    "type": "statement:while"
  }, {
    "id": 158,
    "text": "stringName = string.sub(stringName, n+1)",
    "type": "statement:assign"
  }, {
    "id": 159,
    "text": "n = string.find(stringName, \"/\", 1, 1)",
    "type": "statement:assign"
  }, {
    "id": 160,
    "text": "local n = string.find(stringName, \"\\\\\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 161,
    "text": "while n do\r\n            stringName = string.sub(stringName, n+1)\r\n            n = string.find(stringName, \"\\\\\", 1, 1)\r\n        end",
    "type": "statement:while"
  }, {
    "id": 162,
    "text": "n = string.find(stringName, \"\\\\\", 1, 1)",
    "type": "statement:assign"
  }, {
    "id": 163,
    "text": "local fileData = ReadBinaryFile(inFileName)",
    "type": "statement:localassign"
  }, {
    "id": 164,
    "text": "local outTable = {}",
    "type": "statement:localassign"
  }, {
    "id": 165,
    "text": "if is_text then\r\n        outTable, len = CreateTextData(fileData, outTable, line_ending)\r\n    else -- default is binary\r\n        outTable, len = CreateBinaryData(fileData, outTable)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 166,
    "text": "outTable, len = CreateTextData(fileData, outTable, line_ending)",
    "type": "statement:assign"
  }, {
    "id": 167,
    "text": "outTable, len = CreateBinaryData(fileData, outTable)",
    "type": "statement:assign"
  }, {
    "id": 168,
    "text": "outTable = CreateHeader(stringName, inFileName, len, outTable)",
    "type": "statement:assign"
  }, {
    "id": 169,
    "text": "if not output_file then\r\n        for n = 1, #outTable do\r\n            printf(outTable[n])\r\n        end\r\n    else\r\n        WriteTableToFile(outFileName, outTable, overwrite)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 170,
    "text": "for n = 1, #outTable do\r\n            printf(outTable[n])\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 171,
    "text": "printf(outTable[n])",
    "type": "statement:functioncall"
  }, {
    "id": 172,
    "text": "WriteTableToFile(outFileName, outTable, overwrite)",
    "type": "statement:functioncall"
  }, {
    "id": 173,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 174,
    "text": "",
    "type": "function container"
  }, {
    "id": 175,
    "text": "write",
    "type": "global function"
  }, {
    "id": 176,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 177,
    "text": "print",
    "type": "global function"
  }, {
    "id": 178,
    "text": "sub",
    "type": "global function"
  }, {
    "id": 179,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 180,
    "text": "floor",
    "type": "global function"
  }, {
    "id": 181,
    "text": "len",
    "type": "global function"
  }, {
    "id": 182,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 183,
    "text": "close",
    "type": "global function"
  }, {
    "id": 184,
    "text": "unpack",
    "type": "global function"
  }, {
    "id": 185,
    "text": "format",
    "type": "global function"
  }, {
    "id": 186,
    "text": "gsub",
    "type": "global function"
  }, {
    "id": 187,
    "text": "find",
    "type": "global function"
  }, {
    "id": 188,
    "text": "open",
    "type": "global function"
  }, {
    "id": 189,
    "text": "byte",
    "type": "global function"
  }, {
    "id": 190,
    "text": "",
    "type": "variable container"
  }, {
    "id": 191,
    "text": "",
    "type": "require container"
  } ]
}