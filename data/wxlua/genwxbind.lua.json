{
  "_filename": "genwxbind.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/wxlua/bindings/genwxbind.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "has",
    "to": 3
  }, {
    "from": 2,
    "label": "has",
    "to": 4
  }, {
    "from": 2,
    "label": "has",
    "to": 5
  }, {
    "from": 2,
    "label": "has",
    "to": 6
  }, {
    "from": 2,
    "label": "has",
    "to": 7
  }, {
    "from": 2,
    "label": "has",
    "to": 8
  }, {
    "from": 2,
    "label": "has",
    "to": 9
  }, {
    "from": 2,
    "label": "has",
    "to": 10
  }, {
    "from": 2,
    "label": "has",
    "to": 11
  }, {
    "from": 2,
    "label": "has",
    "to": 12
  }, {
    "from": 13,
    "label": "has",
    "to": 14
  }, {
    "from": 13,
    "label": "has",
    "to": 15
  }, {
    "from": 15,
    "label": "has",
    "to": 16
  }, {
    "from": 13,
    "label": "has",
    "to": 17
  }, {
    "from": 13,
    "label": "has",
    "to": 18
  }, {
    "from": 13,
    "label": "has",
    "to": 19
  }, {
    "from": 19,
    "label": "has",
    "to": 20
  }, {
    "from": 19,
    "label": "has",
    "to": 21
  }, {
    "from": 19,
    "label": "has",
    "to": 22
  }, {
    "from": 19,
    "label": "has",
    "to": 22
  }, {
    "from": 13,
    "label": "has",
    "to": 22
  }, {
    "from": 13,
    "label": "has",
    "to": 23
  }, {
    "from": 24,
    "label": "has",
    "to": 20
  }, {
    "from": 24,
    "label": "has",
    "to": 21
  }, {
    "from": 24,
    "label": "has",
    "to": 22
  }, {
    "from": 24,
    "label": "has",
    "to": 22
  }, {
    "from": 24,
    "label": "has",
    "to": 25
  }, {
    "from": 26,
    "label": "has",
    "to": 14
  }, {
    "from": 26,
    "label": "has",
    "to": 27
  }, {
    "from": 27,
    "label": "has",
    "to": 28
  }, {
    "from": 26,
    "label": "has",
    "to": 17
  }, {
    "from": 26,
    "label": "has",
    "to": 29
  }, {
    "from": 26,
    "label": "has",
    "to": 30
  }, {
    "from": 30,
    "label": "has",
    "to": 31
  }, {
    "from": 26,
    "label": "has",
    "to": 22
  }, {
    "from": 26,
    "label": "has",
    "to": 32
  }, {
    "from": 33,
    "label": "has",
    "to": 34
  }, {
    "from": 34,
    "label": "has",
    "to": 35
  }, {
    "from": 33,
    "label": "has",
    "to": 36
  }, {
    "from": 36,
    "label": "has",
    "to": 37
  }, {
    "from": 33,
    "label": "has",
    "to": 38
  }, {
    "from": 33,
    "label": "has",
    "to": 39
  }, {
    "from": 33,
    "label": "has",
    "to": 40
  }, {
    "from": 33,
    "label": "has",
    "to": 41
  }, {
    "from": 41,
    "label": "has",
    "to": 42
  }, {
    "from": 41,
    "label": "has",
    "to": 43
  }, {
    "from": 41,
    "label": "has",
    "to": 44
  }, {
    "from": 44,
    "label": "has",
    "to": 45
  }, {
    "from": 33,
    "label": "has",
    "to": 46
  }, {
    "from": 47,
    "label": "has",
    "to": 48
  }, {
    "from": 47,
    "label": "has",
    "to": 49
  }, {
    "from": 49,
    "label": "has",
    "to": 50
  }, {
    "from": 50,
    "label": "has",
    "to": 51
  }, {
    "from": 50,
    "label": "has",
    "to": 52
  }, {
    "from": 47,
    "label": "has",
    "to": 22
  }, {
    "from": 47,
    "label": "has",
    "to": 53
  }, {
    "from": 54,
    "label": "has",
    "to": 55
  }, {
    "from": 54,
    "label": "has",
    "to": 56
  }, {
    "from": 56,
    "label": "has",
    "to": 57
  }, {
    "from": 57,
    "label": "has",
    "to": 58
  }, {
    "from": 56,
    "label": "has",
    "to": 59
  }, {
    "from": 54,
    "label": "has",
    "to": 60
  }, {
    "from": 54,
    "label": "has",
    "to": 61
  }, {
    "from": 62,
    "label": "has",
    "to": 63
  }, {
    "from": 62,
    "label": "has",
    "to": 22
  }, {
    "from": 62,
    "label": "has",
    "to": 22
  }, {
    "from": 64,
    "label": "has",
    "to": 65
  }, {
    "from": 65,
    "label": "has",
    "to": 66
  }, {
    "from": 64,
    "label": "has",
    "to": 67
  }, {
    "from": 68,
    "label": "has",
    "to": 69
  }, {
    "from": 68,
    "label": "has",
    "to": 70
  }, {
    "from": 71,
    "label": "has",
    "to": 72
  }, {
    "from": 71,
    "label": "has",
    "to": 73
  }, {
    "from": 71,
    "label": "has",
    "to": 74
  }, {
    "from": 71,
    "label": "has",
    "to": 75
  }, {
    "from": 71,
    "label": "has",
    "to": 76
  }, {
    "from": 71,
    "label": "has",
    "to": 77
  }, {
    "from": 71,
    "label": "has",
    "to": 78
  }, {
    "from": 71,
    "label": "has",
    "to": 79
  }, {
    "from": 71,
    "label": "has",
    "to": 80
  }, {
    "from": 71,
    "label": "has",
    "to": 81
  }, {
    "from": 71,
    "label": "has",
    "to": 82
  }, {
    "from": 71,
    "label": "has",
    "to": 83
  }, {
    "from": 71,
    "label": "has",
    "to": 84
  }, {
    "from": 71,
    "label": "has",
    "to": 85
  }, {
    "from": 71,
    "label": "has",
    "to": 86
  }, {
    "from": 71,
    "label": "has",
    "to": 87
  }, {
    "from": 71,
    "label": "has",
    "to": 88
  }, {
    "from": 71,
    "label": "has",
    "to": 89
  }, {
    "from": 71,
    "label": "has",
    "to": 90
  }, {
    "from": 71,
    "label": "has",
    "to": 91
  }, {
    "from": 71,
    "label": "has",
    "to": 92
  }, {
    "from": 71,
    "label": "has",
    "to": 93
  }, {
    "from": 71,
    "label": "has",
    "to": 94
  }, {
    "from": 71,
    "label": "has",
    "to": 95
  }, {
    "from": 71,
    "label": "has",
    "to": 96
  }, {
    "from": 71,
    "label": "has",
    "to": 97
  }, {
    "from": 71,
    "label": "has",
    "to": 98
  }, {
    "from": 71,
    "label": "has",
    "to": 99
  }, {
    "from": 71,
    "label": "has",
    "to": 100
  }, {
    "from": 71,
    "label": "has",
    "to": 101
  }, {
    "from": 71,
    "label": "has",
    "to": 102
  }, {
    "from": 71,
    "label": "has",
    "to": 103
  }, {
    "from": 71,
    "label": "has",
    "to": 104
  }, {
    "from": 71,
    "label": "has",
    "to": 105
  }, {
    "from": 71,
    "label": "has",
    "to": 106
  }, {
    "from": 71,
    "label": "has",
    "to": 107
  }, {
    "from": 71,
    "label": "has",
    "to": 108
  }, {
    "from": 71,
    "label": "has",
    "to": 109
  }, {
    "from": 71,
    "label": "has",
    "to": 110
  }, {
    "from": 71,
    "label": "has",
    "to": 111
  }, {
    "from": 71,
    "label": "has",
    "to": 112
  }, {
    "from": 71,
    "label": "has",
    "to": 113
  }, {
    "from": 71,
    "label": "has",
    "to": 114
  }, {
    "from": 71,
    "label": "has",
    "to": 115
  }, {
    "from": 71,
    "label": "has",
    "to": 116
  }, {
    "from": 71,
    "label": "has",
    "to": 117
  }, {
    "from": 71,
    "label": "has",
    "to": 118
  }, {
    "from": 71,
    "label": "has",
    "to": 119
  }, {
    "from": 71,
    "label": "has",
    "to": 120
  }, {
    "from": 71,
    "label": "has",
    "to": 121
  }, {
    "from": 71,
    "label": "has",
    "to": 122
  }, {
    "from": 71,
    "label": "has",
    "to": 123
  }, {
    "from": 71,
    "label": "has",
    "to": 124
  }, {
    "from": 71,
    "label": "has",
    "to": 125
  }, {
    "from": 71,
    "label": "has",
    "to": 126
  }, {
    "from": 71,
    "label": "has",
    "to": 127
  }, {
    "from": 71,
    "label": "has",
    "to": 128
  }, {
    "from": 71,
    "label": "has",
    "to": 129
  }, {
    "from": 71,
    "label": "has",
    "to": 130
  }, {
    "from": 71,
    "label": "has",
    "to": 131
  }, {
    "from": 71,
    "label": "has",
    "to": 132
  }, {
    "from": 71,
    "label": "has",
    "to": 133
  }, {
    "from": 71,
    "label": "has",
    "to": 134
  }, {
    "from": 71,
    "label": "has",
    "to": 135
  }, {
    "from": 71,
    "label": "has",
    "to": 136
  }, {
    "from": 71,
    "label": "has",
    "to": 137
  }, {
    "from": 71,
    "label": "has",
    "to": 138
  }, {
    "from": 71,
    "label": "has",
    "to": 139
  }, {
    "from": 71,
    "label": "has",
    "to": 140
  }, {
    "from": 71,
    "label": "has",
    "to": 141
  }, {
    "from": 71,
    "label": "has",
    "to": 142
  }, {
    "from": 71,
    "label": "has",
    "to": 143
  }, {
    "from": 71,
    "label": "has",
    "to": 144
  }, {
    "from": 71,
    "label": "has",
    "to": 145
  }, {
    "from": 71,
    "label": "has",
    "to": 146
  }, {
    "from": 147,
    "label": "has",
    "to": 148
  }, {
    "from": 147,
    "label": "has",
    "to": 149
  }, {
    "from": 147,
    "label": "has",
    "to": 150
  }, {
    "from": 147,
    "label": "has",
    "to": 151
  }, {
    "from": 147,
    "label": "has",
    "to": 152
  }, {
    "from": 147,
    "label": "has",
    "to": 153
  }, {
    "from": 153,
    "label": "has",
    "to": 154
  }, {
    "from": 154,
    "label": "has",
    "to": 155
  }, {
    "from": 153,
    "label": "has",
    "to": 156
  }, {
    "from": 153,
    "label": "has",
    "to": 157
  }, {
    "from": 157,
    "label": "has",
    "to": 158
  }, {
    "from": 157,
    "label": "has",
    "to": 159
  }, {
    "from": 157,
    "label": "has",
    "to": 160
  }, {
    "from": 160,
    "label": "has",
    "to": 161
  }, {
    "from": 160,
    "label": "has",
    "to": 162
  }, {
    "from": 160,
    "label": "has",
    "to": 163
  }, {
    "from": 160,
    "label": "has",
    "to": 163
  }, {
    "from": 147,
    "label": "has",
    "to": 164
  }, {
    "from": 164,
    "label": "has",
    "to": 165
  }, {
    "from": 147,
    "label": "has",
    "to": 22
  }, {
    "from": 147,
    "label": "has",
    "to": 166
  }, {
    "from": 167,
    "label": "has",
    "to": 168
  }, {
    "from": 167,
    "label": "has",
    "to": 169
  }, {
    "from": 169,
    "label": "has",
    "to": 170
  }, {
    "from": 169,
    "label": "has",
    "to": 171
  }, {
    "from": 171,
    "label": "has",
    "to": 172
  }, {
    "from": 169,
    "label": "has",
    "to": 173
  }, {
    "from": 169,
    "label": "has",
    "to": 174
  }, {
    "from": 169,
    "label": "has",
    "to": 175
  }, {
    "from": 167,
    "label": "has",
    "to": 22
  }, {
    "from": 167,
    "label": "has",
    "to": 176
  }, {
    "from": 177,
    "label": "has",
    "to": 178
  }, {
    "from": 177,
    "label": "has",
    "to": 179
  }, {
    "from": 177,
    "label": "has",
    "to": 180
  }, {
    "from": 177,
    "label": "has",
    "to": 181
  }, {
    "from": 181,
    "label": "has",
    "to": 182
  }, {
    "from": 177,
    "label": "has",
    "to": 183
  }, {
    "from": 177,
    "label": "has",
    "to": 184
  }, {
    "from": 177,
    "label": "has",
    "to": 185
  }, {
    "from": 177,
    "label": "has",
    "to": 186
  }, {
    "from": 177,
    "label": "has",
    "to": 187
  }, {
    "from": 188,
    "label": "has",
    "to": 189
  }, {
    "from": 189,
    "label": "has",
    "to": 190
  }, {
    "from": 190,
    "label": "has",
    "to": 191
  }, {
    "from": 188,
    "label": "has",
    "to": 22
  }, {
    "from": 188,
    "label": "has",
    "to": 22
  }, {
    "from": 188,
    "label": "has",
    "to": 22
  }, {
    "from": 188,
    "label": "has",
    "to": 192
  }, {
    "from": 193,
    "label": "has",
    "to": 194
  }, {
    "from": 193,
    "label": "has",
    "to": 195
  }, {
    "from": 195,
    "label": "has",
    "to": 196
  }, {
    "from": 193,
    "label": "has",
    "to": 22
  }, {
    "from": 193,
    "label": "has",
    "to": 22
  }, {
    "from": 193,
    "label": "has",
    "to": 197
  }, {
    "from": 198,
    "label": "has",
    "to": 199
  }, {
    "from": 198,
    "label": "has",
    "to": 22
  }, {
    "from": 198,
    "label": "has",
    "to": 200
  }, {
    "from": 200,
    "label": "has",
    "to": 201
  }, {
    "from": 200,
    "label": "has",
    "to": 202
  }, {
    "from": 198,
    "label": "has",
    "to": 22
  }, {
    "from": 198,
    "label": "has",
    "to": 203
  }, {
    "from": 198,
    "label": "has",
    "to": 22
  }, {
    "from": 198,
    "label": "has",
    "to": 204
  }, {
    "from": 205,
    "label": "has",
    "to": 206
  }, {
    "from": 206,
    "label": "has",
    "to": 207
  }, {
    "from": 205,
    "label": "has",
    "to": 22
  }, {
    "from": 205,
    "label": "has",
    "to": 208
  }, {
    "from": 205,
    "label": "has",
    "to": 22
  }, {
    "from": 205,
    "label": "has",
    "to": 209
  }, {
    "from": 209,
    "label": "has",
    "to": 210
  }, {
    "from": 210,
    "label": "has",
    "to": 211
  }, {
    "from": 210,
    "label": "has",
    "to": 212
  }, {
    "from": 205,
    "label": "has",
    "to": 22
  }, {
    "from": 205,
    "label": "has",
    "to": 22
  }, {
    "from": 205,
    "label": "has",
    "to": 213
  }, {
    "from": 214,
    "label": "has",
    "to": 215
  }, {
    "from": 214,
    "label": "has",
    "to": 216
  }, {
    "from": 216,
    "label": "has",
    "to": 217
  }, {
    "from": 214,
    "label": "has",
    "to": 22
  }, {
    "from": 214,
    "label": "has",
    "to": 22
  }, {
    "from": 214,
    "label": "has",
    "to": 218
  }, {
    "from": 219,
    "label": "has",
    "to": 220
  }, {
    "from": 219,
    "label": "has",
    "to": 221
  }, {
    "from": 221,
    "label": "has",
    "to": 222
  }, {
    "from": 219,
    "label": "has",
    "to": 22
  }, {
    "from": 219,
    "label": "has",
    "to": 22
  }, {
    "from": 219,
    "label": "has",
    "to": 223
  }, {
    "from": 224,
    "label": "has",
    "to": 220
  }, {
    "from": 224,
    "label": "has",
    "to": 225
  }, {
    "from": 225,
    "label": "has",
    "to": 226
  }, {
    "from": 224,
    "label": "has",
    "to": 22
  }, {
    "from": 224,
    "label": "has",
    "to": 22
  }, {
    "from": 224,
    "label": "has",
    "to": 227
  }, {
    "from": 228,
    "label": "has",
    "to": 220
  }, {
    "from": 228,
    "label": "has",
    "to": 229
  }, {
    "from": 229,
    "label": "has",
    "to": 230
  }, {
    "from": 228,
    "label": "has",
    "to": 22
  }, {
    "from": 228,
    "label": "has",
    "to": 22
  }, {
    "from": 228,
    "label": "has",
    "to": 231
  }, {
    "from": 232,
    "label": "has",
    "to": 220
  }, {
    "from": 232,
    "label": "has",
    "to": 233
  }, {
    "from": 233,
    "label": "has",
    "to": 234
  }, {
    "from": 232,
    "label": "has",
    "to": 22
  }, {
    "from": 232,
    "label": "has",
    "to": 22
  }, {
    "from": 232,
    "label": "has",
    "to": 235
  }, {
    "from": 236,
    "label": "has",
    "to": 22
  }, {
    "from": 236,
    "label": "has",
    "to": 237
  }, {
    "from": 238,
    "label": "has",
    "to": 239
  }, {
    "from": 238,
    "label": "has",
    "to": 240
  }, {
    "from": 238,
    "label": "has",
    "to": 22
  }, {
    "from": 238,
    "label": "has",
    "to": 241
  }, {
    "from": 238,
    "label": "has",
    "to": 22
  }, {
    "from": 238,
    "label": "has",
    "to": 242
  }, {
    "from": 243,
    "label": "has",
    "to": 244
  }, {
    "from": 243,
    "label": "has",
    "to": 245
  }, {
    "from": 243,
    "label": "has",
    "to": 22
  }, {
    "from": 243,
    "label": "has",
    "to": 246
  }, {
    "from": 243,
    "label": "has",
    "to": 247
  }, {
    "from": 243,
    "label": "has",
    "to": 241
  }, {
    "from": 243,
    "label": "has",
    "to": 22
  }, {
    "from": 243,
    "label": "has",
    "to": 248
  }, {
    "from": 249,
    "label": "has",
    "to": 250
  }, {
    "from": 249,
    "label": "has",
    "to": 251
  }, {
    "from": 249,
    "label": "has",
    "to": 252
  }, {
    "from": 252,
    "label": "has",
    "to": 253
  }, {
    "from": 249,
    "label": "has",
    "to": 22
  }, {
    "from": 249,
    "label": "has",
    "to": 254
  }, {
    "from": 249,
    "label": "has",
    "to": 255
  }, {
    "from": 249,
    "label": "has",
    "to": 256
  }, {
    "from": 256,
    "label": "has",
    "to": 257
  }, {
    "from": 249,
    "label": "has",
    "to": 22
  }, {
    "from": 249,
    "label": "has",
    "to": 258
  }, {
    "from": 249,
    "label": "has",
    "to": 259
  }, {
    "from": 249,
    "label": "has",
    "to": 260
  }, {
    "from": 249,
    "label": "has",
    "to": 22
  }, {
    "from": 249,
    "label": "has",
    "to": 261
  }, {
    "from": 262,
    "label": "has",
    "to": 263
  }, {
    "from": 262,
    "label": "has",
    "to": 264
  }, {
    "from": 264,
    "label": "has",
    "to": 265
  }, {
    "from": 264,
    "label": "has",
    "to": 266
  }, {
    "from": 264,
    "label": "has",
    "to": 267
  }, {
    "from": 264,
    "label": "has",
    "to": 268
  }, {
    "from": 268,
    "label": "has",
    "to": 269
  }, {
    "from": 268,
    "label": "has",
    "to": 42
  }, {
    "from": 264,
    "label": "has",
    "to": 270
  }, {
    "from": 264,
    "label": "has",
    "to": 271
  }, {
    "from": 264,
    "label": "has",
    "to": 272
  }, {
    "from": 264,
    "label": "has",
    "to": 273
  }, {
    "from": 264,
    "label": "has",
    "to": 274
  }, {
    "from": 264,
    "label": "has",
    "to": 275
  }, {
    "from": 264,
    "label": "has",
    "to": 276
  }, {
    "from": 264,
    "label": "has",
    "to": 272
  }, {
    "from": 264,
    "label": "has",
    "to": 277
  }, {
    "from": 264,
    "label": "has",
    "to": 278
  }, {
    "from": 264,
    "label": "has",
    "to": 279
  }, {
    "from": 264,
    "label": "has",
    "to": 280
  }, {
    "from": 264,
    "label": "has",
    "to": 281
  }, {
    "from": 262,
    "label": "has",
    "to": 22
  }, {
    "from": 262,
    "label": "has",
    "to": 282
  }, {
    "from": 283,
    "label": "has",
    "to": 22
  }, {
    "from": 283,
    "label": "has",
    "to": 284
  }, {
    "from": 285,
    "label": "has",
    "to": 286
  }, {
    "from": 285,
    "label": "has",
    "to": 22
  }, {
    "from": 285,
    "label": "has",
    "to": 22
  }, {
    "from": 285,
    "label": "has",
    "to": 287
  }, {
    "from": 288,
    "label": "has",
    "to": 289
  }, {
    "from": 288,
    "label": "has",
    "to": 290
  }, {
    "from": 290,
    "label": "has",
    "to": 291
  }, {
    "from": 291,
    "label": "has",
    "to": 292
  }, {
    "from": 291,
    "label": "has",
    "to": 293
  }, {
    "from": 291,
    "label": "has",
    "to": 294
  }, {
    "from": 294,
    "label": "has",
    "to": 295
  }, {
    "from": 295,
    "label": "has",
    "to": 296
  }, {
    "from": 288,
    "label": "has",
    "to": 22
  }, {
    "from": 288,
    "label": "has",
    "to": 297
  }, {
    "from": 298,
    "label": "has",
    "to": 289
  }, {
    "from": 298,
    "label": "has",
    "to": 299
  }, {
    "from": 299,
    "label": "has",
    "to": 300
  }, {
    "from": 299,
    "label": "has",
    "to": 301
  }, {
    "from": 299,
    "label": "has",
    "to": 302
  }, {
    "from": 298,
    "label": "has",
    "to": 22
  }, {
    "from": 298,
    "label": "has",
    "to": 303
  }, {
    "from": 304,
    "label": "has",
    "to": 305
  }, {
    "from": 304,
    "label": "has",
    "to": 306
  }, {
    "from": 306,
    "label": "has",
    "to": 307
  }, {
    "from": 307,
    "label": "has",
    "to": 308
  }, {
    "from": 307,
    "label": "has",
    "to": 309
  }, {
    "from": 304,
    "label": "has",
    "to": 22
  }, {
    "from": 304,
    "label": "has",
    "to": 310
  }, {
    "from": 311,
    "label": "has",
    "to": 312
  }, {
    "from": 311,
    "label": "has",
    "to": 313
  }, {
    "from": 311,
    "label": "has",
    "to": 314
  }, {
    "from": 311,
    "label": "has",
    "to": 315
  }, {
    "from": 311,
    "label": "has",
    "to": 316
  }, {
    "from": 311,
    "label": "has",
    "to": 317
  }, {
    "from": 311,
    "label": "has",
    "to": 318
  }, {
    "from": 311,
    "label": "has",
    "to": 319
  }, {
    "from": 311,
    "label": "has",
    "to": 320
  }, {
    "from": 311,
    "label": "has",
    "to": 321
  }, {
    "from": 311,
    "label": "has",
    "to": 322
  }, {
    "from": 311,
    "label": "has",
    "to": 323
  }, {
    "from": 311,
    "label": "has",
    "to": 324
  }, {
    "from": 311,
    "label": "has",
    "to": 325
  }, {
    "from": 311,
    "label": "has",
    "to": 326
  }, {
    "from": 311,
    "label": "has",
    "to": 327
  }, {
    "from": 311,
    "label": "has",
    "to": 328
  }, {
    "from": 311,
    "label": "has",
    "to": 329
  }, {
    "from": 311,
    "label": "has",
    "to": 330
  }, {
    "from": 311,
    "label": "has",
    "to": 331
  }, {
    "from": 311,
    "label": "has",
    "to": 332
  }, {
    "from": 311,
    "label": "has",
    "to": 333
  }, {
    "from": 311,
    "label": "has",
    "to": 334
  }, {
    "from": 311,
    "label": "has",
    "to": 335
  }, {
    "from": 311,
    "label": "has",
    "to": 336
  }, {
    "from": 311,
    "label": "has",
    "to": 337
  }, {
    "from": 311,
    "label": "has",
    "to": 338
  }, {
    "from": 311,
    "label": "has",
    "to": 339
  }, {
    "from": 311,
    "label": "has",
    "to": 340
  }, {
    "from": 311,
    "label": "has",
    "to": 341
  }, {
    "from": 311,
    "label": "has",
    "to": 342
  }, {
    "from": 311,
    "label": "has",
    "to": 343
  }, {
    "from": 311,
    "label": "has",
    "to": 344
  }, {
    "from": 311,
    "label": "has",
    "to": 345
  }, {
    "from": 311,
    "label": "has",
    "to": 346
  }, {
    "from": 311,
    "label": "has",
    "to": 347
  }, {
    "from": 311,
    "label": "has",
    "to": 348
  }, {
    "from": 311,
    "label": "has",
    "to": 349
  }, {
    "from": 311,
    "label": "has",
    "to": 350
  }, {
    "from": 311,
    "label": "has",
    "to": 351
  }, {
    "from": 311,
    "label": "has",
    "to": 352
  }, {
    "from": 311,
    "label": "has",
    "to": 353
  }, {
    "from": 311,
    "label": "has",
    "to": 354
  }, {
    "from": 311,
    "label": "has",
    "to": 355
  }, {
    "from": 311,
    "label": "has",
    "to": 356
  }, {
    "from": 311,
    "label": "has",
    "to": 335
  }, {
    "from": 311,
    "label": "has",
    "to": 357
  }, {
    "from": 311,
    "label": "has",
    "to": 358
  }, {
    "from": 311,
    "label": "has",
    "to": 359
  }, {
    "from": 311,
    "label": "has",
    "to": 360
  }, {
    "from": 311,
    "label": "has",
    "to": 361
  }, {
    "from": 311,
    "label": "has",
    "to": 362
  }, {
    "from": 311,
    "label": "has",
    "to": 363
  }, {
    "from": 311,
    "label": "has",
    "to": 364
  }, {
    "from": 311,
    "label": "has",
    "to": 365
  }, {
    "from": 311,
    "label": "has",
    "to": 366
  }, {
    "from": 311,
    "label": "has",
    "to": 367
  }, {
    "from": 311,
    "label": "has",
    "to": 368
  }, {
    "from": 311,
    "label": "has",
    "to": 369
  }, {
    "from": 311,
    "label": "has",
    "to": 370
  }, {
    "from": 311,
    "label": "has",
    "to": 371
  }, {
    "from": 311,
    "label": "has",
    "to": 372
  }, {
    "from": 311,
    "label": "has",
    "to": 373
  }, {
    "from": 311,
    "label": "has",
    "to": 374
  }, {
    "from": 311,
    "label": "has",
    "to": 375
  }, {
    "from": 311,
    "label": "has",
    "to": 376
  }, {
    "from": 311,
    "label": "has",
    "to": 377
  }, {
    "from": 311,
    "label": "has",
    "to": 378
  }, {
    "from": 311,
    "label": "has",
    "to": 379
  }, {
    "from": 311,
    "label": "has",
    "to": 380
  }, {
    "from": 311,
    "label": "has",
    "to": 381
  }, {
    "from": 311,
    "label": "has",
    "to": 382
  }, {
    "from": 311,
    "label": "has",
    "to": 383
  }, {
    "from": 311,
    "label": "has",
    "to": 384
  }, {
    "from": 311,
    "label": "has",
    "to": 385
  }, {
    "from": 311,
    "label": "has",
    "to": 386
  }, {
    "from": 311,
    "label": "has",
    "to": 387
  }, {
    "from": 311,
    "label": "has",
    "to": 388
  }, {
    "from": 311,
    "label": "has",
    "to": 389
  }, {
    "from": 311,
    "label": "has",
    "to": 390
  }, {
    "from": 311,
    "label": "has",
    "to": 391
  }, {
    "from": 311,
    "label": "has",
    "to": 392
  }, {
    "from": 311,
    "label": "has",
    "to": 393
  }, {
    "from": 311,
    "label": "has",
    "to": 394
  }, {
    "from": 311,
    "label": "has",
    "to": 395
  }, {
    "from": 311,
    "label": "has",
    "to": 396
  }, {
    "from": 311,
    "label": "has",
    "to": 397
  }, {
    "from": 311,
    "label": "has",
    "to": 398
  }, {
    "from": 311,
    "label": "has",
    "to": 399
  }, {
    "from": 311,
    "label": "has",
    "to": 400
  }, {
    "from": 311,
    "label": "has",
    "to": 401
  }, {
    "from": 311,
    "label": "has",
    "to": 402
  }, {
    "from": 311,
    "label": "has",
    "to": 403
  }, {
    "from": 311,
    "label": "has",
    "to": 404
  }, {
    "from": 311,
    "label": "has",
    "to": 405
  }, {
    "from": 311,
    "label": "has",
    "to": 406
  }, {
    "from": 311,
    "label": "has",
    "to": 407
  }, {
    "from": 311,
    "label": "has",
    "to": 408
  }, {
    "from": 311,
    "label": "has",
    "to": 409
  }, {
    "from": 311,
    "label": "has",
    "to": 410
  }, {
    "from": 311,
    "label": "has",
    "to": 411
  }, {
    "from": 311,
    "label": "has",
    "to": 412
  }, {
    "from": 311,
    "label": "has",
    "to": 413
  }, {
    "from": 311,
    "label": "has",
    "to": 414
  }, {
    "from": 311,
    "label": "has",
    "to": 415
  }, {
    "from": 311,
    "label": "has",
    "to": 416
  }, {
    "from": 311,
    "label": "has",
    "to": 417
  }, {
    "from": 311,
    "label": "has",
    "to": 418
  }, {
    "from": 311,
    "label": "has",
    "to": 419
  }, {
    "from": 311,
    "label": "has",
    "to": 420
  }, {
    "from": 311,
    "label": "has",
    "to": 421
  }, {
    "from": 311,
    "label": "has",
    "to": 422
  }, {
    "from": 311,
    "label": "has",
    "to": 423
  }, {
    "from": 311,
    "label": "has",
    "to": 424
  }, {
    "from": 311,
    "label": "has",
    "to": 425
  }, {
    "from": 311,
    "label": "has",
    "to": 426
  }, {
    "from": 311,
    "label": "has",
    "to": 427
  }, {
    "from": 311,
    "label": "has",
    "to": 428
  }, {
    "from": 311,
    "label": "has",
    "to": 429
  }, {
    "from": 311,
    "label": "has",
    "to": 430
  }, {
    "from": 311,
    "label": "has",
    "to": 431
  }, {
    "from": 311,
    "label": "has",
    "to": 432
  }, {
    "from": 311,
    "label": "has",
    "to": 433
  }, {
    "from": 311,
    "label": "has",
    "to": 434
  }, {
    "from": 311,
    "label": "has",
    "to": 435
  }, {
    "from": 311,
    "label": "has",
    "to": 436
  }, {
    "from": 311,
    "label": "has",
    "to": 437
  }, {
    "from": 311,
    "label": "has",
    "to": 438
  }, {
    "from": 311,
    "label": "has",
    "to": 439
  }, {
    "from": 311,
    "label": "has",
    "to": 440
  }, {
    "from": 311,
    "label": "has",
    "to": 441
  }, {
    "from": 311,
    "label": "has",
    "to": 442
  }, {
    "from": 311,
    "label": "has",
    "to": 443
  }, {
    "from": 311,
    "label": "has",
    "to": 444
  }, {
    "from": 311,
    "label": "has",
    "to": 445
  }, {
    "from": 311,
    "label": "has",
    "to": 446
  }, {
    "from": 311,
    "label": "has",
    "to": 447
  }, {
    "from": 311,
    "label": "has",
    "to": 448
  }, {
    "from": 311,
    "label": "has",
    "to": 449
  }, {
    "from": 311,
    "label": "has",
    "to": 450
  }, {
    "from": 311,
    "label": "has",
    "to": 451
  }, {
    "from": 311,
    "label": "has",
    "to": 452
  }, {
    "from": 311,
    "label": "has",
    "to": 453
  }, {
    "from": 311,
    "label": "has",
    "to": 454
  }, {
    "from": 311,
    "label": "has",
    "to": 455
  }, {
    "from": 311,
    "label": "has",
    "to": 456
  }, {
    "from": 311,
    "label": "has",
    "to": 457
  }, {
    "from": 311,
    "label": "has",
    "to": 458
  }, {
    "from": 311,
    "label": "has",
    "to": 459
  }, {
    "from": 311,
    "label": "has",
    "to": 460
  }, {
    "from": 311,
    "label": "has",
    "to": 461
  }, {
    "from": 311,
    "label": "has",
    "to": 462
  }, {
    "from": 311,
    "label": "has",
    "to": 463
  }, {
    "from": 311,
    "label": "has",
    "to": 464
  }, {
    "from": 311,
    "label": "has",
    "to": 465
  }, {
    "from": 311,
    "label": "has",
    "to": 466
  }, {
    "from": 311,
    "label": "has",
    "to": 467
  }, {
    "from": 311,
    "label": "has",
    "to": 468
  }, {
    "from": 311,
    "label": "has",
    "to": 469
  }, {
    "from": 311,
    "label": "has",
    "to": 470
  }, {
    "from": 311,
    "label": "has",
    "to": 471
  }, {
    "from": 311,
    "label": "has",
    "to": 472
  }, {
    "from": 311,
    "label": "has",
    "to": 473
  }, {
    "from": 311,
    "label": "has",
    "to": 474
  }, {
    "from": 311,
    "label": "has",
    "to": 475
  }, {
    "from": 311,
    "label": "has",
    "to": 476
  }, {
    "from": 311,
    "label": "has",
    "to": 477
  }, {
    "from": 311,
    "label": "has",
    "to": 478
  }, {
    "from": 311,
    "label": "has",
    "to": 479
  }, {
    "from": 311,
    "label": "has",
    "to": 480
  }, {
    "from": 311,
    "label": "has",
    "to": 481
  }, {
    "from": 311,
    "label": "has",
    "to": 482
  }, {
    "from": 311,
    "label": "has",
    "to": 483
  }, {
    "from": 311,
    "label": "has",
    "to": 484
  }, {
    "from": 311,
    "label": "has",
    "to": 485
  }, {
    "from": 311,
    "label": "has",
    "to": 486
  }, {
    "from": 311,
    "label": "has",
    "to": 487
  }, {
    "from": 311,
    "label": "has",
    "to": 488
  }, {
    "from": 311,
    "label": "has",
    "to": 489
  }, {
    "from": 311,
    "label": "has",
    "to": 490
  }, {
    "from": 311,
    "label": "has",
    "to": 491
  }, {
    "from": 311,
    "label": "has",
    "to": 492
  }, {
    "from": 311,
    "label": "has",
    "to": 493
  }, {
    "from": 311,
    "label": "has",
    "to": 494
  }, {
    "from": 311,
    "label": "has",
    "to": 495
  }, {
    "from": 311,
    "label": "has",
    "to": 496
  }, {
    "from": 311,
    "label": "has",
    "to": 497
  }, {
    "from": 311,
    "label": "has",
    "to": 498
  }, {
    "from": 311,
    "label": "has",
    "to": 499
  }, {
    "from": 311,
    "label": "has",
    "to": 500
  }, {
    "from": 311,
    "label": "has",
    "to": 501
  }, {
    "from": 311,
    "label": "has",
    "to": 502
  }, {
    "from": 311,
    "label": "has",
    "to": 503
  }, {
    "from": 311,
    "label": "has",
    "to": 504
  }, {
    "from": 311,
    "label": "has",
    "to": 505
  }, {
    "from": 311,
    "label": "has",
    "to": 506
  }, {
    "from": 311,
    "label": "has",
    "to": 507
  }, {
    "from": 311,
    "label": "has",
    "to": 508
  }, {
    "from": 311,
    "label": "has",
    "to": 509
  }, {
    "from": 311,
    "label": "has",
    "to": 510
  }, {
    "from": 311,
    "label": "has",
    "to": 511
  }, {
    "from": 311,
    "label": "has",
    "to": 512
  }, {
    "from": 311,
    "label": "has",
    "to": 513
  }, {
    "from": 311,
    "label": "has",
    "to": 514
  }, {
    "from": 311,
    "label": "has",
    "to": 515
  }, {
    "from": 311,
    "label": "has",
    "to": 516
  }, {
    "from": 311,
    "label": "has",
    "to": 517
  }, {
    "from": 311,
    "label": "has",
    "to": 518
  }, {
    "from": 311,
    "label": "has",
    "to": 519
  }, {
    "from": 311,
    "label": "has",
    "to": 520
  }, {
    "from": 311,
    "label": "has",
    "to": 521
  }, {
    "from": 311,
    "label": "has",
    "to": 522
  }, {
    "from": 311,
    "label": "has",
    "to": 523
  }, {
    "from": 311,
    "label": "has",
    "to": 524
  }, {
    "from": 311,
    "label": "has",
    "to": 525
  }, {
    "from": 311,
    "label": "has",
    "to": 526
  }, {
    "from": 311,
    "label": "has",
    "to": 527
  }, {
    "from": 311,
    "label": "has",
    "to": 528
  }, {
    "from": 311,
    "label": "has",
    "to": 529
  }, {
    "from": 311,
    "label": "has",
    "to": 530
  }, {
    "from": 311,
    "label": "has",
    "to": 531
  }, {
    "from": 311,
    "label": "has",
    "to": 532
  }, {
    "from": 311,
    "label": "has",
    "to": 533
  }, {
    "from": 311,
    "label": "has",
    "to": 534
  }, {
    "from": 311,
    "label": "has",
    "to": 535
  }, {
    "from": 311,
    "label": "has",
    "to": 536
  }, {
    "from": 311,
    "label": "has",
    "to": 537
  }, {
    "from": 311,
    "label": "has",
    "to": 538
  }, {
    "from": 311,
    "label": "has",
    "to": 539
  }, {
    "from": 311,
    "label": "has",
    "to": 540
  }, {
    "from": 311,
    "label": "has",
    "to": 541
  }, {
    "from": 311,
    "label": "has",
    "to": 542
  }, {
    "from": 311,
    "label": "has",
    "to": 543
  }, {
    "from": 311,
    "label": "has",
    "to": 544
  }, {
    "from": 311,
    "label": "has",
    "to": 545
  }, {
    "from": 311,
    "label": "has",
    "to": 546
  }, {
    "from": 311,
    "label": "has",
    "to": 547
  }, {
    "from": 311,
    "label": "has",
    "to": 548
  }, {
    "from": 311,
    "label": "has",
    "to": 549
  }, {
    "from": 311,
    "label": "has",
    "to": 550
  }, {
    "from": 311,
    "label": "has",
    "to": 551
  }, {
    "from": 311,
    "label": "has",
    "to": 552
  }, {
    "from": 311,
    "label": "has",
    "to": 553
  }, {
    "from": 311,
    "label": "has",
    "to": 554
  }, {
    "from": 311,
    "label": "has",
    "to": 555
  }, {
    "from": 311,
    "label": "has",
    "to": 556
  }, {
    "from": 311,
    "label": "has",
    "to": 557
  }, {
    "from": 311,
    "label": "has",
    "to": 558
  }, {
    "from": 311,
    "label": "has",
    "to": 559
  }, {
    "from": 311,
    "label": "has",
    "to": 560
  }, {
    "from": 311,
    "label": "has",
    "to": 561
  }, {
    "from": 311,
    "label": "has",
    "to": 562
  }, {
    "from": 311,
    "label": "has",
    "to": 563
  }, {
    "from": 311,
    "label": "has",
    "to": 564
  }, {
    "from": 311,
    "label": "has",
    "to": 565
  }, {
    "from": 311,
    "label": "has",
    "to": 566
  }, {
    "from": 311,
    "label": "has",
    "to": 567
  }, {
    "from": 311,
    "label": "has",
    "to": 568
  }, {
    "from": 311,
    "label": "has",
    "to": 569
  }, {
    "from": 311,
    "label": "has",
    "to": 570
  }, {
    "from": 311,
    "label": "has",
    "to": 571
  }, {
    "from": 311,
    "label": "has",
    "to": 572
  }, {
    "from": 311,
    "label": "has",
    "to": 573
  }, {
    "from": 311,
    "label": "has",
    "to": 574
  }, {
    "from": 311,
    "label": "has",
    "to": 575
  }, {
    "from": 311,
    "label": "has",
    "to": 576
  }, {
    "from": 311,
    "label": "has",
    "to": 577
  }, {
    "from": 311,
    "label": "has",
    "to": 578
  }, {
    "from": 311,
    "label": "has",
    "to": 579
  }, {
    "from": 311,
    "label": "has",
    "to": 580
  }, {
    "from": 311,
    "label": "has",
    "to": 581
  }, {
    "from": 311,
    "label": "has",
    "to": 582
  }, {
    "from": 311,
    "label": "has",
    "to": 583
  }, {
    "from": 311,
    "label": "has",
    "to": 584
  }, {
    "from": 311,
    "label": "has",
    "to": 585
  }, {
    "from": 311,
    "label": "has",
    "to": 586
  }, {
    "from": 311,
    "label": "has",
    "to": 587
  }, {
    "from": 311,
    "label": "has",
    "to": 588
  }, {
    "from": 311,
    "label": "has",
    "to": 589
  }, {
    "from": 311,
    "label": "has",
    "to": 590
  }, {
    "from": 311,
    "label": "has",
    "to": 591
  }, {
    "from": 311,
    "label": "has",
    "to": 592
  }, {
    "from": 311,
    "label": "has",
    "to": 593
  }, {
    "from": 311,
    "label": "has",
    "to": 594
  }, {
    "from": 311,
    "label": "has",
    "to": 595
  }, {
    "from": 311,
    "label": "has",
    "to": 596
  }, {
    "from": 311,
    "label": "has",
    "to": 597
  }, {
    "from": 311,
    "label": "has",
    "to": 598
  }, {
    "from": 311,
    "label": "has",
    "to": 599
  }, {
    "from": 311,
    "label": "has",
    "to": 600
  }, {
    "from": 311,
    "label": "has",
    "to": 601
  }, {
    "from": 311,
    "label": "has",
    "to": 602
  }, {
    "from": 311,
    "label": "has",
    "to": 603
  }, {
    "from": 311,
    "label": "has",
    "to": 604
  }, {
    "from": 311,
    "label": "has",
    "to": 605
  }, {
    "from": 311,
    "label": "has",
    "to": 606
  }, {
    "from": 311,
    "label": "has",
    "to": 607
  }, {
    "from": 311,
    "label": "has",
    "to": 608
  }, {
    "from": 311,
    "label": "has",
    "to": 609
  }, {
    "from": 311,
    "label": "has",
    "to": 610
  }, {
    "from": 311,
    "label": "has",
    "to": 611
  }, {
    "from": 311,
    "label": "has",
    "to": 612
  }, {
    "from": 311,
    "label": "has",
    "to": 613
  }, {
    "from": 311,
    "label": "has",
    "to": 614
  }, {
    "from": 311,
    "label": "has",
    "to": 615
  }, {
    "from": 311,
    "label": "has",
    "to": 616
  }, {
    "from": 311,
    "label": "has",
    "to": 617
  }, {
    "from": 311,
    "label": "has",
    "to": 618
  }, {
    "from": 311,
    "label": "has",
    "to": 619
  }, {
    "from": 311,
    "label": "has",
    "to": 620
  }, {
    "from": 311,
    "label": "has",
    "to": 621
  }, {
    "from": 311,
    "label": "has",
    "to": 622
  }, {
    "from": 311,
    "label": "has",
    "to": 623
  }, {
    "from": 311,
    "label": "has",
    "to": 624
  }, {
    "from": 311,
    "label": "has",
    "to": 625
  }, {
    "from": 311,
    "label": "has",
    "to": 626
  }, {
    "from": 311,
    "label": "has",
    "to": 627
  }, {
    "from": 311,
    "label": "has",
    "to": 628
  }, {
    "from": 311,
    "label": "has",
    "to": 629
  }, {
    "from": 311,
    "label": "has",
    "to": 630
  }, {
    "from": 311,
    "label": "has",
    "to": 631
  }, {
    "from": 311,
    "label": "has",
    "to": 632
  }, {
    "from": 311,
    "label": "has",
    "to": 633
  }, {
    "from": 311,
    "label": "has",
    "to": 634
  }, {
    "from": 311,
    "label": "has",
    "to": 635
  }, {
    "from": 311,
    "label": "has",
    "to": 636
  }, {
    "from": 311,
    "label": "has",
    "to": 637
  }, {
    "from": 311,
    "label": "has",
    "to": 638
  }, {
    "from": 311,
    "label": "has",
    "to": 639
  }, {
    "from": 311,
    "label": "has",
    "to": 640
  }, {
    "from": 311,
    "label": "has",
    "to": 641
  }, {
    "from": 311,
    "label": "has",
    "to": 642
  }, {
    "from": 311,
    "label": "has",
    "to": 643
  }, {
    "from": 311,
    "label": "has",
    "to": 644
  }, {
    "from": 311,
    "label": "has",
    "to": 645
  }, {
    "from": 311,
    "label": "has",
    "to": 646
  }, {
    "from": 311,
    "label": "has",
    "to": 647
  }, {
    "from": 311,
    "label": "has",
    "to": 648
  }, {
    "from": 311,
    "label": "has",
    "to": 649
  }, {
    "from": 311,
    "label": "has",
    "to": 650
  }, {
    "from": 311,
    "label": "has",
    "to": 651
  }, {
    "from": 311,
    "label": "has",
    "to": 652
  }, {
    "from": 311,
    "label": "has",
    "to": 653
  }, {
    "from": 311,
    "label": "has",
    "to": 654
  }, {
    "from": 311,
    "label": "has",
    "to": 655
  }, {
    "from": 311,
    "label": "has",
    "to": 656
  }, {
    "from": 311,
    "label": "has",
    "to": 657
  }, {
    "from": 311,
    "label": "has",
    "to": 658
  }, {
    "from": 311,
    "label": "has",
    "to": 659
  }, {
    "from": 311,
    "label": "has",
    "to": 660
  }, {
    "from": 311,
    "label": "has",
    "to": 661
  }, {
    "from": 311,
    "label": "has",
    "to": 662
  }, {
    "from": 311,
    "label": "has",
    "to": 663
  }, {
    "from": 311,
    "label": "has",
    "to": 664
  }, {
    "from": 311,
    "label": "has",
    "to": 665
  }, {
    "from": 311,
    "label": "has",
    "to": 666
  }, {
    "from": 311,
    "label": "has",
    "to": 667
  }, {
    "from": 311,
    "label": "has",
    "to": 668
  }, {
    "from": 311,
    "label": "has",
    "to": 669
  }, {
    "from": 311,
    "label": "has",
    "to": 670
  }, {
    "from": 311,
    "label": "has",
    "to": 671
  }, {
    "from": 311,
    "label": "has",
    "to": 672
  }, {
    "from": 311,
    "label": "has",
    "to": 673
  }, {
    "from": 311,
    "label": "has",
    "to": 674
  }, {
    "from": 311,
    "label": "has",
    "to": 675
  }, {
    "from": 311,
    "label": "has",
    "to": 676
  }, {
    "from": 311,
    "label": "has",
    "to": 677
  }, {
    "from": 311,
    "label": "has",
    "to": 678
  }, {
    "from": 311,
    "label": "has",
    "to": 679
  }, {
    "from": 311,
    "label": "has",
    "to": 680
  }, {
    "from": 311,
    "label": "has",
    "to": 681
  }, {
    "from": 311,
    "label": "has",
    "to": 682
  }, {
    "from": 311,
    "label": "has",
    "to": 683
  }, {
    "from": 311,
    "label": "has",
    "to": 684
  }, {
    "from": 311,
    "label": "has",
    "to": 685
  }, {
    "from": 311,
    "label": "has",
    "to": 686
  }, {
    "from": 311,
    "label": "has",
    "to": 687
  }, {
    "from": 311,
    "label": "has",
    "to": 688
  }, {
    "from": 311,
    "label": "has",
    "to": 689
  }, {
    "from": 311,
    "label": "has",
    "to": 690
  }, {
    "from": 311,
    "label": "has",
    "to": 691
  }, {
    "from": 311,
    "label": "has",
    "to": 692
  }, {
    "from": 311,
    "label": "has",
    "to": 693
  }, {
    "from": 311,
    "label": "has",
    "to": 694
  }, {
    "from": 311,
    "label": "has",
    "to": 695
  }, {
    "from": 311,
    "label": "has",
    "to": 696
  }, {
    "from": 311,
    "label": "has",
    "to": 697
  }, {
    "from": 311,
    "label": "has",
    "to": 698
  }, {
    "from": 311,
    "label": "has",
    "to": 699
  }, {
    "from": 311,
    "label": "has",
    "to": 700
  }, {
    "from": 311,
    "label": "has",
    "to": 701
  }, {
    "from": 311,
    "label": "has",
    "to": 702
  }, {
    "from": 311,
    "label": "has",
    "to": 703
  }, {
    "from": 311,
    "label": "has",
    "to": 704
  }, {
    "from": 311,
    "label": "has",
    "to": 705
  }, {
    "from": 311,
    "label": "has",
    "to": 706
  }, {
    "from": 311,
    "label": "has",
    "to": 707
  }, {
    "from": 311,
    "label": "has",
    "to": 708
  }, {
    "from": 311,
    "label": "has",
    "to": 709
  }, {
    "from": 311,
    "label": "has",
    "to": 710
  }, {
    "from": 311,
    "label": "has",
    "to": 711
  }, {
    "from": 311,
    "label": "has",
    "to": 712
  }, {
    "from": 311,
    "label": "has",
    "to": 713
  }, {
    "from": 311,
    "label": "has",
    "to": 714
  }, {
    "from": 311,
    "label": "has",
    "to": 715
  }, {
    "from": 311,
    "label": "has",
    "to": 716
  }, {
    "from": 311,
    "label": "has",
    "to": 717
  }, {
    "from": 311,
    "label": "has",
    "to": 718
  }, {
    "from": 311,
    "label": "has",
    "to": 719
  }, {
    "from": 311,
    "label": "has",
    "to": 720
  }, {
    "from": 311,
    "label": "has",
    "to": 721
  }, {
    "from": 311,
    "label": "has",
    "to": 722
  }, {
    "from": 311,
    "label": "has",
    "to": 723
  }, {
    "from": 311,
    "label": "has",
    "to": 724
  }, {
    "from": 311,
    "label": "has",
    "to": 725
  }, {
    "from": 311,
    "label": "has",
    "to": 726
  }, {
    "from": 311,
    "label": "has",
    "to": 727
  }, {
    "from": 311,
    "label": "has",
    "to": 728
  }, {
    "from": 311,
    "label": "has",
    "to": 729
  }, {
    "from": 311,
    "label": "has",
    "to": 730
  }, {
    "from": 311,
    "label": "has",
    "to": 731
  }, {
    "from": 311,
    "label": "has",
    "to": 732
  }, {
    "from": 311,
    "label": "has",
    "to": 733
  }, {
    "from": 311,
    "label": "has",
    "to": 734
  }, {
    "from": 311,
    "label": "has",
    "to": 735
  }, {
    "from": 311,
    "label": "has",
    "to": 736
  }, {
    "from": 311,
    "label": "has",
    "to": 737
  }, {
    "from": 311,
    "label": "has",
    "to": 738
  }, {
    "from": 311,
    "label": "has",
    "to": 739
  }, {
    "from": 311,
    "label": "has",
    "to": 740
  }, {
    "from": 311,
    "label": "has",
    "to": 741
  }, {
    "from": 311,
    "label": "has",
    "to": 742
  }, {
    "from": 311,
    "label": "has",
    "to": 743
  }, {
    "from": 311,
    "label": "has",
    "to": 744
  }, {
    "from": 311,
    "label": "has",
    "to": 745
  }, {
    "from": 311,
    "label": "has",
    "to": 746
  }, {
    "from": 311,
    "label": "has",
    "to": 747
  }, {
    "from": 311,
    "label": "has",
    "to": 748
  }, {
    "from": 311,
    "label": "has",
    "to": 749
  }, {
    "from": 311,
    "label": "has",
    "to": 750
  }, {
    "from": 311,
    "label": "has",
    "to": 751
  }, {
    "from": 311,
    "label": "has",
    "to": 752
  }, {
    "from": 311,
    "label": "has",
    "to": 753
  }, {
    "from": 311,
    "label": "has",
    "to": 754
  }, {
    "from": 311,
    "label": "has",
    "to": 755
  }, {
    "from": 311,
    "label": "has",
    "to": 756
  }, {
    "from": 311,
    "label": "has",
    "to": 757
  }, {
    "from": 311,
    "label": "has",
    "to": 758
  }, {
    "from": 311,
    "label": "has",
    "to": 759
  }, {
    "from": 311,
    "label": "has",
    "to": 760
  }, {
    "from": 311,
    "label": "has",
    "to": 761
  }, {
    "from": 311,
    "label": "has",
    "to": 762
  }, {
    "from": 311,
    "label": "has",
    "to": 763
  }, {
    "from": 311,
    "label": "has",
    "to": 764
  }, {
    "from": 311,
    "label": "has",
    "to": 765
  }, {
    "from": 311,
    "label": "has",
    "to": 766
  }, {
    "from": 311,
    "label": "has",
    "to": 767
  }, {
    "from": 311,
    "label": "has",
    "to": 768
  }, {
    "from": 311,
    "label": "has",
    "to": 769
  }, {
    "from": 311,
    "label": "has",
    "to": 770
  }, {
    "from": 311,
    "label": "has",
    "to": 771
  }, {
    "from": 311,
    "label": "has",
    "to": 772
  }, {
    "from": 311,
    "label": "has",
    "to": 773
  }, {
    "from": 311,
    "label": "has",
    "to": 774
  }, {
    "from": 311,
    "label": "has",
    "to": 775
  }, {
    "from": 311,
    "label": "has",
    "to": 776
  }, {
    "from": 311,
    "label": "has",
    "to": 777
  }, {
    "from": 311,
    "label": "has",
    "to": 778
  }, {
    "from": 311,
    "label": "has",
    "to": 779
  }, {
    "from": 311,
    "label": "has",
    "to": 780
  }, {
    "from": 781,
    "label": "has",
    "to": 782
  }, {
    "from": 781,
    "label": "has",
    "to": 22
  }, {
    "from": 781,
    "label": "has",
    "to": 22
  }, {
    "from": 781,
    "label": "has",
    "to": 783
  }, {
    "from": 784,
    "label": "has",
    "to": 785
  }, {
    "from": 784,
    "label": "has",
    "to": 786
  }, {
    "from": 784,
    "label": "has",
    "to": 787
  }, {
    "from": 784,
    "label": "has",
    "to": 788
  }, {
    "from": 784,
    "label": "has",
    "to": 22
  }, {
    "from": 784,
    "label": "has",
    "to": 789
  }, {
    "from": 784,
    "label": "has",
    "to": 790
  }, {
    "from": 784,
    "label": "has",
    "to": 791
  }, {
    "from": 784,
    "label": "has",
    "to": 792
  }, {
    "from": 784,
    "label": "has",
    "to": 793
  }, {
    "from": 784,
    "label": "has",
    "to": 794
  }, {
    "from": 784,
    "label": "has",
    "to": 795
  }, {
    "from": 784,
    "label": "has",
    "to": 796
  }, {
    "from": 784,
    "label": "has",
    "to": 797
  }, {
    "from": 797,
    "label": "has",
    "to": 798
  }, {
    "from": 797,
    "label": "has",
    "to": 799
  }, {
    "from": 799,
    "label": "has",
    "to": 800
  }, {
    "from": 799,
    "label": "has",
    "to": 801
  }, {
    "from": 799,
    "label": "has",
    "to": 802
  }, {
    "from": 799,
    "label": "has",
    "to": 803
  }, {
    "from": 803,
    "label": "has",
    "to": 804
  }, {
    "from": 803,
    "label": "has",
    "to": 805
  }, {
    "from": 803,
    "label": "has",
    "to": 806
  }, {
    "from": 784,
    "label": "has",
    "to": 807
  }, {
    "from": 784,
    "label": "has",
    "to": 808
  }, {
    "from": 808,
    "label": "has",
    "to": 809
  }, {
    "from": 809,
    "label": "has",
    "to": 810
  }, {
    "from": 784,
    "label": "has",
    "to": 811
  }, {
    "from": 784,
    "label": "has",
    "to": 812
  }, {
    "from": 812,
    "label": "has",
    "to": 813
  }, {
    "from": 812,
    "label": "has",
    "to": 814
  }, {
    "from": 812,
    "label": "has",
    "to": 815
  }, {
    "from": 812,
    "label": "has",
    "to": 816
  }, {
    "from": 816,
    "label": "has",
    "to": 817
  }, {
    "from": 817,
    "label": "has",
    "to": 818
  }, {
    "from": 818,
    "label": "has",
    "to": 20
  }, {
    "from": 818,
    "label": "has",
    "to": 819
  }, {
    "from": 818,
    "label": "has",
    "to": 820
  }, {
    "from": 817,
    "label": "has",
    "to": 821
  }, {
    "from": 812,
    "label": "has",
    "to": 822
  }, {
    "from": 822,
    "label": "has",
    "to": 823
  }, {
    "from": 823,
    "label": "has",
    "to": 824
  }, {
    "from": 824,
    "label": "has",
    "to": 825
  }, {
    "from": 822,
    "label": "has",
    "to": 826
  }, {
    "from": 826,
    "label": "has",
    "to": 827
  }, {
    "from": 822,
    "label": "has",
    "to": 828
  }, {
    "from": 828,
    "label": "has",
    "to": 829
  }, {
    "from": 812,
    "label": "has",
    "to": 830
  }, {
    "from": 830,
    "label": "has",
    "to": 831
  }, {
    "from": 831,
    "label": "has",
    "to": 832
  }, {
    "from": 830,
    "label": "has",
    "to": 833
  }, {
    "from": 830,
    "label": "has",
    "to": 20
  }, {
    "from": 830,
    "label": "has",
    "to": 834
  }, {
    "from": 834,
    "label": "has",
    "to": 835
  }, {
    "from": 830,
    "label": "has",
    "to": 836
  }, {
    "from": 836,
    "label": "has",
    "to": 837
  }, {
    "from": 830,
    "label": "has",
    "to": 838
  }, {
    "from": 830,
    "label": "has",
    "to": 839
  }, {
    "from": 784,
    "label": "has",
    "to": 840
  }, {
    "from": 840,
    "label": "has",
    "to": 841
  }, {
    "from": 784,
    "label": "has",
    "to": 842
  }, {
    "from": 842,
    "label": "has",
    "to": 843
  }, {
    "from": 842,
    "label": "has",
    "to": 844
  }, {
    "from": 784,
    "label": "has",
    "to": 22
  }, {
    "from": 784,
    "label": "has",
    "to": 845
  }, {
    "from": 846,
    "label": "has",
    "to": 847
  }, {
    "from": 846,
    "label": "has",
    "to": 848
  }, {
    "from": 846,
    "label": "has",
    "to": 849
  }, {
    "from": 846,
    "label": "has",
    "to": 850
  }, {
    "from": 846,
    "label": "has",
    "to": 851
  }, {
    "from": 846,
    "label": "has",
    "to": 852
  }, {
    "from": 846,
    "label": "has",
    "to": 853
  }, {
    "from": 853,
    "label": "has",
    "to": 854
  }, {
    "from": 846,
    "label": "has",
    "to": 22
  }, {
    "from": 846,
    "label": "has",
    "to": 855
  }, {
    "from": 855,
    "label": "has",
    "to": 856
  }, {
    "from": 855,
    "label": "has",
    "to": 857
  }, {
    "from": 855,
    "label": "has",
    "to": 858
  }, {
    "from": 855,
    "label": "has",
    "to": 859
  }, {
    "from": 855,
    "label": "has",
    "to": 860
  }, {
    "from": 860,
    "label": "has",
    "to": 861
  }, {
    "from": 860,
    "label": "has",
    "to": 862
  }, {
    "from": 862,
    "label": "has",
    "to": 863
  }, {
    "from": 862,
    "label": "has",
    "to": 864
  }, {
    "from": 862,
    "label": "has",
    "to": 865
  }, {
    "from": 862,
    "label": "has",
    "to": 866
  }, {
    "from": 862,
    "label": "has",
    "to": 867
  }, {
    "from": 855,
    "label": "has",
    "to": 868
  }, {
    "from": 868,
    "label": "has",
    "to": 869
  }, {
    "from": 869,
    "label": "has",
    "to": 870
  }, {
    "from": 869,
    "label": "has",
    "to": 871
  }, {
    "from": 868,
    "label": "has",
    "to": 872
  }, {
    "from": 855,
    "label": "has",
    "to": 873
  }, {
    "from": 873,
    "label": "has",
    "to": 874
  }, {
    "from": 874,
    "label": "has",
    "to": 875
  }, {
    "from": 873,
    "label": "has",
    "to": 876
  }, {
    "from": 876,
    "label": "has",
    "to": 877
  }, {
    "from": 873,
    "label": "has",
    "to": 878
  }, {
    "from": 873,
    "label": "has",
    "to": 879
  }, {
    "from": 873,
    "label": "has",
    "to": 880
  }, {
    "from": 873,
    "label": "has",
    "to": 881
  }, {
    "from": 873,
    "label": "has",
    "to": 882
  }, {
    "from": 873,
    "label": "has",
    "to": 883
  }, {
    "from": 846,
    "label": "has",
    "to": 884
  }, {
    "from": 885,
    "label": "has",
    "to": 886
  }, {
    "from": 885,
    "label": "has",
    "to": 887
  }, {
    "from": 885,
    "label": "has",
    "to": 22
  }, {
    "from": 885,
    "label": "has",
    "to": 888
  }, {
    "from": 889,
    "label": "has",
    "to": 886
  }, {
    "from": 889,
    "label": "has",
    "to": 887
  }, {
    "from": 889,
    "label": "has",
    "to": 890
  }, {
    "from": 890,
    "label": "has",
    "to": 891
  }, {
    "from": 889,
    "label": "has",
    "to": 22
  }, {
    "from": 889,
    "label": "has",
    "to": 892
  }, {
    "from": 893,
    "label": "has",
    "to": 894
  }, {
    "from": 893,
    "label": "has",
    "to": 895
  }, {
    "from": 893,
    "label": "has",
    "to": 896
  }, {
    "from": 896,
    "label": "has",
    "to": 859
  }, {
    "from": 896,
    "label": "has",
    "to": 897
  }, {
    "from": 896,
    "label": "has",
    "to": 898
  }, {
    "from": 893,
    "label": "has",
    "to": 22
  }, {
    "from": 893,
    "label": "has",
    "to": 899
  }, {
    "from": 900,
    "label": "has",
    "to": 901
  }, {
    "from": 900,
    "label": "has",
    "to": 22
  }, {
    "from": 900,
    "label": "has",
    "to": 22
  }, {
    "from": 900,
    "label": "has",
    "to": 902
  }, {
    "from": 903,
    "label": "has",
    "to": 904
  }, {
    "from": 903,
    "label": "has",
    "to": 905
  }, {
    "from": 903,
    "label": "has",
    "to": 906
  }, {
    "from": 903,
    "label": "has",
    "to": 907
  }, {
    "from": 907,
    "label": "has",
    "to": 908
  }, {
    "from": 907,
    "label": "has",
    "to": 909
  }, {
    "from": 909,
    "label": "has",
    "to": 910
  }, {
    "from": 909,
    "label": "has",
    "to": 911
  }, {
    "from": 909,
    "label": "has",
    "to": 912
  }, {
    "from": 909,
    "label": "has",
    "to": 913
  }, {
    "from": 903,
    "label": "has",
    "to": 914
  }, {
    "from": 903,
    "label": "has",
    "to": 915
  }, {
    "from": 903,
    "label": "has",
    "to": 916
  }, {
    "from": 903,
    "label": "has",
    "to": 917
  }, {
    "from": 917,
    "label": "has",
    "to": 918
  }, {
    "from": 917,
    "label": "has",
    "to": 919
  }, {
    "from": 919,
    "label": "has",
    "to": 920
  }, {
    "from": 919,
    "label": "has",
    "to": 921
  }, {
    "from": 903,
    "label": "has",
    "to": 914
  }, {
    "from": 903,
    "label": "has",
    "to": 922
  }, {
    "from": 903,
    "label": "has",
    "to": 22
  }, {
    "from": 903,
    "label": "has",
    "to": 923
  }, {
    "from": 924,
    "label": "has",
    "to": 906
  }, {
    "from": 924,
    "label": "has",
    "to": 925
  }, {
    "from": 924,
    "label": "has",
    "to": 926
  }, {
    "from": 924,
    "label": "has",
    "to": 927
  }, {
    "from": 927,
    "label": "has",
    "to": 928
  }, {
    "from": 927,
    "label": "has",
    "to": 929
  }, {
    "from": 927,
    "label": "has",
    "to": 930
  }, {
    "from": 927,
    "label": "has",
    "to": 931
  }, {
    "from": 927,
    "label": "has",
    "to": 932
  }, {
    "from": 932,
    "label": "has",
    "to": 933
  }, {
    "from": 932,
    "label": "has",
    "to": 934
  }, {
    "from": 927,
    "label": "has",
    "to": 935
  }, {
    "from": 927,
    "label": "has",
    "to": 936
  }, {
    "from": 936,
    "label": "has",
    "to": 937
  }, {
    "from": 936,
    "label": "has",
    "to": 938
  }, {
    "from": 936,
    "label": "has",
    "to": 939
  }, {
    "from": 939,
    "label": "has",
    "to": 940
  }, {
    "from": 924,
    "label": "has",
    "to": 941
  }, {
    "from": 924,
    "label": "has",
    "to": 942
  }, {
    "from": 924,
    "label": "has",
    "to": 943
  }, {
    "from": 943,
    "label": "has",
    "to": 940
  }, {
    "from": 924,
    "label": "has",
    "to": 930
  }, {
    "from": 924,
    "label": "has",
    "to": 944
  }, {
    "from": 944,
    "label": "has",
    "to": 933
  }, {
    "from": 924,
    "label": "has",
    "to": 945
  }, {
    "from": 924,
    "label": "has",
    "to": 946
  }, {
    "from": 924,
    "label": "has",
    "to": 947
  }, {
    "from": 924,
    "label": "has",
    "to": 948
  }, {
    "from": 924,
    "label": "has",
    "to": 949
  }, {
    "from": 924,
    "label": "has",
    "to": 950
  }, {
    "from": 924,
    "label": "has",
    "to": 951
  }, {
    "from": 924,
    "label": "has",
    "to": 952
  }, {
    "from": 924,
    "label": "has",
    "to": 943
  }, {
    "from": 943,
    "label": "has",
    "to": 940
  }, {
    "from": 924,
    "label": "has",
    "to": 914
  }, {
    "from": 924,
    "label": "has",
    "to": 22
  }, {
    "from": 924,
    "label": "has",
    "to": 953
  }, {
    "from": 954,
    "label": "has",
    "to": 955
  }, {
    "from": 954,
    "label": "has",
    "to": 22
  }, {
    "from": 954,
    "label": "has",
    "to": 956
  }, {
    "from": 957,
    "label": "has",
    "to": 958
  }, {
    "from": 957,
    "label": "has",
    "to": 22
  }, {
    "from": 957,
    "label": "has",
    "to": 959
  }, {
    "from": 960,
    "label": "has",
    "to": 961
  }, {
    "from": 960,
    "label": "has",
    "to": 22
  }, {
    "from": 960,
    "label": "has",
    "to": 962
  }, {
    "from": 963,
    "label": "has",
    "to": 964
  }, {
    "from": 964,
    "label": "has",
    "to": 965
  }, {
    "from": 963,
    "label": "has",
    "to": 966
  }, {
    "from": 967,
    "label": "has",
    "to": 968
  }, {
    "from": 967,
    "label": "has",
    "to": 969
  }, {
    "from": 969,
    "label": "has",
    "to": 970
  }, {
    "from": 969,
    "label": "has",
    "to": 971
  }, {
    "from": 969,
    "label": "has",
    "to": 972
  }, {
    "from": 969,
    "label": "has",
    "to": 973
  }, {
    "from": 969,
    "label": "has",
    "to": 974
  }, {
    "from": 969,
    "label": "has",
    "to": 975
  }, {
    "from": 975,
    "label": "has",
    "to": 976
  }, {
    "from": 975,
    "label": "has",
    "to": 977
  }, {
    "from": 977,
    "label": "has",
    "to": 978
  }, {
    "from": 978,
    "label": "has",
    "to": 979
  }, {
    "from": 978,
    "label": "has",
    "to": 980
  }, {
    "from": 977,
    "label": "has",
    "to": 981
  }, {
    "from": 981,
    "label": "has",
    "to": 982
  }, {
    "from": 982,
    "label": "has",
    "to": 983
  }, {
    "from": 982,
    "label": "has",
    "to": 984
  }, {
    "from": 982,
    "label": "has",
    "to": 985
  }, {
    "from": 982,
    "label": "has",
    "to": 986
  }, {
    "from": 977,
    "label": "has",
    "to": 987
  }, {
    "from": 987,
    "label": "has",
    "to": 988
  }, {
    "from": 988,
    "label": "has",
    "to": 989
  }, {
    "from": 987,
    "label": "has",
    "to": 990
  }, {
    "from": 987,
    "label": "has",
    "to": 991
  }, {
    "from": 987,
    "label": "has",
    "to": 992
  }, {
    "from": 992,
    "label": "has",
    "to": 993
  }, {
    "from": 987,
    "label": "has",
    "to": 994
  }, {
    "from": 987,
    "label": "has",
    "to": 988
  }, {
    "from": 988,
    "label": "has",
    "to": 989
  }, {
    "from": 987,
    "label": "has",
    "to": 995
  }, {
    "from": 995,
    "label": "has",
    "to": 996
  }, {
    "from": 987,
    "label": "has",
    "to": 997
  }, {
    "from": 987,
    "label": "has",
    "to": 991
  }, {
    "from": 987,
    "label": "has",
    "to": 998
  }, {
    "from": 998,
    "label": "has",
    "to": 999
  }, {
    "from": 987,
    "label": "has",
    "to": 1000
  }, {
    "from": 987,
    "label": "has",
    "to": 1001
  }, {
    "from": 1001,
    "label": "has",
    "to": 1002
  }, {
    "from": 987,
    "label": "has",
    "to": 1000
  }, {
    "from": 987,
    "label": "has",
    "to": 1003
  }, {
    "from": 969,
    "label": "has",
    "to": 1004
  }, {
    "from": 1004,
    "label": "has",
    "to": 1005
  }, {
    "from": 1004,
    "label": "has",
    "to": 1006
  }, {
    "from": 1004,
    "label": "has",
    "to": 1007
  }, {
    "from": 1004,
    "label": "has",
    "to": 1008
  }, {
    "from": 1008,
    "label": "has",
    "to": 1009
  }, {
    "from": 1008,
    "label": "has",
    "to": 1010
  }, {
    "from": 1010,
    "label": "has",
    "to": 1011
  }, {
    "from": 967,
    "label": "has",
    "to": 1012
  }, {
    "from": 1013,
    "label": "has",
    "to": 1014
  }, {
    "from": 1013,
    "label": "has",
    "to": 1015
  }, {
    "from": 1013,
    "label": "has",
    "to": 1016
  }, {
    "from": 1013,
    "label": "has",
    "to": 1017
  }, {
    "from": 1013,
    "label": "has",
    "to": 1018
  }, {
    "from": 1013,
    "label": "has",
    "to": 1019
  }, {
    "from": 1013,
    "label": "has",
    "to": 1020
  }, {
    "from": 1013,
    "label": "has",
    "to": 1021
  }, {
    "from": 1021,
    "label": "has",
    "to": 1022
  }, {
    "from": 1021,
    "label": "has",
    "to": 970
  }, {
    "from": 1021,
    "label": "has",
    "to": 1023
  }, {
    "from": 1021,
    "label": "has",
    "to": 1024
  }, {
    "from": 1021,
    "label": "has",
    "to": 1025
  }, {
    "from": 1021,
    "label": "has",
    "to": 1026
  }, {
    "from": 1026,
    "label": "has",
    "to": 1027
  }, {
    "from": 1026,
    "label": "has",
    "to": 976
  }, {
    "from": 1026,
    "label": "has",
    "to": 1028
  }, {
    "from": 1026,
    "label": "has",
    "to": 1029
  }, {
    "from": 1029,
    "label": "has",
    "to": 1030
  }, {
    "from": 1030,
    "label": "has",
    "to": 1031
  }, {
    "from": 1030,
    "label": "has",
    "to": 1032
  }, {
    "from": 1030,
    "label": "has",
    "to": 1033
  }, {
    "from": 1033,
    "label": "has",
    "to": 1034
  }, {
    "from": 1030,
    "label": "has",
    "to": 1035
  }, {
    "from": 1035,
    "label": "has",
    "to": 1036
  }, {
    "from": 1030,
    "label": "has",
    "to": 1037
  }, {
    "from": 1037,
    "label": "has",
    "to": 1038
  }, {
    "from": 1037,
    "label": "has",
    "to": 1039
  }, {
    "from": 1037,
    "label": "has",
    "to": 1040
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1042
  }, {
    "from": 1037,
    "label": "has",
    "to": 1043
  }, {
    "from": 1037,
    "label": "has",
    "to": 1044
  }, {
    "from": 1044,
    "label": "has",
    "to": 1045
  }, {
    "from": 1037,
    "label": "has",
    "to": 1046
  }, {
    "from": 1037,
    "label": "has",
    "to": 1047
  }, {
    "from": 1047,
    "label": "has",
    "to": 1048
  }, {
    "from": 1037,
    "label": "has",
    "to": 1049
  }, {
    "from": 1037,
    "label": "has",
    "to": 1050
  }, {
    "from": 1037,
    "label": "has",
    "to": 1051
  }, {
    "from": 1037,
    "label": "has",
    "to": 1052
  }, {
    "from": 1037,
    "label": "has",
    "to": 1053
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1054
  }, {
    "from": 1037,
    "label": "has",
    "to": 1055
  }, {
    "from": 1037,
    "label": "has",
    "to": 1056
  }, {
    "from": 1037,
    "label": "has",
    "to": 1057
  }, {
    "from": 1037,
    "label": "has",
    "to": 1058
  }, {
    "from": 1058,
    "label": "has",
    "to": 1059
  }, {
    "from": 1037,
    "label": "has",
    "to": 1060
  }, {
    "from": 1037,
    "label": "has",
    "to": 1061
  }, {
    "from": 1037,
    "label": "has",
    "to": 1062
  }, {
    "from": 1062,
    "label": "has",
    "to": 1063
  }, {
    "from": 1037,
    "label": "has",
    "to": 1064
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1065
  }, {
    "from": 1037,
    "label": "has",
    "to": 1066
  }, {
    "from": 1066,
    "label": "has",
    "to": 1067
  }, {
    "from": 1037,
    "label": "has",
    "to": 1068
  }, {
    "from": 1037,
    "label": "has",
    "to": 1069
  }, {
    "from": 1069,
    "label": "has",
    "to": 1070
  }, {
    "from": 1037,
    "label": "has",
    "to": 1071
  }, {
    "from": 1037,
    "label": "has",
    "to": 1072
  }, {
    "from": 1072,
    "label": "has",
    "to": 1073
  }, {
    "from": 1037,
    "label": "has",
    "to": 1074
  }, {
    "from": 1037,
    "label": "has",
    "to": 1075
  }, {
    "from": 1075,
    "label": "has",
    "to": 1076
  }, {
    "from": 1037,
    "label": "has",
    "to": 1077
  }, {
    "from": 1037,
    "label": "has",
    "to": 1077
  }, {
    "from": 1037,
    "label": "has",
    "to": 1077
  }, {
    "from": 1037,
    "label": "has",
    "to": 1078
  }, {
    "from": 1037,
    "label": "has",
    "to": 1079
  }, {
    "from": 1037,
    "label": "has",
    "to": 1080
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1081
  }, {
    "from": 1081,
    "label": "has",
    "to": 1082
  }, {
    "from": 1037,
    "label": "has",
    "to": 1083
  }, {
    "from": 1037,
    "label": "has",
    "to": 1080
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1084
  }, {
    "from": 1084,
    "label": "has",
    "to": 1085
  }, {
    "from": 1037,
    "label": "has",
    "to": 1086
  }, {
    "from": 1037,
    "label": "has",
    "to": 1087
  }, {
    "from": 1087,
    "label": "has",
    "to": 1088
  }, {
    "from": 1037,
    "label": "has",
    "to": 1089
  }, {
    "from": 1037,
    "label": "has",
    "to": 1090
  }, {
    "from": 1090,
    "label": "has",
    "to": 1091
  }, {
    "from": 1037,
    "label": "has",
    "to": 1092
  }, {
    "from": 1037,
    "label": "has",
    "to": 1050
  }, {
    "from": 1037,
    "label": "has",
    "to": 1051
  }, {
    "from": 1037,
    "label": "has",
    "to": 1068
  }, {
    "from": 1037,
    "label": "has",
    "to": 1074
  }, {
    "from": 1037,
    "label": "has",
    "to": 1093
  }, {
    "from": 1037,
    "label": "has",
    "to": 1094
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1054
  }, {
    "from": 1037,
    "label": "has",
    "to": 1055
  }, {
    "from": 1037,
    "label": "has",
    "to": 1056
  }, {
    "from": 1037,
    "label": "has",
    "to": 1057
  }, {
    "from": 1037,
    "label": "has",
    "to": 1095
  }, {
    "from": 1095,
    "label": "has",
    "to": 1096
  }, {
    "from": 1037,
    "label": "has",
    "to": 1060
  }, {
    "from": 1037,
    "label": "has",
    "to": 1061
  }, {
    "from": 1037,
    "label": "has",
    "to": 1097
  }, {
    "from": 1097,
    "label": "has",
    "to": 1098
  }, {
    "from": 1037,
    "label": "has",
    "to": 1099
  }, {
    "from": 1037,
    "label": "has",
    "to": 1050
  }, {
    "from": 1037,
    "label": "has",
    "to": 1051
  }, {
    "from": 1037,
    "label": "has",
    "to": 1100
  }, {
    "from": 1037,
    "label": "has",
    "to": 1101
  }, {
    "from": 1037,
    "label": "has",
    "to": 1102
  }, {
    "from": 1037,
    "label": "has",
    "to": 1103
  }, {
    "from": 1103,
    "label": "has",
    "to": 1104
  }, {
    "from": 1037,
    "label": "has",
    "to": 1105
  }, {
    "from": 1037,
    "label": "has",
    "to": 1060
  }, {
    "from": 1037,
    "label": "has",
    "to": 1061
  }, {
    "from": 1037,
    "label": "has",
    "to": 1106
  }, {
    "from": 1106,
    "label": "has",
    "to": 1107
  }, {
    "from": 1037,
    "label": "has",
    "to": 1108
  }, {
    "from": 1037,
    "label": "has",
    "to": 1050
  }, {
    "from": 1037,
    "label": "has",
    "to": 1051
  }, {
    "from": 1037,
    "label": "has",
    "to": 1109
  }, {
    "from": 1037,
    "label": "has",
    "to": 1110
  }, {
    "from": 1037,
    "label": "has",
    "to": 1111
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1112
  }, {
    "from": 1037,
    "label": "has",
    "to": 1050
  }, {
    "from": 1037,
    "label": "has",
    "to": 1051
  }, {
    "from": 1037,
    "label": "has",
    "to": 1109
  }, {
    "from": 1037,
    "label": "has",
    "to": 1113
  }, {
    "from": 1037,
    "label": "has",
    "to": 1114
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1115
  }, {
    "from": 1037,
    "label": "has",
    "to": 1116
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1117
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1118
  }, {
    "from": 1037,
    "label": "has",
    "to": 1119
  }, {
    "from": 1037,
    "label": "has",
    "to": 1120
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1121
  }, {
    "from": 1037,
    "label": "has",
    "to": 1120
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1122
  }, {
    "from": 1037,
    "label": "has",
    "to": 1120
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1123
  }, {
    "from": 1037,
    "label": "has",
    "to": 1120
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1124
  }, {
    "from": 1037,
    "label": "has",
    "to": 1120
  }, {
    "from": 1037,
    "label": "has",
    "to": 1041
  }, {
    "from": 1037,
    "label": "has",
    "to": 1125
  }, {
    "from": 1029,
    "label": "has",
    "to": 1126
  }, {
    "from": 1126,
    "label": "has",
    "to": 1127
  }, {
    "from": 1127,
    "label": "has",
    "to": 1128
  }, {
    "from": 1128,
    "label": "has",
    "to": 1129
  }, {
    "from": 1128,
    "label": "has",
    "to": 1130
  }, {
    "from": 1128,
    "label": "has",
    "to": 1131
  }, {
    "from": 1131,
    "label": "has",
    "to": 1132
  }, {
    "from": 1128,
    "label": "has",
    "to": 1133
  }, {
    "from": 1127,
    "label": "has",
    "to": 1134
  }, {
    "from": 1126,
    "label": "has",
    "to": 1135
  }, {
    "from": 1135,
    "label": "has",
    "to": 1136
  }, {
    "from": 1126,
    "label": "has",
    "to": 1137
  }, {
    "from": 1137,
    "label": "has",
    "to": 1138
  }, {
    "from": 1137,
    "label": "has",
    "to": 1130
  }, {
    "from": 1137,
    "label": "has",
    "to": 1139
  }, {
    "from": 1139,
    "label": "has",
    "to": 1140
  }, {
    "from": 1140,
    "label": "has",
    "to": 1141
  }, {
    "from": 1139,
    "label": "has",
    "to": 1132
  }, {
    "from": 1126,
    "label": "has",
    "to": 1142
  }, {
    "from": 1126,
    "label": "has",
    "to": 1143
  }, {
    "from": 1143,
    "label": "has",
    "to": 1144
  }, {
    "from": 1126,
    "label": "has",
    "to": 1145
  }, {
    "from": 1145,
    "label": "has",
    "to": 1146
  }, {
    "from": 1146,
    "label": "has",
    "to": 1138
  }, {
    "from": 1146,
    "label": "has",
    "to": 1130
  }, {
    "from": 1146,
    "label": "has",
    "to": 1147
  }, {
    "from": 1147,
    "label": "has",
    "to": 1148
  }, {
    "from": 1148,
    "label": "has",
    "to": 1141
  }, {
    "from": 1147,
    "label": "has",
    "to": 1132
  }, {
    "from": 1145,
    "label": "has",
    "to": 1149
  }, {
    "from": 1145,
    "label": "has",
    "to": 1150
  }, {
    "from": 1150,
    "label": "has",
    "to": 1036
  }, {
    "from": 1145,
    "label": "has",
    "to": 1151
  }, {
    "from": 1151,
    "label": "has",
    "to": 1152
  }, {
    "from": 1152,
    "label": "has",
    "to": 1153
  }, {
    "from": 1153,
    "label": "has",
    "to": 1154
  }, {
    "from": 1153,
    "label": "has",
    "to": 1100
  }, {
    "from": 1153,
    "label": "has",
    "to": 1155
  }, {
    "from": 1153,
    "label": "has",
    "to": 1156
  }, {
    "from": 1153,
    "label": "has",
    "to": 1157
  }, {
    "from": 1153,
    "label": "has",
    "to": 1158
  }, {
    "from": 1152,
    "label": "has",
    "to": 1159
  }, {
    "from": 1159,
    "label": "has",
    "to": 1160
  }, {
    "from": 1159,
    "label": "has",
    "to": 1161
  }, {
    "from": 1159,
    "label": "has",
    "to": 1162
  }, {
    "from": 1159,
    "label": "has",
    "to": 1163
  }, {
    "from": 1159,
    "label": "has",
    "to": 1041
  }, {
    "from": 1159,
    "label": "has",
    "to": 1161
  }, {
    "from": 1159,
    "label": "has",
    "to": 1162
  }, {
    "from": 1159,
    "label": "has",
    "to": 1163
  }, {
    "from": 1159,
    "label": "has",
    "to": 1041
  }, {
    "from": 1159,
    "label": "has",
    "to": 1164
  }, {
    "from": 1159,
    "label": "has",
    "to": 1162
  }, {
    "from": 1159,
    "label": "has",
    "to": 1163
  }, {
    "from": 1159,
    "label": "has",
    "to": 1041
  }, {
    "from": 1159,
    "label": "has",
    "to": 1165
  }, {
    "from": 1159,
    "label": "has",
    "to": 1162
  }, {
    "from": 1159,
    "label": "has",
    "to": 1163
  }, {
    "from": 1159,
    "label": "has",
    "to": 1041
  }, {
    "from": 1159,
    "label": "has",
    "to": 1162
  }, {
    "from": 1159,
    "label": "has",
    "to": 1163
  }, {
    "from": 1159,
    "label": "has",
    "to": 1041
  }, {
    "from": 1159,
    "label": "has",
    "to": 1155
  }, {
    "from": 1159,
    "label": "has",
    "to": 1166
  }, {
    "from": 1159,
    "label": "has",
    "to": 1167
  }, {
    "from": 1159,
    "label": "has",
    "to": 1162
  }, {
    "from": 1159,
    "label": "has",
    "to": 1163
  }, {
    "from": 1159,
    "label": "has",
    "to": 1168
  }, {
    "from": 1152,
    "label": "has",
    "to": 1169
  }, {
    "from": 1151,
    "label": "has",
    "to": 1170
  }, {
    "from": 1151,
    "label": "has",
    "to": 1171
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1172
  }, {
    "from": 1172,
    "label": "has",
    "to": 1173
  }, {
    "from": 1151,
    "label": "has",
    "to": 1174
  }, {
    "from": 1151,
    "label": "has",
    "to": 1041
  }, {
    "from": 1151,
    "label": "has",
    "to": 1175
  }, {
    "from": 1151,
    "label": "has",
    "to": 1171
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1170
  }, {
    "from": 1151,
    "label": "has",
    "to": 1176
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1170
  }, {
    "from": 1151,
    "label": "has",
    "to": 1177
  }, {
    "from": 1151,
    "label": "has",
    "to": 1178
  }, {
    "from": 1151,
    "label": "has",
    "to": 1176
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1170
  }, {
    "from": 1151,
    "label": "has",
    "to": 1176
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1170
  }, {
    "from": 1151,
    "label": "has",
    "to": 1176
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1179
  }, {
    "from": 1151,
    "label": "has",
    "to": 1176
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1155
  }, {
    "from": 1151,
    "label": "has",
    "to": 1180
  }, {
    "from": 1151,
    "label": "has",
    "to": 1181
  }, {
    "from": 1151,
    "label": "has",
    "to": 1182
  }, {
    "from": 1151,
    "label": "has",
    "to": 1041
  }, {
    "from": 1151,
    "label": "has",
    "to": 1181
  }, {
    "from": 1151,
    "label": "has",
    "to": 1182
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1183
  }, {
    "from": 1151,
    "label": "has",
    "to": 1176
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1155
  }, {
    "from": 1151,
    "label": "has",
    "to": 1184
  }, {
    "from": 1184,
    "label": "has",
    "to": 1185
  }, {
    "from": 1184,
    "label": "has",
    "to": 1027
  }, {
    "from": 1151,
    "label": "has",
    "to": 1176
  }, {
    "from": 1151,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1186
  }, {
    "from": 1186,
    "label": "has",
    "to": 1160
  }, {
    "from": 1186,
    "label": "has",
    "to": 1161
  }, {
    "from": 1186,
    "label": "has",
    "to": 1080
  }, {
    "from": 1186,
    "label": "has",
    "to": 1041
  }, {
    "from": 1186,
    "label": "has",
    "to": 1161
  }, {
    "from": 1186,
    "label": "has",
    "to": 1080
  }, {
    "from": 1186,
    "label": "has",
    "to": 1041
  }, {
    "from": 1186,
    "label": "has",
    "to": 1187
  }, {
    "from": 1186,
    "label": "has",
    "to": 1080
  }, {
    "from": 1186,
    "label": "has",
    "to": 1041
  }, {
    "from": 1186,
    "label": "has",
    "to": 1165
  }, {
    "from": 1186,
    "label": "has",
    "to": 1188
  }, {
    "from": 1186,
    "label": "has",
    "to": 1155
  }, {
    "from": 1186,
    "label": "has",
    "to": 1189
  }, {
    "from": 1189,
    "label": "has",
    "to": 1190
  }, {
    "from": 1186,
    "label": "has",
    "to": 1176
  }, {
    "from": 1186,
    "label": "has",
    "to": 1102
  }, {
    "from": 1151,
    "label": "has",
    "to": 1191
  }, {
    "from": 1191,
    "label": "has",
    "to": 1160
  }, {
    "from": 1191,
    "label": "has",
    "to": 1161
  }, {
    "from": 1191,
    "label": "has",
    "to": 1163
  }, {
    "from": 1191,
    "label": "has",
    "to": 1041
  }, {
    "from": 1191,
    "label": "has",
    "to": 1161
  }, {
    "from": 1191,
    "label": "has",
    "to": 1163
  }, {
    "from": 1191,
    "label": "has",
    "to": 1041
  }, {
    "from": 1191,
    "label": "has",
    "to": 1187
  }, {
    "from": 1191,
    "label": "has",
    "to": 1163
  }, {
    "from": 1191,
    "label": "has",
    "to": 1041
  }, {
    "from": 1191,
    "label": "has",
    "to": 1164
  }, {
    "from": 1191,
    "label": "has",
    "to": 1165
  }, {
    "from": 1191,
    "label": "has",
    "to": 1192
  }, {
    "from": 1192,
    "label": "has",
    "to": 1193
  }, {
    "from": 1192,
    "label": "has",
    "to": 1194
  }, {
    "from": 1192,
    "label": "has",
    "to": 1195
  }, {
    "from": 1195,
    "label": "has",
    "to": 1196
  }, {
    "from": 1195,
    "label": "has",
    "to": 1027
  }, {
    "from": 1191,
    "label": "has",
    "to": 1197
  }, {
    "from": 1191,
    "label": "has",
    "to": 1198
  }, {
    "from": 1191,
    "label": "has",
    "to": 1199
  }, {
    "from": 1191,
    "label": "has",
    "to": 1200
  }, {
    "from": 1191,
    "label": "has",
    "to": 1201
  }, {
    "from": 1191,
    "label": "has",
    "to": 1202
  }, {
    "from": 1202,
    "label": "has",
    "to": 1086
  }, {
    "from": 1191,
    "label": "has",
    "to": 1203
  }, {
    "from": 1203,
    "label": "has",
    "to": 1204
  }, {
    "from": 1204,
    "label": "has",
    "to": 1205
  }, {
    "from": 1203,
    "label": "has",
    "to": 1166
  }, {
    "from": 1203,
    "label": "has",
    "to": 1167
  }, {
    "from": 1203,
    "label": "has",
    "to": 1206
  }, {
    "from": 1206,
    "label": "has",
    "to": 1207
  }, {
    "from": 1207,
    "label": "has",
    "to": 1208
  }, {
    "from": 1207,
    "label": "has",
    "to": 1209
  }, {
    "from": 1203,
    "label": "has",
    "to": 1210
  }, {
    "from": 1191,
    "label": "has",
    "to": 1211
  }, {
    "from": 1191,
    "label": "has",
    "to": 1041
  }, {
    "from": 1191,
    "label": "has",
    "to": 1212
  }, {
    "from": 1191,
    "label": "has",
    "to": 1155
  }, {
    "from": 1191,
    "label": "has",
    "to": 1213
  }, {
    "from": 1213,
    "label": "has",
    "to": 1166
  }, {
    "from": 1213,
    "label": "has",
    "to": 1167
  }, {
    "from": 1191,
    "label": "has",
    "to": 1214
  }, {
    "from": 1214,
    "label": "has",
    "to": 1215
  }, {
    "from": 1191,
    "label": "has",
    "to": 1200
  }, {
    "from": 1191,
    "label": "has",
    "to": 1041
  }, {
    "from": 1151,
    "label": "has",
    "to": 1216
  }, {
    "from": 1216,
    "label": "has",
    "to": 1217
  }, {
    "from": 1216,
    "label": "has",
    "to": 1218
  }, {
    "from": 1151,
    "label": "has",
    "to": 1219
  }, {
    "from": 1151,
    "label": "has",
    "to": 1211
  }, {
    "from": 1151,
    "label": "has",
    "to": 1041
  }, {
    "from": 1151,
    "label": "has",
    "to": 1219
  }, {
    "from": 1151,
    "label": "has",
    "to": 1220
  }, {
    "from": 1220,
    "label": "has",
    "to": 1221
  }, {
    "from": 1220,
    "label": "has",
    "to": 1222
  }, {
    "from": 1220,
    "label": "has",
    "to": 1211
  }, {
    "from": 1220,
    "label": "has",
    "to": 1041
  }, {
    "from": 1220,
    "label": "has",
    "to": 1222
  }, {
    "from": 1220,
    "label": "has",
    "to": 1211
  }, {
    "from": 1220,
    "label": "has",
    "to": 1041
  }, {
    "from": 1220,
    "label": "has",
    "to": 1223
  }, {
    "from": 1220,
    "label": "has",
    "to": 1211
  }, {
    "from": 1220,
    "label": "has",
    "to": 1041
  }, {
    "from": 1220,
    "label": "has",
    "to": 1224
  }, {
    "from": 1224,
    "label": "has",
    "to": 1225
  }, {
    "from": 1220,
    "label": "has",
    "to": 1226
  }, {
    "from": 1220,
    "label": "has",
    "to": 1227
  }, {
    "from": 1220,
    "label": "has",
    "to": 1211
  }, {
    "from": 1220,
    "label": "has",
    "to": 1041
  }, {
    "from": 1220,
    "label": "has",
    "to": 1228
  }, {
    "from": 1228,
    "label": "has",
    "to": 1229
  }, {
    "from": 1228,
    "label": "has",
    "to": 1227
  }, {
    "from": 1220,
    "label": "has",
    "to": 1230
  }, {
    "from": 1220,
    "label": "has",
    "to": 1102
  }, {
    "from": 1220,
    "label": "has",
    "to": 1231
  }, {
    "from": 1220,
    "label": "has",
    "to": 1041
  }, {
    "from": 1220,
    "label": "has",
    "to": 1232
  }, {
    "from": 1220,
    "label": "has",
    "to": 1233
  }, {
    "from": 1220,
    "label": "has",
    "to": 1234
  }, {
    "from": 1220,
    "label": "has",
    "to": 1041
  }, {
    "from": 1151,
    "label": "has",
    "to": 1235
  }, {
    "from": 1235,
    "label": "has",
    "to": 1236
  }, {
    "from": 1236,
    "label": "has",
    "to": 1237
  }, {
    "from": 1235,
    "label": "has",
    "to": 1224
  }, {
    "from": 1224,
    "label": "has",
    "to": 1225
  }, {
    "from": 1235,
    "label": "has",
    "to": 1229
  }, {
    "from": 1235,
    "label": "has",
    "to": 1227
  }, {
    "from": 1235,
    "label": "has",
    "to": 1211
  }, {
    "from": 1235,
    "label": "has",
    "to": 1041
  }, {
    "from": 1235,
    "label": "has",
    "to": 1236
  }, {
    "from": 1236,
    "label": "has",
    "to": 1237
  }, {
    "from": 1235,
    "label": "has",
    "to": 1229
  }, {
    "from": 1235,
    "label": "has",
    "to": 1227
  }, {
    "from": 1235,
    "label": "has",
    "to": 1230
  }, {
    "from": 1235,
    "label": "has",
    "to": 1102
  }, {
    "from": 1235,
    "label": "has",
    "to": 1238
  }, {
    "from": 1235,
    "label": "has",
    "to": 1239
  }, {
    "from": 1235,
    "label": "has",
    "to": 1231
  }, {
    "from": 1235,
    "label": "has",
    "to": 1041
  }, {
    "from": 1151,
    "label": "has",
    "to": 1240
  }, {
    "from": 1240,
    "label": "has",
    "to": 1224
  }, {
    "from": 1224,
    "label": "has",
    "to": 1225
  }, {
    "from": 1240,
    "label": "has",
    "to": 1229
  }, {
    "from": 1240,
    "label": "has",
    "to": 1227
  }, {
    "from": 1240,
    "label": "has",
    "to": 1211
  }, {
    "from": 1240,
    "label": "has",
    "to": 1041
  }, {
    "from": 1240,
    "label": "has",
    "to": 1229
  }, {
    "from": 1240,
    "label": "has",
    "to": 1227
  }, {
    "from": 1240,
    "label": "has",
    "to": 1230
  }, {
    "from": 1240,
    "label": "has",
    "to": 1102
  }, {
    "from": 1240,
    "label": "has",
    "to": 1231
  }, {
    "from": 1240,
    "label": "has",
    "to": 1041
  }, {
    "from": 1240,
    "label": "has",
    "to": 1223
  }, {
    "from": 1240,
    "label": "has",
    "to": 1234
  }, {
    "from": 1240,
    "label": "has",
    "to": 1041
  }, {
    "from": 1240,
    "label": "has",
    "to": 1241
  }, {
    "from": 1240,
    "label": "has",
    "to": 1242
  }, {
    "from": 1151,
    "label": "has",
    "to": 1243
  }, {
    "from": 1243,
    "label": "has",
    "to": 1244
  }, {
    "from": 1243,
    "label": "has",
    "to": 1230
  }, {
    "from": 1243,
    "label": "has",
    "to": 1102
  }, {
    "from": 1243,
    "label": "has",
    "to": 1245
  }, {
    "from": 1243,
    "label": "has",
    "to": 1071
  }, {
    "from": 1243,
    "label": "has",
    "to": 1176
  }, {
    "from": 1243,
    "label": "has",
    "to": 1102
  }, {
    "from": 1243,
    "label": "has",
    "to": 1077
  }, {
    "from": 1243,
    "label": "has",
    "to": 1176
  }, {
    "from": 1243,
    "label": "has",
    "to": 1102
  }, {
    "from": 1243,
    "label": "has",
    "to": 1077
  }, {
    "from": 1243,
    "label": "has",
    "to": 1246
  }, {
    "from": 1021,
    "label": "has",
    "to": 1247
  }, {
    "from": 1247,
    "label": "has",
    "to": 1248
  }, {
    "from": 1247,
    "label": "has",
    "to": 1249
  }, {
    "from": 1247,
    "label": "has",
    "to": 1250
  }, {
    "from": 1247,
    "label": "has",
    "to": 1251
  }, {
    "from": 1247,
    "label": "has",
    "to": 1252
  }, {
    "from": 1247,
    "label": "has",
    "to": 1252
  }, {
    "from": 1247,
    "label": "has",
    "to": 1252
  }, {
    "from": 1247,
    "label": "has",
    "to": 1252
  }, {
    "from": 1247,
    "label": "has",
    "to": 1252
  }, {
    "from": 1247,
    "label": "has",
    "to": 1252
  }, {
    "from": 1247,
    "label": "has",
    "to": 1252
  }, {
    "from": 1021,
    "label": "has",
    "to": 1253
  }, {
    "from": 1253,
    "label": "has",
    "to": 1254
  }, {
    "from": 1254,
    "label": "has",
    "to": 1255
  }, {
    "from": 1253,
    "label": "has",
    "to": 1256
  }, {
    "from": 1253,
    "label": "has",
    "to": 1257
  }, {
    "from": 1257,
    "label": "has",
    "to": 1258
  }, {
    "from": 1253,
    "label": "has",
    "to": 1259
  }, {
    "from": 1259,
    "label": "has",
    "to": 1260
  }, {
    "from": 1253,
    "label": "has",
    "to": 1261
  }, {
    "from": 1261,
    "label": "has",
    "to": 1262
  }, {
    "from": 1021,
    "label": "has",
    "to": 1263
  }, {
    "from": 1263,
    "label": "has",
    "to": 1060
  }, {
    "from": 1263,
    "label": "has",
    "to": 1061
  }, {
    "from": 1263,
    "label": "has",
    "to": 1264
  }, {
    "from": 1264,
    "label": "has",
    "to": 1265
  }, {
    "from": 1013,
    "label": "has",
    "to": 1266
  }, {
    "from": 1013,
    "label": "has",
    "to": 1061
  }, {
    "from": 1013,
    "label": "has",
    "to": 1267
  }, {
    "from": 1267,
    "label": "has",
    "to": 1268
  }, {
    "from": 1267,
    "label": "has",
    "to": 1269
  }, {
    "from": 1013,
    "label": "has",
    "to": 22
  }, {
    "from": 1013,
    "label": "has",
    "to": 1270
  }, {
    "from": 1271,
    "label": "has",
    "to": 1272
  }, {
    "from": 1271,
    "label": "has",
    "to": 1273
  }, {
    "from": 1271,
    "label": "has",
    "to": 1274
  }, {
    "from": 1274,
    "label": "has",
    "to": 1275
  }, {
    "from": 1271,
    "label": "has",
    "to": 22
  }, {
    "from": 1271,
    "label": "has",
    "to": 1276
  }, {
    "from": 1277,
    "label": "has",
    "to": 1278
  }, {
    "from": 1277,
    "label": "has",
    "to": 1279
  }, {
    "from": 1279,
    "label": "has",
    "to": 1280
  }, {
    "from": 1279,
    "label": "has",
    "to": 1281
  }, {
    "from": 1281,
    "label": "has",
    "to": 1282
  }, {
    "from": 1277,
    "label": "has",
    "to": 22
  }, {
    "from": 1277,
    "label": "has",
    "to": 1283
  }, {
    "from": 1284,
    "label": "has",
    "to": 1285
  }, {
    "from": 1284,
    "label": "has",
    "to": 22
  }, {
    "from": 1284,
    "label": "has",
    "to": 22
  }, {
    "from": 1284,
    "label": "has",
    "to": 1286
  }, {
    "from": 1287,
    "label": "has",
    "to": 1288
  }, {
    "from": 1287,
    "label": "has",
    "to": 1289
  }, {
    "from": 1289,
    "label": "has",
    "to": 1290
  }, {
    "from": 1290,
    "label": "has",
    "to": 1291
  }, {
    "from": 1290,
    "label": "has",
    "to": 1292
  }, {
    "from": 1287,
    "label": "has",
    "to": 1293
  }, {
    "from": 1293,
    "label": "has",
    "to": 1294
  }, {
    "from": 1287,
    "label": "has",
    "to": 1295
  }, {
    "from": 1296,
    "label": "has",
    "to": 1297
  }, {
    "from": 1296,
    "label": "has",
    "to": 1298
  }, {
    "from": 1298,
    "label": "has",
    "to": 1299
  }, {
    "from": 1298,
    "label": "has",
    "to": 1300
  }, {
    "from": 1300,
    "label": "has",
    "to": 1301
  }, {
    "from": 1300,
    "label": "has",
    "to": 1302
  }, {
    "from": 1300,
    "label": "has",
    "to": 1303
  }, {
    "from": 1303,
    "label": "has",
    "to": 1304
  }, {
    "from": 1300,
    "label": "has",
    "to": 1305
  }, {
    "from": 1300,
    "label": "has",
    "to": 1306
  }, {
    "from": 1298,
    "label": "has",
    "to": 1307
  }, {
    "from": 1307,
    "label": "has",
    "to": 1308
  }, {
    "from": 1307,
    "label": "has",
    "to": 1309
  }, {
    "from": 1307,
    "label": "has",
    "to": 1310
  }, {
    "from": 1310,
    "label": "has",
    "to": 1311
  }, {
    "from": 1307,
    "label": "has",
    "to": 1312
  }, {
    "from": 1312,
    "label": "has",
    "to": 1313
  }, {
    "from": 1307,
    "label": "has",
    "to": 1314
  }, {
    "from": 1314,
    "label": "has",
    "to": 1315
  }, {
    "from": 1298,
    "label": "has",
    "to": 1316
  }, {
    "from": 1316,
    "label": "has",
    "to": 1317
  }, {
    "from": 1316,
    "label": "has",
    "to": 1318
  }, {
    "from": 1316,
    "label": "has",
    "to": 1319
  }, {
    "from": 1319,
    "label": "has",
    "to": 1320
  }, {
    "from": 1319,
    "label": "has",
    "to": 1321
  }, {
    "from": 1319,
    "label": "has",
    "to": 1322
  }, {
    "from": 1319,
    "label": "has",
    "to": 1323
  }, {
    "from": 1323,
    "label": "has",
    "to": 1324
  }, {
    "from": 1323,
    "label": "has",
    "to": 1325
  }, {
    "from": 1319,
    "label": "has",
    "to": 1326
  }, {
    "from": 1319,
    "label": "has",
    "to": 1327
  }, {
    "from": 1319,
    "label": "has",
    "to": 1328
  }, {
    "from": 1328,
    "label": "has",
    "to": 1329
  }, {
    "from": 1328,
    "label": "has",
    "to": 1330
  }, {
    "from": 1319,
    "label": "has",
    "to": 1331
  }, {
    "from": 1319,
    "label": "has",
    "to": 1332
  }, {
    "from": 1319,
    "label": "has",
    "to": 1333
  }, {
    "from": 1319,
    "label": "has",
    "to": 1334
  }, {
    "from": 1319,
    "label": "has",
    "to": 1335
  }, {
    "from": 1319,
    "label": "has",
    "to": 1336
  }, {
    "from": 1336,
    "label": "has",
    "to": 1337
  }, {
    "from": 1319,
    "label": "has",
    "to": 1338
  }, {
    "from": 1319,
    "label": "has",
    "to": 1339
  }, {
    "from": 1339,
    "label": "has",
    "to": 1340
  }, {
    "from": 1319,
    "label": "has",
    "to": 1341
  }, {
    "from": 1319,
    "label": "has",
    "to": 1342
  }, {
    "from": 1342,
    "label": "has",
    "to": 1343
  }, {
    "from": 1319,
    "label": "has",
    "to": 1344
  }, {
    "from": 1319,
    "label": "has",
    "to": 1345
  }, {
    "from": 1319,
    "label": "has",
    "to": 1346
  }, {
    "from": 1319,
    "label": "has",
    "to": 1347
  }, {
    "from": 1319,
    "label": "has",
    "to": 1348
  }, {
    "from": 1319,
    "label": "has",
    "to": 1349
  }, {
    "from": 1319,
    "label": "has",
    "to": 1350
  }, {
    "from": 1319,
    "label": "has",
    "to": 1351
  }, {
    "from": 1351,
    "label": "has",
    "to": 1352
  }, {
    "from": 1351,
    "label": "has",
    "to": 1353
  }, {
    "from": 1351,
    "label": "has",
    "to": 1354
  }, {
    "from": 1351,
    "label": "has",
    "to": 1355
  }, {
    "from": 1319,
    "label": "has",
    "to": 1356
  }, {
    "from": 1356,
    "label": "has",
    "to": 1357
  }, {
    "from": 1356,
    "label": "has",
    "to": 1358
  }, {
    "from": 1356,
    "label": "has",
    "to": 1359
  }, {
    "from": 1356,
    "label": "has",
    "to": 1360
  }, {
    "from": 1356,
    "label": "has",
    "to": 1359
  }, {
    "from": 1356,
    "label": "has",
    "to": 1361
  }, {
    "from": 1356,
    "label": "has",
    "to": 1362
  }, {
    "from": 1356,
    "label": "has",
    "to": 1363
  }, {
    "from": 1356,
    "label": "has",
    "to": 1364
  }, {
    "from": 1356,
    "label": "has",
    "to": 1365
  }, {
    "from": 1319,
    "label": "has",
    "to": 1366
  }, {
    "from": 1319,
    "label": "has",
    "to": 1367
  }, {
    "from": 1319,
    "label": "has",
    "to": 1368
  }, {
    "from": 1319,
    "label": "has",
    "to": 1369
  }, {
    "from": 1319,
    "label": "has",
    "to": 1370
  }, {
    "from": 1370,
    "label": "has",
    "to": 1371
  }, {
    "from": 1370,
    "label": "has",
    "to": 1372
  }, {
    "from": 1319,
    "label": "has",
    "to": 1373
  }, {
    "from": 1319,
    "label": "has",
    "to": 1374
  }, {
    "from": 1319,
    "label": "has",
    "to": 1375
  }, {
    "from": 1319,
    "label": "has",
    "to": 1376
  }, {
    "from": 1319,
    "label": "has",
    "to": 1377
  }, {
    "from": 1377,
    "label": "has",
    "to": 1378
  }, {
    "from": 1377,
    "label": "has",
    "to": 1379
  }, {
    "from": 1319,
    "label": "has",
    "to": 1380
  }, {
    "from": 1380,
    "label": "has",
    "to": 1381
  }, {
    "from": 1319,
    "label": "has",
    "to": 1382
  }, {
    "from": 1319,
    "label": "has",
    "to": 1383
  }, {
    "from": 1319,
    "label": "has",
    "to": 1384
  }, {
    "from": 1384,
    "label": "has",
    "to": 1385
  }, {
    "from": 1384,
    "label": "has",
    "to": 1386
  }, {
    "from": 1384,
    "label": "has",
    "to": 1387
  }, {
    "from": 1384,
    "label": "has",
    "to": 1348
  }, {
    "from": 1384,
    "label": "has",
    "to": 1349
  }, {
    "from": 1384,
    "label": "has",
    "to": 1388
  }, {
    "from": 1384,
    "label": "has",
    "to": 1389
  }, {
    "from": 1389,
    "label": "has",
    "to": 1390
  }, {
    "from": 1389,
    "label": "has",
    "to": 1391
  }, {
    "from": 1389,
    "label": "has",
    "to": 1392
  }, {
    "from": 1389,
    "label": "has",
    "to": 1393
  }, {
    "from": 1389,
    "label": "has",
    "to": 1394
  }, {
    "from": 1389,
    "label": "has",
    "to": 1395
  }, {
    "from": 1389,
    "label": "has",
    "to": 1393
  }, {
    "from": 1389,
    "label": "has",
    "to": 1394
  }, {
    "from": 1389,
    "label": "has",
    "to": 1395
  }, {
    "from": 1389,
    "label": "has",
    "to": 1396
  }, {
    "from": 1389,
    "label": "has",
    "to": 1397
  }, {
    "from": 1389,
    "label": "has",
    "to": 1398
  }, {
    "from": 1389,
    "label": "has",
    "to": 1399
  }, {
    "from": 1389,
    "label": "has",
    "to": 1400
  }, {
    "from": 1389,
    "label": "has",
    "to": 1401
  }, {
    "from": 1389,
    "label": "has",
    "to": 1399
  }, {
    "from": 1389,
    "label": "has",
    "to": 1402
  }, {
    "from": 1389,
    "label": "has",
    "to": 1403
  }, {
    "from": 1389,
    "label": "has",
    "to": 1404
  }, {
    "from": 1389,
    "label": "has",
    "to": 1405
  }, {
    "from": 1389,
    "label": "has",
    "to": 1406
  }, {
    "from": 1384,
    "label": "has",
    "to": 1407
  }, {
    "from": 1407,
    "label": "has",
    "to": 1408
  }, {
    "from": 1408,
    "label": "has",
    "to": 1409
  }, {
    "from": 1408,
    "label": "has",
    "to": 1410
  }, {
    "from": 1407,
    "label": "has",
    "to": 1353
  }, {
    "from": 1407,
    "label": "has",
    "to": 1354
  }, {
    "from": 1407,
    "label": "has",
    "to": 1355
  }, {
    "from": 1407,
    "label": "has",
    "to": 1411
  }, {
    "from": 1411,
    "label": "has",
    "to": 1412
  }, {
    "from": 1411,
    "label": "has",
    "to": 1413
  }, {
    "from": 1384,
    "label": "has",
    "to": 1366
  }, {
    "from": 1384,
    "label": "has",
    "to": 1414
  }, {
    "from": 1384,
    "label": "has",
    "to": 1368
  }, {
    "from": 1384,
    "label": "has",
    "to": 1415
  }, {
    "from": 1384,
    "label": "has",
    "to": 1370
  }, {
    "from": 1370,
    "label": "has",
    "to": 1371
  }, {
    "from": 1370,
    "label": "has",
    "to": 1372
  }, {
    "from": 1384,
    "label": "has",
    "to": 1373
  }, {
    "from": 1384,
    "label": "has",
    "to": 1374
  }, {
    "from": 1384,
    "label": "has",
    "to": 1416
  }, {
    "from": 1384,
    "label": "has",
    "to": 1417
  }, {
    "from": 1384,
    "label": "has",
    "to": 1377
  }, {
    "from": 1377,
    "label": "has",
    "to": 1378
  }, {
    "from": 1377,
    "label": "has",
    "to": 1379
  }, {
    "from": 1384,
    "label": "has",
    "to": 1380
  }, {
    "from": 1380,
    "label": "has",
    "to": 1381
  }, {
    "from": 1384,
    "label": "has",
    "to": 1382
  }, {
    "from": 1384,
    "label": "has",
    "to": 1383
  }, {
    "from": 1319,
    "label": "has",
    "to": 1418
  }, {
    "from": 1319,
    "label": "has",
    "to": 1419
  }, {
    "from": 1319,
    "label": "has",
    "to": 1420
  }, {
    "from": 1319,
    "label": "has",
    "to": 1421
  }, {
    "from": 1319,
    "label": "has",
    "to": 1422
  }, {
    "from": 1319,
    "label": "has",
    "to": 1423
  }, {
    "from": 1319,
    "label": "has",
    "to": 1424
  }, {
    "from": 1424,
    "label": "has",
    "to": 1425
  }, {
    "from": 1424,
    "label": "has",
    "to": 1426
  }, {
    "from": 1426,
    "label": "has",
    "to": 1427
  }, {
    "from": 1426,
    "label": "has",
    "to": 1428
  }, {
    "from": 1428,
    "label": "has",
    "to": 1429
  }, {
    "from": 1424,
    "label": "has",
    "to": 1430
  }, {
    "from": 1424,
    "label": "has",
    "to": 1431
  }, {
    "from": 1431,
    "label": "has",
    "to": 1432
  }, {
    "from": 1424,
    "label": "has",
    "to": 1433
  }, {
    "from": 1319,
    "label": "has",
    "to": 1434
  }, {
    "from": 1434,
    "label": "has",
    "to": 1435
  }, {
    "from": 1435,
    "label": "has",
    "to": 1436
  }, {
    "from": 1434,
    "label": "has",
    "to": 1437
  }, {
    "from": 1434,
    "label": "has",
    "to": 1438
  }, {
    "from": 1434,
    "label": "has",
    "to": 1439
  }, {
    "from": 1434,
    "label": "has",
    "to": 1440
  }, {
    "from": 1319,
    "label": "has",
    "to": 1420
  }, {
    "from": 1319,
    "label": "has",
    "to": 1441
  }, {
    "from": 1319,
    "label": "has",
    "to": 1442
  }, {
    "from": 1319,
    "label": "has",
    "to": 1443
  }, {
    "from": 1319,
    "label": "has",
    "to": 1420
  }, {
    "from": 1319,
    "label": "has",
    "to": 1441
  }, {
    "from": 1319,
    "label": "has",
    "to": 1444
  }, {
    "from": 1319,
    "label": "has",
    "to": 1445
  }, {
    "from": 1319,
    "label": "has",
    "to": 1420
  }, {
    "from": 1319,
    "label": "has",
    "to": 1446
  }, {
    "from": 1319,
    "label": "has",
    "to": 1447
  }, {
    "from": 1319,
    "label": "has",
    "to": 1420
  }, {
    "from": 1319,
    "label": "has",
    "to": 1448
  }, {
    "from": 1319,
    "label": "has",
    "to": 1449
  }, {
    "from": 1319,
    "label": "has",
    "to": 1420
  }, {
    "from": 1319,
    "label": "has",
    "to": 1450
  }, {
    "from": 1319,
    "label": "has",
    "to": 1451
  }, {
    "from": 1319,
    "label": "has",
    "to": 1452
  }, {
    "from": 1319,
    "label": "has",
    "to": 1346
  }, {
    "from": 1319,
    "label": "has",
    "to": 1453
  }, {
    "from": 1319,
    "label": "has",
    "to": 1454
  }, {
    "from": 1319,
    "label": "has",
    "to": 1455
  }, {
    "from": 1455,
    "label": "has",
    "to": 1456
  }, {
    "from": 1455,
    "label": "has",
    "to": 1457
  }, {
    "from": 1455,
    "label": "has",
    "to": 1458
  }, {
    "from": 1455,
    "label": "has",
    "to": 1457
  }, {
    "from": 1455,
    "label": "has",
    "to": 1459
  }, {
    "from": 1455,
    "label": "has",
    "to": 1457
  }, {
    "from": 1319,
    "label": "has",
    "to": 1460
  }, {
    "from": 1460,
    "label": "has",
    "to": 1461
  }, {
    "from": 1460,
    "label": "has",
    "to": 1462
  }, {
    "from": 1460,
    "label": "has",
    "to": 1463
  }, {
    "from": 1460,
    "label": "has",
    "to": 1464
  }, {
    "from": 1464,
    "label": "has",
    "to": 1465
  }, {
    "from": 1464,
    "label": "has",
    "to": 1466
  }, {
    "from": 1460,
    "label": "has",
    "to": 1467
  }, {
    "from": 1460,
    "label": "has",
    "to": 1468
  }, {
    "from": 1468,
    "label": "has",
    "to": 1469
  }, {
    "from": 1468,
    "label": "has",
    "to": 1470
  }, {
    "from": 1460,
    "label": "has",
    "to": 1471
  }, {
    "from": 1460,
    "label": "has",
    "to": 1472
  }, {
    "from": 1460,
    "label": "has",
    "to": 1473
  }, {
    "from": 1460,
    "label": "has",
    "to": 1474
  }, {
    "from": 1460,
    "label": "has",
    "to": 1475
  }, {
    "from": 1460,
    "label": "has",
    "to": 1476
  }, {
    "from": 1460,
    "label": "has",
    "to": 1477
  }, {
    "from": 1460,
    "label": "has",
    "to": 1478
  }, {
    "from": 1460,
    "label": "has",
    "to": 1479
  }, {
    "from": 1479,
    "label": "has",
    "to": 1480
  }, {
    "from": 1479,
    "label": "has",
    "to": 1481
  }, {
    "from": 1460,
    "label": "has",
    "to": 1482
  }, {
    "from": 1482,
    "label": "has",
    "to": 1483
  }, {
    "from": 1482,
    "label": "has",
    "to": 1484
  }, {
    "from": 1460,
    "label": "has",
    "to": 1485
  }, {
    "from": 1485,
    "label": "has",
    "to": 1486
  }, {
    "from": 1460,
    "label": "has",
    "to": 1487
  }, {
    "from": 1460,
    "label": "has",
    "to": 1488
  }, {
    "from": 1460,
    "label": "has",
    "to": 1489
  }, {
    "from": 1460,
    "label": "has",
    "to": 1490
  }, {
    "from": 1460,
    "label": "has",
    "to": 1491
  }, {
    "from": 1460,
    "label": "has",
    "to": 1492
  }, {
    "from": 1460,
    "label": "has",
    "to": 1493
  }, {
    "from": 1460,
    "label": "has",
    "to": 1494
  }, {
    "from": 1460,
    "label": "has",
    "to": 1495
  }, {
    "from": 1460,
    "label": "has",
    "to": 1496
  }, {
    "from": 1496,
    "label": "has",
    "to": 1497
  }, {
    "from": 1496,
    "label": "has",
    "to": 1498
  }, {
    "from": 1496,
    "label": "has",
    "to": 1499
  }, {
    "from": 1496,
    "label": "has",
    "to": 1500
  }, {
    "from": 1496,
    "label": "has",
    "to": 1501
  }, {
    "from": 1460,
    "label": "has",
    "to": 1502
  }, {
    "from": 1502,
    "label": "has",
    "to": 1503
  }, {
    "from": 1502,
    "label": "has",
    "to": 1504
  }, {
    "from": 1502,
    "label": "has",
    "to": 1505
  }, {
    "from": 1460,
    "label": "has",
    "to": 1506
  }, {
    "from": 1506,
    "label": "has",
    "to": 1507
  }, {
    "from": 1506,
    "label": "has",
    "to": 1508
  }, {
    "from": 1506,
    "label": "has",
    "to": 1509
  }, {
    "from": 1506,
    "label": "has",
    "to": 1510
  }, {
    "from": 1506,
    "label": "has",
    "to": 1511
  }, {
    "from": 1506,
    "label": "has",
    "to": 1512
  }, {
    "from": 1506,
    "label": "has",
    "to": 1513
  }, {
    "from": 1506,
    "label": "has",
    "to": 1514
  }, {
    "from": 1506,
    "label": "has",
    "to": 1515
  }, {
    "from": 1506,
    "label": "has",
    "to": 1516
  }, {
    "from": 1506,
    "label": "has",
    "to": 1517
  }, {
    "from": 1506,
    "label": "has",
    "to": 1518
  }, {
    "from": 1506,
    "label": "has",
    "to": 1519
  }, {
    "from": 1506,
    "label": "has",
    "to": 1516
  }, {
    "from": 1506,
    "label": "has",
    "to": 1520
  }, {
    "from": 1506,
    "label": "has",
    "to": 1521
  }, {
    "from": 1506,
    "label": "has",
    "to": 1522
  }, {
    "from": 1506,
    "label": "has",
    "to": 1520
  }, {
    "from": 1506,
    "label": "has",
    "to": 1521
  }, {
    "from": 1506,
    "label": "has",
    "to": 1523
  }, {
    "from": 1506,
    "label": "has",
    "to": 1524
  }, {
    "from": 1524,
    "label": "has",
    "to": 1525
  }, {
    "from": 1525,
    "label": "has",
    "to": 1526
  }, {
    "from": 1524,
    "label": "has",
    "to": 1516
  }, {
    "from": 1524,
    "label": "has",
    "to": 1527
  }, {
    "from": 1524,
    "label": "has",
    "to": 1528
  }, {
    "from": 1524,
    "label": "has",
    "to": 1525
  }, {
    "from": 1525,
    "label": "has",
    "to": 1526
  }, {
    "from": 1524,
    "label": "has",
    "to": 1516
  }, {
    "from": 1524,
    "label": "has",
    "to": 1529
  }, {
    "from": 1524,
    "label": "has",
    "to": 1530
  }, {
    "from": 1524,
    "label": "has",
    "to": 1531
  }, {
    "from": 1524,
    "label": "has",
    "to": 1532
  }, {
    "from": 1506,
    "label": "has",
    "to": 1533
  }, {
    "from": 1533,
    "label": "has",
    "to": 1390
  }, {
    "from": 1533,
    "label": "has",
    "to": 1534
  }, {
    "from": 1533,
    "label": "has",
    "to": 1535
  }, {
    "from": 1535,
    "label": "has",
    "to": 1536
  }, {
    "from": 1536,
    "label": "has",
    "to": 1537
  }, {
    "from": 1536,
    "label": "has",
    "to": 1538
  }, {
    "from": 1536,
    "label": "has",
    "to": 1539
  }, {
    "from": 1533,
    "label": "has",
    "to": 1540
  }, {
    "from": 1540,
    "label": "has",
    "to": 1541
  }, {
    "from": 1540,
    "label": "has",
    "to": 1542
  }, {
    "from": 1533,
    "label": "has",
    "to": 1390
  }, {
    "from": 1533,
    "label": "has",
    "to": 1543
  }, {
    "from": 1533,
    "label": "has",
    "to": 1544
  }, {
    "from": 1533,
    "label": "has",
    "to": 1545
  }, {
    "from": 1533,
    "label": "has",
    "to": 1546
  }, {
    "from": 1546,
    "label": "has",
    "to": 1547
  }, {
    "from": 1546,
    "label": "has",
    "to": 1548
  }, {
    "from": 1546,
    "label": "has",
    "to": 1523
  }, {
    "from": 1533,
    "label": "has",
    "to": 1549
  }, {
    "from": 1549,
    "label": "has",
    "to": 1550
  }, {
    "from": 1549,
    "label": "has",
    "to": 1531
  }, {
    "from": 1549,
    "label": "has",
    "to": 1551
  }, {
    "from": 1549,
    "label": "has",
    "to": 1532
  }, {
    "from": 1533,
    "label": "has",
    "to": 1552
  }, {
    "from": 1552,
    "label": "has",
    "to": 1553
  }, {
    "from": 1553,
    "label": "has",
    "to": 1554
  }, {
    "from": 1553,
    "label": "has",
    "to": 1555
  }, {
    "from": 1552,
    "label": "has",
    "to": 1556
  }, {
    "from": 1506,
    "label": "has",
    "to": 1557
  }, {
    "from": 1557,
    "label": "has",
    "to": 1550
  }, {
    "from": 1557,
    "label": "has",
    "to": 1558
  }, {
    "from": 1557,
    "label": "has",
    "to": 1531
  }, {
    "from": 1557,
    "label": "has",
    "to": 1551
  }, {
    "from": 1557,
    "label": "has",
    "to": 1523
  }, {
    "from": 1557,
    "label": "has",
    "to": 1532
  }, {
    "from": 1506,
    "label": "has",
    "to": 1559
  }, {
    "from": 1559,
    "label": "has",
    "to": 1390
  }, {
    "from": 1559,
    "label": "has",
    "to": 1534
  }, {
    "from": 1559,
    "label": "has",
    "to": 1560
  }, {
    "from": 1560,
    "label": "has",
    "to": 1561
  }, {
    "from": 1561,
    "label": "has",
    "to": 1537
  }, {
    "from": 1561,
    "label": "has",
    "to": 1562
  }, {
    "from": 1561,
    "label": "has",
    "to": 1539
  }, {
    "from": 1559,
    "label": "has",
    "to": 1523
  }, {
    "from": 1559,
    "label": "has",
    "to": 1549
  }, {
    "from": 1549,
    "label": "has",
    "to": 1550
  }, {
    "from": 1549,
    "label": "has",
    "to": 1531
  }, {
    "from": 1549,
    "label": "has",
    "to": 1551
  }, {
    "from": 1549,
    "label": "has",
    "to": 1532
  }, {
    "from": 1559,
    "label": "has",
    "to": 1563
  }, {
    "from": 1563,
    "label": "has",
    "to": 1564
  }, {
    "from": 1559,
    "label": "has",
    "to": 1565
  }, {
    "from": 1506,
    "label": "has",
    "to": 1566
  }, {
    "from": 1566,
    "label": "has",
    "to": 1390
  }, {
    "from": 1566,
    "label": "has",
    "to": 1534
  }, {
    "from": 1566,
    "label": "has",
    "to": 1560
  }, {
    "from": 1560,
    "label": "has",
    "to": 1561
  }, {
    "from": 1561,
    "label": "has",
    "to": 1537
  }, {
    "from": 1561,
    "label": "has",
    "to": 1562
  }, {
    "from": 1561,
    "label": "has",
    "to": 1539
  }, {
    "from": 1566,
    "label": "has",
    "to": 1396
  }, {
    "from": 1566,
    "label": "has",
    "to": 1567
  }, {
    "from": 1566,
    "label": "has",
    "to": 1399
  }, {
    "from": 1566,
    "label": "has",
    "to": 1568
  }, {
    "from": 1566,
    "label": "has",
    "to": 1399
  }, {
    "from": 1566,
    "label": "has",
    "to": 1569
  }, {
    "from": 1566,
    "label": "has",
    "to": 1550
  }, {
    "from": 1566,
    "label": "has",
    "to": 1570
  }, {
    "from": 1566,
    "label": "has",
    "to": 1404
  }, {
    "from": 1566,
    "label": "has",
    "to": 1571
  }, {
    "from": 1506,
    "label": "has",
    "to": 1572
  }, {
    "from": 1506,
    "label": "has",
    "to": 1573
  }, {
    "from": 1573,
    "label": "has",
    "to": 1574
  }, {
    "from": 1506,
    "label": "has",
    "to": 1575
  }, {
    "from": 1460,
    "label": "has",
    "to": 1576
  }, {
    "from": 1576,
    "label": "has",
    "to": 1577
  }, {
    "from": 1460,
    "label": "has",
    "to": 1578
  }, {
    "from": 1460,
    "label": "has",
    "to": 1579
  }, {
    "from": 1579,
    "label": "has",
    "to": 1580
  }, {
    "from": 1460,
    "label": "has",
    "to": 1581
  }, {
    "from": 1581,
    "label": "has",
    "to": 1582
  }, {
    "from": 1460,
    "label": "has",
    "to": 1385
  }, {
    "from": 1460,
    "label": "has",
    "to": 1583
  }, {
    "from": 1583,
    "label": "has",
    "to": 1584
  }, {
    "from": 1583,
    "label": "has",
    "to": 1585
  }, {
    "from": 1583,
    "label": "has",
    "to": 1586
  }, {
    "from": 1583,
    "label": "has",
    "to": 1587
  }, {
    "from": 1460,
    "label": "has",
    "to": 1588
  }, {
    "from": 1460,
    "label": "has",
    "to": 1589
  }, {
    "from": 1319,
    "label": "has",
    "to": 1385
  }, {
    "from": 1319,
    "label": "has",
    "to": 1334
  }, {
    "from": 1319,
    "label": "has",
    "to": 1590
  }, {
    "from": 1319,
    "label": "has",
    "to": 1591
  }, {
    "from": 1319,
    "label": "has",
    "to": 1592
  }, {
    "from": 1319,
    "label": "has",
    "to": 1593
  }, {
    "from": 1319,
    "label": "has",
    "to": 1594
  }, {
    "from": 1594,
    "label": "has",
    "to": 1595
  }, {
    "from": 1594,
    "label": "has",
    "to": 1596
  }, {
    "from": 1594,
    "label": "has",
    "to": 1597
  }, {
    "from": 1594,
    "label": "has",
    "to": 1598
  }, {
    "from": 1594,
    "label": "has",
    "to": 1599
  }, {
    "from": 1594,
    "label": "has",
    "to": 1600
  }, {
    "from": 1594,
    "label": "has",
    "to": 1601
  }, {
    "from": 1594,
    "label": "has",
    "to": 1329
  }, {
    "from": 1594,
    "label": "has",
    "to": 1599
  }, {
    "from": 1594,
    "label": "has",
    "to": 1602
  }, {
    "from": 1594,
    "label": "has",
    "to": 1603
  }, {
    "from": 1594,
    "label": "has",
    "to": 1599
  }, {
    "from": 1594,
    "label": "has",
    "to": 1604
  }, {
    "from": 1604,
    "label": "has",
    "to": 1605
  }, {
    "from": 1594,
    "label": "has",
    "to": 1606
  }, {
    "from": 1606,
    "label": "has",
    "to": 1607
  }, {
    "from": 1606,
    "label": "has",
    "to": 1608
  }, {
    "from": 1608,
    "label": "has",
    "to": 1609
  }, {
    "from": 1594,
    "label": "has",
    "to": 1601
  }, {
    "from": 1594,
    "label": "has",
    "to": 1610
  }, {
    "from": 1594,
    "label": "has",
    "to": 1599
  }, {
    "from": 1319,
    "label": "has",
    "to": 1611
  }, {
    "from": 1611,
    "label": "has",
    "to": 1597
  }, {
    "from": 1319,
    "label": "has",
    "to": 1331
  }, {
    "from": 1319,
    "label": "has",
    "to": 1612
  }, {
    "from": 1612,
    "label": "has",
    "to": 1613
  }, {
    "from": 1613,
    "label": "has",
    "to": 1614
  }, {
    "from": 1613,
    "label": "has",
    "to": 1615
  }, {
    "from": 1613,
    "label": "has",
    "to": 1616
  }, {
    "from": 1319,
    "label": "has",
    "to": 1348
  }, {
    "from": 1319,
    "label": "has",
    "to": 1349
  }, {
    "from": 1319,
    "label": "has",
    "to": 1617
  }, {
    "from": 1319,
    "label": "has",
    "to": 1618
  }, {
    "from": 1618,
    "label": "has",
    "to": 1619
  }, {
    "from": 1618,
    "label": "has",
    "to": 1620
  }, {
    "from": 1319,
    "label": "has",
    "to": 1621
  }, {
    "from": 1319,
    "label": "has",
    "to": 1622
  }, {
    "from": 1622,
    "label": "has",
    "to": 1623
  }, {
    "from": 1622,
    "label": "has",
    "to": 1624
  }, {
    "from": 1319,
    "label": "has",
    "to": 1625
  }, {
    "from": 1319,
    "label": "has",
    "to": 1626
  }, {
    "from": 1319,
    "label": "has",
    "to": 1332
  }, {
    "from": 1319,
    "label": "has",
    "to": 1333
  }, {
    "from": 1319,
    "label": "has",
    "to": 1488
  }, {
    "from": 1319,
    "label": "has",
    "to": 1627
  }, {
    "from": 1319,
    "label": "has",
    "to": 1628
  }, {
    "from": 1319,
    "label": "has",
    "to": 1629
  }, {
    "from": 1319,
    "label": "has",
    "to": 1492
  }, {
    "from": 1319,
    "label": "has",
    "to": 1630
  }, {
    "from": 1319,
    "label": "has",
    "to": 1631
  }, {
    "from": 1319,
    "label": "has",
    "to": 1632
  }, {
    "from": 1632,
    "label": "has",
    "to": 1633
  }, {
    "from": 1632,
    "label": "has",
    "to": 1634
  }, {
    "from": 1632,
    "label": "has",
    "to": 1635
  }, {
    "from": 1632,
    "label": "has",
    "to": 1636
  }, {
    "from": 1632,
    "label": "has",
    "to": 1501
  }, {
    "from": 1319,
    "label": "has",
    "to": 1637
  }, {
    "from": 1319,
    "label": "has",
    "to": 1638
  }, {
    "from": 1638,
    "label": "has",
    "to": 1639
  }, {
    "from": 1639,
    "label": "has",
    "to": 1640
  }, {
    "from": 1638,
    "label": "has",
    "to": 1641
  }, {
    "from": 1641,
    "label": "has",
    "to": 1642
  }, {
    "from": 1641,
    "label": "has",
    "to": 1643
  }, {
    "from": 1641,
    "label": "has",
    "to": 1644
  }, {
    "from": 1638,
    "label": "has",
    "to": 1645
  }, {
    "from": 1645,
    "label": "has",
    "to": 1646
  }, {
    "from": 1638,
    "label": "has",
    "to": 1647
  }, {
    "from": 1647,
    "label": "has",
    "to": 1648
  }, {
    "from": 1319,
    "label": "has",
    "to": 1335
  }, {
    "from": 1319,
    "label": "has",
    "to": 1336
  }, {
    "from": 1336,
    "label": "has",
    "to": 1337
  }, {
    "from": 1319,
    "label": "has",
    "to": 1649
  }, {
    "from": 1319,
    "label": "has",
    "to": 1339
  }, {
    "from": 1339,
    "label": "has",
    "to": 1340
  }, {
    "from": 1319,
    "label": "has",
    "to": 1650
  }, {
    "from": 1319,
    "label": "has",
    "to": 1651
  }, {
    "from": 1319,
    "label": "has",
    "to": 1652
  }, {
    "from": 1652,
    "label": "has",
    "to": 1653
  }, {
    "from": 1653,
    "label": "has",
    "to": 1654
  }, {
    "from": 1654,
    "label": "has",
    "to": 1655
  }, {
    "from": 1654,
    "label": "has",
    "to": 1656
  }, {
    "from": 1652,
    "label": "has",
    "to": 1657
  }, {
    "from": 1657,
    "label": "has",
    "to": 1658
  }, {
    "from": 1657,
    "label": "has",
    "to": 1659
  }, {
    "from": 1652,
    "label": "has",
    "to": 1660
  }, {
    "from": 1660,
    "label": "has",
    "to": 1661
  }, {
    "from": 1660,
    "label": "has",
    "to": 1662
  }, {
    "from": 1662,
    "label": "has",
    "to": 1663
  }, {
    "from": 1660,
    "label": "has",
    "to": 1664
  }, {
    "from": 1660,
    "label": "has",
    "to": 1665
  }, {
    "from": 1665,
    "label": "has",
    "to": 1666
  }, {
    "from": 1319,
    "label": "has",
    "to": 1667
  }, {
    "from": 1667,
    "label": "has",
    "to": 1668
  }, {
    "from": 1319,
    "label": "has",
    "to": 1669
  }, {
    "from": 1669,
    "label": "has",
    "to": 1670
  }, {
    "from": 1669,
    "label": "has",
    "to": 1671
  }, {
    "from": 1669,
    "label": "has",
    "to": 1672
  }, {
    "from": 1672,
    "label": "has",
    "to": 1673
  }, {
    "from": 1672,
    "label": "has",
    "to": 1674
  }, {
    "from": 1672,
    "label": "has",
    "to": 1675
  }, {
    "from": 1675,
    "label": "has",
    "to": 1676
  }, {
    "from": 1672,
    "label": "has",
    "to": 1677
  }, {
    "from": 1677,
    "label": "has",
    "to": 1678
  }, {
    "from": 1677,
    "label": "has",
    "to": 1679
  }, {
    "from": 1672,
    "label": "has",
    "to": 1680
  }, {
    "from": 1672,
    "label": "has",
    "to": 1681
  }, {
    "from": 1669,
    "label": "has",
    "to": 1682
  }, {
    "from": 1669,
    "label": "has",
    "to": 1683
  }, {
    "from": 1669,
    "label": "has",
    "to": 1684
  }, {
    "from": 1669,
    "label": "has",
    "to": 1368
  }, {
    "from": 1669,
    "label": "has",
    "to": 1685
  }, {
    "from": 1685,
    "label": "has",
    "to": 1686
  }, {
    "from": 1685,
    "label": "has",
    "to": 1687
  }, {
    "from": 1685,
    "label": "has",
    "to": 1353
  }, {
    "from": 1685,
    "label": "has",
    "to": 1688
  }, {
    "from": 1685,
    "label": "has",
    "to": 1355
  }, {
    "from": 1685,
    "label": "has",
    "to": 1689
  }, {
    "from": 1689,
    "label": "has",
    "to": 1690
  }, {
    "from": 1689,
    "label": "has",
    "to": 1691
  }, {
    "from": 1691,
    "label": "has",
    "to": 1692
  }, {
    "from": 1691,
    "label": "has",
    "to": 1693
  }, {
    "from": 1685,
    "label": "has",
    "to": 1655
  }, {
    "from": 1685,
    "label": "has",
    "to": 1694
  }, {
    "from": 1685,
    "label": "has",
    "to": 1695
  }, {
    "from": 1695,
    "label": "has",
    "to": 1696
  }, {
    "from": 1696,
    "label": "has",
    "to": 1697
  }, {
    "from": 1696,
    "label": "has",
    "to": 1698
  }, {
    "from": 1696,
    "label": "has",
    "to": 1699
  }, {
    "from": 1696,
    "label": "has",
    "to": 1700
  }, {
    "from": 1696,
    "label": "has",
    "to": 1698
  }, {
    "from": 1696,
    "label": "has",
    "to": 1697
  }, {
    "from": 1695,
    "label": "has",
    "to": 1686
  }, {
    "from": 1695,
    "label": "has",
    "to": 1701
  }, {
    "from": 1669,
    "label": "has",
    "to": 1702
  }, {
    "from": 1702,
    "label": "has",
    "to": 1703
  }, {
    "from": 1669,
    "label": "has",
    "to": 1704
  }, {
    "from": 1669,
    "label": "has",
    "to": 1705
  }, {
    "from": 1705,
    "label": "has",
    "to": 1706
  }, {
    "from": 1669,
    "label": "has",
    "to": 1707
  }, {
    "from": 1707,
    "label": "has",
    "to": 1708
  }, {
    "from": 1669,
    "label": "has",
    "to": 1709
  }, {
    "from": 1669,
    "label": "has",
    "to": 1710
  }, {
    "from": 1710,
    "label": "has",
    "to": 1711
  }, {
    "from": 1710,
    "label": "has",
    "to": 1712
  }, {
    "from": 1710,
    "label": "has",
    "to": 1368
  }, {
    "from": 1710,
    "label": "has",
    "to": 1713
  }, {
    "from": 1713,
    "label": "has",
    "to": 1711
  }, {
    "from": 1713,
    "label": "has",
    "to": 1714
  }, {
    "from": 1713,
    "label": "has",
    "to": 1715
  }, {
    "from": 1715,
    "label": "has",
    "to": 1716
  }, {
    "from": 1715,
    "label": "has",
    "to": 1717
  }, {
    "from": 1713,
    "label": "has",
    "to": 1718
  }, {
    "from": 1713,
    "label": "has",
    "to": 1719
  }, {
    "from": 1713,
    "label": "has",
    "to": 1720
  }, {
    "from": 1713,
    "label": "has",
    "to": 1674
  }, {
    "from": 1713,
    "label": "has",
    "to": 1721
  }, {
    "from": 1721,
    "label": "has",
    "to": 1676
  }, {
    "from": 1713,
    "label": "has",
    "to": 1722
  }, {
    "from": 1713,
    "label": "has",
    "to": 1723
  }, {
    "from": 1723,
    "label": "has",
    "to": 1724
  }, {
    "from": 1723,
    "label": "has",
    "to": 1725
  }, {
    "from": 1713,
    "label": "has",
    "to": 1726
  }, {
    "from": 1713,
    "label": "has",
    "to": 1727
  }, {
    "from": 1713,
    "label": "has",
    "to": 1728
  }, {
    "from": 1728,
    "label": "has",
    "to": 1729
  }, {
    "from": 1729,
    "label": "has",
    "to": 1730
  }, {
    "from": 1729,
    "label": "has",
    "to": 1731
  }, {
    "from": 1728,
    "label": "has",
    "to": 1732
  }, {
    "from": 1713,
    "label": "has",
    "to": 1733
  }, {
    "from": 1710,
    "label": "has",
    "to": 1734
  }, {
    "from": 1734,
    "label": "has",
    "to": 1357
  }, {
    "from": 1734,
    "label": "has",
    "to": 1735
  }, {
    "from": 1734,
    "label": "has",
    "to": 1359
  }, {
    "from": 1734,
    "label": "has",
    "to": 1736
  }, {
    "from": 1734,
    "label": "has",
    "to": 1362
  }, {
    "from": 1734,
    "label": "has",
    "to": 1737
  }, {
    "from": 1734,
    "label": "has",
    "to": 1738
  }, {
    "from": 1734,
    "label": "has",
    "to": 1739
  }, {
    "from": 1734,
    "label": "has",
    "to": 1364
  }, {
    "from": 1734,
    "label": "has",
    "to": 1740
  }, {
    "from": 1710,
    "label": "has",
    "to": 1684
  }, {
    "from": 1710,
    "label": "has",
    "to": 1368
  }, {
    "from": 1319,
    "label": "has",
    "to": 1415
  }, {
    "from": 1319,
    "label": "has",
    "to": 1370
  }, {
    "from": 1370,
    "label": "has",
    "to": 1371
  }, {
    "from": 1370,
    "label": "has",
    "to": 1372
  }, {
    "from": 1319,
    "label": "has",
    "to": 1374
  }, {
    "from": 1319,
    "label": "has",
    "to": 1741
  }, {
    "from": 1319,
    "label": "has",
    "to": 1742
  }, {
    "from": 1319,
    "label": "has",
    "to": 1743
  }, {
    "from": 1319,
    "label": "has",
    "to": 1744
  }, {
    "from": 1744,
    "label": "has",
    "to": 1745
  }, {
    "from": 1319,
    "label": "has",
    "to": 1373
  }, {
    "from": 1319,
    "label": "has",
    "to": 1746
  }, {
    "from": 1319,
    "label": "has",
    "to": 1747
  }, {
    "from": 1319,
    "label": "has",
    "to": 1748
  }, {
    "from": 1748,
    "label": "has",
    "to": 1749
  }, {
    "from": 1748,
    "label": "has",
    "to": 1750
  }, {
    "from": 1748,
    "label": "has",
    "to": 1751
  }, {
    "from": 1748,
    "label": "has",
    "to": 1378
  }, {
    "from": 1748,
    "label": "has",
    "to": 1379
  }, {
    "from": 1319,
    "label": "has",
    "to": 1752
  }, {
    "from": 1752,
    "label": "has",
    "to": 1753
  }, {
    "from": 1752,
    "label": "has",
    "to": 1382
  }, {
    "from": 1298,
    "label": "has",
    "to": 1754
  }, {
    "from": 1754,
    "label": "has",
    "to": 1755
  }, {
    "from": 1755,
    "label": "has",
    "to": 1756
  }, {
    "from": 1756,
    "label": "has",
    "to": 1757
  }, {
    "from": 1755,
    "label": "has",
    "to": 1758
  }, {
    "from": 1758,
    "label": "has",
    "to": 1759
  }, {
    "from": 1754,
    "label": "has",
    "to": 1760
  }, {
    "from": 1754,
    "label": "has",
    "to": 1761
  }, {
    "from": 1754,
    "label": "has",
    "to": 1762
  }, {
    "from": 1754,
    "label": "has",
    "to": 1763
  }, {
    "from": 1754,
    "label": "has",
    "to": 1764
  }, {
    "from": 1764,
    "label": "has",
    "to": 1765
  }, {
    "from": 1764,
    "label": "has",
    "to": 1766
  }, {
    "from": 1764,
    "label": "has",
    "to": 1767
  }, {
    "from": 1764,
    "label": "has",
    "to": 1768
  }, {
    "from": 1754,
    "label": "has",
    "to": 1769
  }, {
    "from": 1754,
    "label": "has",
    "to": 1770
  }, {
    "from": 1754,
    "label": "has",
    "to": 1771
  }, {
    "from": 1771,
    "label": "has",
    "to": 1772
  }, {
    "from": 1754,
    "label": "has",
    "to": 1773
  }, {
    "from": 1754,
    "label": "has",
    "to": 1774
  }, {
    "from": 1754,
    "label": "has",
    "to": 1775
  }, {
    "from": 1775,
    "label": "has",
    "to": 1776
  }, {
    "from": 1754,
    "label": "has",
    "to": 1777
  }, {
    "from": 1754,
    "label": "has",
    "to": 1778
  }, {
    "from": 1754,
    "label": "has",
    "to": 1779
  }, {
    "from": 1754,
    "label": "has",
    "to": 1780
  }, {
    "from": 1754,
    "label": "has",
    "to": 1781
  }, {
    "from": 1781,
    "label": "has",
    "to": 1782
  }, {
    "from": 1781,
    "label": "has",
    "to": 1783
  }, {
    "from": 1754,
    "label": "has",
    "to": 1784
  }, {
    "from": 1754,
    "label": "has",
    "to": 1785
  }, {
    "from": 1785,
    "label": "has",
    "to": 1786
  }, {
    "from": 1754,
    "label": "has",
    "to": 1787
  }, {
    "from": 1787,
    "label": "has",
    "to": 1385
  }, {
    "from": 1787,
    "label": "has",
    "to": 1788
  }, {
    "from": 1787,
    "label": "has",
    "to": 1789
  }, {
    "from": 1787,
    "label": "has",
    "to": 1790
  }, {
    "from": 1790,
    "label": "has",
    "to": 1791
  }, {
    "from": 1787,
    "label": "has",
    "to": 1374
  }, {
    "from": 1787,
    "label": "has",
    "to": 1415
  }, {
    "from": 1787,
    "label": "has",
    "to": 1792
  }, {
    "from": 1787,
    "label": "has",
    "to": 1793
  }, {
    "from": 1787,
    "label": "has",
    "to": 1373
  }, {
    "from": 1787,
    "label": "has",
    "to": 1326
  }, {
    "from": 1787,
    "label": "has",
    "to": 1331
  }, {
    "from": 1787,
    "label": "has",
    "to": 1794
  }, {
    "from": 1787,
    "label": "has",
    "to": 1795
  }, {
    "from": 1795,
    "label": "has",
    "to": 1796
  }, {
    "from": 1795,
    "label": "has",
    "to": 1797
  }, {
    "from": 1787,
    "label": "has",
    "to": 1798
  }, {
    "from": 1754,
    "label": "has",
    "to": 1799
  }, {
    "from": 1754,
    "label": "has",
    "to": 1800
  }, {
    "from": 1754,
    "label": "has",
    "to": 1801
  }, {
    "from": 1296,
    "label": "has",
    "to": 1802
  }, {
    "from": 1803,
    "label": "has",
    "to": 1804
  }, {
    "from": 1804,
    "label": "has",
    "to": 1805
  }, {
    "from": 1804,
    "label": "has",
    "to": 1806
  }, {
    "from": 1806,
    "label": "has",
    "to": 1807
  }, {
    "from": 1804,
    "label": "has",
    "to": 1808
  }, {
    "from": 1808,
    "label": "has",
    "to": 1809
  }, {
    "from": 1808,
    "label": "has",
    "to": 1810
  }, {
    "from": 1803,
    "label": "has",
    "to": 1811
  }, {
    "from": 1812,
    "label": "has",
    "to": 1813
  }, {
    "from": 1812,
    "label": "has",
    "to": 1814
  }, {
    "from": 1812,
    "label": "has",
    "to": 1815
  }, {
    "from": 1812,
    "label": "has",
    "to": 1816
  }, {
    "from": 1816,
    "label": "has",
    "to": 1817
  }, {
    "from": 1816,
    "label": "has",
    "to": 1818
  }, {
    "from": 1816,
    "label": "has",
    "to": 1819
  }, {
    "from": 1819,
    "label": "has",
    "to": 1820
  }, {
    "from": 1819,
    "label": "has",
    "to": 1821
  }, {
    "from": 1819,
    "label": "has",
    "to": 1822
  }, {
    "from": 1822,
    "label": "has",
    "to": 1823
  }, {
    "from": 1822,
    "label": "has",
    "to": 1824
  }, {
    "from": 1819,
    "label": "has",
    "to": 1825
  }, {
    "from": 1825,
    "label": "has",
    "to": 1826
  }, {
    "from": 1819,
    "label": "has",
    "to": 1827
  }, {
    "from": 1827,
    "label": "has",
    "to": 1828
  }, {
    "from": 1827,
    "label": "has",
    "to": 1829
  }, {
    "from": 1819,
    "label": "has",
    "to": 1830
  }, {
    "from": 1819,
    "label": "has",
    "to": 1831
  }, {
    "from": 1831,
    "label": "has",
    "to": 1832
  }, {
    "from": 1832,
    "label": "has",
    "to": 1833
  }, {
    "from": 1832,
    "label": "has",
    "to": 1834
  }, {
    "from": 1832,
    "label": "has",
    "to": 1835
  }, {
    "from": 1832,
    "label": "has",
    "to": 1836
  }, {
    "from": 1819,
    "label": "has",
    "to": 1837
  }, {
    "from": 1837,
    "label": "has",
    "to": 1838
  }, {
    "from": 1812,
    "label": "has",
    "to": 1839
  }, {
    "from": 1840,
    "label": "has",
    "to": 930
  }, {
    "from": 1840,
    "label": "has",
    "to": 1841
  }, {
    "from": 1840,
    "label": "has",
    "to": 1842
  }, {
    "from": 1840,
    "label": "has",
    "to": 1843
  }, {
    "from": 1840,
    "label": "has",
    "to": 1844
  }, {
    "from": 1840,
    "label": "has",
    "to": 1845
  }, {
    "from": 1840,
    "label": "has",
    "to": 1841
  }, {
    "from": 1840,
    "label": "has",
    "to": 1838
  }, {
    "from": 1840,
    "label": "has",
    "to": 1846
  }, {
    "from": 1840,
    "label": "has",
    "to": 1847
  }, {
    "from": 1840,
    "label": "has",
    "to": 1848
  }, {
    "from": 1840,
    "label": "has",
    "to": 1849
  }, {
    "from": 1840,
    "label": "has",
    "to": 1850
  }, {
    "from": 1840,
    "label": "has",
    "to": 1841
  }, {
    "from": 1840,
    "label": "has",
    "to": 1851
  }, {
    "from": 1840,
    "label": "has",
    "to": 1852
  }, {
    "from": 1840,
    "label": "has",
    "to": 1853
  }, {
    "from": 1840,
    "label": "has",
    "to": 1854
  }, {
    "from": 1840,
    "label": "has",
    "to": 1855
  }, {
    "from": 1840,
    "label": "has",
    "to": 1856
  }, {
    "from": 1840,
    "label": "has",
    "to": 1857
  }, {
    "from": 1840,
    "label": "has",
    "to": 1858
  }, {
    "from": 1858,
    "label": "has",
    "to": 1859
  }, {
    "from": 1840,
    "label": "has",
    "to": 1860
  }, {
    "from": 1840,
    "label": "has",
    "to": 1861
  }, {
    "from": 1840,
    "label": "has",
    "to": 1862
  }, {
    "from": 1840,
    "label": "has",
    "to": 1863
  }, {
    "from": 1840,
    "label": "has",
    "to": 1864
  }, {
    "from": 1840,
    "label": "has",
    "to": 1838
  }, {
    "from": 1840,
    "label": "has",
    "to": 1865
  }, {
    "from": 1840,
    "label": "has",
    "to": 1866
  }, {
    "from": 1840,
    "label": "has",
    "to": 1867
  }, {
    "from": 1840,
    "label": "has",
    "to": 1868
  }, {
    "from": 1840,
    "label": "has",
    "to": 1869
  }, {
    "from": 1840,
    "label": "has",
    "to": 1870
  }, {
    "from": 1840,
    "label": "has",
    "to": 1871
  }, {
    "from": 1840,
    "label": "has",
    "to": 1872
  }, {
    "from": 1872,
    "label": "has",
    "to": 1873
  }, {
    "from": 1872,
    "label": "has",
    "to": 1874
  }, {
    "from": 1872,
    "label": "has",
    "to": 1875
  }, {
    "from": 1840,
    "label": "has",
    "to": 1841
  }, {
    "from": 1840,
    "label": "has",
    "to": 1876
  }, {
    "from": 1840,
    "label": "has",
    "to": 1857
  }, {
    "from": 1840,
    "label": "has",
    "to": 1877
  }, {
    "from": 1877,
    "label": "has",
    "to": 1878
  }, {
    "from": 1877,
    "label": "has",
    "to": 1879
  }, {
    "from": 1879,
    "label": "has",
    "to": 1880
  }, {
    "from": 1879,
    "label": "has",
    "to": 1826
  }, {
    "from": 1877,
    "label": "has",
    "to": 1881
  }, {
    "from": 1881,
    "label": "has",
    "to": 1882
  }, {
    "from": 1877,
    "label": "has",
    "to": 1883
  }, {
    "from": 1883,
    "label": "has",
    "to": 1884
  }, {
    "from": 1883,
    "label": "has",
    "to": 1838
  }, {
    "from": 1840,
    "label": "has",
    "to": 1841
  }, {
    "from": 1840,
    "label": "has",
    "to": 1885
  }, {
    "from": 1840,
    "label": "has",
    "to": 1857
  }, {
    "from": 1840,
    "label": "has",
    "to": 1886
  }, {
    "from": 1886,
    "label": "has",
    "to": 1878
  }, {
    "from": 1886,
    "label": "has",
    "to": 1879
  }, {
    "from": 1879,
    "label": "has",
    "to": 1880
  }, {
    "from": 1879,
    "label": "has",
    "to": 1826
  }, {
    "from": 1886,
    "label": "has",
    "to": 1887
  }, {
    "from": 1887,
    "label": "has",
    "to": 1888
  }, {
    "from": 1886,
    "label": "has",
    "to": 1883
  }, {
    "from": 1883,
    "label": "has",
    "to": 1884
  }, {
    "from": 1883,
    "label": "has",
    "to": 1838
  }, {
    "from": 1840,
    "label": "has",
    "to": 1838
  }, {
    "from": 1840,
    "label": "has",
    "to": 1841
  }, {
    "from": 1840,
    "label": "has",
    "to": 1889
  }, {
    "from": 1840,
    "label": "has",
    "to": 1857
  }, {
    "from": 1840,
    "label": "has",
    "to": 1890
  }, {
    "from": 1890,
    "label": "has",
    "to": 1878
  }, {
    "from": 1890,
    "label": "has",
    "to": 1879
  }, {
    "from": 1879,
    "label": "has",
    "to": 1880
  }, {
    "from": 1879,
    "label": "has",
    "to": 1826
  }, {
    "from": 1890,
    "label": "has",
    "to": 1891
  }, {
    "from": 1891,
    "label": "has",
    "to": 1892
  }, {
    "from": 1892,
    "label": "has",
    "to": 1893
  }, {
    "from": 1890,
    "label": "has",
    "to": 1883
  }, {
    "from": 1883,
    "label": "has",
    "to": 1884
  }, {
    "from": 1883,
    "label": "has",
    "to": 1838
  }, {
    "from": 1840,
    "label": "has",
    "to": 1838
  }, {
    "from": 1840,
    "label": "has",
    "to": 1894
  }, {
    "from": 1840,
    "label": "has",
    "to": 22
  }, {
    "from": 1840,
    "label": "has",
    "to": 1895
  }, {
    "from": 1896,
    "label": "has",
    "to": 1841
  }, {
    "from": 1896,
    "label": "has",
    "to": 1897
  }, {
    "from": 1896,
    "label": "has",
    "to": 1843
  }, {
    "from": 1896,
    "label": "has",
    "to": 1898
  }, {
    "from": 1896,
    "label": "has",
    "to": 1857
  }, {
    "from": 1896,
    "label": "has",
    "to": 1899
  }, {
    "from": 1899,
    "label": "has",
    "to": 1900
  }, {
    "from": 1899,
    "label": "has",
    "to": 1901
  }, {
    "from": 1899,
    "label": "has",
    "to": 1902
  }, {
    "from": 1899,
    "label": "has",
    "to": 1838
  }, {
    "from": 1899,
    "label": "has",
    "to": 1903
  }, {
    "from": 1899,
    "label": "has",
    "to": 1838
  }, {
    "from": 1899,
    "label": "has",
    "to": 1904
  }, {
    "from": 1899,
    "label": "has",
    "to": 1905
  }, {
    "from": 1899,
    "label": "has",
    "to": 1902
  }, {
    "from": 1899,
    "label": "has",
    "to": 1838
  }, {
    "from": 1899,
    "label": "has",
    "to": 1906
  }, {
    "from": 1899,
    "label": "has",
    "to": 1838
  }, {
    "from": 1899,
    "label": "has",
    "to": 1849
  }, {
    "from": 1899,
    "label": "has",
    "to": 1907
  }, {
    "from": 1899,
    "label": "has",
    "to": 1908
  }, {
    "from": 1899,
    "label": "has",
    "to": 1838
  }, {
    "from": 1896,
    "label": "has",
    "to": 22
  }, {
    "from": 1896,
    "label": "has",
    "to": 1909
  }, {
    "from": 1910,
    "label": "has",
    "to": 1911
  }, {
    "from": 1910,
    "label": "has",
    "to": 1869
  }, {
    "from": 1910,
    "label": "has",
    "to": 1841
  }, {
    "from": 1910,
    "label": "has",
    "to": 1912
  }, {
    "from": 1910,
    "label": "has",
    "to": 1857
  }, {
    "from": 1910,
    "label": "has",
    "to": 1913
  }, {
    "from": 1910,
    "label": "has",
    "to": 1914
  }, {
    "from": 1910,
    "label": "has",
    "to": 1915
  }, {
    "from": 1910,
    "label": "has",
    "to": 1916
  }, {
    "from": 1910,
    "label": "has",
    "to": 1917
  }, {
    "from": 1917,
    "label": "has",
    "to": 1918
  }, {
    "from": 1918,
    "label": "has",
    "to": 1919
  }, {
    "from": 1918,
    "label": "has",
    "to": 1920
  }, {
    "from": 1920,
    "label": "has",
    "to": 1921
  }, {
    "from": 1910,
    "label": "has",
    "to": 1922
  }, {
    "from": 1910,
    "label": "has",
    "to": 1923
  }, {
    "from": 1923,
    "label": "has",
    "to": 1924
  }, {
    "from": 1910,
    "label": "has",
    "to": 1838
  }, {
    "from": 1910,
    "label": "has",
    "to": 1925
  }, {
    "from": 1925,
    "label": "has",
    "to": 1926
  }, {
    "from": 1926,
    "label": "has",
    "to": 1927
  }, {
    "from": 1927,
    "label": "has",
    "to": 1928
  }, {
    "from": 1927,
    "label": "has",
    "to": 1929
  }, {
    "from": 1927,
    "label": "has",
    "to": 1930
  }, {
    "from": 1930,
    "label": "has",
    "to": 1931
  }, {
    "from": 1930,
    "label": "has",
    "to": 1932
  }, {
    "from": 1927,
    "label": "has",
    "to": 1933
  }, {
    "from": 1927,
    "label": "has",
    "to": 1934
  }, {
    "from": 1910,
    "label": "has",
    "to": 1841
  }, {
    "from": 1910,
    "label": "has",
    "to": 1885
  }, {
    "from": 1910,
    "label": "has",
    "to": 1857
  }, {
    "from": 1910,
    "label": "has",
    "to": 1935
  }, {
    "from": 1935,
    "label": "has",
    "to": 1878
  }, {
    "from": 1935,
    "label": "has",
    "to": 1879
  }, {
    "from": 1879,
    "label": "has",
    "to": 1880
  }, {
    "from": 1879,
    "label": "has",
    "to": 1826
  }, {
    "from": 1935,
    "label": "has",
    "to": 1936
  }, {
    "from": 1936,
    "label": "has",
    "to": 1937
  }, {
    "from": 1936,
    "label": "has",
    "to": 1938
  }, {
    "from": 1936,
    "label": "has",
    "to": 1939
  }, {
    "from": 1939,
    "label": "has",
    "to": 1940
  }, {
    "from": 1939,
    "label": "has",
    "to": 1941
  }, {
    "from": 1935,
    "label": "has",
    "to": 1883
  }, {
    "from": 1883,
    "label": "has",
    "to": 1884
  }, {
    "from": 1883,
    "label": "has",
    "to": 1838
  }, {
    "from": 1910,
    "label": "has",
    "to": 1838
  }, {
    "from": 1910,
    "label": "has",
    "to": 1869
  }, {
    "from": 1910,
    "label": "has",
    "to": 1942
  }, {
    "from": 1910,
    "label": "has",
    "to": 1943
  }, {
    "from": 1910,
    "label": "has",
    "to": 1944
  }, {
    "from": 1910,
    "label": "has",
    "to": 1838
  }, {
    "from": 1910,
    "label": "has",
    "to": 1945
  }, {
    "from": 1910,
    "label": "has",
    "to": 1946
  }, {
    "from": 1910,
    "label": "has",
    "to": 1947
  }, {
    "from": 1910,
    "label": "has",
    "to": 1948
  }, {
    "from": 1910,
    "label": "has",
    "to": 1949
  }, {
    "from": 1910,
    "label": "has",
    "to": 1841
  }, {
    "from": 1910,
    "label": "has",
    "to": 1950
  }, {
    "from": 1910,
    "label": "has",
    "to": 1857
  }, {
    "from": 1910,
    "label": "has",
    "to": 1858
  }, {
    "from": 1858,
    "label": "has",
    "to": 1859
  }, {
    "from": 1910,
    "label": "has",
    "to": 1951
  }, {
    "from": 1910,
    "label": "has",
    "to": 1952
  }, {
    "from": 1910,
    "label": "has",
    "to": 1862
  }, {
    "from": 1910,
    "label": "has",
    "to": 1953
  }, {
    "from": 1910,
    "label": "has",
    "to": 1954
  }, {
    "from": 1910,
    "label": "has",
    "to": 1955
  }, {
    "from": 1910,
    "label": "has",
    "to": 1956
  }, {
    "from": 1910,
    "label": "has",
    "to": 1957
  }, {
    "from": 1910,
    "label": "has",
    "to": 1958
  }, {
    "from": 1910,
    "label": "has",
    "to": 1959
  }, {
    "from": 1910,
    "label": "has",
    "to": 1960
  }, {
    "from": 1910,
    "label": "has",
    "to": 1949
  }, {
    "from": 1910,
    "label": "has",
    "to": 1961
  }, {
    "from": 1910,
    "label": "has",
    "to": 1857
  }, {
    "from": 1910,
    "label": "has",
    "to": 1962
  }, {
    "from": 1910,
    "label": "has",
    "to": 1862
  }, {
    "from": 1910,
    "label": "has",
    "to": 1963
  }, {
    "from": 1910,
    "label": "has",
    "to": 1964
  }, {
    "from": 1910,
    "label": "has",
    "to": 1965
  }, {
    "from": 1910,
    "label": "has",
    "to": 1966
  }, {
    "from": 1910,
    "label": "has",
    "to": 1949
  }, {
    "from": 1910,
    "label": "has",
    "to": 1967
  }, {
    "from": 1967,
    "label": "has",
    "to": 1875
  }, {
    "from": 1910,
    "label": "has",
    "to": 1968
  }, {
    "from": 1968,
    "label": "has",
    "to": 1969
  }, {
    "from": 1969,
    "label": "has",
    "to": 1970
  }, {
    "from": 1968,
    "label": "has",
    "to": 1971
  }, {
    "from": 1971,
    "label": "has",
    "to": 1972
  }, {
    "from": 1972,
    "label": "has",
    "to": 1973
  }, {
    "from": 1968,
    "label": "has",
    "to": 1974
  }, {
    "from": 1974,
    "label": "has",
    "to": 1884
  }, {
    "from": 1910,
    "label": "has",
    "to": 1838
  }, {
    "from": 1910,
    "label": "has",
    "to": 22
  }, {
    "from": 1910,
    "label": "has",
    "to": 1975
  }, {
    "from": 1976,
    "label": "has",
    "to": 1911
  }, {
    "from": 1976,
    "label": "has",
    "to": 1841
  }, {
    "from": 1976,
    "label": "has",
    "to": 1977
  }, {
    "from": 1976,
    "label": "has",
    "to": 1857
  }, {
    "from": 1976,
    "label": "has",
    "to": 1978
  }, {
    "from": 1976,
    "label": "has",
    "to": 1979
  }, {
    "from": 1976,
    "label": "has",
    "to": 1913
  }, {
    "from": 1976,
    "label": "has",
    "to": 1980
  }, {
    "from": 1976,
    "label": "has",
    "to": 1981
  }, {
    "from": 1976,
    "label": "has",
    "to": 1915
  }, {
    "from": 1976,
    "label": "has",
    "to": 1982
  }, {
    "from": 1976,
    "label": "has",
    "to": 1838
  }, {
    "from": 1976,
    "label": "has",
    "to": 1983
  }, {
    "from": 1976,
    "label": "has",
    "to": 1946
  }, {
    "from": 1976,
    "label": "has",
    "to": 1984
  }, {
    "from": 1976,
    "label": "has",
    "to": 1985
  }, {
    "from": 1976,
    "label": "has",
    "to": 1949
  }, {
    "from": 1976,
    "label": "has",
    "to": 1857
  }, {
    "from": 1976,
    "label": "has",
    "to": 1986
  }, {
    "from": 1976,
    "label": "has",
    "to": 1857
  }, {
    "from": 1976,
    "label": "has",
    "to": 1987
  }, {
    "from": 1976,
    "label": "has",
    "to": 1988
  }, {
    "from": 1976,
    "label": "has",
    "to": 1913
  }, {
    "from": 1976,
    "label": "has",
    "to": 1989
  }, {
    "from": 1976,
    "label": "has",
    "to": 1915
  }, {
    "from": 1976,
    "label": "has",
    "to": 1982
  }, {
    "from": 1976,
    "label": "has",
    "to": 1838
  }, {
    "from": 1976,
    "label": "has",
    "to": 1983
  }, {
    "from": 1976,
    "label": "has",
    "to": 1946
  }, {
    "from": 1976,
    "label": "has",
    "to": 1990
  }, {
    "from": 1976,
    "label": "has",
    "to": 1991
  }, {
    "from": 1976,
    "label": "has",
    "to": 1949
  }, {
    "from": 1976,
    "label": "has",
    "to": 22
  }, {
    "from": 1976,
    "label": "has",
    "to": 1992
  }, {
    "from": 1993,
    "label": "has",
    "to": 1911
  }, {
    "from": 1993,
    "label": "has",
    "to": 1841
  }, {
    "from": 1993,
    "label": "has",
    "to": 1994
  }, {
    "from": 1993,
    "label": "has",
    "to": 1857
  }, {
    "from": 1993,
    "label": "has",
    "to": 1995
  }, {
    "from": 1993,
    "label": "has",
    "to": 1996
  }, {
    "from": 1993,
    "label": "has",
    "to": 1913
  }, {
    "from": 1993,
    "label": "has",
    "to": 1997
  }, {
    "from": 1993,
    "label": "has",
    "to": 1998
  }, {
    "from": 1993,
    "label": "has",
    "to": 1915
  }, {
    "from": 1993,
    "label": "has",
    "to": 1982
  }, {
    "from": 1993,
    "label": "has",
    "to": 1838
  }, {
    "from": 1993,
    "label": "has",
    "to": 1999
  }, {
    "from": 1993,
    "label": "has",
    "to": 1946
  }, {
    "from": 1993,
    "label": "has",
    "to": 2000
  }, {
    "from": 1993,
    "label": "has",
    "to": 2001
  }, {
    "from": 1993,
    "label": "has",
    "to": 1949
  }, {
    "from": 1993,
    "label": "has",
    "to": 22
  }, {
    "from": 1993,
    "label": "has",
    "to": 2002
  }, {
    "from": 2003,
    "label": "has",
    "to": 1911
  }, {
    "from": 2003,
    "label": "has",
    "to": 1841
  }, {
    "from": 2003,
    "label": "has",
    "to": 2004
  }, {
    "from": 2003,
    "label": "has",
    "to": 1857
  }, {
    "from": 2003,
    "label": "has",
    "to": 2005
  }, {
    "from": 2003,
    "label": "has",
    "to": 2006
  }, {
    "from": 2003,
    "label": "has",
    "to": 1913
  }, {
    "from": 2003,
    "label": "has",
    "to": 2007
  }, {
    "from": 2003,
    "label": "has",
    "to": 1915
  }, {
    "from": 2003,
    "label": "has",
    "to": 1982
  }, {
    "from": 2003,
    "label": "has",
    "to": 1838
  }, {
    "from": 2003,
    "label": "has",
    "to": 2008
  }, {
    "from": 2003,
    "label": "has",
    "to": 1946
  }, {
    "from": 2003,
    "label": "has",
    "to": 2009
  }, {
    "from": 2003,
    "label": "has",
    "to": 2010
  }, {
    "from": 2003,
    "label": "has",
    "to": 1949
  }, {
    "from": 2003,
    "label": "has",
    "to": 22
  }, {
    "from": 2003,
    "label": "has",
    "to": 2011
  }, {
    "from": 2012,
    "label": "has",
    "to": 1911
  }, {
    "from": 2012,
    "label": "has",
    "to": 1841
  }, {
    "from": 2012,
    "label": "has",
    "to": 2013
  }, {
    "from": 2012,
    "label": "has",
    "to": 1857
  }, {
    "from": 2012,
    "label": "has",
    "to": 1913
  }, {
    "from": 2012,
    "label": "has",
    "to": 2014
  }, {
    "from": 2012,
    "label": "has",
    "to": 1915
  }, {
    "from": 2012,
    "label": "has",
    "to": 2015
  }, {
    "from": 2015,
    "label": "has",
    "to": 2016
  }, {
    "from": 2016,
    "label": "has",
    "to": 2017
  }, {
    "from": 2017,
    "label": "has",
    "to": 2018
  }, {
    "from": 2016,
    "label": "has",
    "to": 2019
  }, {
    "from": 2016,
    "label": "has",
    "to": 2020
  }, {
    "from": 2020,
    "label": "has",
    "to": 2021
  }, {
    "from": 2012,
    "label": "has",
    "to": 2022
  }, {
    "from": 2012,
    "label": "has",
    "to": 1841
  }, {
    "from": 2012,
    "label": "has",
    "to": 2013
  }, {
    "from": 2012,
    "label": "has",
    "to": 1857
  }, {
    "from": 2012,
    "label": "has",
    "to": 2023
  }, {
    "from": 2012,
    "label": "has",
    "to": 2024
  }, {
    "from": 2012,
    "label": "has",
    "to": 1944
  }, {
    "from": 2012,
    "label": "has",
    "to": 1838
  }, {
    "from": 2012,
    "label": "has",
    "to": 2025
  }, {
    "from": 2012,
    "label": "has",
    "to": 1946
  }, {
    "from": 2012,
    "label": "has",
    "to": 2026
  }, {
    "from": 2012,
    "label": "has",
    "to": 2027
  }, {
    "from": 2012,
    "label": "has",
    "to": 1949
  }, {
    "from": 2012,
    "label": "has",
    "to": 22
  }, {
    "from": 2012,
    "label": "has",
    "to": 2028
  }, {
    "from": 2029,
    "label": "has",
    "to": 2016
  }, {
    "from": 2016,
    "label": "has",
    "to": 2017
  }, {
    "from": 2017,
    "label": "has",
    "to": 2018
  }, {
    "from": 2016,
    "label": "has",
    "to": 2019
  }, {
    "from": 2016,
    "label": "has",
    "to": 2020
  }, {
    "from": 2020,
    "label": "has",
    "to": 2021
  }, {
    "from": 2029,
    "label": "has",
    "to": 2030
  }, {
    "from": 2031,
    "label": "has",
    "to": 2032
  }, {
    "from": 2031,
    "label": "has",
    "to": 2033
  }, {
    "from": 2033,
    "label": "has",
    "to": 2034
  }, {
    "from": 2033,
    "label": "has",
    "to": 2035
  }, {
    "from": 2033,
    "label": "has",
    "to": 2036
  }, {
    "from": 2033,
    "label": "has",
    "to": 2037
  }, {
    "from": 2033,
    "label": "has",
    "to": 2038
  }, {
    "from": 2033,
    "label": "has",
    "to": 2039
  }, {
    "from": 2033,
    "label": "has",
    "to": 2040
  }, {
    "from": 2040,
    "label": "has",
    "to": 2041
  }, {
    "from": 2041,
    "label": "has",
    "to": 2042
  }, {
    "from": 2041,
    "label": "has",
    "to": 2043
  }, {
    "from": 2043,
    "label": "has",
    "to": 2044
  }, {
    "from": 2041,
    "label": "has",
    "to": 2045
  }, {
    "from": 2045,
    "label": "has",
    "to": 2046
  }, {
    "from": 2041,
    "label": "has",
    "to": 2047
  }, {
    "from": 2047,
    "label": "has",
    "to": 2048
  }, {
    "from": 2041,
    "label": "has",
    "to": 2049
  }, {
    "from": 2049,
    "label": "has",
    "to": 2050
  }, {
    "from": 2050,
    "label": "has",
    "to": 2051
  }, {
    "from": 2033,
    "label": "has",
    "to": 2052
  }, {
    "from": 2052,
    "label": "has",
    "to": 2053
  }, {
    "from": 2052,
    "label": "has",
    "to": 2054
  }, {
    "from": 2052,
    "label": "has",
    "to": 2055
  }, {
    "from": 2052,
    "label": "has",
    "to": 2056
  }, {
    "from": 2056,
    "label": "has",
    "to": 2057
  }, {
    "from": 2057,
    "label": "has",
    "to": 2058
  }, {
    "from": 2058,
    "label": "has",
    "to": 2059
  }, {
    "from": 2057,
    "label": "has",
    "to": 2060
  }, {
    "from": 2057,
    "label": "has",
    "to": 2061
  }, {
    "from": 2052,
    "label": "has",
    "to": 2062
  }, {
    "from": 2052,
    "label": "has",
    "to": 2063
  }, {
    "from": 2052,
    "label": "has",
    "to": 2064
  }, {
    "from": 2052,
    "label": "has",
    "to": 2065
  }, {
    "from": 2052,
    "label": "has",
    "to": 2066
  }, {
    "from": 2052,
    "label": "has",
    "to": 2067
  }, {
    "from": 2067,
    "label": "has",
    "to": 2068
  }, {
    "from": 2068,
    "label": "has",
    "to": 2069
  }, {
    "from": 2067,
    "label": "has",
    "to": 2070
  }, {
    "from": 2067,
    "label": "has",
    "to": 2071
  }, {
    "from": 2071,
    "label": "has",
    "to": 2072
  }, {
    "from": 2052,
    "label": "has",
    "to": 2073
  }, {
    "from": 2052,
    "label": "has",
    "to": 2074
  }, {
    "from": 2052,
    "label": "has",
    "to": 2075
  }, {
    "from": 2052,
    "label": "has",
    "to": 1345
  }, {
    "from": 2052,
    "label": "has",
    "to": 2076
  }, {
    "from": 2052,
    "label": "has",
    "to": 2077
  }, {
    "from": 2052,
    "label": "has",
    "to": 2078
  }, {
    "from": 2052,
    "label": "has",
    "to": 2079
  }, {
    "from": 2052,
    "label": "has",
    "to": 2080
  }, {
    "from": 2031,
    "label": "has",
    "to": 22
  }, {
    "from": 2031,
    "label": "has",
    "to": 2081
  }, {
    "from": 2082,
    "label": "has",
    "to": 2083
  }, {
    "from": 2082,
    "label": "has",
    "to": 2084
  }, {
    "from": 2084,
    "label": "has",
    "to": 2085
  }, {
    "from": 2082,
    "label": "has",
    "to": 1838
  }, {
    "from": 2082,
    "label": "has",
    "to": 2086
  }, {
    "from": 2086,
    "label": "has",
    "to": 2087
  }, {
    "from": 2086,
    "label": "has",
    "to": 2088
  }, {
    "from": 2088,
    "label": "has",
    "to": 2089
  }, {
    "from": 2088,
    "label": "has",
    "to": 2090
  }, {
    "from": 2088,
    "label": "has",
    "to": 2091
  }, {
    "from": 2088,
    "label": "has",
    "to": 2092
  }, {
    "from": 2092,
    "label": "has",
    "to": 2093
  }, {
    "from": 2088,
    "label": "has",
    "to": 1841
  }, {
    "from": 2088,
    "label": "has",
    "to": 2094
  }, {
    "from": 2088,
    "label": "has",
    "to": 1857
  }, {
    "from": 2088,
    "label": "has",
    "to": 2095
  }, {
    "from": 2088,
    "label": "has",
    "to": 1838
  }, {
    "from": 2088,
    "label": "has",
    "to": 1913
  }, {
    "from": 2088,
    "label": "has",
    "to": 2096
  }, {
    "from": 2088,
    "label": "has",
    "to": 1915
  }, {
    "from": 2088,
    "label": "has",
    "to": 2097
  }, {
    "from": 2097,
    "label": "has",
    "to": 2098
  }, {
    "from": 2098,
    "label": "has",
    "to": 2099
  }, {
    "from": 2099,
    "label": "has",
    "to": 2100
  }, {
    "from": 2098,
    "label": "has",
    "to": 2101
  }, {
    "from": 2101,
    "label": "has",
    "to": 2018
  }, {
    "from": 2098,
    "label": "has",
    "to": 2102
  }, {
    "from": 2102,
    "label": "has",
    "to": 2103
  }, {
    "from": 2103,
    "label": "has",
    "to": 2104
  }, {
    "from": 2102,
    "label": "has",
    "to": 2105
  }, {
    "from": 2098,
    "label": "has",
    "to": 2106
  }, {
    "from": 2088,
    "label": "has",
    "to": 2107
  }, {
    "from": 2088,
    "label": "has",
    "to": 1869
  }, {
    "from": 2088,
    "label": "has",
    "to": 2108
  }, {
    "from": 2088,
    "label": "has",
    "to": 2109
  }, {
    "from": 2109,
    "label": "has",
    "to": 2110
  }, {
    "from": 2110,
    "label": "has",
    "to": 2111
  }, {
    "from": 2110,
    "label": "has",
    "to": 2019
  }, {
    "from": 2088,
    "label": "has",
    "to": 2112
  }, {
    "from": 2088,
    "label": "has",
    "to": 2113
  }, {
    "from": 2088,
    "label": "has",
    "to": 2114
  }, {
    "from": 2088,
    "label": "has",
    "to": 2115
  }, {
    "from": 2088,
    "label": "has",
    "to": 2116
  }, {
    "from": 2088,
    "label": "has",
    "to": 2117
  }, {
    "from": 2088,
    "label": "has",
    "to": 2118
  }, {
    "from": 2088,
    "label": "has",
    "to": 2119
  }, {
    "from": 2119,
    "label": "has",
    "to": 2120
  }, {
    "from": 2119,
    "label": "has",
    "to": 1913
  }, {
    "from": 2119,
    "label": "has",
    "to": 2121
  }, {
    "from": 2119,
    "label": "has",
    "to": 1915
  }, {
    "from": 2119,
    "label": "has",
    "to": 1982
  }, {
    "from": 2119,
    "label": "has",
    "to": 2122
  }, {
    "from": 2119,
    "label": "has",
    "to": 1868
  }, {
    "from": 2119,
    "label": "has",
    "to": 2123
  }, {
    "from": 2088,
    "label": "has",
    "to": 2124
  }, {
    "from": 2124,
    "label": "has",
    "to": 2125
  }, {
    "from": 2088,
    "label": "has",
    "to": 1838
  }, {
    "from": 2082,
    "label": "has",
    "to": 2126
  }, {
    "from": 2082,
    "label": "has",
    "to": 22
  }, {
    "from": 2082,
    "label": "has",
    "to": 2127
  }, {
    "from": 2128,
    "label": "has",
    "to": 2098
  }, {
    "from": 2098,
    "label": "has",
    "to": 2099
  }, {
    "from": 2099,
    "label": "has",
    "to": 2100
  }, {
    "from": 2098,
    "label": "has",
    "to": 2101
  }, {
    "from": 2101,
    "label": "has",
    "to": 2018
  }, {
    "from": 2098,
    "label": "has",
    "to": 2102
  }, {
    "from": 2102,
    "label": "has",
    "to": 2103
  }, {
    "from": 2103,
    "label": "has",
    "to": 2104
  }, {
    "from": 2102,
    "label": "has",
    "to": 2105
  }, {
    "from": 2098,
    "label": "has",
    "to": 2106
  }, {
    "from": 2128,
    "label": "has",
    "to": 2129
  }, {
    "from": 2130,
    "label": "has",
    "to": 2110
  }, {
    "from": 2110,
    "label": "has",
    "to": 2111
  }, {
    "from": 2110,
    "label": "has",
    "to": 2019
  }, {
    "from": 2130,
    "label": "has",
    "to": 2131
  }, {
    "from": 2132,
    "label": "has",
    "to": 2133
  }, {
    "from": 2132,
    "label": "has",
    "to": 2134
  }, {
    "from": 2134,
    "label": "has",
    "to": 2135
  }, {
    "from": 2135,
    "label": "has",
    "to": 2136
  }, {
    "from": 2135,
    "label": "has",
    "to": 2137
  }, {
    "from": 2135,
    "label": "has",
    "to": 2138
  }, {
    "from": 2135,
    "label": "has",
    "to": 2139
  }, {
    "from": 2135,
    "label": "has",
    "to": 2140
  }, {
    "from": 2135,
    "label": "has",
    "to": 2141
  }, {
    "from": 2141,
    "label": "has",
    "to": 2142
  }, {
    "from": 2142,
    "label": "has",
    "to": 2143
  }, {
    "from": 2132,
    "label": "has",
    "to": 2144
  }, {
    "from": 2144,
    "label": "has",
    "to": 2145
  }, {
    "from": 2145,
    "label": "has",
    "to": 2146
  }, {
    "from": 2132,
    "label": "has",
    "to": 2147
  }, {
    "from": 2148,
    "label": "has",
    "to": 930
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 2150
  }, {
    "from": 2148,
    "label": "has",
    "to": 2151
  }, {
    "from": 2148,
    "label": "has",
    "to": 2152
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 1869
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 2153
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 2154
  }, {
    "from": 2148,
    "label": "has",
    "to": 2155
  }, {
    "from": 2148,
    "label": "has",
    "to": 1869
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 2156
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 2157
  }, {
    "from": 2148,
    "label": "has",
    "to": 2158
  }, {
    "from": 2148,
    "label": "has",
    "to": 1869
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 2159
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 2160
  }, {
    "from": 2148,
    "label": "has",
    "to": 2161
  }, {
    "from": 2148,
    "label": "has",
    "to": 1869
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 2162
  }, {
    "from": 2148,
    "label": "has",
    "to": 2149
  }, {
    "from": 2148,
    "label": "has",
    "to": 2163
  }, {
    "from": 2148,
    "label": "has",
    "to": 2164
  }, {
    "from": 2148,
    "label": "has",
    "to": 2165
  }, {
    "from": 2148,
    "label": "has",
    "to": 2166
  }, {
    "from": 2148,
    "label": "has",
    "to": 2167
  }, {
    "from": 2148,
    "label": "has",
    "to": 2165
  }, {
    "from": 2148,
    "label": "has",
    "to": 2168
  }, {
    "from": 2148,
    "label": "has",
    "to": 2169
  }, {
    "from": 2148,
    "label": "has",
    "to": 2165
  }, {
    "from": 2148,
    "label": "has",
    "to": 2170
  }, {
    "from": 2148,
    "label": "has",
    "to": 2171
  }, {
    "from": 2172,
    "label": "has",
    "to": 2173
  }, {
    "from": 2173,
    "label": "has",
    "to": 2174
  }, {
    "from": 2172,
    "label": "has",
    "to": 2175
  }, {
    "from": 2172,
    "label": "has",
    "to": 2176
  }, {
    "from": 2176,
    "label": "has",
    "to": 2177
  }, {
    "from": 2176,
    "label": "has",
    "to": 2178
  }, {
    "from": 2176,
    "label": "has",
    "to": 2179
  }, {
    "from": 2179,
    "label": "has",
    "to": 2180
  }, {
    "from": 2179,
    "label": "has",
    "to": 2181
  }, {
    "from": 2176,
    "label": "has",
    "to": 2182
  }, {
    "from": 2176,
    "label": "has",
    "to": 2183
  }, {
    "from": 2183,
    "label": "has",
    "to": 2184
  }, {
    "from": 2184,
    "label": "has",
    "to": 2185
  }, {
    "from": 2183,
    "label": "has",
    "to": 2186
  }, {
    "from": 2186,
    "label": "has",
    "to": 2187
  }, {
    "from": 2186,
    "label": "has",
    "to": 2188
  }, {
    "from": 2186,
    "label": "has",
    "to": 2189
  }, {
    "from": 2186,
    "label": "has",
    "to": 2190
  }, {
    "from": 2183,
    "label": "has",
    "to": 2191
  }, {
    "from": 2183,
    "label": "has",
    "to": 2192
  }, {
    "from": 2192,
    "label": "has",
    "to": 2193
  }, {
    "from": 2176,
    "label": "has",
    "to": 2194
  }, {
    "from": 2194,
    "label": "has",
    "to": 2185
  }, {
    "from": 2176,
    "label": "has",
    "to": 2195
  }, {
    "from": 2176,
    "label": "has",
    "to": 2196
  }, {
    "from": 2196,
    "label": "has",
    "to": 2197
  }, {
    "from": 2176,
    "label": "has",
    "to": 2198
  }, {
    "from": 2176,
    "label": "has",
    "to": 2199
  }, {
    "from": 2176,
    "label": "has",
    "to": 2200
  }, {
    "from": 2172,
    "label": "has",
    "to": 22
  }, {
    "from": 2172,
    "label": "has",
    "to": 2201
  }, {
    "from": 2202,
    "label": "has",
    "to": 906
  }, {
    "from": 2202,
    "label": "has",
    "to": 2203
  }, {
    "from": 2203,
    "label": "has",
    "to": 2204
  }, {
    "from": 2203,
    "label": "has",
    "to": 2205
  }, {
    "from": 2202,
    "label": "has",
    "to": 22
  }, {
    "from": 2202,
    "label": "has",
    "to": 2206
  }, {
    "from": 2202,
    "label": "has",
    "to": 2207
  }, {
    "from": 2207,
    "label": "has",
    "to": 2208
  }, {
    "from": 2207,
    "label": "has",
    "to": 2209
  }, {
    "from": 2207,
    "label": "has",
    "to": 2210
  }, {
    "from": 2207,
    "label": "has",
    "to": 2211
  }, {
    "from": 2207,
    "label": "has",
    "to": 2212
  }, {
    "from": 2207,
    "label": "has",
    "to": 2205
  }, {
    "from": 2202,
    "label": "has",
    "to": 22
  }, {
    "from": 2202,
    "label": "has",
    "to": 2213
  }, {
    "from": 2213,
    "label": "has",
    "to": 2214
  }, {
    "from": 2214,
    "label": "has",
    "to": 2215
  }, {
    "from": 2215,
    "label": "has",
    "to": 2216
  }, {
    "from": 2215,
    "label": "has",
    "to": 2217
  }, {
    "from": 2215,
    "label": "has",
    "to": 2218
  }, {
    "from": 2215,
    "label": "has",
    "to": 2219
  }, {
    "from": 2202,
    "label": "has",
    "to": 2220
  }, {
    "from": 2202,
    "label": "has",
    "to": 2221
  }, {
    "from": 2202,
    "label": "has",
    "to": 2222
  }, {
    "from": 2222,
    "label": "has",
    "to": 2223
  }, {
    "from": 2223,
    "label": "has",
    "to": 2224
  }, {
    "from": 2202,
    "label": "has",
    "to": 926
  }, {
    "from": 2202,
    "label": "has",
    "to": 2225
  }, {
    "from": 2225,
    "label": "has",
    "to": 2226
  }, {
    "from": 2225,
    "label": "has",
    "to": 2227
  }, {
    "from": 2202,
    "label": "has",
    "to": 2228
  }, {
    "from": 2228,
    "label": "has",
    "to": 2229
  }, {
    "from": 2202,
    "label": "has",
    "to": 2230
  }, {
    "from": 2230,
    "label": "has",
    "to": 2231
  }, {
    "from": 2231,
    "label": "has",
    "to": 2232
  }, {
    "from": 2202,
    "label": "has",
    "to": 2233
  }, {
    "from": 2202,
    "label": "has",
    "to": 2234
  }, {
    "from": 1296,
    "label": "calls",
    "to": 62
  }, {
    "from": 1296,
    "label": "calls",
    "to": 62
  }, {
    "from": 1910,
    "label": "calls",
    "to": 26
  }, {
    "from": 1910,
    "label": "calls",
    "to": 26
  }, {
    "from": 1976,
    "label": "calls",
    "to": 26
  }, {
    "from": 1976,
    "label": "calls",
    "to": 26
  }, {
    "from": 1993,
    "label": "calls",
    "to": 26
  }, {
    "from": 2003,
    "label": "calls",
    "to": 26
  }, {
    "from": 2012,
    "label": "calls",
    "to": 26
  }, {
    "from": 2082,
    "label": "calls",
    "to": 26
  }, {
    "from": 2082,
    "label": "calls",
    "to": 26
  }, {
    "from": 903,
    "label": "calls",
    "to": 885
  }, {
    "from": 924,
    "label": "calls",
    "to": 885
  }, {
    "from": 924,
    "label": "calls",
    "to": 885
  }, {
    "from": 2,
    "label": "calls",
    "to": 2248
  }, {
    "from": 2,
    "label": "calls",
    "to": 2248
  }, {
    "from": 2,
    "label": "calls",
    "to": 2248
  }, {
    "from": 2,
    "label": "calls",
    "to": 2248
  }, {
    "from": 2,
    "label": "calls",
    "to": 2248
  }, {
    "from": 2,
    "label": "calls",
    "to": 2248
  }, {
    "from": 2,
    "label": "calls",
    "to": 2248
  }, {
    "from": 2,
    "label": "calls",
    "to": 2248
  }, {
    "from": 2,
    "label": "calls",
    "to": 2248
  }, {
    "from": 249,
    "label": "calls",
    "to": 2248
  }, {
    "from": 262,
    "label": "calls",
    "to": 2248
  }, {
    "from": 262,
    "label": "calls",
    "to": 2248
  }, {
    "from": 262,
    "label": "calls",
    "to": 2248
  }, {
    "from": 784,
    "label": "calls",
    "to": 2248
  }, {
    "from": 238,
    "label": "calls",
    "to": 2249
  }, {
    "from": 243,
    "label": "calls",
    "to": 2249
  }, {
    "from": 2202,
    "label": "calls",
    "to": 71
  }, {
    "from": 167,
    "label": "calls",
    "to": 167
  }, {
    "from": 177,
    "label": "calls",
    "to": 167
  }, {
    "from": 262,
    "label": "calls",
    "to": 2250
  }, {
    "from": 262,
    "label": "calls",
    "to": 2257
  }, {
    "from": 262,
    "label": "calls",
    "to": 2257
  }, {
    "from": 262,
    "label": "calls",
    "to": 2257
  }, {
    "from": 262,
    "label": "calls",
    "to": 2257
  }, {
    "from": 262,
    "label": "calls",
    "to": 2257
  }, {
    "from": 262,
    "label": "calls",
    "to": 2257
  }, {
    "from": 262,
    "label": "calls",
    "to": 2257
  }, {
    "from": 262,
    "label": "calls",
    "to": 2257
  }, {
    "from": 262,
    "label": "calls",
    "to": 2257
  }, {
    "from": 304,
    "label": "calls",
    "to": 2257
  }, {
    "from": 784,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1287,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1287,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2257
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2257
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2257
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2257
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2257
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2257
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2257
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2257
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2257
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1277
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1277
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1277
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1277
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1277
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1277
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1277
  }, {
    "from": 205,
    "label": "calls",
    "to": 2237
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2237
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2237
  }, {
    "from": 205,
    "label": "calls",
    "to": 205
  }, {
    "from": 1296,
    "label": "calls",
    "to": 205
  }, {
    "from": 1296,
    "label": "calls",
    "to": 205
  }, {
    "from": 33,
    "label": "calls",
    "to": 2238
  }, {
    "from": 33,
    "label": "calls",
    "to": 2238
  }, {
    "from": 147,
    "label": "calls",
    "to": 2238
  }, {
    "from": 147,
    "label": "calls",
    "to": 2238
  }, {
    "from": 188,
    "label": "calls",
    "to": 2238
  }, {
    "from": 198,
    "label": "calls",
    "to": 2238
  }, {
    "from": 205,
    "label": "calls",
    "to": 2238
  }, {
    "from": 214,
    "label": "calls",
    "to": 2238
  }, {
    "from": 219,
    "label": "calls",
    "to": 2238
  }, {
    "from": 224,
    "label": "calls",
    "to": 2238
  }, {
    "from": 228,
    "label": "calls",
    "to": 2238
  }, {
    "from": 232,
    "label": "calls",
    "to": 2238
  }, {
    "from": 249,
    "label": "calls",
    "to": 2238
  }, {
    "from": 249,
    "label": "calls",
    "to": 2238
  }, {
    "from": 249,
    "label": "calls",
    "to": 2238
  }, {
    "from": 262,
    "label": "calls",
    "to": 2238
  }, {
    "from": 262,
    "label": "calls",
    "to": 2238
  }, {
    "from": 262,
    "label": "calls",
    "to": 2238
  }, {
    "from": 262,
    "label": "calls",
    "to": 2238
  }, {
    "from": 784,
    "label": "calls",
    "to": 2238
  }, {
    "from": 784,
    "label": "calls",
    "to": 2238
  }, {
    "from": 846,
    "label": "calls",
    "to": 2238
  }, {
    "from": 846,
    "label": "calls",
    "to": 2238
  }, {
    "from": 846,
    "label": "calls",
    "to": 2238
  }, {
    "from": 846,
    "label": "calls",
    "to": 2238
  }, {
    "from": 903,
    "label": "calls",
    "to": 2238
  }, {
    "from": 903,
    "label": "calls",
    "to": 2238
  }, {
    "from": 903,
    "label": "calls",
    "to": 2238
  }, {
    "from": 967,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2238
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2238
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2238
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2238
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2238
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2238
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2238
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2238
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2238
  }, {
    "from": 33,
    "label": "calls",
    "to": 33
  }, {
    "from": 1013,
    "label": "calls",
    "to": 33
  }, {
    "from": 1296,
    "label": "calls",
    "to": 214
  }, {
    "from": 1296,
    "label": "calls",
    "to": 214
  }, {
    "from": 1296,
    "label": "calls",
    "to": 214
  }, {
    "from": 924,
    "label": "calls",
    "to": 1993
  }, {
    "from": 1812,
    "label": "calls",
    "to": 2029
  }, {
    "from": 1910,
    "label": "calls",
    "to": 1803
  }, {
    "from": 1976,
    "label": "calls",
    "to": 1803
  }, {
    "from": 1976,
    "label": "calls",
    "to": 1803
  }, {
    "from": 1976,
    "label": "calls",
    "to": 1803
  }, {
    "from": 1993,
    "label": "calls",
    "to": 1803
  }, {
    "from": 1993,
    "label": "calls",
    "to": 1803
  }, {
    "from": 2003,
    "label": "calls",
    "to": 1803
  }, {
    "from": 2012,
    "label": "calls",
    "to": 1803
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1803
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1803
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2251
  }, {
    "from": 2202,
    "label": "calls",
    "to": 924
  }, {
    "from": 2235,
    "label": "calls",
    "to": 2202
  }, {
    "from": 262,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2239
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2239
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2239
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2239
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2239
  }, {
    "from": 167,
    "label": "calls",
    "to": 147
  }, {
    "from": 924,
    "label": "calls",
    "to": 1910
  }, {
    "from": 1013,
    "label": "calls",
    "to": 954
  }, {
    "from": 1013,
    "label": "calls",
    "to": 954
  }, {
    "from": 1013,
    "label": "calls",
    "to": 954
  }, {
    "from": 1013,
    "label": "calls",
    "to": 954
  }, {
    "from": 1013,
    "label": "calls",
    "to": 954
  }, {
    "from": 1013,
    "label": "calls",
    "to": 954
  }, {
    "from": 47,
    "label": "calls",
    "to": 47
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2241
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2241
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2241
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2241
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2241
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2241
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2241
  }, {
    "from": 1287,
    "label": "calls",
    "to": 2241
  }, {
    "from": 903,
    "label": "calls",
    "to": 967
  }, {
    "from": 188,
    "label": "calls",
    "to": 2236
  }, {
    "from": 198,
    "label": "calls",
    "to": 2236
  }, {
    "from": 219,
    "label": "calls",
    "to": 2236
  }, {
    "from": 224,
    "label": "calls",
    "to": 2236
  }, {
    "from": 228,
    "label": "calls",
    "to": 2236
  }, {
    "from": 232,
    "label": "calls",
    "to": 2236
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2236
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2236
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2236
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2236
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2236
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2236
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2236
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2236
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2236
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2236
  }, {
    "from": 249,
    "label": "calls",
    "to": 243
  }, {
    "from": 924,
    "label": "calls",
    "to": 1976
  }, {
    "from": 2,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2,
    "label": "calls",
    "to": 2254
  }, {
    "from": 33,
    "label": "calls",
    "to": 2254
  }, {
    "from": 47,
    "label": "calls",
    "to": 2254
  }, {
    "from": 900,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2254
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2254
  }, {
    "from": 784,
    "label": "calls",
    "to": 2266
  }, {
    "from": 784,
    "label": "calls",
    "to": 2266
  }, {
    "from": 784,
    "label": "calls",
    "to": 2266
  }, {
    "from": 903,
    "label": "calls",
    "to": 1013
  }, {
    "from": 2202,
    "label": "calls",
    "to": 311
  }, {
    "from": 903,
    "label": "calls",
    "to": 893
  }, {
    "from": 167,
    "label": "calls",
    "to": 2242
  }, {
    "from": 167,
    "label": "calls",
    "to": 2242
  }, {
    "from": 177,
    "label": "calls",
    "to": 2242
  }, {
    "from": 177,
    "label": "calls",
    "to": 2242
  }, {
    "from": 249,
    "label": "calls",
    "to": 2242
  }, {
    "from": 967,
    "label": "calls",
    "to": 2242
  }, {
    "from": 967,
    "label": "calls",
    "to": 2242
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2242
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2242
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2242
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2242
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2242
  }, {
    "from": 846,
    "label": "calls",
    "to": 238
  }, {
    "from": 903,
    "label": "calls",
    "to": 238
  }, {
    "from": 2202,
    "label": "calls",
    "to": 238
  }, {
    "from": 262,
    "label": "calls",
    "to": 2245
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2245
  }, {
    "from": 967,
    "label": "calls",
    "to": 262
  }, {
    "from": 1013,
    "label": "calls",
    "to": 262
  }, {
    "from": 1013,
    "label": "calls",
    "to": 262
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 1296,
    "label": "calls",
    "to": 64
  }, {
    "from": 2031,
    "label": "calls",
    "to": 64
  }, {
    "from": 2082,
    "label": "calls",
    "to": 64
  }, {
    "from": 1013,
    "label": "calls",
    "to": 188
  }, {
    "from": 1013,
    "label": "calls",
    "to": 188
  }, {
    "from": 1013,
    "label": "calls",
    "to": 188
  }, {
    "from": 1013,
    "label": "calls",
    "to": 188
  }, {
    "from": 1013,
    "label": "calls",
    "to": 188
  }, {
    "from": 1013,
    "label": "calls",
    "to": 188
  }, {
    "from": 1013,
    "label": "calls",
    "to": 188
  }, {
    "from": 1013,
    "label": "calls",
    "to": 963
  }, {
    "from": 1013,
    "label": "calls",
    "to": 963
  }, {
    "from": 1013,
    "label": "calls",
    "to": 963
  }, {
    "from": 1013,
    "label": "calls",
    "to": 963
  }, {
    "from": 1013,
    "label": "calls",
    "to": 963
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2132
  }, {
    "from": 924,
    "label": "calls",
    "to": 2003
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2264
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2148
  }, {
    "from": 903,
    "label": "calls",
    "to": 2253
  }, {
    "from": 903,
    "label": "calls",
    "to": 2253
  }, {
    "from": 903,
    "label": "calls",
    "to": 2253
  }, {
    "from": 924,
    "label": "calls",
    "to": 2253
  }, {
    "from": 924,
    "label": "calls",
    "to": 2253
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2253
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2253
  }, {
    "from": 167,
    "label": "calls",
    "to": 781
  }, {
    "from": 177,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 1013,
    "label": "calls",
    "to": 781
  }, {
    "from": 13,
    "label": "calls",
    "to": 2240
  }, {
    "from": 26,
    "label": "calls",
    "to": 2240
  }, {
    "from": 26,
    "label": "calls",
    "to": 2240
  }, {
    "from": 64,
    "label": "calls",
    "to": 2240
  }, {
    "from": 147,
    "label": "calls",
    "to": 2240
  }, {
    "from": 147,
    "label": "calls",
    "to": 2240
  }, {
    "from": 784,
    "label": "calls",
    "to": 2240
  }, {
    "from": 784,
    "label": "calls",
    "to": 2240
  }, {
    "from": 784,
    "label": "calls",
    "to": 2240
  }, {
    "from": 784,
    "label": "calls",
    "to": 2240
  }, {
    "from": 784,
    "label": "calls",
    "to": 2240
  }, {
    "from": 846,
    "label": "calls",
    "to": 2240
  }, {
    "from": 846,
    "label": "calls",
    "to": 2240
  }, {
    "from": 846,
    "label": "calls",
    "to": 2240
  }, {
    "from": 893,
    "label": "calls",
    "to": 2240
  }, {
    "from": 903,
    "label": "calls",
    "to": 2240
  }, {
    "from": 903,
    "label": "calls",
    "to": 2240
  }, {
    "from": 924,
    "label": "calls",
    "to": 2240
  }, {
    "from": 963,
    "label": "calls",
    "to": 2240
  }, {
    "from": 967,
    "label": "calls",
    "to": 2240
  }, {
    "from": 967,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1013,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1803,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1803,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1812,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1812,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1812,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1812,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1812,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1840,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1896,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1976,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1993,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2003,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2012,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2031,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2029,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2240
  }, {
    "from": 1296,
    "label": "calls",
    "to": 298
  }, {
    "from": 1296,
    "label": "calls",
    "to": 298
  }, {
    "from": 1296,
    "label": "calls",
    "to": 298
  }, {
    "from": 147,
    "label": "calls",
    "to": 784
  }, {
    "from": 193,
    "label": "calls",
    "to": 784
  }, {
    "from": 846,
    "label": "calls",
    "to": 784
  }, {
    "from": 885,
    "label": "calls",
    "to": 784
  }, {
    "from": 885,
    "label": "calls",
    "to": 784
  }, {
    "from": 889,
    "label": "calls",
    "to": 784
  }, {
    "from": 889,
    "label": "calls",
    "to": 784
  }, {
    "from": 893,
    "label": "calls",
    "to": 784
  }, {
    "from": 1271,
    "label": "calls",
    "to": 784
  }, {
    "from": 903,
    "label": "calls",
    "to": 2265
  }, {
    "from": 903,
    "label": "calls",
    "to": 2265
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2265
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1284
  }, {
    "from": 924,
    "label": "calls",
    "to": 2082
  }, {
    "from": 1296,
    "label": "calls",
    "to": 224
  }, {
    "from": 1296,
    "label": "calls",
    "to": 224
  }, {
    "from": 33,
    "label": "calls",
    "to": 13
  }, {
    "from": 1840,
    "label": "calls",
    "to": 13
  }, {
    "from": 1840,
    "label": "calls",
    "to": 13
  }, {
    "from": 1840,
    "label": "calls",
    "to": 13
  }, {
    "from": 1840,
    "label": "calls",
    "to": 13
  }, {
    "from": 1840,
    "label": "calls",
    "to": 13
  }, {
    "from": 1840,
    "label": "calls",
    "to": 13
  }, {
    "from": 1910,
    "label": "calls",
    "to": 13
  }, {
    "from": 1910,
    "label": "calls",
    "to": 13
  }, {
    "from": 1910,
    "label": "calls",
    "to": 13
  }, {
    "from": 1910,
    "label": "calls",
    "to": 13
  }, {
    "from": 2082,
    "label": "calls",
    "to": 13
  }, {
    "from": 2172,
    "label": "calls",
    "to": 13
  }, {
    "from": 2202,
    "label": "calls",
    "to": 13
  }, {
    "from": 262,
    "label": "calls",
    "to": 2252
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2252
  }, {
    "from": 846,
    "label": "calls",
    "to": 2243
  }, {
    "from": 893,
    "label": "calls",
    "to": 2243
  }, {
    "from": 784,
    "label": "calls",
    "to": 2244
  }, {
    "from": 784,
    "label": "calls",
    "to": 2244
  }, {
    "from": 784,
    "label": "calls",
    "to": 2244
  }, {
    "from": 2235,
    "label": "calls",
    "to": 2263
  }, {
    "from": 2235,
    "label": "calls",
    "to": 2263
  }, {
    "from": 1013,
    "label": "calls",
    "to": 960
  }, {
    "from": 1013,
    "label": "calls",
    "to": 960
  }, {
    "from": 1013,
    "label": "calls",
    "to": 960
  }, {
    "from": 1013,
    "label": "calls",
    "to": 960
  }, {
    "from": 1013,
    "label": "calls",
    "to": 960
  }, {
    "from": 1013,
    "label": "calls",
    "to": 960
  }, {
    "from": 1013,
    "label": "calls",
    "to": 960
  }, {
    "from": 784,
    "label": "calls",
    "to": 2255
  }, {
    "from": 784,
    "label": "calls",
    "to": 2255
  }, {
    "from": 784,
    "label": "calls",
    "to": 2255
  }, {
    "from": 219,
    "label": "calls",
    "to": 2256
  }, {
    "from": 224,
    "label": "calls",
    "to": 2256
  }, {
    "from": 228,
    "label": "calls",
    "to": 2256
  }, {
    "from": 232,
    "label": "calls",
    "to": 2256
  }, {
    "from": 1296,
    "label": "calls",
    "to": 285
  }, {
    "from": 1296,
    "label": "calls",
    "to": 285
  }, {
    "from": 1296,
    "label": "calls",
    "to": 285
  }, {
    "from": 1296,
    "label": "calls",
    "to": 285
  }, {
    "from": 1296,
    "label": "calls",
    "to": 285
  }, {
    "from": 1296,
    "label": "calls",
    "to": 285
  }, {
    "from": 1296,
    "label": "calls",
    "to": 285
  }, {
    "from": 1296,
    "label": "calls",
    "to": 285
  }, {
    "from": 924,
    "label": "calls",
    "to": 1896
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1896
  }, {
    "from": 198,
    "label": "calls",
    "to": 193
  }, {
    "from": 1277,
    "label": "calls",
    "to": 193
  }, {
    "from": 1277,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1271
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1271
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1271
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2172
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2172
  }, {
    "from": 2148,
    "label": "calls",
    "to": 2172
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2172
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2172
  }, {
    "from": 924,
    "label": "calls",
    "to": 889
  }, {
    "from": 13,
    "label": "calls",
    "to": 2259
  }, {
    "from": 26,
    "label": "calls",
    "to": 2259
  }, {
    "from": 47,
    "label": "calls",
    "to": 2259
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2259
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2259
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2259
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2259
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2259
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2259
  }, {
    "from": 2132,
    "label": "calls",
    "to": 2259
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2259
  }, {
    "from": 214,
    "label": "calls",
    "to": 198
  }, {
    "from": 219,
    "label": "calls",
    "to": 198
  }, {
    "from": 224,
    "label": "calls",
    "to": 198
  }, {
    "from": 228,
    "label": "calls",
    "to": 198
  }, {
    "from": 232,
    "label": "calls",
    "to": 198
  }, {
    "from": 1296,
    "label": "calls",
    "to": 198
  }, {
    "from": 238,
    "label": "calls",
    "to": 2260
  }, {
    "from": 243,
    "label": "calls",
    "to": 2260
  }, {
    "from": 249,
    "label": "calls",
    "to": 2260
  }, {
    "from": 1013,
    "label": "calls",
    "to": 288
  }, {
    "from": 1013,
    "label": "calls",
    "to": 288
  }, {
    "from": 1013,
    "label": "calls",
    "to": 288
  }, {
    "from": 1013,
    "label": "calls",
    "to": 288
  }, {
    "from": 1013,
    "label": "calls",
    "to": 288
  }, {
    "from": 1013,
    "label": "calls",
    "to": 288
  }, {
    "from": 1013,
    "label": "calls",
    "to": 288
  }, {
    "from": 1013,
    "label": "calls",
    "to": 288
  }, {
    "from": 1013,
    "label": "calls",
    "to": 288
  }, {
    "from": 2172,
    "label": "calls",
    "to": 2261
  }, {
    "from": 13,
    "label": "calls",
    "to": 2246
  }, {
    "from": 26,
    "label": "calls",
    "to": 2246
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2258
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2258
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2262
  }, {
    "from": 285,
    "label": "calls",
    "to": 283
  }, {
    "from": 288,
    "label": "calls",
    "to": 283
  }, {
    "from": 288,
    "label": "calls",
    "to": 283
  }, {
    "from": 288,
    "label": "calls",
    "to": 283
  }, {
    "from": 298,
    "label": "calls",
    "to": 283
  }, {
    "from": 298,
    "label": "calls",
    "to": 283
  }, {
    "from": 298,
    "label": "calls",
    "to": 283
  }, {
    "from": 298,
    "label": "calls",
    "to": 283
  }, {
    "from": 1296,
    "label": "calls",
    "to": 283
  }, {
    "from": 1296,
    "label": "calls",
    "to": 283
  }, {
    "from": 1803,
    "label": "calls",
    "to": 283
  }, {
    "from": 1812,
    "label": "calls",
    "to": 283
  }, {
    "from": 1812,
    "label": "calls",
    "to": 283
  }, {
    "from": 1840,
    "label": "calls",
    "to": 283
  }, {
    "from": 1840,
    "label": "calls",
    "to": 283
  }, {
    "from": 1840,
    "label": "calls",
    "to": 283
  }, {
    "from": 1840,
    "label": "calls",
    "to": 283
  }, {
    "from": 1840,
    "label": "calls",
    "to": 283
  }, {
    "from": 1840,
    "label": "calls",
    "to": 283
  }, {
    "from": 1910,
    "label": "calls",
    "to": 283
  }, {
    "from": 1910,
    "label": "calls",
    "to": 283
  }, {
    "from": 1910,
    "label": "calls",
    "to": 283
  }, {
    "from": 1910,
    "label": "calls",
    "to": 283
  }, {
    "from": 2031,
    "label": "calls",
    "to": 283
  }, {
    "from": 2031,
    "label": "calls",
    "to": 283
  }, {
    "from": 2031,
    "label": "calls",
    "to": 283
  }, {
    "from": 1013,
    "label": "calls",
    "to": 957
  }, {
    "from": 1013,
    "label": "calls",
    "to": 957
  }, {
    "from": 1013,
    "label": "calls",
    "to": 957
  }, {
    "from": 1013,
    "label": "calls",
    "to": 957
  }, {
    "from": 1013,
    "label": "calls",
    "to": 957
  }, {
    "from": 1013,
    "label": "calls",
    "to": 957
  }, {
    "from": 1013,
    "label": "calls",
    "to": 957
  }, {
    "from": 1013,
    "label": "calls",
    "to": 957
  }, {
    "from": 1910,
    "label": "calls",
    "to": 1812
  }, {
    "from": 1976,
    "label": "calls",
    "to": 1812
  }, {
    "from": 1976,
    "label": "calls",
    "to": 1812
  }, {
    "from": 1993,
    "label": "calls",
    "to": 1812
  }, {
    "from": 2003,
    "label": "calls",
    "to": 1812
  }, {
    "from": 2012,
    "label": "calls",
    "to": 1812
  }, {
    "from": 2012,
    "label": "calls",
    "to": 1812
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1812
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1812
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1812
  }, {
    "from": 2082,
    "label": "calls",
    "to": 1812
  }, {
    "from": 1296,
    "label": "calls",
    "to": 177
  }, {
    "from": 1296,
    "label": "calls",
    "to": 177
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 71,
    "label": "calls",
    "to": 68
  }, {
    "from": 967,
    "label": "calls",
    "to": 68
  }, {
    "from": 967,
    "label": "calls",
    "to": 68
  }, {
    "from": 967,
    "label": "calls",
    "to": 68
  }, {
    "from": 967,
    "label": "calls",
    "to": 68
  }, {
    "from": 967,
    "label": "calls",
    "to": 68
  }, {
    "from": 2082,
    "label": "calls",
    "to": 2031
  }, {
    "from": 924,
    "label": "calls",
    "to": 1840
  }, {
    "from": 924,
    "label": "calls",
    "to": 1296
  }, {
    "from": 1296,
    "label": "calls",
    "to": 232
  }, {
    "from": 1296,
    "label": "calls",
    "to": 232
  }, {
    "from": 1296,
    "label": "calls",
    "to": 232
  }, {
    "from": 1296,
    "label": "calls",
    "to": 232
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2267
  }, {
    "from": 2202,
    "label": "calls",
    "to": 846
  }, {
    "from": 924,
    "label": "calls",
    "to": 2012
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1287
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1287
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1287
  }, {
    "from": 1296,
    "label": "calls",
    "to": 1287
  }, {
    "from": 1013,
    "label": "calls",
    "to": 236
  }, {
    "from": 1013,
    "label": "calls",
    "to": 236
  }, {
    "from": 1013,
    "label": "calls",
    "to": 236
  }, {
    "from": 1013,
    "label": "calls",
    "to": 236
  }, {
    "from": 1296,
    "label": "calls",
    "to": 219
  }, {
    "from": 1296,
    "label": "calls",
    "to": 219
  }, {
    "from": 1296,
    "label": "calls",
    "to": 219
  }, {
    "from": 2202,
    "label": "calls",
    "to": 903
  }, {
    "from": 304,
    "label": "calls",
    "to": 2247
  }, {
    "from": 1284,
    "label": "calls",
    "to": 2247
  }, {
    "from": 1296,
    "label": "calls",
    "to": 2247
  }, {
    "from": 1910,
    "label": "calls",
    "to": 2247
  }, {
    "from": 2202,
    "label": "calls",
    "to": 2247
  }, {
    "from": 924,
    "label": "calls",
    "to": 249
  }, {
    "from": 924,
    "label": "calls",
    "to": 249
  }, {
    "from": 924,
    "label": "calls",
    "to": 249
  }, {
    "from": 2148,
    "label": "calls",
    "to": 249
  }, {
    "from": 1013,
    "label": "calls",
    "to": 228
  }, {
    "from": 1296,
    "label": "calls",
    "to": 228
  }, {
    "from": 1296,
    "label": "calls",
    "to": 228
  }, {
    "from": 784,
    "label": "calls",
    "to": 900
  }, {
    "from": 784,
    "label": "calls",
    "to": 900
  }, {
    "from": 967,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1013,
    "label": "calls",
    "to": 900
  }, {
    "from": 1296,
    "label": "calls",
    "to": 900
  }, {
    "from": 1296,
    "label": "calls",
    "to": 900
  }, {
    "from": 1296,
    "label": "calls",
    "to": 900
  }, {
    "from": 1296,
    "label": "calls",
    "to": 900
  }, {
    "from": 1,
    "label": "contains",
    "to": 2235
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2
  }, {
    "from": 2235,
    "label": "declares",
    "to": 13
  }, {
    "from": 2235,
    "label": "declares",
    "to": 24
  }, {
    "from": 2235,
    "label": "declares",
    "to": 26
  }, {
    "from": 2235,
    "label": "declares",
    "to": 33
  }, {
    "from": 2235,
    "label": "declares",
    "to": 47
  }, {
    "from": 2235,
    "label": "declares",
    "to": 54
  }, {
    "from": 2235,
    "label": "declares",
    "to": 62
  }, {
    "from": 2235,
    "label": "declares",
    "to": 64
  }, {
    "from": 2235,
    "label": "declares",
    "to": 68
  }, {
    "from": 2235,
    "label": "declares",
    "to": 71
  }, {
    "from": 2235,
    "label": "declares",
    "to": 147
  }, {
    "from": 2235,
    "label": "declares",
    "to": 167
  }, {
    "from": 2235,
    "label": "declares",
    "to": 177
  }, {
    "from": 2235,
    "label": "declares",
    "to": 188
  }, {
    "from": 2235,
    "label": "declares",
    "to": 193
  }, {
    "from": 2235,
    "label": "declares",
    "to": 198
  }, {
    "from": 2235,
    "label": "declares",
    "to": 205
  }, {
    "from": 2235,
    "label": "declares",
    "to": 214
  }, {
    "from": 2235,
    "label": "declares",
    "to": 219
  }, {
    "from": 2235,
    "label": "declares",
    "to": 224
  }, {
    "from": 2235,
    "label": "declares",
    "to": 228
  }, {
    "from": 2235,
    "label": "declares",
    "to": 232
  }, {
    "from": 2235,
    "label": "declares",
    "to": 236
  }, {
    "from": 2235,
    "label": "declares",
    "to": 238
  }, {
    "from": 2235,
    "label": "declares",
    "to": 243
  }, {
    "from": 2235,
    "label": "declares",
    "to": 249
  }, {
    "from": 2235,
    "label": "declares",
    "to": 262
  }, {
    "from": 2235,
    "label": "declares",
    "to": 283
  }, {
    "from": 2235,
    "label": "declares",
    "to": 285
  }, {
    "from": 2235,
    "label": "declares",
    "to": 288
  }, {
    "from": 2235,
    "label": "declares",
    "to": 298
  }, {
    "from": 2235,
    "label": "declares",
    "to": 304
  }, {
    "from": 2235,
    "label": "declares",
    "to": 311
  }, {
    "from": 2235,
    "label": "declares",
    "to": 781
  }, {
    "from": 2235,
    "label": "declares",
    "to": 784
  }, {
    "from": 2235,
    "label": "declares",
    "to": 846
  }, {
    "from": 2235,
    "label": "declares",
    "to": 885
  }, {
    "from": 2235,
    "label": "declares",
    "to": 889
  }, {
    "from": 2235,
    "label": "declares",
    "to": 893
  }, {
    "from": 2235,
    "label": "declares",
    "to": 900
  }, {
    "from": 2235,
    "label": "declares",
    "to": 903
  }, {
    "from": 2235,
    "label": "declares",
    "to": 924
  }, {
    "from": 2235,
    "label": "declares",
    "to": 954
  }, {
    "from": 2235,
    "label": "declares",
    "to": 957
  }, {
    "from": 2235,
    "label": "declares",
    "to": 960
  }, {
    "from": 2235,
    "label": "declares",
    "to": 963
  }, {
    "from": 2235,
    "label": "declares",
    "to": 967
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1013
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1271
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1277
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1284
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1287
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1296
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1803
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1812
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1840
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1896
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1910
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1976
  }, {
    "from": 2235,
    "label": "declares",
    "to": 1993
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2003
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2012
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2029
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2031
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2082
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2128
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2130
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2132
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2148
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2172
  }, {
    "from": 2235,
    "label": "declares",
    "to": 2202
  }, {
    "from": 1,
    "label": "contains",
    "to": 2268
  }, {
    "from": 1,
    "label": "contains",
    "to": 2269
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2270
  }, {
    "from": 2270,
    "label": "assigns",
    "to": 2271
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2272
  }, {
    "from": 2272,
    "label": "assigns",
    "to": 2273
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2274
  }, {
    "from": 2274,
    "label": "assigns",
    "to": 2275
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2276
  }, {
    "from": 2276,
    "label": "assigns",
    "to": 2277
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2278
  }, {
    "from": 2278,
    "label": "assigns",
    "to": 2279
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2280
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2281
  }, {
    "from": 2281,
    "label": "assigns",
    "to": 2282
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2283
  }, {
    "from": 2283,
    "label": "assigns",
    "to": 2284
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2285
  }, {
    "from": 2285,
    "label": "assigns",
    "to": 2286
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2287
  }, {
    "from": 2287,
    "label": "assigns",
    "to": 2288
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2289
  }, {
    "from": 2289,
    "label": "assigns",
    "to": 2290
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2291
  }, {
    "from": 2291,
    "label": "assigns",
    "to": 2292
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2293
  }, {
    "from": 2293,
    "label": "assigns",
    "to": 2294
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2295
  }, {
    "from": 2295,
    "label": "assigns",
    "to": 2296
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2297
  }, {
    "from": 2297,
    "label": "assigns",
    "to": 2298
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2299
  }, {
    "from": 2299,
    "label": "assigns",
    "to": 2300
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2301
  }, {
    "from": 2301,
    "label": "assigns",
    "to": 2302
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2303
  }, {
    "from": 2303,
    "label": "assigns",
    "to": 2304
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2305
  }, {
    "from": 2305,
    "label": "assigns",
    "to": 2306
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2307
  }, {
    "from": 2307,
    "label": "assigns",
    "to": 2308
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2309
  }, {
    "from": 2309,
    "label": "assigns",
    "to": 2310
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2311
  }, {
    "from": 2311,
    "label": "assigns",
    "to": 2312
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2313
  }, {
    "from": 2313,
    "label": "assigns",
    "to": 2314
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2315
  }, {
    "from": 2315,
    "label": "assigns",
    "to": 2316
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2317
  }, {
    "from": 2317,
    "label": "assigns",
    "to": 2318
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2319
  }, {
    "from": 2319,
    "label": "assigns",
    "to": 2320
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2321
  }, {
    "from": 2321,
    "label": "assigns",
    "to": 2322
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2323
  }, {
    "from": 2323,
    "label": "assigns",
    "to": 2324
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2325
  }, {
    "from": 2325,
    "label": "assigns",
    "to": 2326
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2327
  }, {
    "from": 2327,
    "label": "assigns",
    "to": 2328
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2329
  }, {
    "from": 2329,
    "label": "assigns",
    "to": 2330
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2331
  }, {
    "from": 2331,
    "label": "assigns",
    "to": 2332
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2333
  }, {
    "from": 2333,
    "label": "assigns",
    "to": 2334
  }, {
    "from": 2268,
    "label": "initializes",
    "to": 2335
  }, {
    "from": 2335,
    "label": "assigns",
    "to": 2336
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "genwxbind",
    "type": "module"
  }, {
    "id": 2,
    "text": "function CheckRules()\r\n    assert(type(interface_filepath)         == \"string\", \"Rules file ERROR: 'interface_filepath' is not a string\")\r\n    assert(type(output_cpp_filepath)        == \"string\", \"Rules file ERROR: 'output_cpp_filepath' is not a string\")\r\n    assert(type(output_cpp_header_filepath) == \"string\", \"Rules file ERROR: 'output_cpp_header_filepath' is not a string\")\r\n    assert(type(output_cpp_impexpsymbol)    == \"string\", \"Rules file ERROR: 'output_cpp_impexpsymbol' is not a string\")\r\n    assert(type(output_cpp_impexpdatasymbol) == \"string\", \"Rules file ERROR: 'output_cpp_impexpdatasymbol' is not a string\")\r\n\r\n    assert(type(hook_lua_namespace) == \"string\", \"Rules file ERROR: 'hook_lua_namespace' is not a string\")\r\n    assert(type(hook_cpp_namespace) == \"string\", \"Rules file ERROR: 'hook_cpp_namespace' is not a string\")\r\n\r\n    assert(wxLuaBinding_PreRegister == nil, \"Rules file ERROR: 'wxLuaBinding_PreRegister' is deprecated\")\r\n    assert(wxLuaBinding_PostRegister == nil, \"Rules file ERROR: 'wxLuaBinding_PreRegister' is deprecated\")\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "assert(type(interface_filepath)         == \"string\", \"Rules file ERROR: 'interface_filepath' is not a string\")",
    "type": "statement:functioncall"
  }, {
    "id": 4,
    "text": "assert(type(output_cpp_filepath)        == \"string\", \"Rules file ERROR: 'output_cpp_filepath' is not a string\")",
    "type": "statement:functioncall"
  }, {
    "id": 5,
    "text": "assert(type(output_cpp_header_filepath) == \"string\", \"Rules file ERROR: 'output_cpp_header_filepath' is not a string\")",
    "type": "statement:functioncall"
  }, {
    "id": 6,
    "text": "assert(type(output_cpp_impexpsymbol)    == \"string\", \"Rules file ERROR: 'output_cpp_impexpsymbol' is not a string\")",
    "type": "statement:functioncall"
  }, {
    "id": 7,
    "text": "assert(type(output_cpp_impexpdatasymbol) == \"string\", \"Rules file ERROR: 'output_cpp_impexpdatasymbol' is not a string\")",
    "type": "statement:functioncall"
  }, {
    "id": 8,
    "text": "assert(type(hook_lua_namespace) == \"string\", \"Rules file ERROR: 'hook_lua_namespace' is not a string\")",
    "type": "statement:functioncall"
  }, {
    "id": 9,
    "text": "assert(type(hook_cpp_namespace) == \"string\", \"Rules file ERROR: 'hook_cpp_namespace' is not a string\")",
    "type": "statement:functioncall"
  }, {
    "id": 10,
    "text": "assert(wxLuaBinding_PreRegister == nil, \"Rules file ERROR: 'wxLuaBinding_PreRegister' is deprecated\")",
    "type": "statement:functioncall"
  }, {
    "id": 11,
    "text": "assert(wxLuaBinding_PostRegister == nil, \"Rules file ERROR: 'wxLuaBinding_PreRegister' is deprecated\")",
    "type": "statement:functioncall"
  }, {
    "id": 12,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 13,
    "text": "function pairs_sort(atable, comp_func)\r\n    local a = {}\r\n    for n in pairs(atable) do table.insert(a, n) end\r\n    table.sort(a, comp_func)\r\n    local i = 0                -- iterator variable\r\n    local iter = function ()   -- iterator function\r\n        i = i + 1\r\n        if a[i] == nil then return nil\r\n        else return a[i], atable[a[i]] end\r\n    end\r\n    return iter\r\nend",
    "type": "function"
  }, {
    "id": 14,
    "text": "local a = {}",
    "type": "statement:localassign"
  }, {
    "id": 15,
    "text": "for n in pairs(atable) do table.insert(a, n) end",
    "type": "statement:genericfor"
  }, {
    "id": 16,
    "text": "table.insert(a, n)",
    "type": "statement:functioncall"
  }, {
    "id": 17,
    "text": "table.sort(a, comp_func)",
    "type": "statement:functioncall"
  }, {
    "id": 18,
    "text": "local i = 0",
    "type": "statement:localassign"
  }, {
    "id": 19,
    "text": "local iter = function ()   -- iterator function\r\n        i = i + 1\r\n        if a[i] == nil then return nil\r\n        else return a[i], atable[a[i]] end\r\n    end",
    "type": "statement:localassign"
  }, {
    "id": 20,
    "text": "i = i + 1",
    "type": "statement:assign"
  }, {
    "id": 21,
    "text": "if a[i] == nil then return nil\r\n        else return a[i], atable[a[i]] end",
    "type": "statement:if"
  }, {
    "id": 22,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 23,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 24,
    "text": "function ()   -- iterator function\r\n        i = i + 1\r\n        if a[i] == nil then return nil\r\n        else return a[i], atable[a[i]] end\r\n    end",
    "type": "function"
  }, {
    "id": 25,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 26,
    "text": "function TableSort(atable, comp_func)\r\n    local a = {}\r\n    for k, v in pairs(atable) do table.insert(a, k) end\r\n    table.sort(a, comp_func)\r\n    local b = {}\r\n    for n = 1, #a do table.insert(b, atable[a[n]]) end\r\n    return b\r\nend",
    "type": "function"
  }, {
    "id": 27,
    "text": "for k, v in pairs(atable) do table.insert(a, k) end",
    "type": "statement:genericfor"
  }, {
    "id": 28,
    "text": "table.insert(a, k)",
    "type": "statement:functioncall"
  }, {
    "id": 29,
    "text": "local b = {}",
    "type": "statement:localassign"
  }, {
    "id": 30,
    "text": "for n = 1, #a do table.insert(b, atable[a[n]]) end",
    "type": "statement:numericfor"
  }, {
    "id": 31,
    "text": "table.insert(b, atable[a[n]])",
    "type": "statement:functioncall"
  }, {
    "id": 32,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 33,
    "text": "function TableDump(atable, prefix, tablelevel)\r\n    if prefix == nil then prefix = \"\" end\r\n    if tablelevel == nil then tablelevel = \"\" end\r\n\r\n    print(prefix..\"-Dumping Table \"..tablelevel, atable)\r\n    prefix = prefix..\"  \"\r\n    local n = 0\r\n\r\n    for k, v in pairs_sort(atable) do\r\n        n = n + 1\r\n        print(prefix..n, tablelevel..\"[\"..k..\"]\", v)\r\n        if type(v) == \"table\" then\r\n            TableDump(v, prefix..\"  \", tablelevel..\"[\"..k..\"]\")\r\n        end\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 34,
    "text": "if prefix == nil then prefix = \"\" end",
    "type": "statement:if"
  }, {
    "id": 35,
    "text": "prefix = \"\"",
    "type": "statement:assign"
  }, {
    "id": 36,
    "text": "if tablelevel == nil then tablelevel = \"\" end",
    "type": "statement:if"
  }, {
    "id": 37,
    "text": "tablelevel = \"\"",
    "type": "statement:assign"
  }, {
    "id": 38,
    "text": "print(prefix..\"-Dumping Table \"..tablelevel, atable)",
    "type": "statement:functioncall"
  }, {
    "id": 39,
    "text": "prefix = prefix..\"  \"",
    "type": "statement:assign"
  }, {
    "id": 40,
    "text": "local n = 0",
    "type": "statement:localassign"
  }, {
    "id": 41,
    "text": "for k, v in pairs_sort(atable) do\r\n        n = n + 1\r\n        print(prefix..n, tablelevel..\"[\"..k..\"]\", v)\r\n        if type(v) == \"table\" then\r\n            TableDump(v, prefix..\"  \", tablelevel..\"[\"..k..\"]\")\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 42,
    "text": "n = n + 1",
    "type": "statement:assign"
  }, {
    "id": 43,
    "text": "print(prefix..n, tablelevel..\"[\"..k..\"]\", v)",
    "type": "statement:functioncall"
  }, {
    "id": 44,
    "text": "if type(v) == \"table\" then\r\n            TableDump(v, prefix..\"  \", tablelevel..\"[\"..k..\"]\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 45,
    "text": "TableDump(v, prefix..\"  \", tablelevel..\"[\"..k..\"]\")",
    "type": "statement:functioncall"
  }, {
    "id": 46,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 47,
    "text": "function TableCopy(atable)\r\n    local newtable = {}\r\n    for k, v in pairs(atable) do\r\n        if type(v) == \"table\" then\r\n            newtable[k] = TableCopy(v)\r\n        else\r\n            newtable[k] = v\r\n        end\r\n    end\r\n    return newtable\r\nend",
    "type": "function"
  }, {
    "id": 48,
    "text": "local newtable = {}",
    "type": "statement:localassign"
  }, {
    "id": 49,
    "text": "for k, v in pairs(atable) do\r\n        if type(v) == \"table\" then\r\n            newtable[k] = TableCopy(v)\r\n        else\r\n            newtable[k] = v\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 50,
    "text": "if type(v) == \"table\" then\r\n            newtable[k] = TableCopy(v)\r\n        else\r\n            newtable[k] = v\r\n        end",
    "type": "statement:if"
  }, {
    "id": 51,
    "text": "newtable[k] = TableCopy(v)",
    "type": "statement:assign"
  }, {
    "id": 52,
    "text": "newtable[k] = v",
    "type": "statement:assign"
  }, {
    "id": 53,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 54,
    "text": "function TableAdd(value, atable, ...)\r\n    local t = atable\r\n    for n = 1, #arg-1 do\r\n        if not t[arg[n]] then t[arg[n]] = {} end\r\n        t = t[arg[n]]\r\n    end\r\n    t[arg[#arg]] = value\r\nend",
    "type": "function"
  }, {
    "id": 55,
    "text": "local t = atable",
    "type": "statement:localassign"
  }, {
    "id": 56,
    "text": "for n = 1, #arg-1 do\r\n        if not t[arg[n]] then t[arg[n]] = {} end\r\n        t = t[arg[n]]\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 57,
    "text": "if not t[arg[n]] then t[arg[n]] = {} end",
    "type": "statement:if"
  }, {
    "id": 58,
    "text": "t[arg[n]] = {}",
    "type": "statement:assign"
  }, {
    "id": 59,
    "text": "t = t[arg[n]]",
    "type": "statement:assign"
  }, {
    "id": 60,
    "text": "t[arg[#arg]] = value",
    "type": "statement:assign"
  }, {
    "id": 61,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 62,
    "text": "function iff(cond, A, B) if cond then return A else return B end end",
    "type": "function"
  }, {
    "id": 63,
    "text": "if cond then return A else return B end",
    "type": "statement:if"
  }, {
    "id": 64,
    "text": "function CommentBindingTable(atable, str)\r\n    if comment_cpp_binding_code then\r\n        table.insert(atable, str)\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 65,
    "text": "if comment_cpp_binding_code then\r\n        table.insert(atable, str)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 66,
    "text": "table.insert(atable, str)",
    "type": "statement:functioncall"
  }, {
    "id": 67,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 68,
    "text": "function AllocDataType(name, value_type, is_number, abstract)\r\n    dataTypeTable[name] =\r\n    {\r\n        Name        = name,       -- typename, eg. void, bool, wxInt32\r\n        ValueType   = value_type, -- \"number\", \"enum\", \"class\", \"special\" (special handling)\r\n                                  -- determines how to handle the data type\r\n        BaseClasses = nil,        -- the BaseClass of this, if this is a class\r\n        IsNumber    = is_number,  -- can this data type be stored as a double (Lua's number type)\r\n        Abstract    = abstract,\r\n        Condition   = nil,        -- conditions for this data type, eg. wxLUA_USE_xxx\r\n        [\"%encapsulate\"] = nil,   -- Non wxObject derived class\r\n    }\r\nend",
    "type": "function"
  }, {
    "id": 69,
    "text": "dataTypeTable[name] =\r\n    {\r\n        Name        = name,       -- typename, eg. void, bool, wxInt32\r\n        ValueType   = value_type, -- \"number\", \"enum\", \"class\", \"special\" (special handling)\r\n                                  -- determines how to handle the data type\r\n        BaseClasses = nil,        -- the BaseClass of this, if this is a class\r\n        IsNumber    = is_number,  -- can this data type be stored as a double (Lua's number type)\r\n        Abstract    = abstract,\r\n        Condition   = nil,        -- conditions for this data type, eg. wxLUA_USE_xxx\r\n        [\"%encapsulate\"] = nil,   -- Non wxObject derived class\r\n    }",
    "type": "statement:assign"
  }, {
    "id": 70,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 71,
    "text": "function InitDataTypes()\r\n    -- Standard C data types\r\n    AllocDataType(\"bool\",               \"number\", true)\r\n    AllocDataType(\"BOOL\",               \"number\", true)\r\n    AllocDataType(\"double\",             \"number\", true)\r\n    AllocDataType(\"int\",                \"number\", true)\r\n    AllocDataType(\"char\",               \"number\", true)\r\n    AllocDataType(\"float\",              \"number\", true)\r\n    AllocDataType(\"long\",               \"number\", true)\r\n    AllocDataType(\"short\",              \"number\", true)\r\n    AllocDataType(\"size_t\",             \"number\", true)\r\n    AllocDataType(\"time_t\",             \"number\", true)\r\n    AllocDataType(\"unsigned char\",      \"number\", true)\r\n    AllocDataType(\"unsigned short\",     \"number\", true)\r\n    AllocDataType(\"unsigned int\",       \"number\", true)\r\n    AllocDataType(\"unsigned long\",      \"number\", true)\r\n    AllocDataType(\"uchar\",              \"number\", true)\r\n    AllocDataType(\"ushort\",             \"number\", true)\r\n    AllocDataType(\"uint\",               \"number\", true)\r\n    AllocDataType(\"ulong\",              \"number\", true)\r\n    AllocDataType(\"void\",               \"number\", true)\r\n    AllocDataType(\"wchar_t\",            \"number\", true)\r\n\r\n    -- wxWidgets defined data types\r\n    --AllocDataType(\"wxString\",           \"special\", true) -- treat as wxString\r\n    AllocDataType(\"wxByte\",             \"number\", true)\r\n    AllocDataType(\"wxChar\",             \"number\", true)\r\n    AllocDataType(\"wxWord\",             \"number\", true)\r\n    AllocDataType(\"wxInt8\",             \"number\", true)\r\n    AllocDataType(\"wxUint8\",            \"number\", true)\r\n    AllocDataType(\"wxInt16\",            \"number\", true)\r\n    AllocDataType(\"wxUint16\",           \"number\", true)\r\n    AllocDataType(\"wxInt32\",            \"number\", true)\r\n    AllocDataType(\"wxUint32\",           \"number\", true)\r\n    AllocDataType(\"wxInt64\",            \"number\", true)\r\n    AllocDataType(\"wxUint64\",           \"number\", true)\r\n    AllocDataType(\"wxFloat32\",          \"number\", true)\r\n    AllocDataType(\"wxFloat64\",          \"number\", true)\r\n    AllocDataType(\"wxDouble\",           \"number\", true)\r\n    AllocDataType(\"wxCoord\",            \"number\", true)\r\n    AllocDataType(\"wxTextCoord\",        \"number\", true)\r\n    AllocDataType(\"wxMemorySize\",       \"number\", true)\r\n    AllocDataType(\"WXTYPE\",             \"number\", true)\r\n    AllocDataType(\"wxWindowID\",         \"number\", true)\r\n    AllocDataType(\"wxEventType\",        \"number\", true)\r\n    AllocDataType(\"wxFileOffset\",       \"number\", true)\r\n    --AllocDataType(\"wxStructStat\",       \"number\", true)\r\n\r\n    -- Lua data types\r\n    AllocDataType(\"lua_State\",          \"number\", false)\r\n\r\n    -- win32 data types\r\n    --AllocDataType(\"HANDLE\",             \"number\", false)\r\n    --AllocDataType(\"DWORD64\",            \"number\", true)\r\n    --AllocDataType(\"DWORD\",              \"number\", true)\r\n    --AllocDataType(\"PVOID\",              \"number\", true)\r\n    --AllocDataType(\"LPCVOID\",            \"number\", true)\r\n    --AllocDataType(\"LPVOID\",             \"number\", true)\r\n    --AllocDataType(\"LPDWORD\",            \"number\", true)\r\n\r\n    -- \"fake\" data types that we handle in some more complicated way\r\n    AllocDataType(\"LuaFunction\",           \"special\", true)\r\n    AllocDataType(\"LuaTable\",              \"special\", true)\r\n    AllocDataType(\"wxString\",              \"special\", true)\r\n    --AllocDataType(\"wxArrayString\",         \"special\", true) -- special, but we only convert input, not output\r\n    --AllocDataType(\"wxSortedArrayString\",   \"special\", true) -- special, but we only convert input, not output\r\n    --AllocDataType(\"wxArrayInt\",            \"special\", true) -- special, but we only convert input, not output\r\n    AllocDataType(\"IntArray_FromLuaTable\", \"special\", true)\r\n    AllocDataType(\"voidptr_long\",          \"special\", true)\r\n\r\n    -- attributes that can precede a data type (must set equal to true)\r\n    dataTypeAttribTable[\"unsigned\"] = true\r\n    dataTypeAttribTable[\"const\"]    = true\r\n\r\n    dataTypeAttribTable[\"%gc\"]     = true -- this object will be gc by Lua\r\n    dataTypeAttribTable[\"%ungc\"]   = true -- this object won't be gc by Lua\r\n\r\n    -- datatypes that are unsigned integers to be treated differently\r\n    dataTypeUIntTable[\"size_t\"]         = true\r\n    dataTypeUIntTable[\"time_t\"]         = true\r\n    dataTypeUIntTable[\"unsigned char\"]  = true\r\n    dataTypeUIntTable[\"unsigned short\"] = true\r\n    dataTypeUIntTable[\"unsigned int\"]   = true\r\n    dataTypeUIntTable[\"unsigned long\"]  = true\r\n    dataTypeUIntTable[\"uchar\"]          = true\r\n    dataTypeUIntTable[\"ushort\"]         = true\r\n    dataTypeUIntTable[\"uint\"]           = true\r\n    dataTypeUIntTable[\"ulong\"]          = true\r\n    dataTypeUIntTable[\"void\"]           = true\r\n\r\n    dataTypeUIntTable[\"wxUint8\"]        = true\r\n    dataTypeUIntTable[\"wxUint16\"]       = true\r\n    dataTypeUIntTable[\"wxUint32\"]       = true\r\n    dataTypeUIntTable[\"wxUint64\"]       = true\r\n    dataTypeUIntTable[\"wxMemorySize\"]   = true\r\n    dataTypeUIntTable[\"wxFileOffset\"]   = true\r\n\r\n    -- datatypes that are boolean integers to be treated differently\r\n    dataTypeBoolTable[\"bool\"] = true\r\n    dataTypeBoolTable[\"BOOL\"] = true\r\n\r\n    -- attributes that can precede a function (must set equal to true)\r\n    functionAttribTable[\"static\"]  = true\r\n    functionAttribTable[\"virtual\"] = true\r\n    functionAttribTable[\"inline\"]  = true\r\n    functionAttribTable[\"friend\"]  = true\r\nend",
    "type": "function"
  }, {
    "id": 72,
    "text": "AllocDataType(\"bool\",               \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 73,
    "text": "AllocDataType(\"BOOL\",               \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 74,
    "text": "AllocDataType(\"double\",             \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 75,
    "text": "AllocDataType(\"int\",                \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 76,
    "text": "AllocDataType(\"char\",               \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 77,
    "text": "AllocDataType(\"float\",              \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 78,
    "text": "AllocDataType(\"long\",               \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 79,
    "text": "AllocDataType(\"short\",              \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 80,
    "text": "AllocDataType(\"size_t\",             \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 81,
    "text": "AllocDataType(\"time_t\",             \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 82,
    "text": "AllocDataType(\"unsigned char\",      \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 83,
    "text": "AllocDataType(\"unsigned short\",     \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 84,
    "text": "AllocDataType(\"unsigned int\",       \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 85,
    "text": "AllocDataType(\"unsigned long\",      \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 86,
    "text": "AllocDataType(\"uchar\",              \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 87,
    "text": "AllocDataType(\"ushort\",             \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 88,
    "text": "AllocDataType(\"uint\",               \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 89,
    "text": "AllocDataType(\"ulong\",              \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 90,
    "text": "AllocDataType(\"void\",               \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 91,
    "text": "AllocDataType(\"wchar_t\",            \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 92,
    "text": "AllocDataType(\"wxByte\",             \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 93,
    "text": "AllocDataType(\"wxChar\",             \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 94,
    "text": "AllocDataType(\"wxWord\",             \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 95,
    "text": "AllocDataType(\"wxInt8\",             \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 96,
    "text": "AllocDataType(\"wxUint8\",            \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 97,
    "text": "AllocDataType(\"wxInt16\",            \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 98,
    "text": "AllocDataType(\"wxUint16\",           \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 99,
    "text": "AllocDataType(\"wxInt32\",            \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 100,
    "text": "AllocDataType(\"wxUint32\",           \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 101,
    "text": "AllocDataType(\"wxInt64\",            \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 102,
    "text": "AllocDataType(\"wxUint64\",           \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 103,
    "text": "AllocDataType(\"wxFloat32\",          \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 104,
    "text": "AllocDataType(\"wxFloat64\",          \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 105,
    "text": "AllocDataType(\"wxDouble\",           \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 106,
    "text": "AllocDataType(\"wxCoord\",            \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 107,
    "text": "AllocDataType(\"wxTextCoord\",        \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 108,
    "text": "AllocDataType(\"wxMemorySize\",       \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 109,
    "text": "AllocDataType(\"WXTYPE\",             \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 110,
    "text": "AllocDataType(\"wxWindowID\",         \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 111,
    "text": "AllocDataType(\"wxEventType\",        \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 112,
    "text": "AllocDataType(\"wxFileOffset\",       \"number\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 113,
    "text": "AllocDataType(\"lua_State\",          \"number\", false)",
    "type": "statement:functioncall"
  }, {
    "id": 114,
    "text": "AllocDataType(\"LuaFunction\",           \"special\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 115,
    "text": "AllocDataType(\"LuaTable\",              \"special\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 116,
    "text": "AllocDataType(\"wxString\",              \"special\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 117,
    "text": "AllocDataType(\"IntArray_FromLuaTable\", \"special\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 118,
    "text": "AllocDataType(\"voidptr_long\",          \"special\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 119,
    "text": "dataTypeAttribTable[\"unsigned\"] = true",
    "type": "statement:assign"
  }, {
    "id": 120,
    "text": "dataTypeAttribTable[\"const\"]    = true",
    "type": "statement:assign"
  }, {
    "id": 121,
    "text": "dataTypeAttribTable[\"%gc\"]     = true",
    "type": "statement:assign"
  }, {
    "id": 122,
    "text": "dataTypeAttribTable[\"%ungc\"]   = true",
    "type": "statement:assign"
  }, {
    "id": 123,
    "text": "dataTypeUIntTable[\"size_t\"]         = true",
    "type": "statement:assign"
  }, {
    "id": 124,
    "text": "dataTypeUIntTable[\"time_t\"]         = true",
    "type": "statement:assign"
  }, {
    "id": 125,
    "text": "dataTypeUIntTable[\"unsigned char\"]  = true",
    "type": "statement:assign"
  }, {
    "id": 126,
    "text": "dataTypeUIntTable[\"unsigned short\"] = true",
    "type": "statement:assign"
  }, {
    "id": 127,
    "text": "dataTypeUIntTable[\"unsigned int\"]   = true",
    "type": "statement:assign"
  }, {
    "id": 128,
    "text": "dataTypeUIntTable[\"unsigned long\"]  = true",
    "type": "statement:assign"
  }, {
    "id": 129,
    "text": "dataTypeUIntTable[\"uchar\"]          = true",
    "type": "statement:assign"
  }, {
    "id": 130,
    "text": "dataTypeUIntTable[\"ushort\"]         = true",
    "type": "statement:assign"
  }, {
    "id": 131,
    "text": "dataTypeUIntTable[\"uint\"]           = true",
    "type": "statement:assign"
  }, {
    "id": 132,
    "text": "dataTypeUIntTable[\"ulong\"]          = true",
    "type": "statement:assign"
  }, {
    "id": 133,
    "text": "dataTypeUIntTable[\"void\"]           = true",
    "type": "statement:assign"
  }, {
    "id": 134,
    "text": "dataTypeUIntTable[\"wxUint8\"]        = true",
    "type": "statement:assign"
  }, {
    "id": 135,
    "text": "dataTypeUIntTable[\"wxUint16\"]       = true",
    "type": "statement:assign"
  }, {
    "id": 136,
    "text": "dataTypeUIntTable[\"wxUint32\"]       = true",
    "type": "statement:assign"
  }, {
    "id": 137,
    "text": "dataTypeUIntTable[\"wxUint64\"]       = true",
    "type": "statement:assign"
  }, {
    "id": 138,
    "text": "dataTypeUIntTable[\"wxMemorySize\"]   = true",
    "type": "statement:assign"
  }, {
    "id": 139,
    "text": "dataTypeUIntTable[\"wxFileOffset\"]   = true",
    "type": "statement:assign"
  }, {
    "id": 140,
    "text": "dataTypeBoolTable[\"bool\"] = true",
    "type": "statement:assign"
  }, {
    "id": 141,
    "text": "dataTypeBoolTable[\"BOOL\"] = true",
    "type": "statement:assign"
  }, {
    "id": 142,
    "text": "functionAttribTable[\"static\"]  = true",
    "type": "statement:assign"
  }, {
    "id": 143,
    "text": "functionAttribTable[\"virtual\"] = true",
    "type": "statement:assign"
  }, {
    "id": 144,
    "text": "functionAttribTable[\"inline\"]  = true",
    "type": "statement:assign"
  }, {
    "id": 145,
    "text": "functionAttribTable[\"friend\"]  = true",
    "type": "statement:assign"
  }, {
    "id": 146,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 147,
    "text": "function DecodeDecl(decl)\r\n    local attribs = {}\r\n    local data_type = nil\r\n    local ptrs = {}\r\n    local cast = 0\r\n\r\n    local typeData = SplitString(decl, { \"[]\", \" \", \"&\", \"*\", \"(\", \")\" }, { \"[]\", \"&\", \"*\", \"(\", \")\" })\r\n\r\n    for i = 1, #typeData do\r\n        if cast < 0 then\r\n            print(\"ERROR: Mismatched () in casting data type: '\"..decl..\"'\")\r\n        end\r\n\r\n        local type_n = typeData[i]\r\n\r\n        if type_n == \"(\" then\r\n            cast = cast + 1\r\n        elseif type_n == \")\" then\r\n            cast = cast - 1\r\n        elseif cast == 0 then\r\n            if dataTypeAttribTable[type_n] then\r\n                table.insert(attribs, type_n)\r\n            elseif (type_n == \"[]\") or (type_n == \"*\") or (type_n == \"&\") then\r\n                table.insert(ptrs, type_n)\r\n            elseif dataTypeTable[type_n] then\r\n                data_type = type_n\r\n            elseif typedefTable[type_n] then\r\n                data_type = type_n\r\n            end\r\n        end\r\n    end\r\n\r\n    if not data_type then\r\n        print(\"ERROR: Cannot find data type: '\"..decl..\"'\")\r\n    end\r\n\r\n    return attribs, data_type, ptrs\r\nend",
    "type": "function"
  }, {
    "id": 148,
    "text": "local attribs = {}",
    "type": "statement:localassign"
  }, {
    "id": 149,
    "text": "local data_type = nil",
    "type": "statement:localassign"
  }, {
    "id": 150,
    "text": "local ptrs = {}",
    "type": "statement:localassign"
  }, {
    "id": 151,
    "text": "local cast = 0",
    "type": "statement:localassign"
  }, {
    "id": 152,
    "text": "local typeData = SplitString(decl, { \"[]\", \" \", \"&\", \"*\", \"(\", \")\" }, { \"[]\", \"&\", \"*\", \"(\", \")\" })",
    "type": "statement:localassign"
  }, {
    "id": 153,
    "text": "for i = 1, #typeData do\r\n        if cast < 0 then\r\n            print(\"ERROR: Mismatched () in casting data type: '\"..decl..\"'\")\r\n        end\r\n\r\n        local type_n = typeData[i]\r\n\r\n        if type_n == \"(\" then\r\n            cast = cast + 1\r\n        elseif type_n == \")\" then\r\n            cast = cast - 1\r\n        elseif cast == 0 then\r\n            if dataTypeAttribTable[type_n] then\r\n                table.insert(attribs, type_n)\r\n            elseif (type_n == \"[]\") or (type_n == \"*\") or (type_n == \"&\") then\r\n                table.insert(ptrs, type_n)\r\n            elseif dataTypeTable[type_n] then\r\n                data_type = type_n\r\n            elseif typedefTable[type_n] then\r\n                data_type = type_n\r\n            end\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 154,
    "text": "if cast < 0 then\r\n            print(\"ERROR: Mismatched () in casting data type: '\"..decl..\"'\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 155,
    "text": "print(\"ERROR: Mismatched () in casting data type: '\"..decl..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 156,
    "text": "local type_n = typeData[i]",
    "type": "statement:localassign"
  }, {
    "id": 157,
    "text": "if type_n == \"(\" then\r\n            cast = cast + 1\r\n        elseif type_n == \")\" then\r\n            cast = cast - 1\r\n        elseif cast == 0 then\r\n            if dataTypeAttribTable[type_n] then\r\n                table.insert(attribs, type_n)\r\n            elseif (type_n == \"[]\") or (type_n == \"*\") or (type_n == \"&\") then\r\n                table.insert(ptrs, type_n)\r\n            elseif dataTypeTable[type_n] then\r\n                data_type = type_n\r\n            elseif typedefTable[type_n] then\r\n                data_type = type_n\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 158,
    "text": "cast = cast + 1",
    "type": "statement:assign"
  }, {
    "id": 159,
    "text": "cast = cast - 1",
    "type": "statement:assign"
  }, {
    "id": 160,
    "text": "if dataTypeAttribTable[type_n] then\r\n                table.insert(attribs, type_n)\r\n            elseif (type_n == \"[]\") or (type_n == \"*\") or (type_n == \"&\") then\r\n                table.insert(ptrs, type_n)\r\n            elseif dataTypeTable[type_n] then\r\n                data_type = type_n\r\n            elseif typedefTable[type_n] then\r\n                data_type = type_n\r\n            end",
    "type": "statement:if"
  }, {
    "id": 161,
    "text": "table.insert(attribs, type_n)",
    "type": "statement:functioncall"
  }, {
    "id": 162,
    "text": "table.insert(ptrs, type_n)",
    "type": "statement:functioncall"
  }, {
    "id": 163,
    "text": "data_type = type_n",
    "type": "statement:assign"
  }, {
    "id": 164,
    "text": "if not data_type then\r\n        print(\"ERROR: Cannot find data type: '\"..decl..\"'\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 165,
    "text": "print(\"ERROR: Cannot find data type: '\"..decl..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 166,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 167,
    "text": "function DecodeDataType(decl)\r\n    local attribs, data_type, ptrs = DecodeDecl(decl)\r\n\r\n    -- merge typeDef declaration\r\n    if typedefTable[data_type] then\r\n        -- build new datatype using typeDef\r\n        local datatype = nil\r\n        if #attribs > 0 then\r\n            datatype = table.concat(attribs, \" \")\r\n        end\r\n\r\n        datatype = SpaceSeparateStrings(datatype, typedefTable[data_type])\r\n        datatype = datatype..table.concat(ptrs)\r\n\r\n        attribs, data_type, ptrs = DecodeDataType(datatype)\r\n    end\r\n\r\n    return attribs, data_type, ptrs\r\nend",
    "type": "function"
  }, {
    "id": 168,
    "text": "local attribs, data_type, ptrs = DecodeDecl(decl)",
    "type": "statement:localassign"
  }, {
    "id": 169,
    "text": "if typedefTable[data_type] then\r\n        -- build new datatype using typeDef\r\n        local datatype = nil\r\n        if #attribs > 0 then\r\n            datatype = table.concat(attribs, \" \")\r\n        end\r\n\r\n        datatype = SpaceSeparateStrings(datatype, typedefTable[data_type])\r\n        datatype = datatype..table.concat(ptrs)\r\n\r\n        attribs, data_type, ptrs = DecodeDataType(datatype)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 170,
    "text": "local datatype = nil",
    "type": "statement:localassign"
  }, {
    "id": 171,
    "text": "if #attribs > 0 then\r\n            datatype = table.concat(attribs, \" \")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 172,
    "text": "datatype = table.concat(attribs, \" \")",
    "type": "statement:assign"
  }, {
    "id": 173,
    "text": "datatype = SpaceSeparateStrings(datatype, typedefTable[data_type])",
    "type": "statement:assign"
  }, {
    "id": 174,
    "text": "datatype = datatype..table.concat(ptrs)",
    "type": "statement:assign"
  }, {
    "id": 175,
    "text": "attribs, data_type, ptrs = DecodeDataType(datatype)",
    "type": "statement:assign"
  }, {
    "id": 176,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 177,
    "text": "function TranslateDataType(param)\r\n    -- build datatype\r\n    local datatype = param.DataTypeWithAttrib..\" \"..table.concat(param.DataTypePointer)\r\n\r\n    local attribs, data_type, ptrs = DecodeDataType(datatype)\r\n\r\n    -- build new datatype\r\n    local tlstype = nil\r\n    if #attribs > 0 then\r\n        tlstype = table.concat(attribs, \" \")\r\n    end\r\n\r\n    tlstype = SpaceSeparateStrings(tlstype, data_type)\r\n\r\n    param.TypedDataType           = data_type\r\n    param.TypedDataTypeWithAttrib = tlstype\r\n    param.TypedDataTypePointer    = ptrs\r\nend",
    "type": "function"
  }, {
    "id": 178,
    "text": "local datatype = param.DataTypeWithAttrib..\" \"..table.concat(param.DataTypePointer)",
    "type": "statement:localassign"
  }, {
    "id": 179,
    "text": "local attribs, data_type, ptrs = DecodeDataType(datatype)",
    "type": "statement:localassign"
  }, {
    "id": 180,
    "text": "local tlstype = nil",
    "type": "statement:localassign"
  }, {
    "id": 181,
    "text": "if #attribs > 0 then\r\n        tlstype = table.concat(attribs, \" \")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 182,
    "text": "tlstype = table.concat(attribs, \" \")",
    "type": "statement:assign"
  }, {
    "id": 183,
    "text": "tlstype = SpaceSeparateStrings(tlstype, data_type)",
    "type": "statement:assign"
  }, {
    "id": 184,
    "text": "param.TypedDataType           = data_type",
    "type": "statement:assign"
  }, {
    "id": 185,
    "text": "param.TypedDataTypeWithAttrib = tlstype",
    "type": "statement:assign"
  }, {
    "id": 186,
    "text": "param.TypedDataTypePointer    = ptrs",
    "type": "statement:assign"
  }, {
    "id": 187,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 188,
    "text": "function IsDataType(datatype)\r\n    if dataTypeTable[datatype] then\r\n        return true\r\n    elseif typedefTable[datatype] then\r\n        if not dataTypeTable[typedefTable[datatype]] then\r\n            print(\"ERROR: Supposed datatype: '\"..tostring(datatype)..\"' has typedef = '\"..typedefTable[datatype]..\"' which is not a data type either\")\r\n        end\r\n\r\n        return true\r\n    end\r\n\r\n    return false\r\nend",
    "type": "function"
  }, {
    "id": 189,
    "text": "if dataTypeTable[datatype] then\r\n        return true\r\n    elseif typedefTable[datatype] then\r\n        if not dataTypeTable[typedefTable[datatype]] then\r\n            print(\"ERROR: Supposed datatype: '\"..tostring(datatype)..\"' has typedef = '\"..typedefTable[datatype]..\"' which is not a data type either\")\r\n        end\r\n\r\n        return true\r\n    end",
    "type": "statement:if"
  }, {
    "id": 190,
    "text": "if not dataTypeTable[typedefTable[datatype]] then\r\n            print(\"ERROR: Supposed datatype: '\"..tostring(datatype)..\"' has typedef = '\"..typedefTable[datatype]..\"' which is not a data type either\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 191,
    "text": "print(\"ERROR: Supposed datatype: '\"..tostring(datatype)..\"' has typedef = '\"..typedefTable[datatype]..\"' which is not a data type either\")",
    "type": "statement:functioncall"
  }, {
    "id": 192,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 193,
    "text": "function GetDataTypeOnly(typedefinition)\r\n    local typeData = SplitString(typedefinition, { \" \", \"&\", \"*\" })\r\n\r\n    for i = 1, #typeData do\r\n        if dataTypeTable[typeData[i]] then\r\n            return typeData[i]\r\n        end\r\n    end\r\n\r\n    return nil\r\nend",
    "type": "function"
  }, {
    "id": 194,
    "text": "local typeData = SplitString(typedefinition, { \" \", \"&\", \"*\" })",
    "type": "statement:localassign"
  }, {
    "id": 195,
    "text": "for i = 1, #typeData do\r\n        if dataTypeTable[typeData[i]] then\r\n            return typeData[i]\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 196,
    "text": "if dataTypeTable[typeData[i]] then\r\n            return typeData[i]\r\n        end",
    "type": "statement:if"
  }, {
    "id": 197,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 198,
    "text": "function GetDataTypedefBase(datatype)\r\n    if dataTypeTable[datatype] then\r\n        return dataTypeTable[datatype]\r\n    end\r\n\r\n    -- try for underlying TypeDef DataType\r\n    if  typedefTable[datatype] then\r\n        local base_type = GetDataTypeOnly(typedefTable[datatype])\r\n        if base_type and dataTypeTable[base_type] then\r\n            return dataTypeTable[base_type]\r\n        end\r\n    end\r\n\r\n    print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in GetDataTypedefBase.\")\r\n\r\n    return nil\r\nend",
    "type": "function"
  }, {
    "id": 199,
    "text": "if dataTypeTable[datatype] then\r\n        return dataTypeTable[datatype]\r\n    end",
    "type": "statement:if"
  }, {
    "id": 200,
    "text": "if  typedefTable[datatype] then\r\n        local base_type = GetDataTypeOnly(typedefTable[datatype])\r\n        if base_type and dataTypeTable[base_type] then\r\n            return dataTypeTable[base_type]\r\n        end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 201,
    "text": "local base_type = GetDataTypeOnly(typedefTable[datatype])",
    "type": "statement:localassign"
  }, {
    "id": 202,
    "text": "if base_type and dataTypeTable[base_type] then\r\n            return dataTypeTable[base_type]\r\n        end",
    "type": "statement:if"
  }, {
    "id": 203,
    "text": "print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in GetDataTypedefBase.\")",
    "type": "statement:functioncall"
  }, {
    "id": 204,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 205,
    "text": "function IsDerivedClass(classname, base_classname)\r\n\r\n    if dataTypeTable[classname] == nil then\r\n        print(\"ERROR: dataTypeTable for classname is nil in IsDerivedClass()\", classname, base_classname)\r\n        return false\r\n    end\r\n\r\n    if classname == base_classname then\r\n        return true\r\n    end\r\n\r\n    if dataTypeTable[classname].BaseClasses then\r\n        for _, c in ipairs(dataTypeTable[classname].BaseClasses) do\r\n            local c_name = dataTypeTable[c].Name\r\n            if IsDerivedClass(c_name, base_classname) then\r\n                return true\r\n            end\r\n        end\r\n    end\r\n\r\n    return false\r\nend",
    "type": "function"
  }, {
    "id": 206,
    "text": "if dataTypeTable[classname] == nil then\r\n        print(\"ERROR: dataTypeTable for classname is nil in IsDerivedClass()\", classname, base_classname)\r\n        return false\r\n    end",
    "type": "statement:if"
  }, {
    "id": 207,
    "text": "print(\"ERROR: dataTypeTable for classname is nil in IsDerivedClass()\", classname, base_classname)",
    "type": "statement:functioncall"
  }, {
    "id": 208,
    "text": "if classname == base_classname then\r\n        return true\r\n    end",
    "type": "statement:if"
  }, {
    "id": 209,
    "text": "if dataTypeTable[classname].BaseClasses then\r\n        for _, c in ipairs(dataTypeTable[classname].BaseClasses) do\r\n            local c_name = dataTypeTable[c].Name\r\n            if IsDerivedClass(c_name, base_classname) then\r\n                return true\r\n            end\r\n        end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 210,
    "text": "for _, c in ipairs(dataTypeTable[classname].BaseClasses) do\r\n            local c_name = dataTypeTable[c].Name\r\n            if IsDerivedClass(c_name, base_classname) then\r\n                return true\r\n            end\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 211,
    "text": "local c_name = dataTypeTable[c].Name",
    "type": "statement:localassign"
  }, {
    "id": 212,
    "text": "if IsDerivedClass(c_name, base_classname) then\r\n                return true\r\n            end",
    "type": "statement:if"
  }, {
    "id": 213,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 214,
    "text": "function GetDataTypeCondition(datatype)\r\n    local dtype = GetDataTypedefBase(datatype)\r\n    if dtype then\r\n        return dtype.Condition\r\n    else\r\n        print(\"ERROR: Missing data type '\"..datatype..\"' in GetDataTypeCondition.\")\r\n    end\r\n\r\n    return nil\r\nend",
    "type": "function"
  }, {
    "id": 215,
    "text": "local dtype = GetDataTypedefBase(datatype)",
    "type": "statement:localassign"
  }, {
    "id": 216,
    "text": "if dtype then\r\n        return dtype.Condition\r\n    else\r\n        print(\"ERROR: Missing data type '\"..datatype..\"' in GetDataTypeCondition.\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 217,
    "text": "print(\"ERROR: Missing data type '\"..datatype..\"' in GetDataTypeCondition.\")",
    "type": "statement:functioncall"
  }, {
    "id": 218,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 219,
    "text": "function IsDataTypeNumeric(datatype)\r\n    local dtype = GetDataTypedefBase(string.gsub(datatype, \"const \", \"\"))\r\n    if dtype then\r\n        return dtype.IsNumber\r\n    else\r\n        print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeNumeric.\")\r\n    end\r\n\r\n    return false\r\nend",
    "type": "function"
  }, {
    "id": 220,
    "text": "local dtype = GetDataTypedefBase(string.gsub(datatype, \"const \", \"\"))",
    "type": "statement:localassign"
  }, {
    "id": 221,
    "text": "if dtype then\r\n        return dtype.IsNumber\r\n    else\r\n        print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeNumeric.\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 222,
    "text": "print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeNumeric.\")",
    "type": "statement:functioncall"
  }, {
    "id": 223,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 224,
    "text": "function IsDataTypeUInt(datatype)\r\n    local dtype = GetDataTypedefBase(string.gsub(datatype, \"const \", \"\"))\r\n    if dtype then\r\n        return dataTypeUIntTable[dtype.Name] or false\r\n    else\r\n        print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeUInt.\")\r\n    end\r\n\r\n    return false\r\nend",
    "type": "function"
  }, {
    "id": 225,
    "text": "if dtype then\r\n        return dataTypeUIntTable[dtype.Name] or false\r\n    else\r\n        print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeUInt.\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 226,
    "text": "print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeUInt.\")",
    "type": "statement:functioncall"
  }, {
    "id": 227,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 228,
    "text": "function IsDataTypeEnum(datatype)\r\n    local dtype = GetDataTypedefBase(string.gsub(datatype, \"const \", \"\"))\r\n    if dtype then\r\n        return (dtype.ValueType == \"enum\")\r\n    else\r\n        print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeEnum.\")\r\n    end\r\n\r\n    return false\r\nend",
    "type": "function"
  }, {
    "id": 229,
    "text": "if dtype then\r\n        return (dtype.ValueType == \"enum\")\r\n    else\r\n        print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeEnum.\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 230,
    "text": "print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeEnum.\")",
    "type": "statement:functioncall"
  }, {
    "id": 231,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 232,
    "text": "function IsDataTypeBool(datatype)\r\n    local dtype = GetDataTypedefBase(string.gsub(datatype, \"const \", \"\"))\r\n    if dtype then\r\n        return dataTypeBoolTable[dtype.Name] or false\r\n    else\r\n        print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeBool.\")\r\n    end\r\n\r\n    return false\r\nend",
    "type": "function"
  }, {
    "id": 233,
    "text": "if dtype then\r\n        return dataTypeBoolTable[dtype.Name] or false\r\n    else\r\n        print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeBool.\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 234,
    "text": "print(\"ERROR: Missing data type '\"..tostring(datatype)..\"' in IsDataTypeBool.\")",
    "type": "statement:functioncall"
  }, {
    "id": 235,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 236,
    "text": "function IsDelimiter(delim)\r\n    return bindingDelimiters_hash[delim] or false\r\nend",
    "type": "function"
  }, {
    "id": 237,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 238,
    "text": "function FileExists(path)\r\n    local file_handle = io.open(path, \"rb\")\r\n    if not file_handle then\r\n        return false\r\n    end\r\n\r\n    io.close(file_handle)\r\n    return true\r\nend",
    "type": "function"
  }, {
    "id": 239,
    "text": "local file_handle = io.open(path, \"rb\")",
    "type": "statement:localassign"
  }, {
    "id": 240,
    "text": "if not file_handle then\r\n        return false\r\n    end",
    "type": "statement:if"
  }, {
    "id": 241,
    "text": "io.close(file_handle)",
    "type": "statement:functioncall"
  }, {
    "id": 242,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 243,
    "text": "function FileDataIsStringData(filename, strData)\r\n    local file_handle = io.open(filename, \"rb\")\r\n    if not file_handle then return false end -- ok if it doesn't exist\r\n\r\n    local f = file_handle:read(\"*a\")\r\n    local is_same = (f == strData)\r\n    io.close(file_handle)\r\n    return is_same\r\nend",
    "type": "function"
  }, {
    "id": 244,
    "text": "local file_handle = io.open(filename, \"rb\")",
    "type": "statement:localassign"
  }, {
    "id": 245,
    "text": "if not file_handle then return false end",
    "type": "statement:if"
  }, {
    "id": 246,
    "text": "local f = file_handle:read(\"*a\")",
    "type": "statement:localassign"
  }, {
    "id": 247,
    "text": "local is_same = (f == strData)",
    "type": "statement:localassign"
  }, {
    "id": 248,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 249,
    "text": "function WriteTableToFile(filename, fileData, overwrite_always)\r\n    assert(filename and fileData, \"Invalid filename or fileData in WriteTableToFile\")\r\n\r\n    local strData = table.concat(fileData)\r\n\r\n    if (not overwrite_always) and FileDataIsStringData(filename, strData) then\r\n        print(\"No changes to file : '\"..filename..\"'\")\r\n        return false\r\n    end\r\n\r\n    print(\"Updating file      : '\"..filename..\"'\")\r\n\r\n    local outfile = io.open(filename, \"w+\")\r\n    if not outfile then\r\n        print(\"Unable to open file for writing '\"..filename..\"'.\")\r\n        return\r\n    end\r\n\r\n    outfile:write(strData)\r\n\r\n    outfile:flush()\r\n    outfile:close()\r\n    return true\r\nend",
    "type": "function"
  }, {
    "id": 250,
    "text": "assert(filename and fileData, \"Invalid filename or fileData in WriteTableToFile\")",
    "type": "statement:functioncall"
  }, {
    "id": 251,
    "text": "local strData = table.concat(fileData)",
    "type": "statement:localassign"
  }, {
    "id": 252,
    "text": "if (not overwrite_always) and FileDataIsStringData(filename, strData) then\r\n        print(\"No changes to file : '\"..filename..\"'\")\r\n        return false\r\n    end",
    "type": "statement:if"
  }, {
    "id": 253,
    "text": "print(\"No changes to file : '\"..filename..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 254,
    "text": "print(\"Updating file      : '\"..filename..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 255,
    "text": "local outfile = io.open(filename, \"w+\")",
    "type": "statement:localassign"
  }, {
    "id": 256,
    "text": "if not outfile then\r\n        print(\"Unable to open file for writing '\"..filename..\"'.\")\r\n        return\r\n    end",
    "type": "statement:if"
  }, {
    "id": 257,
    "text": "print(\"Unable to open file for writing '\"..filename..\"'.\")",
    "type": "statement:functioncall"
  }, {
    "id": 258,
    "text": "outfile:write(strData)",
    "type": "statement:functioncall"
  }, {
    "id": 259,
    "text": "outfile:flush()",
    "type": "statement:functioncall"
  }, {
    "id": 260,
    "text": "outfile:close()",
    "type": "statement:functioncall"
  }, {
    "id": 261,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 262,
    "text": "function FindOrCreateCondition(condition)\r\n    local result = nil\r\n\r\n    if preprocConditionTable[condition] then\r\n        result = preprocConditionTable[condition]\r\n\r\n    elseif string.find(condition, \"%wxchkver_\", 1, 1) then\r\n        -- check for conditions like %wxchkver_1_2_3 = wxCHECK_VERSION(1,2,3)\r\n        local ver = { 0, 0, 0 }\r\n        local n = 1\r\n        for v in string.gmatch(condition, \"%d+\") do\r\n            ver[n] = tonumber(v);\r\n            n = n + 1\r\n        end\r\n        assert(#ver == 3, \"%wxchkver_x_y_z conditions has too many version numbers. '\"..condition..\"'\")\r\n        result = string.format(\"wxCHECK_VERSION(%d,%d,%d)\", ver[1], ver[2], ver[3])\r\n        preprocConditionTable[condition] = result -- cache result\r\n    elseif string.find(condition, \"wxchkver_\", 1, 1) then\r\n        print(\"WARNING: found wxchkver_XXX, did you forget the leading '%'? '\"..condition..\"'\")\r\n\r\n    elseif string.find(condition, \"%wxcompat_\", 1, 1) then\r\n        -- check for conditions like %wxcompat_1_2 = WXWIN_COMPATIBILITY_1_2\r\n        -- just copy everything after wxcompat_\r\n        local p1, p2 = string.find(condition, \"%wxcompat_\", 1, 1)\r\n        result = \"WXWIN_COMPATIBILITY\"..string.sub(condition, p2)\r\n        result = \"(defined(\"..result..\") && \"..result..\")\"\r\n        preprocConditionTable[condition] = result -- cache result\r\n    elseif string.find(condition, \"wxcompat_\", 1, 1) then\r\n        print(\"WARNING: found wxcompat_XXX, did you forget the leading '%'? '\"..condition..\"'\")\r\n\r\n    elseif string.find(condition, \"wxLUA_USE_\", 1, 1) then\r\n        print(\"WARNING: unknown wxLUA_USE_XXX condition? '\"..condition..\"'\")\r\n    elseif string.find(condition, \"wxUSE_\", 1, 1) then\r\n        print(\"WARNING: unknown wxUSE_XXX condition? '\"..condition..\"'\")\r\n\r\n    elseif string.find(condition, \"%wxchkver2\", 1, 1) then\r\n        assert(false, \"ERROR: %wxchkverXYZ has been replaced by %wxchkver_X_Y_Z, please update your bindings.\")\r\n    elseif string.find(condition, \"%wxcompat2\", 1, 1) then\r\n        assert(false, \"ERROR: %wxcompatXY has been replaced by %wxcompat_X_Y, please update your bindings.\")\r\n    end\r\n\r\n    return result\r\nend",
    "type": "function"
  }, {
    "id": 263,
    "text": "local result = nil",
    "type": "statement:localassign"
  }, {
    "id": 264,
    "text": "if preprocConditionTable[condition] then\r\n        result = preprocConditionTable[condition]\r\n\r\n    elseif string.find(condition, \"%wxchkver_\", 1, 1) then\r\n        -- check for conditions like %wxchkver_1_2_3 = wxCHECK_VERSION(1,2,3)\r\n        local ver = { 0, 0, 0 }\r\n        local n = 1\r\n        for v in string.gmatch(condition, \"%d+\") do\r\n            ver[n] = tonumber(v);\r\n            n = n + 1\r\n        end\r\n        assert(#ver == 3, \"%wxchkver_x_y_z conditions has too many version numbers. '\"..condition..\"'\")\r\n        result = string.format(\"wxCHECK_VERSION(%d,%d,%d)\", ver[1], ver[2], ver[3])\r\n        preprocConditionTable[condition] = result -- cache result\r\n    elseif string.find(condition, \"wxchkver_\", 1, 1) then\r\n        print(\"WARNING: found wxchkver_XXX, did you forget the leading '%'? '\"..condition..\"'\")\r\n\r\n    elseif string.find(condition, \"%wxcompat_\", 1, 1) then\r\n        -- check for conditions like %wxcompat_1_2 = WXWIN_COMPATIBILITY_1_2\r\n        -- just copy everything after wxcompat_\r\n        local p1, p2 = string.find(condition, \"%wxcompat_\", 1, 1)\r\n        result = \"WXWIN_COMPATIBILITY\"..string.sub(condition, p2)\r\n        result = \"(defined(\"..result..\") && \"..result..\")\"\r\n        preprocConditionTable[condition] = result -- cache result\r\n    elseif string.find(condition, \"wxcompat_\", 1, 1) then\r\n        print(\"WARNING: found wxcompat_XXX, did you forget the leading '%'? '\"..condition..\"'\")\r\n\r\n    elseif string.find(condition, \"wxLUA_USE_\", 1, 1) then\r\n        print(\"WARNING: unknown wxLUA_USE_XXX condition? '\"..condition..\"'\")\r\n    elseif string.find(condition, \"wxUSE_\", 1, 1) then\r\n        print(\"WARNING: unknown wxUSE_XXX condition? '\"..condition..\"'\")\r\n\r\n    elseif string.find(condition, \"%wxchkver2\", 1, 1) then\r\n        assert(false, \"ERROR: %wxchkverXYZ has been replaced by %wxchkver_X_Y_Z, please update your bindings.\")\r\n    elseif string.find(condition, \"%wxcompat2\", 1, 1) then\r\n        assert(false, \"ERROR: %wxcompatXY has been replaced by %wxcompat_X_Y, please update your bindings.\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 265,
    "text": "result = preprocConditionTable[condition]",
    "type": "statement:assign"
  }, {
    "id": 266,
    "text": "local ver = { 0, 0, 0 }",
    "type": "statement:localassign"
  }, {
    "id": 267,
    "text": "local n = 1",
    "type": "statement:localassign"
  }, {
    "id": 268,
    "text": "for v in string.gmatch(condition, \"%d+\") do\r\n            ver[n] = tonumber(v);\r\n            n = n + 1\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 269,
    "text": "ver[n] = tonumber(v)",
    "type": "statement:assign"
  }, {
    "id": 270,
    "text": "assert(#ver == 3, \"%wxchkver_x_y_z conditions has too many version numbers. '\"..condition..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 271,
    "text": "result = string.format(\"wxCHECK_VERSION(%d,%d,%d)\", ver[1], ver[2], ver[3])",
    "type": "statement:assign"
  }, {
    "id": 272,
    "text": "preprocConditionTable[condition] = result",
    "type": "statement:assign"
  }, {
    "id": 273,
    "text": "print(\"WARNING: found wxchkver_XXX, did you forget the leading '%'? '\"..condition..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 274,
    "text": "local p1, p2 = string.find(condition, \"%wxcompat_\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 275,
    "text": "result = \"WXWIN_COMPATIBILITY\"..string.sub(condition, p2)",
    "type": "statement:assign"
  }, {
    "id": 276,
    "text": "result = \"(defined(\"..result..\") && \"..result..\")\"",
    "type": "statement:assign"
  }, {
    "id": 277,
    "text": "print(\"WARNING: found wxcompat_XXX, did you forget the leading '%'? '\"..condition..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 278,
    "text": "print(\"WARNING: unknown wxLUA_USE_XXX condition? '\"..condition..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 279,
    "text": "print(\"WARNING: unknown wxUSE_XXX condition? '\"..condition..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 280,
    "text": "assert(false, \"ERROR: %wxchkverXYZ has been replaced by %wxchkver_X_Y_Z, please update your bindings.\")",
    "type": "statement:functioncall"
  }, {
    "id": 281,
    "text": "assert(false, \"ERROR: %wxcompatXY has been replaced by %wxcompat_X_Y, please update your bindings.\")",
    "type": "statement:functioncall"
  }, {
    "id": 282,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 283,
    "text": "function HasCondition(condition)\r\n    return (condition ~= nil) and (condition ~= \"1\") and (condition ~= \"\")\r\nend",
    "type": "function"
  }, {
    "id": 284,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 285,
    "text": "function FixCondition(condition)\r\n    if not HasCondition(condition) then\r\n        return \"1\"\r\n    end\r\n\r\n    return condition\r\nend",
    "type": "function"
  }, {
    "id": 286,
    "text": "if not HasCondition(condition) then\r\n        return \"1\"\r\n    end",
    "type": "statement:if"
  }, {
    "id": 287,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 288,
    "text": "function BuildCondition(conditionStack)\r\n    local condition = nil\r\n\r\n    if HasCondition(conditionStack[1]) then\r\n        if not HasCondition(conditionStack[2]) then -- only one item\r\n            condition = conditionStack[1]\r\n        else\r\n            condition = \"(\"..conditionStack[1]..\")\"\r\n            for i = 2, #conditionStack do\r\n                if HasCondition(conditionStack[i]) then\r\n                    condition = condition..\" && (\"..conditionStack[i]..\")\"\r\n                end\r\n            end\r\n        end\r\n    end\r\n\r\n    return condition\r\nend",
    "type": "function"
  }, {
    "id": 289,
    "text": "local condition = nil",
    "type": "statement:localassign"
  }, {
    "id": 290,
    "text": "if HasCondition(conditionStack[1]) then\r\n        if not HasCondition(conditionStack[2]) then -- only one item\r\n            condition = conditionStack[1]\r\n        else\r\n            condition = \"(\"..conditionStack[1]..\")\"\r\n            for i = 2, #conditionStack do\r\n                if HasCondition(conditionStack[i]) then\r\n                    condition = condition..\" && (\"..conditionStack[i]..\")\"\r\n                end\r\n            end\r\n        end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 291,
    "text": "if not HasCondition(conditionStack[2]) then -- only one item\r\n            condition = conditionStack[1]\r\n        else\r\n            condition = \"(\"..conditionStack[1]..\")\"\r\n            for i = 2, #conditionStack do\r\n                if HasCondition(conditionStack[i]) then\r\n                    condition = condition..\" && (\"..conditionStack[i]..\")\"\r\n                end\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 292,
    "text": "condition = conditionStack[1]",
    "type": "statement:assign"
  }, {
    "id": 293,
    "text": "condition = \"(\"..conditionStack[1]..\")\"",
    "type": "statement:assign"
  }, {
    "id": 294,
    "text": "for i = 2, #conditionStack do\r\n                if HasCondition(conditionStack[i]) then\r\n                    condition = condition..\" && (\"..conditionStack[i]..\")\"\r\n                end\r\n            end",
    "type": "statement:numericfor"
  }, {
    "id": 295,
    "text": "if HasCondition(conditionStack[i]) then\r\n                    condition = condition..\" && (\"..conditionStack[i]..\")\"\r\n                end",
    "type": "statement:if"
  }, {
    "id": 296,
    "text": "condition = condition..\" && (\"..conditionStack[i]..\")\"",
    "type": "statement:assign"
  }, {
    "id": 297,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 298,
    "text": "function AddCondition(condition1, condition2)\r\n    local condition = nil\r\n\r\n    if HasCondition(condition1) and HasCondition(condition2) then\r\n        condition = \"(\"..condition1..\") && (\"..condition2..\")\"\r\n    elseif HasCondition(condition1) then\r\n        condition = condition1\r\n    elseif HasCondition(condition2) then\r\n        condition = condition2\r\n    end\r\n\r\n    return condition\r\nend",
    "type": "function"
  }, {
    "id": 299,
    "text": "if HasCondition(condition1) and HasCondition(condition2) then\r\n        condition = \"(\"..condition1..\") && (\"..condition2..\")\"\r\n    elseif HasCondition(condition1) then\r\n        condition = condition1\r\n    elseif HasCondition(condition2) then\r\n        condition = condition2\r\n    end",
    "type": "statement:if"
  }, {
    "id": 300,
    "text": "condition = \"(\"..condition1..\") && (\"..condition2..\")\"",
    "type": "statement:assign"
  }, {
    "id": 301,
    "text": "condition = condition1",
    "type": "statement:assign"
  }, {
    "id": 302,
    "text": "condition = condition2",
    "type": "statement:assign"
  }, {
    "id": 303,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 304,
    "text": "function AddOredValue(value, new_value)\r\n    local v = value\r\n\r\n    if not string.find(value, new_value, 1, 1) then\r\n        if string.len(v) > 1 then\r\n            v = value..\"|\"..new_value\r\n        else\r\n            v = new_value\r\n        end\r\n    end\r\n\r\n    return v\r\nend",
    "type": "function"
  }, {
    "id": 305,
    "text": "local v = value",
    "type": "statement:localassign"
  }, {
    "id": 306,
    "text": "if not string.find(value, new_value, 1, 1) then\r\n        if string.len(v) > 1 then\r\n            v = value..\"|\"..new_value\r\n        else\r\n            v = new_value\r\n        end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 307,
    "text": "if string.len(v) > 1 then\r\n            v = value..\"|\"..new_value\r\n        else\r\n            v = new_value\r\n        end",
    "type": "statement:if"
  }, {
    "id": 308,
    "text": "v = value..\"|\"..new_value",
    "type": "statement:assign"
  }, {
    "id": 309,
    "text": "v = new_value",
    "type": "statement:assign"
  }, {
    "id": 310,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 311,
    "text": "function InitKeywords()\r\n\r\n    preprocConditionTable[\"WXWIN_COMPATIBILITY_2\"]   = \"(defined(WXWIN_COMPATIBILITY_2) && WXWIN_COMPATIBILITY_2)\"\r\n    preprocConditionTable[\"WXWIN_COMPATIBILITY_2_2\"] = \"(defined(WXWIN_COMPATIBILITY_2_2) && WXWIN_COMPATIBILITY_2_2)\"\r\n    preprocConditionTable[\"WXWIN_COMPATIBILITY_2_4\"] = \"(defined(WXWIN_COMPATIBILITY_2_4) && WXWIN_COMPATIBILITY_2_4)\"\r\n    preprocConditionTable[\"WXWIN_COMPATIBILITY_2_6\"] = \"(defined(WXWIN_COMPATIBILITY_2_6) && WXWIN_COMPATIBILITY_2_6)\"\r\n    preprocConditionTable[\"WXWIN_COMPATIBILITY_2_8\"] = \"(defined(WXWIN_COMPATIBILITY_2_8) && WXWIN_COMPATIBILITY_2_8)\"\r\n\r\n    -- wxWidgets platform checks\r\n    preprocConditionTable[\"%win\"]        = \"defined(__WXMSW__)\"\r\n    preprocConditionTable[\"%msw\"]        = \"defined(__WXMSW__)\"\r\n    preprocConditionTable[\"%gtk\"]        = \"defined(__WXGTK__)\"\r\n    preprocConditionTable[\"%mac\"]        = \"defined(__WXMAC__)\"\r\n    preprocConditionTable[\"%mgl\"]        = \"defined(__WXMGL__)\"\r\n    preprocConditionTable[\"%motif\"]      = \"defined(__WXMOTIF__)\"\r\n    preprocConditionTable[\"%univ\"]       = \"defined(__WXUNIVERSAL__)\"\r\n    preprocConditionTable[\"%x11\"]        = \"defined(__WXX11__)\"\r\n    preprocConditionTable[\"%cocoa\"]      = \"defined(__WXCOCOA__)\"\r\n    preprocConditionTable[\"%os2\"]        = \"defined(__WXPM__)\"\r\n    preprocConditionTable[\"%palm\"]       = \"defined(__WXPALMOS__)\"\r\n    preprocConditionTable[\"%wince\"]      = \"defined(__WXWINCE__)\"\r\n\r\n    preprocConditionTable[\"%__WINDOWS__\"]       = \"defined(__WINDOWS__)\"\r\n    preprocConditionTable[\"%__WIN16__\"]         = \"defined(__WIN16__)\"\r\n    preprocConditionTable[\"%__WIN32__\"]         = \"defined(__WIN32__)\"\r\n    preprocConditionTable[\"%__WIN95__\"]         = \"defined(__WIN95__)\"\r\n    preprocConditionTable[\"%__WXBASE__\"]        = \"defined(__WXBASE__)\"\r\n    preprocConditionTable[\"%__WXCOCOA__\"]       = \"defined(__WXCOCOA__)\"\r\n    preprocConditionTable[\"%__WXWINCE__\"]       = \"defined(__WXWINCE__)\"\r\n    preprocConditionTable[\"%__WXGTK__\"]         = \"defined(__WXGTK__)\"\r\n    preprocConditionTable[\"%__WXGTK12__\"]       = \"defined(__WXGTK12__)\"\r\n    preprocConditionTable[\"%__WXGTK20__\"]       = \"defined(__WXGTK20__)\"\r\n    preprocConditionTable[\"%__WXMOTIF__\"]       = \"defined(__WXMOTIF__)\"\r\n    preprocConditionTable[\"%__WXMOTIF20__\"]     = \"defined(__WXMOTIF20__)\"\r\n    preprocConditionTable[\"%__WXMAC__\"]         = \"defined(__WXMAC__)\"\r\n    preprocConditionTable[\"%__WXMAC_CLASSIC__\"] = \"defined(__WXMAC_CLASSIC__)\"\r\n    preprocConditionTable[\"%__WXMAC_CARBON__\"]  = \"defined(__WXMAC_CARBON__)\"\r\n    preprocConditionTable[\"%__WXMAC_OSX__\"]     = \"defined(__WXMAC_OSX__)\"\r\n    preprocConditionTable[\"%__WXMGL__\"]         = \"defined(__WXMGL__)\"\r\n    preprocConditionTable[\"%__WXMSW__\"]         = \"defined(__WXMSW__)\"\r\n    preprocConditionTable[\"%__WXOS2__\"]         = \"defined(__WXOS2__)\"\r\n    preprocConditionTable[\"%__WXOSX__\"]         = \"defined(__WXOSX__)\"\r\n    preprocConditionTable[\"%__WXPALMOS__\"]      = \"defined(__WXPALMOS__)\"\r\n    preprocConditionTable[\"%__WXPM__\"]          = \"defined(__WXPM__)\"\r\n    preprocConditionTable[\"%__WXSTUBS__\"]       = \"defined(__WXSTUBS__)\"\r\n    preprocConditionTable[\"%__WXXT__\"]          = \"defined(__WXXT__)\"\r\n    preprocConditionTable[\"%__WXX11__\"]         = \"defined(__WXX11__)\"\r\n    preprocConditionTable[\"%__WXWINE__\"]        = \"defined(__WXWINE__)\"\r\n    preprocConditionTable[\"%__WXUNIVERSAL__\"]   = \"defined(__WXUNIVERSAL__)\"\r\n    preprocConditionTable[\"%__X__\"]             = \"defined(__X__)\"\r\n    preprocConditionTable[\"%__WXWINCE__\"]       = \"defined(__WXWINCE__)\"\r\n\r\n    preprocConditionTable[\"wxHAS_POWER_EVENTS\"]     = \"defined(wxHAS_POWER_EVENTS)\"\r\n    preprocConditionTable[\"%wxHAS_NATIVE_RENDERER\"] = \"defined(wxHAS_NATIVE_RENDERER)\"\r\n\r\n    -- wxUSE_ conditions\r\n    preprocConditionTable[\"wxUSE_ABOUTDLG\"]                = \"wxUSE_ABOUTDLG\"\r\n    preprocConditionTable[\"wxUSE_ACCEL\"]                   = \"wxUSE_ACCEL\"\r\n    preprocConditionTable[\"wxUSE_ACCESSIBILITY\"]           = \"wxUSE_ACCESSIBILITY\"\r\n    preprocConditionTable[\"wxUSE_AFM_FOR_POSTSCRIPT\"]      = \"wxUSE_AFM_FOR_POSTSCRIPT\"\r\n    preprocConditionTable[\"wxUSE_ANIMATIONCTRL\"]           = \"wxUSE_ANIMATIONCTRL\"\r\n    preprocConditionTable[\"wxUSE_APPLE_IEEE\"]              = \"wxUSE_APPLE_IEEE\"\r\n    preprocConditionTable[\"wxUSE_AUI\"]                     = \"wxUSE_AUI\"\r\n    preprocConditionTable[\"wxUSE_BITMAPCOMBOBOX\"]          = \"wxUSE_BITMAPCOMBOBOX\"\r\n    preprocConditionTable[\"wxUSE_BMPBUTTON\"]               = \"wxUSE_BMPBUTTON\"\r\n    preprocConditionTable[\"wxUSE_BOOKCTRL\"]                = \"wxUSE_BOOKCTRL\"\r\n    preprocConditionTable[\"wxUSE_BUILTIN_IODBC\"]           = \"wxUSE_BUILTIN_IODBC\"\r\n    preprocConditionTable[\"wxUSE_BUSYINFO\"]                = \"wxUSE_BUSYINFO\"\r\n    preprocConditionTable[\"wxUSE_BUTTON\"]                  = \"wxUSE_BUTTON\"\r\n    preprocConditionTable[\"wxUSE_CALENDARCTRL\"]            = \"wxUSE_CALENDARCTRL\"\r\n    preprocConditionTable[\"wxUSE_CARET\"]                   = \"wxUSE_CARET\"\r\n    preprocConditionTable[\"wxUSE_CHECKBOX\"]                = \"wxUSE_CHECKBOX\"\r\n    preprocConditionTable[\"wxUSE_CHECKLISTBOX\"]            = \"wxUSE_CHECKLISTBOX\"\r\n    preprocConditionTable[\"wxUSE_CHOICE\"]                  = \"wxUSE_CHOICE\"\r\n    preprocConditionTable[\"wxUSE_CHOICEBOOK\"]              = \"wxUSE_CHOICEBOOK\"\r\n    preprocConditionTable[\"wxUSE_CHOICEDLG\"]               = \"wxUSE_CHOICEDLG\"\r\n    preprocConditionTable[\"wxUSE_CLIPBOARD\"]               = \"wxUSE_CLIPBOARD\"\r\n    preprocConditionTable[\"wxUSE_CMDLINE_PARSER\"]          = \"wxUSE_CMDLINE_PARSER\"\r\n    preprocConditionTable[\"wxUSE_COLLPANE\"]                = \"wxUSE_COLLPANE\"\r\n    preprocConditionTable[\"wxUSE_COLOURDLG\"]               = \"wxUSE_COLOURDLG\"\r\n    preprocConditionTable[\"wxUSE_COLOURPICKERCTRL\"]        = \"wxUSE_COLOURPICKERCTRL\"\r\n    preprocConditionTable[\"wxUSE_COMBOBOX\"]                = \"wxUSE_COMBOBOX\"\r\n    preprocConditionTable[\"wxUSE_CONFIG\"]                  = \"wxUSE_CONFIG\"\r\n    preprocConditionTable[\"wxUSE_CONSTRAINTS\"]             = \"wxUSE_CONSTRAINTS\"\r\n    preprocConditionTable[\"wxUSE_CONTROLS\"]                = \"wxUSE_CONTROLS\"\r\n    preprocConditionTable[\"wxUSE_DATAOBJ\"]                 = \"wxUSE_DATAOBJ\"\r\n    preprocConditionTable[\"wxUSE_DATEPICKCTRL\"]            = \"wxUSE_DATEPICKCTRL\"\r\n    preprocConditionTable[\"wxUSE_DATETIME\"]                = \"wxUSE_DATETIME\"\r\n    preprocConditionTable[\"wxUSE_DEBUG_CONTEXT\"]           = \"wxUSE_DEBUG_CONTEXT\"\r\n    preprocConditionTable[\"wxUSE_DEBUG_NEW_ALWAYS\"]        = \"wxUSE_DEBUG_NEW_ALWAYS\"\r\n    preprocConditionTable[\"wxUSE_DIALUP_MANAGER\"]          = \"wxUSE_DIALUP_MANAGER\"\r\n    preprocConditionTable[\"wxUSE_DIRDLG\"]                  = \"wxUSE_DIRDLG\"\r\n    preprocConditionTable[\"wxUSE_DIRPICKERCTRL\"]           = \"wxUSE_DIRPICKERCTRL\"\r\n    preprocConditionTable[\"wxUSE_DISPLAY\"]                 = \"wxUSE_DISPLAY\"\r\n    preprocConditionTable[\"wxUSE_DOC_VIEW_ARCHITECTURE\"]   = \"wxUSE_DOC_VIEW_ARCHITECTURE\"\r\n    preprocConditionTable[\"wxUSE_DRAGIMAGE\"]               = \"wxUSE_DRAGIMAGE\"\r\n    preprocConditionTable[\"wxUSE_DRAG_AND_DROP\"]           = \"wxUSE_DRAG_AND_DROP\"\r\n    preprocConditionTable[\"wxUSE_DYNAMIC_CLASSES\"]         = \"wxUSE_DYNAMIC_CLASSES\"\r\n    preprocConditionTable[\"wxUSE_DYNAMIC_LOADER\"]          = \"wxUSE_DYNAMIC_LOADER\"\r\n    preprocConditionTable[\"wxUSE_DYNLIB_CLASS\"]            = \"wxUSE_DYNLIB_CLASS\"\r\n    preprocConditionTable[\"wxUSE_ENH_METAFILE\"]            = \"wxUSE_ENH_METAFILE\"\r\n    preprocConditionTable[\"wxUSE_EXCEPTIONS\"]              = \"wxUSE_EXCEPTIONS\"\r\n    preprocConditionTable[\"wxUSE_EXPERIMENTAL_PRINTF\"]     = \"wxUSE_EXPERIMENTAL_PRINTF\"\r\n    preprocConditionTable[\"wxUSE_FFILE\"]                   = \"wxUSE_FFILE\"\r\n    preprocConditionTable[\"wxUSE_FILE\"]                    = \"wxUSE_FILE\"\r\n    preprocConditionTable[\"wxUSE_FILEDLG\"]                 = \"wxUSE_FILEDLG\"\r\n    preprocConditionTable[\"wxUSE_FILEPICKERCTRL\"]          = \"wxUSE_FILEPICKERCTRL\"\r\n    preprocConditionTable[\"wxUSE_FILESYSTEM\"]              = \"wxUSE_FILESYSTEM\"\r\n    preprocConditionTable[\"wxUSE_FINDREPLDLG\"]             = \"wxUSE_FINDREPLDLG\"\r\n    preprocConditionTable[\"wxUSE_FONTDLG\"]                 = \"wxUSE_FONTDLG\"\r\n    preprocConditionTable[\"wxUSE_FONTMAP\"]                 = \"wxUSE_FONTMAP\"\r\n    preprocConditionTable[\"wxUSE_FONTPICKERCTRL\"]          = \"wxUSE_FONTPICKERCTRL\"\r\n    preprocConditionTable[\"wxUSE_FREETYPE\"]                = \"wxUSE_FREETYPE\"\r\n    preprocConditionTable[\"wxUSE_FSVOLUME\"]                = \"wxUSE_FSVOLUME\"\r\n    preprocConditionTable[\"wxUSE_FS_INET\"]                 = \"wxUSE_FS_INET\"\r\n    preprocConditionTable[\"wxUSE_FS_ZIP\"]                  = \"wxUSE_FS_ZIP\"\r\n    preprocConditionTable[\"wxUSE_GAUGE\"]                   = \"wxUSE_GAUGE\"\r\n    preprocConditionTable[\"wxUSE_GEOMETRY\"]                = \"wxUSE_GEOMETRY\"\r\n    preprocConditionTable[\"wxUSE_GIF\"]                     = \"wxUSE_GIF\"\r\n    preprocConditionTable[\"wxUSE_GLCANVAS\"]                = \"wxUSE_GLCANVAS\"\r\n    preprocConditionTable[\"wxUSE_GLOBAL_MEMORY_OPERATORS\"] = \"wxUSE_GLOBAL_MEMORY_OPERATORS\"\r\n    preprocConditionTable[\"wxUSE_GRID\"]                    = \"wxUSE_GRID\"\r\n    preprocConditionTable[\"wxUSE_GUI\"]                     = \"wxUSE_GUI\"\r\n    preprocConditionTable[\"wxUSE_HELP\"]                    = \"wxUSE_HELP\"\r\n    preprocConditionTable[\"wxUSE_HOTKEY\"]                  = \"wxUSE_HOTKEY\"\r\n    preprocConditionTable[\"wxUSE_HTML\"]                    = \"wxUSE_HTML\"\r\n    preprocConditionTable[\"wxUSE_HYPERLINKCTRL\"]           = \"wxUSE_HYPERLINKCTRL\"\r\n    preprocConditionTable[\"wxUSE_ICO_CUR\"]                 = \"wxUSE_ICO_CUR\"\r\n    preprocConditionTable[\"wxUSE_IFF\"]                     = \"wxUSE_IFF\"\r\n    preprocConditionTable[\"wxUSE_IMAGE\"]                   = \"wxUSE_IMAGE\"\r\n    preprocConditionTable[\"wxUSE_IMAGLIST\"]                = \"wxUSE_IMAGLIST\"\r\n    preprocConditionTable[\"wxUSE_INTL\"]                    = \"wxUSE_INTL\"\r\n    preprocConditionTable[\"wxUSE_IOSTREAMH\"]               = \"wxUSE_IOSTREAMH\"\r\n    preprocConditionTable[\"wxUSE_IPC\"]                     = \"wxUSE_IPC\"\r\n    preprocConditionTable[\"wxUSE_JOYSTICK\"]                = \"wxUSE_JOYSTICK\"\r\n    preprocConditionTable[\"wxUSE_LIBJPEG\"]                 = \"wxUSE_LIBJPEG\"\r\n    preprocConditionTable[\"wxUSE_LIBMSPACK\"]               = \"wxUSE_LIBMSPACK\"\r\n    preprocConditionTable[\"wxUSE_LIBPNG\"]                  = \"wxUSE_LIBPNG\"\r\n    preprocConditionTable[\"wxUSE_LIBSDL\"]                  = \"wxUSE_LIBSDL\"\r\n    preprocConditionTable[\"wxUSE_LIBTIFF\"]                 = \"wxUSE_LIBTIFF\"\r\n    preprocConditionTable[\"wxUSE_LISTBOOK\"]                = \"wxUSE_LISTBOOK\"\r\n    preprocConditionTable[\"wxUSE_LISTBOX\"]                 = \"wxUSE_LISTBOX\"\r\n    preprocConditionTable[\"wxUSE_LISTCTRL\"]                = \"wxUSE_LISTCTRL\"\r\n    preprocConditionTable[\"wxUSE_LOG\"]                     = \"wxUSE_LOG\"\r\n    preprocConditionTable[\"wxUSE_LOGGUI\"]                  = \"wxUSE_LOGGUI\"\r\n    preprocConditionTable[\"wxUSE_LOGWINDOW\"]               = \"wxUSE_LOGWINDOW\"\r\n    preprocConditionTable[\"wxUSE_LOG_DIALOG\"]              = \"wxUSE_LOG_DIALOG\"\r\n    preprocConditionTable[\"wxUSE_LONGLONG\"]                = \"wxUSE_LONGLONG\"\r\n    preprocConditionTable[\"wxUSE_MDI\"]                     = \"wxUSE_MDI\"\r\n    preprocConditionTable[\"wxUSE_MDI_ARCHITECTURE\"]        = \"wxUSE_MDI_ARCHITECTURE\"\r\n    preprocConditionTable[\"wxUSE_MEDIACTRL\"]               = \"wxUSE_MEDIACTRL\"\r\n    preprocConditionTable[\"wxUSE_MEMORY_TRACING\"]          = \"wxUSE_MEMORY_TRACING\"\r\n    preprocConditionTable[\"wxUSE_MENUS\"]                   = \"wxUSE_MENUS\"\r\n    preprocConditionTable[\"wxUSE_METAFILE\"]                = \"wxUSE_METAFILE\"\r\n    preprocConditionTable[\"wxUSE_MIMETYPE\"]                = \"wxUSE_MIMETYPE\"\r\n    preprocConditionTable[\"wxUSE_MINIFRAME\"]               = \"wxUSE_MINIFRAME\"\r\n    preprocConditionTable[\"wxUSE_MOUSEWHEEL\"]              = \"wxUSE_MOUSEWHEEL\"\r\n    preprocConditionTable[\"wxUSE_MSGDLG\"]                  = \"wxUSE_MSGDLG\"\r\n    preprocConditionTable[\"wxUSE_MS_HTML_HELP\"]            = \"wxUSE_MS_HTML_HELP\"\r\n    preprocConditionTable[\"wxUSE_NANOX\"]                   = \"wxUSE_NANOX\"\r\n    preprocConditionTable[\"wxUSE_NATIVE_STATUSBAR\"]        = \"wxUSE_NATIVE_STATUSBAR\"\r\n    preprocConditionTable[\"wxUSE_NEW_GRID\"]                = \"wxUSE_NEW_GRID\"\r\n    preprocConditionTable[\"wxUSE_NOGUI\"]                   = \"wxUSE_NOGUI\"\r\n    preprocConditionTable[\"wxUSE_NORMALIZED_PS_FONTS\"]     = \"wxUSE_NORMALIZED_PS_FONTS\"\r\n    preprocConditionTable[\"wxUSE_NOTEBOOK\"]                = \"wxUSE_NOTEBOOK\"\r\n    preprocConditionTable[\"wxUSE_NUMBERDLG\"]               = \"wxUSE_NUMBERDLG\"\r\n    preprocConditionTable[\"wxUSE_ODBC\"]                    = \"wxUSE_ODBC\"\r\n    preprocConditionTable[\"wxUSE_OLE\"]                     = \"wxUSE_OLE\"\r\n    preprocConditionTable[\"wxUSE_ON_FATAL_EXCEPTION\"]      = \"wxUSE_ON_FATAL_EXCEPTION\"\r\n    preprocConditionTable[\"wxUSE_OPENGL\"]                  = \"wxUSE_OPENGL\"\r\n    preprocConditionTable[\"wxUSE_OWNER_DRAWN\"]             = \"wxUSE_OWNER_DRAWN\"\r\n    preprocConditionTable[\"wxUSE_PALETTE\"]                 = \"wxUSE_PALETTE\"\r\n    preprocConditionTable[\"wxUSE_PCX\"]                     = \"wxUSE_PCX\"\r\n    preprocConditionTable[\"wxUSE_PLUGINS\"]                 = \"wxUSE_PLUGINS\"\r\n    preprocConditionTable[\"wxUSE_PNM\"]                     = \"wxUSE_PNM\"\r\n    preprocConditionTable[\"wxUSE_POPUPWIN\"]                = \"wxUSE_POPUPWIN\"\r\n    preprocConditionTable[\"wxUSE_POSTSCRIPT\"]              = \"wxUSE_POSTSCRIPT\"\r\n    preprocConditionTable[\"wxUSE_PRINTING_ARCHITECTURE\"]   = \"wxUSE_PRINTING_ARCHITECTURE\"\r\n    preprocConditionTable[\"wxUSE_PROGRESSDLG\"]             = \"wxUSE_PROGRESSDLG\"\r\n    preprocConditionTable[\"wxUSE_PROLOGIO\"]                = \"wxUSE_PROLOGIO\"\r\n    preprocConditionTable[\"wxUSE_PROPSHEET\"]               = \"wxUSE_PROPSHEET\"\r\n    preprocConditionTable[\"wxUSE_PROTOCOL\"]                = \"wxUSE_PROTOCOL\"\r\n    preprocConditionTable[\"wxUSE_PROTOCOL_FILE\"]           = \"wxUSE_PROTOCOL_FILE\"\r\n    preprocConditionTable[\"wxUSE_PROTOCOL_FTP\"]            = \"wxUSE_PROTOCOL_FTP\"\r\n    preprocConditionTable[\"wxUSE_PROTOCOL_HTTP\"]           = \"wxUSE_PROTOCOL_HTTP\"\r\n    preprocConditionTable[\"wxUSE_RADIOBOX\"]                = \"wxUSE_RADIOBOX\"\r\n    preprocConditionTable[\"wxUSE_RADIOBTN\"]                = \"wxUSE_RADIOBTN\"\r\n    preprocConditionTable[\"wxUSE_REGEX\"]                   = \"wxUSE_REGEX\"\r\n    preprocConditionTable[\"wxUSE_RESOURCES\"]               = \"wxUSE_RESOURCES\"\r\n    preprocConditionTable[\"wxUSE_RICHEDIT\"]                = \"wxUSE_RICHEDIT\"\r\n    preprocConditionTable[\"wxUSE_RICHTEXT\"]                = \"wxUSE_RICHTEXT\"\r\n    preprocConditionTable[\"wxUSE_SASH\"]                    = \"wxUSE_SASH\"\r\n    preprocConditionTable[\"wxUSE_SCROLLBAR\"]               = \"wxUSE_SCROLLBAR\"\r\n    preprocConditionTable[\"wxUSE_SLIDER\"]                  = \"wxUSE_SLIDER\"\r\n    preprocConditionTable[\"wxUSE_SNGLINST_CHECKER\"]        = \"wxUSE_SNGLINST_CHECKER\"\r\n    preprocConditionTable[\"wxUSE_SOCKETS\"]                 = \"wxUSE_SOCKETS\"\r\n    preprocConditionTable[\"wxUSE_SOUND\"]                   = \"wxUSE_SOUND\"\r\n    preprocConditionTable[\"wxUSE_SPINBTN\"]                 = \"wxUSE_SPINBTN\"\r\n    preprocConditionTable[\"wxUSE_SPINCTRL\"]                = \"wxUSE_SPINCTRL\"\r\n    preprocConditionTable[\"wxUSE_SPLASH\"]                  = \"wxUSE_SPLASH\"\r\n    preprocConditionTable[\"wxUSE_SPLINES\"]                 = \"wxUSE_SPLINES\"\r\n    preprocConditionTable[\"wxUSE_SPLITTER\"]                = \"wxUSE_SPLITTER\"\r\n    preprocConditionTable[\"wxUSE_STARTUP_TIPS\"]            = \"wxUSE_STARTUP_TIPS\"\r\n    preprocConditionTable[\"wxUSE_STATBMP\"]                 = \"wxUSE_STATBMP\"\r\n    preprocConditionTable[\"wxUSE_STATBOX\"]                 = \"wxUSE_STATBOX\"\r\n    preprocConditionTable[\"wxUSE_STATLINE\"]                = \"wxUSE_STATLINE\"\r\n    preprocConditionTable[\"wxUSE_STATTEXT\"]                = \"wxUSE_STATTEXT\"\r\n    preprocConditionTable[\"wxUSE_STATUSBAR\"]               = \"wxUSE_STATUSBAR\"\r\n    preprocConditionTable[\"wxUSE_STD_IOSTREAM\"]            = \"wxUSE_STD_IOSTREAM\"\r\n    preprocConditionTable[\"wxUSE_STL\"]                     = \"wxUSE_STL\"\r\n    preprocConditionTable[\"wxUSE_STOPWATCH\"]               = \"wxUSE_STOPWATCH\"\r\n    preprocConditionTable[\"wxUSE_STREAMS\"]                 = \"wxUSE_STREAMS\"\r\n    preprocConditionTable[\"wxUSE_SYSTEM_OPTIONS\"]          = \"wxUSE_SYSTEM_OPTIONS\"\r\n    preprocConditionTable[\"wxUSE_TABDIALOG\"]               = \"wxUSE_TABDIALOG\"\r\n    preprocConditionTable[\"wxUSE_TAB_DIALOG\"]              = \"wxUSE_TAB_DIALOG\"\r\n    preprocConditionTable[\"wxUSE_TEXTBUFFER\"]              = \"wxUSE_TEXTBUFFER\"\r\n    preprocConditionTable[\"wxUSE_TEXTCTRL\"]                = \"wxUSE_TEXTCTRL\"\r\n    preprocConditionTable[\"wxUSE_TEXTDLG\"]                 = \"wxUSE_TEXTDLG\"\r\n    preprocConditionTable[\"wxUSE_TEXTFILE\"]                = \"wxUSE_TEXTFILE\"\r\n    preprocConditionTable[\"wxUSE_TGA\"]                     = \"wxUSE_TGA\"\r\n    preprocConditionTable[\"wxUSE_THREADS\"]                 = \"wxUSE_THREADS\"\r\n    preprocConditionTable[\"wxUSE_TIMEDATE\"]                = \"wxUSE_TIMEDATE\"\r\n    preprocConditionTable[\"wxUSE_TIMER\"]                   = \"wxUSE_TIMER\"\r\n    preprocConditionTable[\"wxUSE_TIPWINDOW\"]               = \"wxUSE_TIPWINDOW\"\r\n    preprocConditionTable[\"wxUSE_TOGGLEBTN\"]               = \"wxUSE_TOGGLEBTN\"\r\n    preprocConditionTable[\"wxUSE_TOOLBAR\"]                 = \"wxUSE_TOOLBAR\"\r\n    preprocConditionTable[\"wxUSE_TOOLBAR_NATIVE\"]          = \"wxUSE_TOOLBAR_NATIVE\"\r\n    preprocConditionTable[\"wxUSE_TOOLBOOK\"]                = \"wxUSE_TOOLBOOK\"\r\n    preprocConditionTable[\"wxUSE_TOOLTIPS\"]                = \"wxUSE_TOOLTIPS\"\r\n    preprocConditionTable[\"wxUSE_TREEBOOK\"]                = \"wxUSE_TREEBOOK\"\r\n    preprocConditionTable[\"wxUSE_TREECTRL\"]                = \"wxUSE_TREECTRL\"\r\n    preprocConditionTable[\"wxUSE_TREELAYOUT\"]              = \"wxUSE_TREELAYOUT\"\r\n    preprocConditionTable[\"wxUSE_UNICODE\"]                 = \"wxUSE_UNICODE\"\r\n    preprocConditionTable[\"wxUSE_UNICODE_MSLU\"]            = \"wxUSE_UNICODE_MSLU\"\r\n    preprocConditionTable[\"wxUSE_UNIX\"]                    = \"wxUSE_UNIX\"\r\n    preprocConditionTable[\"wxUSE_URL\"]                     = \"wxUSE_URL\"\r\n    preprocConditionTable[\"wxUSE_UXTHEME\"]                 = \"wxUSE_UXTHEME\"\r\n    preprocConditionTable[\"wxUSE_UXTHEME_AUTO\"]            = \"wxUSE_UXTHEME_AUTO\"\r\n    preprocConditionTable[\"wxUSE_VALIDATORS\"]              = \"wxUSE_VALIDATORS\"\r\n    preprocConditionTable[\"wxUSE_WAVE\"]                    = \"wxUSE_WAVE\"\r\n    preprocConditionTable[\"wxUSE_WCHAR_T\"]                 = \"wxUSE_WCHAR_T\"\r\n    preprocConditionTable[\"wxUSE_WCSRTOMBS\"]               = \"wxUSE_WCSRTOMBS\"\r\n    preprocConditionTable[\"wxUSE_WIZARDDLG\"]               = \"wxUSE_WIZARDDLG\"\r\n    preprocConditionTable[\"wxUSE_WXHTML_HELP\"]             = \"wxUSE_WXHTML_HELP\"\r\n    preprocConditionTable[\"wxUSE_WX_RESOURCES\"]            = \"wxUSE_WX_RESOURCES\"\r\n    preprocConditionTable[\"wxUSE_XML\"]                     = \"wxUSE_XML\"\r\n    preprocConditionTable[\"wxUSE_XPM\"]                     = \"wxUSE_XPM\"\r\n    preprocConditionTable[\"wxUSE_XPM_IN_MSW\"]              = \"wxUSE_XPM_IN_MSW\"\r\n    preprocConditionTable[\"wxUSE_XRC\"]                     = \"wxUSE_XRC\"\r\n    preprocConditionTable[\"wxUSE_X_RESOURCES\"]             = \"wxUSE_X_RESOURCES\"\r\n    preprocConditionTable[\"wxUSE_ZIPSTREAM\"]               = \"wxUSE_ZIPSTREAM\"\r\n    preprocConditionTable[\"wxUSE_ZLIB\"]                    = \"wxUSE_ZLIB\"\r\n\r\n    -- wxLUA_USE_xxx conditions\r\n    preprocConditionTable[\"wxLUA_USE_FL\"]                      = \"wxLUA_USE_FL\"\r\n    preprocConditionTable[\"wxLUA_USE_Geometry\"]                = \"wxLUA_USE_Geometry\"\r\n    preprocConditionTable[\"wxLUA_USE_MDI\"]                     = \"wxLUA_USE_MDI\"\r\n    preprocConditionTable[\"wxLUA_USE_wxAboutDialog\"]           = \"wxLUA_USE_wxAboutDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxAcceleratorTable\"]      = \"wxLUA_USE_wxAcceleratorTable\"\r\n    preprocConditionTable[\"wxLUA_USE_wxAnimation\"]             = \"wxLUA_USE_wxAnimation\"\r\n    preprocConditionTable[\"wxLUA_USE_wxApp\"]                   = \"wxLUA_USE_wxApp\"\r\n    preprocConditionTable[\"wxLUA_USE_wxArrayInt\"]              = \"wxLUA_USE_wxArrayInt\"\r\n    preprocConditionTable[\"wxLUA_USE_wxArrayString\"]           = \"wxLUA_USE_wxArrayString\"\r\n    preprocConditionTable[\"wxLUA_USE_wxArtProvider\"]           = \"wxLUA_USE_wxArtProvider\"\r\n    preprocConditionTable[\"wxLUA_USE_wxAUI\"]                   = \"wxLUA_USE_wxAUI\"\r\n    preprocConditionTable[\"wxLUA_USE_wxBitmap\"]                = \"wxLUA_USE_wxBitmap\"\r\n    preprocConditionTable[\"wxLUA_USE_wxBitmapComboBox\"]        = \"wxLUA_USE_wxBitmapComboBox\"\r\n    preprocConditionTable[\"wxLUA_USE_wxBitmapButton\"]          = \"wxLUA_USE_wxBitmapButton\"\r\n    preprocConditionTable[\"wxLUA_USE_wxBrushList\"]             = \"wxLUA_USE_wxBrushList\"\r\n    preprocConditionTable[\"wxLUA_USE_wxBusyCursor\"]            = \"wxLUA_USE_wxBusyCursor\"\r\n    preprocConditionTable[\"wxLUA_USE_wxBusyInfo\"]              = \"wxLUA_USE_wxBusyInfo\"\r\n    preprocConditionTable[\"wxLUA_USE_wxButton\"]                = \"wxLUA_USE_wxButton\"\r\n    preprocConditionTable[\"wxLUA_USE_wxCalendarCtrl\"]          = \"wxLUA_USE_wxCalendarCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxCaret\"]                 = \"wxLUA_USE_wxCaret\"\r\n    preprocConditionTable[\"wxLUA_USE_wxCheckBox\"]              = \"wxLUA_USE_wxCheckBox\"\r\n    preprocConditionTable[\"wxLUA_USE_wxCheckListBox\"]          = \"wxLUA_USE_wxCheckListBox\"\r\n    preprocConditionTable[\"wxLUA_USE_wxChoice\"]                = \"wxLUA_USE_wxChoice\"\r\n    preprocConditionTable[\"wxLUA_USE_wxClassInfo\"]             = \"wxLUA_USE_wxClassInfo\"\r\n    preprocConditionTable[\"wxLUA_USE_wxClipboard\"]             = \"wxLUA_USE_wxClipboard\"\r\n    preprocConditionTable[\"wxLUA_USE_wxCollapsiblePane\"]       = \"wxLUA_USE_wxCollapsiblePane\"\r\n    preprocConditionTable[\"wxLUA_USE_wxColourDialog\"]          = \"wxLUA_USE_wxColourDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxColourPenBrush\"]        = \"wxLUA_USE_wxColourPenBrush\"\r\n    preprocConditionTable[\"wxLUA_USE_wxColourPickerCtrl\"]      = \"wxLUA_USE_wxColourPickerCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxComboBox\"]              = \"wxLUA_USE_wxComboBox\"\r\n    preprocConditionTable[\"wxLUA_USE_wxCommandProcessor\"]      = \"wxLUA_USE_wxCommandProcessor\"\r\n    preprocConditionTable[\"wxLUA_USE_wxConfig\"]                = \"wxLUA_USE_wxConfig\"\r\n    preprocConditionTable[\"wxLUA_USE_wxCursor\"]                = \"wxLUA_USE_wxCursor\"\r\n    preprocConditionTable[\"wxLUA_USE_wxCriticalSection\"]       = \"wxLUA_USE_wxCriticalSection\"\r\n    preprocConditionTable[\"wxLUA_USE_wxCriticalSectionLocker\"] = \"wxLUA_USE_wxCriticalSectionLocker\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDataObject\"]            = \"wxLUA_USE_wxDataObject\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDatePickerCtrl\"]        = \"wxLUA_USE_wxDatePickerCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDateSpan\"]              = \"wxLUA_USE_wxDateSpan\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDateTime\"]              = \"wxLUA_USE_wxDateTime\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDateTimeHolidayAuthority\"] = \"wxLUA_USE_wxDateTimeHolidayAuthority\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDC\"]                    = \"wxLUA_USE_wxDC\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDialog\"]                = \"wxLUA_USE_wxDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDir\"]                   = \"wxLUA_USE_wxDir\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDirDialog\"]             = \"wxLUA_USE_wxDirDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDirPickerCtrl\"]         = \"wxLUA_USE_wxDirPickerCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDisplay\"]               = \"wxLUA_USE_wxDisplay\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDragDrop\"]              = \"wxLUA_USE_wxDragDrop\"\r\n    preprocConditionTable[\"wxLUA_USE_wxDynamicLibrary\"]        = \"wxLUA_USE_wxDynamicLibrary\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFile\"]                  = \"wxLUA_USE_wxFile\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFileDialog\"]            = \"wxLUA_USE_wxFileDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFileHistory\"]           = \"wxLUA_USE_wxFileHistory\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFileName\"]              = \"wxLUA_USE_wxFileName\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFilePickerCtrl\"]        = \"wxLUA_USE_wxFilePickerCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFindReplaceDialog\"]     = \"wxLUA_USE_wxFindReplaceDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFont\"]                  = \"wxLUA_USE_wxFont\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFontDialog\"]            = \"wxLUA_USE_wxFontDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFontEnumerator\"]        = \"wxLUA_USE_wxFontEnumerator\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFontList\"]              = \"wxLUA_USE_wxFontList\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFontMapper\"]            = \"wxLUA_USE_wxFontMapper\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFontPickerCtrl\"]        = \"wxLUA_USE_wxFontPickerCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxFrame\"]                 = \"wxLUA_USE_wxFrame\"\r\n    preprocConditionTable[\"wxLUA_USE_wxGauge\"]                 = \"wxLUA_USE_wxGauge\"\r\n    preprocConditionTable[\"wxLUA_USE_wxGenericDirCtrl\"]        = \"wxLUA_USE_wxGenericDirCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxGenericValidator\"]      = \"wxLUA_USE_wxGenericValidator\"\r\n    preprocConditionTable[\"wxLUA_USE_wxGLCanvas\"]              = \"wxLUA_USE_wxGLCanvas\"\r\n    preprocConditionTable[\"wxLUA_USE_wxGrid\"]                  = \"wxLUA_USE_wxGrid\"\r\n    preprocConditionTable[\"wxLUA_USE_wxHashTable\"]             = \"wxLUA_USE_wxHashTable\"\r\n    preprocConditionTable[\"wxLUA_USE_wxHelpController\"]        = \"wxLUA_USE_wxHelpController\"\r\n    preprocConditionTable[\"wxLUA_USE_wxHTML\"]                  = \"wxLUA_USE_wxHTML\"\r\n    preprocConditionTable[\"wxLUA_USE_wxHtmlHelpController\"]    = \"wxLUA_USE_wxHtmlHelpController\"\r\n    preprocConditionTable[\"wxLUA_USE_wxHyperlinkCtrl\"]         = \"wxLUA_USE_wxHyperlinkCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxIcon\"]                  = \"wxLUA_USE_wxIcon\"\r\n    preprocConditionTable[\"wxLUA_USE_wxID_XXX\"]                = \"wxLUA_USE_wxID_XXX\"\r\n    preprocConditionTable[\"wxLUA_USE_wxImage\"]                 = \"wxLUA_USE_wxImage\"\r\n    preprocConditionTable[\"wxLUA_USE_wxImageList\"]             = \"wxLUA_USE_wxImageList\"\r\n    preprocConditionTable[\"wxLUA_USE_wxJoystick\"]              = \"wxLUA_USE_wxJoystick\"\r\n    preprocConditionTable[\"wxLUA_USE_wxLayoutConstraints\"]     = \"wxLUA_USE_wxLayoutConstraints\"\r\n    preprocConditionTable[\"wxLUA_USE_wxList\"]                  = \"wxLUA_USE_wxList\"\r\n    preprocConditionTable[\"wxLUA_USE_wxListBox\"]               = \"wxLUA_USE_wxListBox\"\r\n    preprocConditionTable[\"wxLUA_USE_wxListCtrl\"]              = \"wxLUA_USE_wxListCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxLog\"]                   = \"wxLUA_USE_wxLog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxLogWindow\"]             = \"wxLUA_USE_wxLogWindow\"\r\n    preprocConditionTable[\"wxLUA_USE_wxLuaHtmlWindow\"]         = \"wxLUA_USE_wxLuaHtmlWindow\"\r\n    preprocConditionTable[\"wxLUA_USE_wxLuaPrintout\"]           = \"wxLUA_USE_wxLuaPrintout\"\r\n    preprocConditionTable[\"wxLUA_USE_wxMask\"]                  = \"wxLUA_USE_wxMask\"\r\n    preprocConditionTable[\"wxLUA_USE_wxMediaCtrl\"]             = \"wxLUA_USE_wxMediaCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxMenu\"]                  = \"wxLUA_USE_wxMenu\"\r\n    preprocConditionTable[\"wxLUA_USE_wxMessageDialog\"]         = \"wxLUA_USE_wxMessageDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxMetafile\"]              = \"wxLUA_USE_wxMetafile\"\r\n    preprocConditionTable[\"wxLUA_USE_wxMiniFrame\"]             = \"wxLUA_USE_wxMiniFrame\"\r\n    preprocConditionTable[\"wxLUA_USE_wxMultiChoiceDialog\"]     = \"wxLUA_USE_wxMultiChoiceDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxNotebook\"]              = \"wxLUA_USE_wxNotebook\"\r\n    preprocConditionTable[\"wxLUA_USE_wxObject\"]                = \"wxLUA_USE_wxObject\"\r\n    preprocConditionTable[\"wxLUA_USE_wxPalette\"]               = \"wxLUA_USE_wxPalette\"\r\n    preprocConditionTable[\"wxLUA_USE_wxPenList\"]               = \"wxLUA_USE_wxPenList\"\r\n    preprocConditionTable[\"wxLUA_USE_wxPicker\"]                = \"wxLUA_USE_wxPicker\"\r\n    preprocConditionTable[\"wxLUA_USE_wxPointSizeRect\"]         = \"wxLUA_USE_wxPointSizeRect\"\r\n    preprocConditionTable[\"wxLUA_USE_wxPrint\"]                 = \"wxLUA_USE_wxPrint\"\r\n    preprocConditionTable[\"wxLUA_USE_wxProcess\"]               = \"wxLUA_USE_wxProcess\"\r\n    preprocConditionTable[\"wxLUA_USE_wxProgressDialog\"]        = \"wxLUA_USE_wxProgressDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxRadioBox\"]              = \"wxLUA_USE_wxRadioBox\"\r\n    preprocConditionTable[\"wxLUA_USE_wxRadioButton\"]           = \"wxLUA_USE_wxRadioButton\"\r\n    preprocConditionTable[\"wxLUA_USE_wxRegEx\"]                 = \"wxLUA_USE_wxRegEx\"\r\n    preprocConditionTable[\"wxLUA_USE_wxRegion\"]                = \"wxLUA_USE_wxRegion\"\r\n    preprocConditionTable[\"wxLUA_USE_wxRenderer\"]              = \"wxLUA_USE_wxRenderer\"\r\n    preprocConditionTable[\"wxLUA_USE_wxRichText\"]              = \"wxLUA_USE_wxRichText\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSashWindow\"]            = \"wxLUA_USE_wxSashWindow\"\r\n    preprocConditionTable[\"wxLUA_USE_wxScrollBar\"]             = \"wxLUA_USE_wxScrollBar\"\r\n    preprocConditionTable[\"wxLUA_USE_wxScrolledWindow\"]        = \"wxLUA_USE_wxScrolledWindow\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSingleChoiceDialog\"]    = \"wxLUA_USE_wxSingleChoiceDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSizer\"]                 = \"wxLUA_USE_wxSizer\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSlider\"]                = \"wxLUA_USE_wxSlider\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSocket\"]                = \"wxLUA_USE_wxSocket\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSpinButton\"]            = \"wxLUA_USE_wxSpinButton\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSpinCtrl\"]              = \"wxLUA_USE_wxSpinCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSplashScreen\"]          = \"wxLUA_USE_wxSplashScreen\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSplitterWindow\"]        = \"wxLUA_USE_wxSplitterWindow\"\r\n    preprocConditionTable[\"wxLUA_USE_wxStandardPaths\"]         = \"wxLUA_USE_wxStandardPaths\"\r\n    preprocConditionTable[\"wxLUA_USE_wxStaticBitmap\"]          = \"wxLUA_USE_wxStaticBitmap\"\r\n    preprocConditionTable[\"wxLUA_USE_wxStaticBox\"]             = \"wxLUA_USE_wxStaticBox\"\r\n    preprocConditionTable[\"wxLUA_USE_wxStaticLine\"]            = \"wxLUA_USE_wxStaticLine\"\r\n    preprocConditionTable[\"wxLUA_USE_wxStaticText\"]            = \"wxLUA_USE_wxStaticText\"\r\n    preprocConditionTable[\"wxLUA_USE_wxStatusBar\"]             = \"wxLUA_USE_wxStatusBar\"\r\n    preprocConditionTable[\"wxLUA_USE_wxStopWatch\"]             = \"wxLUA_USE_wxStopWatch\"\r\n    preprocConditionTable[\"wxLUA_USE_wxStringList\"]            = \"wxLUA_USE_wxStringList\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSystemOptions\"]         = \"wxLUA_USE_wxSystemOptions\"\r\n    preprocConditionTable[\"wxLUA_USE_wxSystemSettings\"]        = \"wxLUA_USE_wxSystemSettings\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTabCtrl\"]               = \"wxLUA_USE_wxTabCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTaskBarIcon\"]           = \"wxLUA_USE_wxTaskBarIcon\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTextCtrl\"]              = \"wxLUA_USE_wxTextCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTextEntryDialog\"]       = \"wxLUA_USE_wxTextEntryDialog\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTextValidator\"]         = \"wxLUA_USE_wxTextValidator\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTimer\"]                 = \"wxLUA_USE_wxTimer\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTimeSpan\"]              = \"wxLUA_USE_wxTimeSpan\"\r\n    preprocConditionTable[\"wxLUA_USE_wxToggleButton\"]          = \"wxLUA_USE_wxToggleButton\"\r\n    preprocConditionTable[\"wxLUA_USE_wxToolbar\"]               = \"wxLUA_USE_wxToolbar\"\r\n    preprocConditionTable[\"wxLUA_USE_wxToolbook\"]              = \"wxLUA_USE_wxToolbook\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTooltip\"]               = \"wxLUA_USE_wxTooltip\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTreebook\"]              = \"wxLUA_USE_wxTreebook\"\r\n    preprocConditionTable[\"wxLUA_USE_wxTreeCtrl\"]              = \"wxLUA_USE_wxTreeCtrl\"\r\n    preprocConditionTable[\"wxLUA_USE_wxValidator\"]             = \"wxLUA_USE_wxValidator\"\r\n    preprocConditionTable[\"wxLUA_USE_wxWave\"]                  = \"wxLUA_USE_wxWave\"\r\n    preprocConditionTable[\"wxLUA_USE_wxWindowList\"]            = \"wxLUA_USE_wxWindowList\"\r\n    preprocConditionTable[\"wxLUA_USE_wxWizard\"]                = \"wxLUA_USE_wxWizard\"\r\n    preprocConditionTable[\"wxLUA_USE_wxXML\"]                   = \"wxLUA_USE_wxXML\"\r\n    preprocConditionTable[\"wxLUA_USE_wxXRC\"]                   = \"wxLUA_USE_wxXRC\"\r\n\r\n    -- condition operators for preprocessor #if statements\r\n    preprocOperatorTable[\"|\"]  = \"||\"\r\n    preprocOperatorTable[\"||\"] = \"||\"\r\n    preprocOperatorTable[\"&\"]  = \"&&\"\r\n    preprocOperatorTable[\"&&\"] = \"&&\"\r\n    preprocOperatorTable[\"!\"]  = \"!\"\r\n    preprocOperatorTable[\"(\"]  = \"(\"\r\n    preprocOperatorTable[\")\"]  = \")\"\r\n\r\n    -- operators for %operator\r\n\r\n    bindingOperatorTable[\"==\"]  = \"op_eq\"\r\n    bindingOperatorTable[\"!=\"]  = \"op_ne\"\r\n    bindingOperatorTable[\"<\"]   = \"op_lt\"\r\n    bindingOperatorTable[\">\"]   = \"op_gt\"\r\n    bindingOperatorTable[\"<=\"]  = \"op_le\"\r\n    bindingOperatorTable[\">=\"]  = \"op_ge\"\r\n    bindingOperatorTable[\"||\"]  = \"op_lor\"  -- logical or\r\n    bindingOperatorTable[\"&&\"]  = \"op_land\" -- logical and\r\n    bindingOperatorTable[\"!\"]   = \"op_not\"\r\n\r\n    bindingOperatorTable[\"|\"]   = \"op_or\"\r\n    bindingOperatorTable[\"&\"]   = \"op_and\"\r\n    bindingOperatorTable[\"^\"]   = \"op_xor\"\r\n    bindingOperatorTable[\"<<\"]  = \"op_lshift\"\r\n    bindingOperatorTable[\">>\"]  = \"op_rshift\"\r\n\r\n    bindingOperatorTable[\"|=\"]  = \"op_ior\"\r\n    bindingOperatorTable[\"&=\"]  = \"op_iand\"\r\n    bindingOperatorTable[\"^=\"]  = \"op_ixor\"\r\n    bindingOperatorTable[\"<<=\"] = \"op_ilshift\"\r\n    bindingOperatorTable[\">>=\"] = \"op_irshift\"\r\n\r\n    bindingOperatorTable[\"=\"]  = \"op_set\"\r\n    bindingOperatorTable[\"()\"] = \"op_func\"\r\n    bindingOperatorTable[\"[]\"] = \"op_index\"\r\n\r\n    bindingOperatorTable[\"++\"] = \"op_inc\"  -- or op_preinc\r\n    bindingOperatorTable[\"--\"] = \"op_dec\"  -- or op_predec\r\n    bindingOperatorTable[\"~\"]  = \"op_comp\" -- bitwise one's compliment\r\n    --bindingOperatorTable[\"-\"] = \"op_neg\" -- also op_sub if not unary -\r\n\r\n    bindingOperatorTable[\"+\"]  = \"op_add\"\r\n    bindingOperatorTable[\"-\"]  = \"op_sub\"  -- also op_neg if unary -\r\n    bindingOperatorTable[\"*\"]  = \"op_mul\"  -- also op_deref if no args\r\n    bindingOperatorTable[\"/\"]  = \"op_div\"\r\n    bindingOperatorTable[\"%\"]  = \"op_mod\"\r\n\r\n    bindingOperatorTable[\"+=\"] = \"op_iadd\"\r\n    bindingOperatorTable[\"-=\"] = \"op_isub\"\r\n    bindingOperatorTable[\"*=\"] = \"op_imul\"\r\n    bindingOperatorTable[\"/=\"] = \"op_idiv\"\r\n    bindingOperatorTable[\"%=\"] = \"op_imod\"\r\n\r\n    -- bindingKeywordTable\r\n    bindingKeywordTable[\"%if\"]          = true\r\n    bindingKeywordTable[\"%endif\"]       = true\r\n    bindingKeywordTable[\"%rename\"]      = true\r\n    bindingKeywordTable[\"%class\"]       = true\r\n        -- keywords that come after %class tag\r\n        bindingKeywordTable[\"%delete\"]      = true\r\n        bindingKeywordTable[\"%noclassinfo\"] = true\r\n        bindingKeywordTable[\"%encapsulate\"] = true\r\n        -- keywords that can only be used within %class tag\r\n        bindingKeywordTable[\"%constructor\"] = true\r\n        bindingKeywordTable[\"%member\"]      = true\r\n        bindingKeywordTable[\"%member_func\"] = true\r\n        bindingKeywordTable[\"%operator\"]    = true\r\n        bindingKeywordTable[\"%property\"]    = true\r\n        bindingKeywordTable[\"%private\"]     = true\r\n        bindingKeywordTable[\"%protected\"]   = true\r\n    bindingKeywordTable[\"%endclass\"]    = true\r\n    bindingKeywordTable[\"%abstract\"]    = true\r\n    bindingKeywordTable[\"%struct\"]      = true\r\n    bindingKeywordTable[\"%endstruct\"]   = true\r\n    bindingKeywordTable[\"%enum\"]        = true\r\n    bindingKeywordTable[\"%endenum\"]     = true\r\n    bindingKeywordTable[\"%function\"]    = true\r\n    bindingKeywordTable[\"%override\"]    = true\r\n    bindingKeywordTable[\"%override_name\"] = true\r\n    bindingKeywordTable[\"%not_overload\"] = true\r\n    bindingKeywordTable[\"%typedef\"]     = true\r\n    bindingKeywordTable[\"%include\"]     = true\r\n    bindingKeywordTable[\"%includefile\"] = true\r\n\r\n    bindingKeywordTable[\"%gc_this\"]     = true\r\n    bindingKeywordTable[\"%ungc_this\"]   = true\r\n\r\n    bindingKeywordTable[\"%define\"]         = true\r\n    bindingKeywordTable[\"%define_string\"]  = true\r\n    bindingKeywordTable[\"%define_event\"]   = true\r\n    bindingKeywordTable[\"%define_object\"]  = true\r\n    bindingKeywordTable[\"%define_pointer\"] = true\r\n\r\n    bindingKeywordTable[\"//\"]           = true\r\n    bindingKeywordTable[\"/*\"]           = true\r\n    bindingKeywordTable[\"*/\"]           = true\r\nend",
    "type": "function"
  }, {
    "id": 312,
    "text": "preprocConditionTable[\"WXWIN_COMPATIBILITY_2\"]   = \"(defined(WXWIN_COMPATIBILITY_2) && WXWIN_COMPATIBILITY_2)\"",
    "type": "statement:assign"
  }, {
    "id": 313,
    "text": "preprocConditionTable[\"WXWIN_COMPATIBILITY_2_2\"] = \"(defined(WXWIN_COMPATIBILITY_2_2) && WXWIN_COMPATIBILITY_2_2)\"",
    "type": "statement:assign"
  }, {
    "id": 314,
    "text": "preprocConditionTable[\"WXWIN_COMPATIBILITY_2_4\"] = \"(defined(WXWIN_COMPATIBILITY_2_4) && WXWIN_COMPATIBILITY_2_4)\"",
    "type": "statement:assign"
  }, {
    "id": 315,
    "text": "preprocConditionTable[\"WXWIN_COMPATIBILITY_2_6\"] = \"(defined(WXWIN_COMPATIBILITY_2_6) && WXWIN_COMPATIBILITY_2_6)\"",
    "type": "statement:assign"
  }, {
    "id": 316,
    "text": "preprocConditionTable[\"WXWIN_COMPATIBILITY_2_8\"] = \"(defined(WXWIN_COMPATIBILITY_2_8) && WXWIN_COMPATIBILITY_2_8)\"",
    "type": "statement:assign"
  }, {
    "id": 317,
    "text": "preprocConditionTable[\"%win\"]        = \"defined(__WXMSW__)\"",
    "type": "statement:assign"
  }, {
    "id": 318,
    "text": "preprocConditionTable[\"%msw\"]        = \"defined(__WXMSW__)\"",
    "type": "statement:assign"
  }, {
    "id": 319,
    "text": "preprocConditionTable[\"%gtk\"]        = \"defined(__WXGTK__)\"",
    "type": "statement:assign"
  }, {
    "id": 320,
    "text": "preprocConditionTable[\"%mac\"]        = \"defined(__WXMAC__)\"",
    "type": "statement:assign"
  }, {
    "id": 321,
    "text": "preprocConditionTable[\"%mgl\"]        = \"defined(__WXMGL__)\"",
    "type": "statement:assign"
  }, {
    "id": 322,
    "text": "preprocConditionTable[\"%motif\"]      = \"defined(__WXMOTIF__)\"",
    "type": "statement:assign"
  }, {
    "id": 323,
    "text": "preprocConditionTable[\"%univ\"]       = \"defined(__WXUNIVERSAL__)\"",
    "type": "statement:assign"
  }, {
    "id": 324,
    "text": "preprocConditionTable[\"%x11\"]        = \"defined(__WXX11__)\"",
    "type": "statement:assign"
  }, {
    "id": 325,
    "text": "preprocConditionTable[\"%cocoa\"]      = \"defined(__WXCOCOA__)\"",
    "type": "statement:assign"
  }, {
    "id": 326,
    "text": "preprocConditionTable[\"%os2\"]        = \"defined(__WXPM__)\"",
    "type": "statement:assign"
  }, {
    "id": 327,
    "text": "preprocConditionTable[\"%palm\"]       = \"defined(__WXPALMOS__)\"",
    "type": "statement:assign"
  }, {
    "id": 328,
    "text": "preprocConditionTable[\"%wince\"]      = \"defined(__WXWINCE__)\"",
    "type": "statement:assign"
  }, {
    "id": 329,
    "text": "preprocConditionTable[\"%__WINDOWS__\"]       = \"defined(__WINDOWS__)\"",
    "type": "statement:assign"
  }, {
    "id": 330,
    "text": "preprocConditionTable[\"%__WIN16__\"]         = \"defined(__WIN16__)\"",
    "type": "statement:assign"
  }, {
    "id": 331,
    "text": "preprocConditionTable[\"%__WIN32__\"]         = \"defined(__WIN32__)\"",
    "type": "statement:assign"
  }, {
    "id": 332,
    "text": "preprocConditionTable[\"%__WIN95__\"]         = \"defined(__WIN95__)\"",
    "type": "statement:assign"
  }, {
    "id": 333,
    "text": "preprocConditionTable[\"%__WXBASE__\"]        = \"defined(__WXBASE__)\"",
    "type": "statement:assign"
  }, {
    "id": 334,
    "text": "preprocConditionTable[\"%__WXCOCOA__\"]       = \"defined(__WXCOCOA__)\"",
    "type": "statement:assign"
  }, {
    "id": 335,
    "text": "preprocConditionTable[\"%__WXWINCE__\"]       = \"defined(__WXWINCE__)\"",
    "type": "statement:assign"
  }, {
    "id": 336,
    "text": "preprocConditionTable[\"%__WXGTK__\"]         = \"defined(__WXGTK__)\"",
    "type": "statement:assign"
  }, {
    "id": 337,
    "text": "preprocConditionTable[\"%__WXGTK12__\"]       = \"defined(__WXGTK12__)\"",
    "type": "statement:assign"
  }, {
    "id": 338,
    "text": "preprocConditionTable[\"%__WXGTK20__\"]       = \"defined(__WXGTK20__)\"",
    "type": "statement:assign"
  }, {
    "id": 339,
    "text": "preprocConditionTable[\"%__WXMOTIF__\"]       = \"defined(__WXMOTIF__)\"",
    "type": "statement:assign"
  }, {
    "id": 340,
    "text": "preprocConditionTable[\"%__WXMOTIF20__\"]     = \"defined(__WXMOTIF20__)\"",
    "type": "statement:assign"
  }, {
    "id": 341,
    "text": "preprocConditionTable[\"%__WXMAC__\"]         = \"defined(__WXMAC__)\"",
    "type": "statement:assign"
  }, {
    "id": 342,
    "text": "preprocConditionTable[\"%__WXMAC_CLASSIC__\"] = \"defined(__WXMAC_CLASSIC__)\"",
    "type": "statement:assign"
  }, {
    "id": 343,
    "text": "preprocConditionTable[\"%__WXMAC_CARBON__\"]  = \"defined(__WXMAC_CARBON__)\"",
    "type": "statement:assign"
  }, {
    "id": 344,
    "text": "preprocConditionTable[\"%__WXMAC_OSX__\"]     = \"defined(__WXMAC_OSX__)\"",
    "type": "statement:assign"
  }, {
    "id": 345,
    "text": "preprocConditionTable[\"%__WXMGL__\"]         = \"defined(__WXMGL__)\"",
    "type": "statement:assign"
  }, {
    "id": 346,
    "text": "preprocConditionTable[\"%__WXMSW__\"]         = \"defined(__WXMSW__)\"",
    "type": "statement:assign"
  }, {
    "id": 347,
    "text": "preprocConditionTable[\"%__WXOS2__\"]         = \"defined(__WXOS2__)\"",
    "type": "statement:assign"
  }, {
    "id": 348,
    "text": "preprocConditionTable[\"%__WXOSX__\"]         = \"defined(__WXOSX__)\"",
    "type": "statement:assign"
  }, {
    "id": 349,
    "text": "preprocConditionTable[\"%__WXPALMOS__\"]      = \"defined(__WXPALMOS__)\"",
    "type": "statement:assign"
  }, {
    "id": 350,
    "text": "preprocConditionTable[\"%__WXPM__\"]          = \"defined(__WXPM__)\"",
    "type": "statement:assign"
  }, {
    "id": 351,
    "text": "preprocConditionTable[\"%__WXSTUBS__\"]       = \"defined(__WXSTUBS__)\"",
    "type": "statement:assign"
  }, {
    "id": 352,
    "text": "preprocConditionTable[\"%__WXXT__\"]          = \"defined(__WXXT__)\"",
    "type": "statement:assign"
  }, {
    "id": 353,
    "text": "preprocConditionTable[\"%__WXX11__\"]         = \"defined(__WXX11__)\"",
    "type": "statement:assign"
  }, {
    "id": 354,
    "text": "preprocConditionTable[\"%__WXWINE__\"]        = \"defined(__WXWINE__)\"",
    "type": "statement:assign"
  }, {
    "id": 355,
    "text": "preprocConditionTable[\"%__WXUNIVERSAL__\"]   = \"defined(__WXUNIVERSAL__)\"",
    "type": "statement:assign"
  }, {
    "id": 356,
    "text": "preprocConditionTable[\"%__X__\"]             = \"defined(__X__)\"",
    "type": "statement:assign"
  }, {
    "id": 357,
    "text": "preprocConditionTable[\"wxHAS_POWER_EVENTS\"]     = \"defined(wxHAS_POWER_EVENTS)\"",
    "type": "statement:assign"
  }, {
    "id": 358,
    "text": "preprocConditionTable[\"%wxHAS_NATIVE_RENDERER\"] = \"defined(wxHAS_NATIVE_RENDERER)\"",
    "type": "statement:assign"
  }, {
    "id": 359,
    "text": "preprocConditionTable[\"wxUSE_ABOUTDLG\"]                = \"wxUSE_ABOUTDLG\"",
    "type": "statement:assign"
  }, {
    "id": 360,
    "text": "preprocConditionTable[\"wxUSE_ACCEL\"]                   = \"wxUSE_ACCEL\"",
    "type": "statement:assign"
  }, {
    "id": 361,
    "text": "preprocConditionTable[\"wxUSE_ACCESSIBILITY\"]           = \"wxUSE_ACCESSIBILITY\"",
    "type": "statement:assign"
  }, {
    "id": 362,
    "text": "preprocConditionTable[\"wxUSE_AFM_FOR_POSTSCRIPT\"]      = \"wxUSE_AFM_FOR_POSTSCRIPT\"",
    "type": "statement:assign"
  }, {
    "id": 363,
    "text": "preprocConditionTable[\"wxUSE_ANIMATIONCTRL\"]           = \"wxUSE_ANIMATIONCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 364,
    "text": "preprocConditionTable[\"wxUSE_APPLE_IEEE\"]              = \"wxUSE_APPLE_IEEE\"",
    "type": "statement:assign"
  }, {
    "id": 365,
    "text": "preprocConditionTable[\"wxUSE_AUI\"]                     = \"wxUSE_AUI\"",
    "type": "statement:assign"
  }, {
    "id": 366,
    "text": "preprocConditionTable[\"wxUSE_BITMAPCOMBOBOX\"]          = \"wxUSE_BITMAPCOMBOBOX\"",
    "type": "statement:assign"
  }, {
    "id": 367,
    "text": "preprocConditionTable[\"wxUSE_BMPBUTTON\"]               = \"wxUSE_BMPBUTTON\"",
    "type": "statement:assign"
  }, {
    "id": 368,
    "text": "preprocConditionTable[\"wxUSE_BOOKCTRL\"]                = \"wxUSE_BOOKCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 369,
    "text": "preprocConditionTable[\"wxUSE_BUILTIN_IODBC\"]           = \"wxUSE_BUILTIN_IODBC\"",
    "type": "statement:assign"
  }, {
    "id": 370,
    "text": "preprocConditionTable[\"wxUSE_BUSYINFO\"]                = \"wxUSE_BUSYINFO\"",
    "type": "statement:assign"
  }, {
    "id": 371,
    "text": "preprocConditionTable[\"wxUSE_BUTTON\"]                  = \"wxUSE_BUTTON\"",
    "type": "statement:assign"
  }, {
    "id": 372,
    "text": "preprocConditionTable[\"wxUSE_CALENDARCTRL\"]            = \"wxUSE_CALENDARCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 373,
    "text": "preprocConditionTable[\"wxUSE_CARET\"]                   = \"wxUSE_CARET\"",
    "type": "statement:assign"
  }, {
    "id": 374,
    "text": "preprocConditionTable[\"wxUSE_CHECKBOX\"]                = \"wxUSE_CHECKBOX\"",
    "type": "statement:assign"
  }, {
    "id": 375,
    "text": "preprocConditionTable[\"wxUSE_CHECKLISTBOX\"]            = \"wxUSE_CHECKLISTBOX\"",
    "type": "statement:assign"
  }, {
    "id": 376,
    "text": "preprocConditionTable[\"wxUSE_CHOICE\"]                  = \"wxUSE_CHOICE\"",
    "type": "statement:assign"
  }, {
    "id": 377,
    "text": "preprocConditionTable[\"wxUSE_CHOICEBOOK\"]              = \"wxUSE_CHOICEBOOK\"",
    "type": "statement:assign"
  }, {
    "id": 378,
    "text": "preprocConditionTable[\"wxUSE_CHOICEDLG\"]               = \"wxUSE_CHOICEDLG\"",
    "type": "statement:assign"
  }, {
    "id": 379,
    "text": "preprocConditionTable[\"wxUSE_CLIPBOARD\"]               = \"wxUSE_CLIPBOARD\"",
    "type": "statement:assign"
  }, {
    "id": 380,
    "text": "preprocConditionTable[\"wxUSE_CMDLINE_PARSER\"]          = \"wxUSE_CMDLINE_PARSER\"",
    "type": "statement:assign"
  }, {
    "id": 381,
    "text": "preprocConditionTable[\"wxUSE_COLLPANE\"]                = \"wxUSE_COLLPANE\"",
    "type": "statement:assign"
  }, {
    "id": 382,
    "text": "preprocConditionTable[\"wxUSE_COLOURDLG\"]               = \"wxUSE_COLOURDLG\"",
    "type": "statement:assign"
  }, {
    "id": 383,
    "text": "preprocConditionTable[\"wxUSE_COLOURPICKERCTRL\"]        = \"wxUSE_COLOURPICKERCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 384,
    "text": "preprocConditionTable[\"wxUSE_COMBOBOX\"]                = \"wxUSE_COMBOBOX\"",
    "type": "statement:assign"
  }, {
    "id": 385,
    "text": "preprocConditionTable[\"wxUSE_CONFIG\"]                  = \"wxUSE_CONFIG\"",
    "type": "statement:assign"
  }, {
    "id": 386,
    "text": "preprocConditionTable[\"wxUSE_CONSTRAINTS\"]             = \"wxUSE_CONSTRAINTS\"",
    "type": "statement:assign"
  }, {
    "id": 387,
    "text": "preprocConditionTable[\"wxUSE_CONTROLS\"]                = \"wxUSE_CONTROLS\"",
    "type": "statement:assign"
  }, {
    "id": 388,
    "text": "preprocConditionTable[\"wxUSE_DATAOBJ\"]                 = \"wxUSE_DATAOBJ\"",
    "type": "statement:assign"
  }, {
    "id": 389,
    "text": "preprocConditionTable[\"wxUSE_DATEPICKCTRL\"]            = \"wxUSE_DATEPICKCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 390,
    "text": "preprocConditionTable[\"wxUSE_DATETIME\"]                = \"wxUSE_DATETIME\"",
    "type": "statement:assign"
  }, {
    "id": 391,
    "text": "preprocConditionTable[\"wxUSE_DEBUG_CONTEXT\"]           = \"wxUSE_DEBUG_CONTEXT\"",
    "type": "statement:assign"
  }, {
    "id": 392,
    "text": "preprocConditionTable[\"wxUSE_DEBUG_NEW_ALWAYS\"]        = \"wxUSE_DEBUG_NEW_ALWAYS\"",
    "type": "statement:assign"
  }, {
    "id": 393,
    "text": "preprocConditionTable[\"wxUSE_DIALUP_MANAGER\"]          = \"wxUSE_DIALUP_MANAGER\"",
    "type": "statement:assign"
  }, {
    "id": 394,
    "text": "preprocConditionTable[\"wxUSE_DIRDLG\"]                  = \"wxUSE_DIRDLG\"",
    "type": "statement:assign"
  }, {
    "id": 395,
    "text": "preprocConditionTable[\"wxUSE_DIRPICKERCTRL\"]           = \"wxUSE_DIRPICKERCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 396,
    "text": "preprocConditionTable[\"wxUSE_DISPLAY\"]                 = \"wxUSE_DISPLAY\"",
    "type": "statement:assign"
  }, {
    "id": 397,
    "text": "preprocConditionTable[\"wxUSE_DOC_VIEW_ARCHITECTURE\"]   = \"wxUSE_DOC_VIEW_ARCHITECTURE\"",
    "type": "statement:assign"
  }, {
    "id": 398,
    "text": "preprocConditionTable[\"wxUSE_DRAGIMAGE\"]               = \"wxUSE_DRAGIMAGE\"",
    "type": "statement:assign"
  }, {
    "id": 399,
    "text": "preprocConditionTable[\"wxUSE_DRAG_AND_DROP\"]           = \"wxUSE_DRAG_AND_DROP\"",
    "type": "statement:assign"
  }, {
    "id": 400,
    "text": "preprocConditionTable[\"wxUSE_DYNAMIC_CLASSES\"]         = \"wxUSE_DYNAMIC_CLASSES\"",
    "type": "statement:assign"
  }, {
    "id": 401,
    "text": "preprocConditionTable[\"wxUSE_DYNAMIC_LOADER\"]          = \"wxUSE_DYNAMIC_LOADER\"",
    "type": "statement:assign"
  }, {
    "id": 402,
    "text": "preprocConditionTable[\"wxUSE_DYNLIB_CLASS\"]            = \"wxUSE_DYNLIB_CLASS\"",
    "type": "statement:assign"
  }, {
    "id": 403,
    "text": "preprocConditionTable[\"wxUSE_ENH_METAFILE\"]            = \"wxUSE_ENH_METAFILE\"",
    "type": "statement:assign"
  }, {
    "id": 404,
    "text": "preprocConditionTable[\"wxUSE_EXCEPTIONS\"]              = \"wxUSE_EXCEPTIONS\"",
    "type": "statement:assign"
  }, {
    "id": 405,
    "text": "preprocConditionTable[\"wxUSE_EXPERIMENTAL_PRINTF\"]     = \"wxUSE_EXPERIMENTAL_PRINTF\"",
    "type": "statement:assign"
  }, {
    "id": 406,
    "text": "preprocConditionTable[\"wxUSE_FFILE\"]                   = \"wxUSE_FFILE\"",
    "type": "statement:assign"
  }, {
    "id": 407,
    "text": "preprocConditionTable[\"wxUSE_FILE\"]                    = \"wxUSE_FILE\"",
    "type": "statement:assign"
  }, {
    "id": 408,
    "text": "preprocConditionTable[\"wxUSE_FILEDLG\"]                 = \"wxUSE_FILEDLG\"",
    "type": "statement:assign"
  }, {
    "id": 409,
    "text": "preprocConditionTable[\"wxUSE_FILEPICKERCTRL\"]          = \"wxUSE_FILEPICKERCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 410,
    "text": "preprocConditionTable[\"wxUSE_FILESYSTEM\"]              = \"wxUSE_FILESYSTEM\"",
    "type": "statement:assign"
  }, {
    "id": 411,
    "text": "preprocConditionTable[\"wxUSE_FINDREPLDLG\"]             = \"wxUSE_FINDREPLDLG\"",
    "type": "statement:assign"
  }, {
    "id": 412,
    "text": "preprocConditionTable[\"wxUSE_FONTDLG\"]                 = \"wxUSE_FONTDLG\"",
    "type": "statement:assign"
  }, {
    "id": 413,
    "text": "preprocConditionTable[\"wxUSE_FONTMAP\"]                 = \"wxUSE_FONTMAP\"",
    "type": "statement:assign"
  }, {
    "id": 414,
    "text": "preprocConditionTable[\"wxUSE_FONTPICKERCTRL\"]          = \"wxUSE_FONTPICKERCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 415,
    "text": "preprocConditionTable[\"wxUSE_FREETYPE\"]                = \"wxUSE_FREETYPE\"",
    "type": "statement:assign"
  }, {
    "id": 416,
    "text": "preprocConditionTable[\"wxUSE_FSVOLUME\"]                = \"wxUSE_FSVOLUME\"",
    "type": "statement:assign"
  }, {
    "id": 417,
    "text": "preprocConditionTable[\"wxUSE_FS_INET\"]                 = \"wxUSE_FS_INET\"",
    "type": "statement:assign"
  }, {
    "id": 418,
    "text": "preprocConditionTable[\"wxUSE_FS_ZIP\"]                  = \"wxUSE_FS_ZIP\"",
    "type": "statement:assign"
  }, {
    "id": 419,
    "text": "preprocConditionTable[\"wxUSE_GAUGE\"]                   = \"wxUSE_GAUGE\"",
    "type": "statement:assign"
  }, {
    "id": 420,
    "text": "preprocConditionTable[\"wxUSE_GEOMETRY\"]                = \"wxUSE_GEOMETRY\"",
    "type": "statement:assign"
  }, {
    "id": 421,
    "text": "preprocConditionTable[\"wxUSE_GIF\"]                     = \"wxUSE_GIF\"",
    "type": "statement:assign"
  }, {
    "id": 422,
    "text": "preprocConditionTable[\"wxUSE_GLCANVAS\"]                = \"wxUSE_GLCANVAS\"",
    "type": "statement:assign"
  }, {
    "id": 423,
    "text": "preprocConditionTable[\"wxUSE_GLOBAL_MEMORY_OPERATORS\"] = \"wxUSE_GLOBAL_MEMORY_OPERATORS\"",
    "type": "statement:assign"
  }, {
    "id": 424,
    "text": "preprocConditionTable[\"wxUSE_GRID\"]                    = \"wxUSE_GRID\"",
    "type": "statement:assign"
  }, {
    "id": 425,
    "text": "preprocConditionTable[\"wxUSE_GUI\"]                     = \"wxUSE_GUI\"",
    "type": "statement:assign"
  }, {
    "id": 426,
    "text": "preprocConditionTable[\"wxUSE_HELP\"]                    = \"wxUSE_HELP\"",
    "type": "statement:assign"
  }, {
    "id": 427,
    "text": "preprocConditionTable[\"wxUSE_HOTKEY\"]                  = \"wxUSE_HOTKEY\"",
    "type": "statement:assign"
  }, {
    "id": 428,
    "text": "preprocConditionTable[\"wxUSE_HTML\"]                    = \"wxUSE_HTML\"",
    "type": "statement:assign"
  }, {
    "id": 429,
    "text": "preprocConditionTable[\"wxUSE_HYPERLINKCTRL\"]           = \"wxUSE_HYPERLINKCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 430,
    "text": "preprocConditionTable[\"wxUSE_ICO_CUR\"]                 = \"wxUSE_ICO_CUR\"",
    "type": "statement:assign"
  }, {
    "id": 431,
    "text": "preprocConditionTable[\"wxUSE_IFF\"]                     = \"wxUSE_IFF\"",
    "type": "statement:assign"
  }, {
    "id": 432,
    "text": "preprocConditionTable[\"wxUSE_IMAGE\"]                   = \"wxUSE_IMAGE\"",
    "type": "statement:assign"
  }, {
    "id": 433,
    "text": "preprocConditionTable[\"wxUSE_IMAGLIST\"]                = \"wxUSE_IMAGLIST\"",
    "type": "statement:assign"
  }, {
    "id": 434,
    "text": "preprocConditionTable[\"wxUSE_INTL\"]                    = \"wxUSE_INTL\"",
    "type": "statement:assign"
  }, {
    "id": 435,
    "text": "preprocConditionTable[\"wxUSE_IOSTREAMH\"]               = \"wxUSE_IOSTREAMH\"",
    "type": "statement:assign"
  }, {
    "id": 436,
    "text": "preprocConditionTable[\"wxUSE_IPC\"]                     = \"wxUSE_IPC\"",
    "type": "statement:assign"
  }, {
    "id": 437,
    "text": "preprocConditionTable[\"wxUSE_JOYSTICK\"]                = \"wxUSE_JOYSTICK\"",
    "type": "statement:assign"
  }, {
    "id": 438,
    "text": "preprocConditionTable[\"wxUSE_LIBJPEG\"]                 = \"wxUSE_LIBJPEG\"",
    "type": "statement:assign"
  }, {
    "id": 439,
    "text": "preprocConditionTable[\"wxUSE_LIBMSPACK\"]               = \"wxUSE_LIBMSPACK\"",
    "type": "statement:assign"
  }, {
    "id": 440,
    "text": "preprocConditionTable[\"wxUSE_LIBPNG\"]                  = \"wxUSE_LIBPNG\"",
    "type": "statement:assign"
  }, {
    "id": 441,
    "text": "preprocConditionTable[\"wxUSE_LIBSDL\"]                  = \"wxUSE_LIBSDL\"",
    "type": "statement:assign"
  }, {
    "id": 442,
    "text": "preprocConditionTable[\"wxUSE_LIBTIFF\"]                 = \"wxUSE_LIBTIFF\"",
    "type": "statement:assign"
  }, {
    "id": 443,
    "text": "preprocConditionTable[\"wxUSE_LISTBOOK\"]                = \"wxUSE_LISTBOOK\"",
    "type": "statement:assign"
  }, {
    "id": 444,
    "text": "preprocConditionTable[\"wxUSE_LISTBOX\"]                 = \"wxUSE_LISTBOX\"",
    "type": "statement:assign"
  }, {
    "id": 445,
    "text": "preprocConditionTable[\"wxUSE_LISTCTRL\"]                = \"wxUSE_LISTCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 446,
    "text": "preprocConditionTable[\"wxUSE_LOG\"]                     = \"wxUSE_LOG\"",
    "type": "statement:assign"
  }, {
    "id": 447,
    "text": "preprocConditionTable[\"wxUSE_LOGGUI\"]                  = \"wxUSE_LOGGUI\"",
    "type": "statement:assign"
  }, {
    "id": 448,
    "text": "preprocConditionTable[\"wxUSE_LOGWINDOW\"]               = \"wxUSE_LOGWINDOW\"",
    "type": "statement:assign"
  }, {
    "id": 449,
    "text": "preprocConditionTable[\"wxUSE_LOG_DIALOG\"]              = \"wxUSE_LOG_DIALOG\"",
    "type": "statement:assign"
  }, {
    "id": 450,
    "text": "preprocConditionTable[\"wxUSE_LONGLONG\"]                = \"wxUSE_LONGLONG\"",
    "type": "statement:assign"
  }, {
    "id": 451,
    "text": "preprocConditionTable[\"wxUSE_MDI\"]                     = \"wxUSE_MDI\"",
    "type": "statement:assign"
  }, {
    "id": 452,
    "text": "preprocConditionTable[\"wxUSE_MDI_ARCHITECTURE\"]        = \"wxUSE_MDI_ARCHITECTURE\"",
    "type": "statement:assign"
  }, {
    "id": 453,
    "text": "preprocConditionTable[\"wxUSE_MEDIACTRL\"]               = \"wxUSE_MEDIACTRL\"",
    "type": "statement:assign"
  }, {
    "id": 454,
    "text": "preprocConditionTable[\"wxUSE_MEMORY_TRACING\"]          = \"wxUSE_MEMORY_TRACING\"",
    "type": "statement:assign"
  }, {
    "id": 455,
    "text": "preprocConditionTable[\"wxUSE_MENUS\"]                   = \"wxUSE_MENUS\"",
    "type": "statement:assign"
  }, {
    "id": 456,
    "text": "preprocConditionTable[\"wxUSE_METAFILE\"]                = \"wxUSE_METAFILE\"",
    "type": "statement:assign"
  }, {
    "id": 457,
    "text": "preprocConditionTable[\"wxUSE_MIMETYPE\"]                = \"wxUSE_MIMETYPE\"",
    "type": "statement:assign"
  }, {
    "id": 458,
    "text": "preprocConditionTable[\"wxUSE_MINIFRAME\"]               = \"wxUSE_MINIFRAME\"",
    "type": "statement:assign"
  }, {
    "id": 459,
    "text": "preprocConditionTable[\"wxUSE_MOUSEWHEEL\"]              = \"wxUSE_MOUSEWHEEL\"",
    "type": "statement:assign"
  }, {
    "id": 460,
    "text": "preprocConditionTable[\"wxUSE_MSGDLG\"]                  = \"wxUSE_MSGDLG\"",
    "type": "statement:assign"
  }, {
    "id": 461,
    "text": "preprocConditionTable[\"wxUSE_MS_HTML_HELP\"]            = \"wxUSE_MS_HTML_HELP\"",
    "type": "statement:assign"
  }, {
    "id": 462,
    "text": "preprocConditionTable[\"wxUSE_NANOX\"]                   = \"wxUSE_NANOX\"",
    "type": "statement:assign"
  }, {
    "id": 463,
    "text": "preprocConditionTable[\"wxUSE_NATIVE_STATUSBAR\"]        = \"wxUSE_NATIVE_STATUSBAR\"",
    "type": "statement:assign"
  }, {
    "id": 464,
    "text": "preprocConditionTable[\"wxUSE_NEW_GRID\"]                = \"wxUSE_NEW_GRID\"",
    "type": "statement:assign"
  }, {
    "id": 465,
    "text": "preprocConditionTable[\"wxUSE_NOGUI\"]                   = \"wxUSE_NOGUI\"",
    "type": "statement:assign"
  }, {
    "id": 466,
    "text": "preprocConditionTable[\"wxUSE_NORMALIZED_PS_FONTS\"]     = \"wxUSE_NORMALIZED_PS_FONTS\"",
    "type": "statement:assign"
  }, {
    "id": 467,
    "text": "preprocConditionTable[\"wxUSE_NOTEBOOK\"]                = \"wxUSE_NOTEBOOK\"",
    "type": "statement:assign"
  }, {
    "id": 468,
    "text": "preprocConditionTable[\"wxUSE_NUMBERDLG\"]               = \"wxUSE_NUMBERDLG\"",
    "type": "statement:assign"
  }, {
    "id": 469,
    "text": "preprocConditionTable[\"wxUSE_ODBC\"]                    = \"wxUSE_ODBC\"",
    "type": "statement:assign"
  }, {
    "id": 470,
    "text": "preprocConditionTable[\"wxUSE_OLE\"]                     = \"wxUSE_OLE\"",
    "type": "statement:assign"
  }, {
    "id": 471,
    "text": "preprocConditionTable[\"wxUSE_ON_FATAL_EXCEPTION\"]      = \"wxUSE_ON_FATAL_EXCEPTION\"",
    "type": "statement:assign"
  }, {
    "id": 472,
    "text": "preprocConditionTable[\"wxUSE_OPENGL\"]                  = \"wxUSE_OPENGL\"",
    "type": "statement:assign"
  }, {
    "id": 473,
    "text": "preprocConditionTable[\"wxUSE_OWNER_DRAWN\"]             = \"wxUSE_OWNER_DRAWN\"",
    "type": "statement:assign"
  }, {
    "id": 474,
    "text": "preprocConditionTable[\"wxUSE_PALETTE\"]                 = \"wxUSE_PALETTE\"",
    "type": "statement:assign"
  }, {
    "id": 475,
    "text": "preprocConditionTable[\"wxUSE_PCX\"]                     = \"wxUSE_PCX\"",
    "type": "statement:assign"
  }, {
    "id": 476,
    "text": "preprocConditionTable[\"wxUSE_PLUGINS\"]                 = \"wxUSE_PLUGINS\"",
    "type": "statement:assign"
  }, {
    "id": 477,
    "text": "preprocConditionTable[\"wxUSE_PNM\"]                     = \"wxUSE_PNM\"",
    "type": "statement:assign"
  }, {
    "id": 478,
    "text": "preprocConditionTable[\"wxUSE_POPUPWIN\"]                = \"wxUSE_POPUPWIN\"",
    "type": "statement:assign"
  }, {
    "id": 479,
    "text": "preprocConditionTable[\"wxUSE_POSTSCRIPT\"]              = \"wxUSE_POSTSCRIPT\"",
    "type": "statement:assign"
  }, {
    "id": 480,
    "text": "preprocConditionTable[\"wxUSE_PRINTING_ARCHITECTURE\"]   = \"wxUSE_PRINTING_ARCHITECTURE\"",
    "type": "statement:assign"
  }, {
    "id": 481,
    "text": "preprocConditionTable[\"wxUSE_PROGRESSDLG\"]             = \"wxUSE_PROGRESSDLG\"",
    "type": "statement:assign"
  }, {
    "id": 482,
    "text": "preprocConditionTable[\"wxUSE_PROLOGIO\"]                = \"wxUSE_PROLOGIO\"",
    "type": "statement:assign"
  }, {
    "id": 483,
    "text": "preprocConditionTable[\"wxUSE_PROPSHEET\"]               = \"wxUSE_PROPSHEET\"",
    "type": "statement:assign"
  }, {
    "id": 484,
    "text": "preprocConditionTable[\"wxUSE_PROTOCOL\"]                = \"wxUSE_PROTOCOL\"",
    "type": "statement:assign"
  }, {
    "id": 485,
    "text": "preprocConditionTable[\"wxUSE_PROTOCOL_FILE\"]           = \"wxUSE_PROTOCOL_FILE\"",
    "type": "statement:assign"
  }, {
    "id": 486,
    "text": "preprocConditionTable[\"wxUSE_PROTOCOL_FTP\"]            = \"wxUSE_PROTOCOL_FTP\"",
    "type": "statement:assign"
  }, {
    "id": 487,
    "text": "preprocConditionTable[\"wxUSE_PROTOCOL_HTTP\"]           = \"wxUSE_PROTOCOL_HTTP\"",
    "type": "statement:assign"
  }, {
    "id": 488,
    "text": "preprocConditionTable[\"wxUSE_RADIOBOX\"]                = \"wxUSE_RADIOBOX\"",
    "type": "statement:assign"
  }, {
    "id": 489,
    "text": "preprocConditionTable[\"wxUSE_RADIOBTN\"]                = \"wxUSE_RADIOBTN\"",
    "type": "statement:assign"
  }, {
    "id": 490,
    "text": "preprocConditionTable[\"wxUSE_REGEX\"]                   = \"wxUSE_REGEX\"",
    "type": "statement:assign"
  }, {
    "id": 491,
    "text": "preprocConditionTable[\"wxUSE_RESOURCES\"]               = \"wxUSE_RESOURCES\"",
    "type": "statement:assign"
  }, {
    "id": 492,
    "text": "preprocConditionTable[\"wxUSE_RICHEDIT\"]                = \"wxUSE_RICHEDIT\"",
    "type": "statement:assign"
  }, {
    "id": 493,
    "text": "preprocConditionTable[\"wxUSE_RICHTEXT\"]                = \"wxUSE_RICHTEXT\"",
    "type": "statement:assign"
  }, {
    "id": 494,
    "text": "preprocConditionTable[\"wxUSE_SASH\"]                    = \"wxUSE_SASH\"",
    "type": "statement:assign"
  }, {
    "id": 495,
    "text": "preprocConditionTable[\"wxUSE_SCROLLBAR\"]               = \"wxUSE_SCROLLBAR\"",
    "type": "statement:assign"
  }, {
    "id": 496,
    "text": "preprocConditionTable[\"wxUSE_SLIDER\"]                  = \"wxUSE_SLIDER\"",
    "type": "statement:assign"
  }, {
    "id": 497,
    "text": "preprocConditionTable[\"wxUSE_SNGLINST_CHECKER\"]        = \"wxUSE_SNGLINST_CHECKER\"",
    "type": "statement:assign"
  }, {
    "id": 498,
    "text": "preprocConditionTable[\"wxUSE_SOCKETS\"]                 = \"wxUSE_SOCKETS\"",
    "type": "statement:assign"
  }, {
    "id": 499,
    "text": "preprocConditionTable[\"wxUSE_SOUND\"]                   = \"wxUSE_SOUND\"",
    "type": "statement:assign"
  }, {
    "id": 500,
    "text": "preprocConditionTable[\"wxUSE_SPINBTN\"]                 = \"wxUSE_SPINBTN\"",
    "type": "statement:assign"
  }, {
    "id": 501,
    "text": "preprocConditionTable[\"wxUSE_SPINCTRL\"]                = \"wxUSE_SPINCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 502,
    "text": "preprocConditionTable[\"wxUSE_SPLASH\"]                  = \"wxUSE_SPLASH\"",
    "type": "statement:assign"
  }, {
    "id": 503,
    "text": "preprocConditionTable[\"wxUSE_SPLINES\"]                 = \"wxUSE_SPLINES\"",
    "type": "statement:assign"
  }, {
    "id": 504,
    "text": "preprocConditionTable[\"wxUSE_SPLITTER\"]                = \"wxUSE_SPLITTER\"",
    "type": "statement:assign"
  }, {
    "id": 505,
    "text": "preprocConditionTable[\"wxUSE_STARTUP_TIPS\"]            = \"wxUSE_STARTUP_TIPS\"",
    "type": "statement:assign"
  }, {
    "id": 506,
    "text": "preprocConditionTable[\"wxUSE_STATBMP\"]                 = \"wxUSE_STATBMP\"",
    "type": "statement:assign"
  }, {
    "id": 507,
    "text": "preprocConditionTable[\"wxUSE_STATBOX\"]                 = \"wxUSE_STATBOX\"",
    "type": "statement:assign"
  }, {
    "id": 508,
    "text": "preprocConditionTable[\"wxUSE_STATLINE\"]                = \"wxUSE_STATLINE\"",
    "type": "statement:assign"
  }, {
    "id": 509,
    "text": "preprocConditionTable[\"wxUSE_STATTEXT\"]                = \"wxUSE_STATTEXT\"",
    "type": "statement:assign"
  }, {
    "id": 510,
    "text": "preprocConditionTable[\"wxUSE_STATUSBAR\"]               = \"wxUSE_STATUSBAR\"",
    "type": "statement:assign"
  }, {
    "id": 511,
    "text": "preprocConditionTable[\"wxUSE_STD_IOSTREAM\"]            = \"wxUSE_STD_IOSTREAM\"",
    "type": "statement:assign"
  }, {
    "id": 512,
    "text": "preprocConditionTable[\"wxUSE_STL\"]                     = \"wxUSE_STL\"",
    "type": "statement:assign"
  }, {
    "id": 513,
    "text": "preprocConditionTable[\"wxUSE_STOPWATCH\"]               = \"wxUSE_STOPWATCH\"",
    "type": "statement:assign"
  }, {
    "id": 514,
    "text": "preprocConditionTable[\"wxUSE_STREAMS\"]                 = \"wxUSE_STREAMS\"",
    "type": "statement:assign"
  }, {
    "id": 515,
    "text": "preprocConditionTable[\"wxUSE_SYSTEM_OPTIONS\"]          = \"wxUSE_SYSTEM_OPTIONS\"",
    "type": "statement:assign"
  }, {
    "id": 516,
    "text": "preprocConditionTable[\"wxUSE_TABDIALOG\"]               = \"wxUSE_TABDIALOG\"",
    "type": "statement:assign"
  }, {
    "id": 517,
    "text": "preprocConditionTable[\"wxUSE_TAB_DIALOG\"]              = \"wxUSE_TAB_DIALOG\"",
    "type": "statement:assign"
  }, {
    "id": 518,
    "text": "preprocConditionTable[\"wxUSE_TEXTBUFFER\"]              = \"wxUSE_TEXTBUFFER\"",
    "type": "statement:assign"
  }, {
    "id": 519,
    "text": "preprocConditionTable[\"wxUSE_TEXTCTRL\"]                = \"wxUSE_TEXTCTRL\"",
    "type": "statement:assign"
  }, {
    "id": 520,
    "text": "preprocConditionTable[\"wxUSE_TEXTDLG\"]                 = \"wxUSE_TEXTDLG\"",
    "type": "statement:assign"
  }, {
    "id": 521,
    "text": "preprocConditionTable[\"wxUSE_TEXTFILE\"]                = \"wxUSE_TEXTFILE\"",
    "type": "statement:assign"
  }, {
    "id": 522,
    "text": "preprocConditionTable[\"wxUSE_TGA\"]                     = \"wxUSE_TGA\"",
    "type": "statement:assign"
  }, {
    "id": 523,
    "text": "preprocConditionTable[\"wxUSE_THREADS\"]                 = \"wxUSE_THREADS\"",
    "type": "statement:assign"
  }, {
    "id": 524,
    "text": "preprocConditionTable[\"wxUSE_TIMEDATE\"]                = \"wxUSE_TIMEDATE\"",
    "type": "statement:assign"
  }, {
    "id": 525,
    "text": "preprocConditionTable[\"wxUSE_TIMER\"]                   = \"wxUSE_TIMER\"",
    "type": "statement:assign"
  }, {
    "id": 526,
    "text": "preprocConditionTable[\"wxUSE_TIPWINDOW\"]               = \"wxUSE_TIPWINDOW\"",
    "type": "statement:assign"
  }, {
    "id": 527,
    "text": "preprocConditionTable[\"wxUSE_TOGGLEBTN\"]               = \"wxUSE_TOGGLEBTN\"",
    "type": "statement:assign"
  }, {
    "id": 528,
    "text": "preprocConditionTable[\"wxUSE_TOOLBAR\"]                 = \"wxUSE_TOOLBAR\"",
    "type": "statement:assign"
  }, {
    "id": 529,
    "text": "preprocConditionTable[\"wxUSE_TOOLBAR_NATIVE\"]          = \"wxUSE_TOOLBAR_NATIVE\"",
    "type": "statement:assign"
  }, {
    "id": 530,
    "text": "preprocConditionTable[\"wxUSE_TOOLBOOK\"]                = \"wxUSE_TOOLBOOK\"",
    "type": "statement:assign"
  }, {
    "id": 531,
    "text": "preprocConditionTable[\"wxUSE_TOOLTIPS\"]                = \"wxUSE_TOOLTIPS\"",
    "type": "statement:assign"
  }, {
    "id": 532,
    "text": "preprocConditionTable[\"wxUSE_TREEBOOK\"]                = \"wxUSE_TREEBOOK\"",
    "type": "statement:assign"
  }, {
    "id": 533,
    "text": "preprocConditionTable[\"wxUSE_TREECTRL\"]                = \"wxUSE_TREECTRL\"",
    "type": "statement:assign"
  }, {
    "id": 534,
    "text": "preprocConditionTable[\"wxUSE_TREELAYOUT\"]              = \"wxUSE_TREELAYOUT\"",
    "type": "statement:assign"
  }, {
    "id": 535,
    "text": "preprocConditionTable[\"wxUSE_UNICODE\"]                 = \"wxUSE_UNICODE\"",
    "type": "statement:assign"
  }, {
    "id": 536,
    "text": "preprocConditionTable[\"wxUSE_UNICODE_MSLU\"]            = \"wxUSE_UNICODE_MSLU\"",
    "type": "statement:assign"
  }, {
    "id": 537,
    "text": "preprocConditionTable[\"wxUSE_UNIX\"]                    = \"wxUSE_UNIX\"",
    "type": "statement:assign"
  }, {
    "id": 538,
    "text": "preprocConditionTable[\"wxUSE_URL\"]                     = \"wxUSE_URL\"",
    "type": "statement:assign"
  }, {
    "id": 539,
    "text": "preprocConditionTable[\"wxUSE_UXTHEME\"]                 = \"wxUSE_UXTHEME\"",
    "type": "statement:assign"
  }, {
    "id": 540,
    "text": "preprocConditionTable[\"wxUSE_UXTHEME_AUTO\"]            = \"wxUSE_UXTHEME_AUTO\"",
    "type": "statement:assign"
  }, {
    "id": 541,
    "text": "preprocConditionTable[\"wxUSE_VALIDATORS\"]              = \"wxUSE_VALIDATORS\"",
    "type": "statement:assign"
  }, {
    "id": 542,
    "text": "preprocConditionTable[\"wxUSE_WAVE\"]                    = \"wxUSE_WAVE\"",
    "type": "statement:assign"
  }, {
    "id": 543,
    "text": "preprocConditionTable[\"wxUSE_WCHAR_T\"]                 = \"wxUSE_WCHAR_T\"",
    "type": "statement:assign"
  }, {
    "id": 544,
    "text": "preprocConditionTable[\"wxUSE_WCSRTOMBS\"]               = \"wxUSE_WCSRTOMBS\"",
    "type": "statement:assign"
  }, {
    "id": 545,
    "text": "preprocConditionTable[\"wxUSE_WIZARDDLG\"]               = \"wxUSE_WIZARDDLG\"",
    "type": "statement:assign"
  }, {
    "id": 546,
    "text": "preprocConditionTable[\"wxUSE_WXHTML_HELP\"]             = \"wxUSE_WXHTML_HELP\"",
    "type": "statement:assign"
  }, {
    "id": 547,
    "text": "preprocConditionTable[\"wxUSE_WX_RESOURCES\"]            = \"wxUSE_WX_RESOURCES\"",
    "type": "statement:assign"
  }, {
    "id": 548,
    "text": "preprocConditionTable[\"wxUSE_XML\"]                     = \"wxUSE_XML\"",
    "type": "statement:assign"
  }, {
    "id": 549,
    "text": "preprocConditionTable[\"wxUSE_XPM\"]                     = \"wxUSE_XPM\"",
    "type": "statement:assign"
  }, {
    "id": 550,
    "text": "preprocConditionTable[\"wxUSE_XPM_IN_MSW\"]              = \"wxUSE_XPM_IN_MSW\"",
    "type": "statement:assign"
  }, {
    "id": 551,
    "text": "preprocConditionTable[\"wxUSE_XRC\"]                     = \"wxUSE_XRC\"",
    "type": "statement:assign"
  }, {
    "id": 552,
    "text": "preprocConditionTable[\"wxUSE_X_RESOURCES\"]             = \"wxUSE_X_RESOURCES\"",
    "type": "statement:assign"
  }, {
    "id": 553,
    "text": "preprocConditionTable[\"wxUSE_ZIPSTREAM\"]               = \"wxUSE_ZIPSTREAM\"",
    "type": "statement:assign"
  }, {
    "id": 554,
    "text": "preprocConditionTable[\"wxUSE_ZLIB\"]                    = \"wxUSE_ZLIB\"",
    "type": "statement:assign"
  }, {
    "id": 555,
    "text": "preprocConditionTable[\"wxLUA_USE_FL\"]                      = \"wxLUA_USE_FL\"",
    "type": "statement:assign"
  }, {
    "id": 556,
    "text": "preprocConditionTable[\"wxLUA_USE_Geometry\"]                = \"wxLUA_USE_Geometry\"",
    "type": "statement:assign"
  }, {
    "id": 557,
    "text": "preprocConditionTable[\"wxLUA_USE_MDI\"]                     = \"wxLUA_USE_MDI\"",
    "type": "statement:assign"
  }, {
    "id": 558,
    "text": "preprocConditionTable[\"wxLUA_USE_wxAboutDialog\"]           = \"wxLUA_USE_wxAboutDialog\"",
    "type": "statement:assign"
  }, {
    "id": 559,
    "text": "preprocConditionTable[\"wxLUA_USE_wxAcceleratorTable\"]      = \"wxLUA_USE_wxAcceleratorTable\"",
    "type": "statement:assign"
  }, {
    "id": 560,
    "text": "preprocConditionTable[\"wxLUA_USE_wxAnimation\"]             = \"wxLUA_USE_wxAnimation\"",
    "type": "statement:assign"
  }, {
    "id": 561,
    "text": "preprocConditionTable[\"wxLUA_USE_wxApp\"]                   = \"wxLUA_USE_wxApp\"",
    "type": "statement:assign"
  }, {
    "id": 562,
    "text": "preprocConditionTable[\"wxLUA_USE_wxArrayInt\"]              = \"wxLUA_USE_wxArrayInt\"",
    "type": "statement:assign"
  }, {
    "id": 563,
    "text": "preprocConditionTable[\"wxLUA_USE_wxArrayString\"]           = \"wxLUA_USE_wxArrayString\"",
    "type": "statement:assign"
  }, {
    "id": 564,
    "text": "preprocConditionTable[\"wxLUA_USE_wxArtProvider\"]           = \"wxLUA_USE_wxArtProvider\"",
    "type": "statement:assign"
  }, {
    "id": 565,
    "text": "preprocConditionTable[\"wxLUA_USE_wxAUI\"]                   = \"wxLUA_USE_wxAUI\"",
    "type": "statement:assign"
  }, {
    "id": 566,
    "text": "preprocConditionTable[\"wxLUA_USE_wxBitmap\"]                = \"wxLUA_USE_wxBitmap\"",
    "type": "statement:assign"
  }, {
    "id": 567,
    "text": "preprocConditionTable[\"wxLUA_USE_wxBitmapComboBox\"]        = \"wxLUA_USE_wxBitmapComboBox\"",
    "type": "statement:assign"
  }, {
    "id": 568,
    "text": "preprocConditionTable[\"wxLUA_USE_wxBitmapButton\"]          = \"wxLUA_USE_wxBitmapButton\"",
    "type": "statement:assign"
  }, {
    "id": 569,
    "text": "preprocConditionTable[\"wxLUA_USE_wxBrushList\"]             = \"wxLUA_USE_wxBrushList\"",
    "type": "statement:assign"
  }, {
    "id": 570,
    "text": "preprocConditionTable[\"wxLUA_USE_wxBusyCursor\"]            = \"wxLUA_USE_wxBusyCursor\"",
    "type": "statement:assign"
  }, {
    "id": 571,
    "text": "preprocConditionTable[\"wxLUA_USE_wxBusyInfo\"]              = \"wxLUA_USE_wxBusyInfo\"",
    "type": "statement:assign"
  }, {
    "id": 572,
    "text": "preprocConditionTable[\"wxLUA_USE_wxButton\"]                = \"wxLUA_USE_wxButton\"",
    "type": "statement:assign"
  }, {
    "id": 573,
    "text": "preprocConditionTable[\"wxLUA_USE_wxCalendarCtrl\"]          = \"wxLUA_USE_wxCalendarCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 574,
    "text": "preprocConditionTable[\"wxLUA_USE_wxCaret\"]                 = \"wxLUA_USE_wxCaret\"",
    "type": "statement:assign"
  }, {
    "id": 575,
    "text": "preprocConditionTable[\"wxLUA_USE_wxCheckBox\"]              = \"wxLUA_USE_wxCheckBox\"",
    "type": "statement:assign"
  }, {
    "id": 576,
    "text": "preprocConditionTable[\"wxLUA_USE_wxCheckListBox\"]          = \"wxLUA_USE_wxCheckListBox\"",
    "type": "statement:assign"
  }, {
    "id": 577,
    "text": "preprocConditionTable[\"wxLUA_USE_wxChoice\"]                = \"wxLUA_USE_wxChoice\"",
    "type": "statement:assign"
  }, {
    "id": 578,
    "text": "preprocConditionTable[\"wxLUA_USE_wxClassInfo\"]             = \"wxLUA_USE_wxClassInfo\"",
    "type": "statement:assign"
  }, {
    "id": 579,
    "text": "preprocConditionTable[\"wxLUA_USE_wxClipboard\"]             = \"wxLUA_USE_wxClipboard\"",
    "type": "statement:assign"
  }, {
    "id": 580,
    "text": "preprocConditionTable[\"wxLUA_USE_wxCollapsiblePane\"]       = \"wxLUA_USE_wxCollapsiblePane\"",
    "type": "statement:assign"
  }, {
    "id": 581,
    "text": "preprocConditionTable[\"wxLUA_USE_wxColourDialog\"]          = \"wxLUA_USE_wxColourDialog\"",
    "type": "statement:assign"
  }, {
    "id": 582,
    "text": "preprocConditionTable[\"wxLUA_USE_wxColourPenBrush\"]        = \"wxLUA_USE_wxColourPenBrush\"",
    "type": "statement:assign"
  }, {
    "id": 583,
    "text": "preprocConditionTable[\"wxLUA_USE_wxColourPickerCtrl\"]      = \"wxLUA_USE_wxColourPickerCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 584,
    "text": "preprocConditionTable[\"wxLUA_USE_wxComboBox\"]              = \"wxLUA_USE_wxComboBox\"",
    "type": "statement:assign"
  }, {
    "id": 585,
    "text": "preprocConditionTable[\"wxLUA_USE_wxCommandProcessor\"]      = \"wxLUA_USE_wxCommandProcessor\"",
    "type": "statement:assign"
  }, {
    "id": 586,
    "text": "preprocConditionTable[\"wxLUA_USE_wxConfig\"]                = \"wxLUA_USE_wxConfig\"",
    "type": "statement:assign"
  }, {
    "id": 587,
    "text": "preprocConditionTable[\"wxLUA_USE_wxCursor\"]                = \"wxLUA_USE_wxCursor\"",
    "type": "statement:assign"
  }, {
    "id": 588,
    "text": "preprocConditionTable[\"wxLUA_USE_wxCriticalSection\"]       = \"wxLUA_USE_wxCriticalSection\"",
    "type": "statement:assign"
  }, {
    "id": 589,
    "text": "preprocConditionTable[\"wxLUA_USE_wxCriticalSectionLocker\"] = \"wxLUA_USE_wxCriticalSectionLocker\"",
    "type": "statement:assign"
  }, {
    "id": 590,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDataObject\"]            = \"wxLUA_USE_wxDataObject\"",
    "type": "statement:assign"
  }, {
    "id": 591,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDatePickerCtrl\"]        = \"wxLUA_USE_wxDatePickerCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 592,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDateSpan\"]              = \"wxLUA_USE_wxDateSpan\"",
    "type": "statement:assign"
  }, {
    "id": 593,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDateTime\"]              = \"wxLUA_USE_wxDateTime\"",
    "type": "statement:assign"
  }, {
    "id": 594,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDateTimeHolidayAuthority\"] = \"wxLUA_USE_wxDateTimeHolidayAuthority\"",
    "type": "statement:assign"
  }, {
    "id": 595,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDC\"]                    = \"wxLUA_USE_wxDC\"",
    "type": "statement:assign"
  }, {
    "id": 596,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDialog\"]                = \"wxLUA_USE_wxDialog\"",
    "type": "statement:assign"
  }, {
    "id": 597,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDir\"]                   = \"wxLUA_USE_wxDir\"",
    "type": "statement:assign"
  }, {
    "id": 598,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDirDialog\"]             = \"wxLUA_USE_wxDirDialog\"",
    "type": "statement:assign"
  }, {
    "id": 599,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDirPickerCtrl\"]         = \"wxLUA_USE_wxDirPickerCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 600,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDisplay\"]               = \"wxLUA_USE_wxDisplay\"",
    "type": "statement:assign"
  }, {
    "id": 601,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDragDrop\"]              = \"wxLUA_USE_wxDragDrop\"",
    "type": "statement:assign"
  }, {
    "id": 602,
    "text": "preprocConditionTable[\"wxLUA_USE_wxDynamicLibrary\"]        = \"wxLUA_USE_wxDynamicLibrary\"",
    "type": "statement:assign"
  }, {
    "id": 603,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFile\"]                  = \"wxLUA_USE_wxFile\"",
    "type": "statement:assign"
  }, {
    "id": 604,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFileDialog\"]            = \"wxLUA_USE_wxFileDialog\"",
    "type": "statement:assign"
  }, {
    "id": 605,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFileHistory\"]           = \"wxLUA_USE_wxFileHistory\"",
    "type": "statement:assign"
  }, {
    "id": 606,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFileName\"]              = \"wxLUA_USE_wxFileName\"",
    "type": "statement:assign"
  }, {
    "id": 607,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFilePickerCtrl\"]        = \"wxLUA_USE_wxFilePickerCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 608,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFindReplaceDialog\"]     = \"wxLUA_USE_wxFindReplaceDialog\"",
    "type": "statement:assign"
  }, {
    "id": 609,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFont\"]                  = \"wxLUA_USE_wxFont\"",
    "type": "statement:assign"
  }, {
    "id": 610,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFontDialog\"]            = \"wxLUA_USE_wxFontDialog\"",
    "type": "statement:assign"
  }, {
    "id": 611,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFontEnumerator\"]        = \"wxLUA_USE_wxFontEnumerator\"",
    "type": "statement:assign"
  }, {
    "id": 612,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFontList\"]              = \"wxLUA_USE_wxFontList\"",
    "type": "statement:assign"
  }, {
    "id": 613,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFontMapper\"]            = \"wxLUA_USE_wxFontMapper\"",
    "type": "statement:assign"
  }, {
    "id": 614,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFontPickerCtrl\"]        = \"wxLUA_USE_wxFontPickerCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 615,
    "text": "preprocConditionTable[\"wxLUA_USE_wxFrame\"]                 = \"wxLUA_USE_wxFrame\"",
    "type": "statement:assign"
  }, {
    "id": 616,
    "text": "preprocConditionTable[\"wxLUA_USE_wxGauge\"]                 = \"wxLUA_USE_wxGauge\"",
    "type": "statement:assign"
  }, {
    "id": 617,
    "text": "preprocConditionTable[\"wxLUA_USE_wxGenericDirCtrl\"]        = \"wxLUA_USE_wxGenericDirCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 618,
    "text": "preprocConditionTable[\"wxLUA_USE_wxGenericValidator\"]      = \"wxLUA_USE_wxGenericValidator\"",
    "type": "statement:assign"
  }, {
    "id": 619,
    "text": "preprocConditionTable[\"wxLUA_USE_wxGLCanvas\"]              = \"wxLUA_USE_wxGLCanvas\"",
    "type": "statement:assign"
  }, {
    "id": 620,
    "text": "preprocConditionTable[\"wxLUA_USE_wxGrid\"]                  = \"wxLUA_USE_wxGrid\"",
    "type": "statement:assign"
  }, {
    "id": 621,
    "text": "preprocConditionTable[\"wxLUA_USE_wxHashTable\"]             = \"wxLUA_USE_wxHashTable\"",
    "type": "statement:assign"
  }, {
    "id": 622,
    "text": "preprocConditionTable[\"wxLUA_USE_wxHelpController\"]        = \"wxLUA_USE_wxHelpController\"",
    "type": "statement:assign"
  }, {
    "id": 623,
    "text": "preprocConditionTable[\"wxLUA_USE_wxHTML\"]                  = \"wxLUA_USE_wxHTML\"",
    "type": "statement:assign"
  }, {
    "id": 624,
    "text": "preprocConditionTable[\"wxLUA_USE_wxHtmlHelpController\"]    = \"wxLUA_USE_wxHtmlHelpController\"",
    "type": "statement:assign"
  }, {
    "id": 625,
    "text": "preprocConditionTable[\"wxLUA_USE_wxHyperlinkCtrl\"]         = \"wxLUA_USE_wxHyperlinkCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 626,
    "text": "preprocConditionTable[\"wxLUA_USE_wxIcon\"]                  = \"wxLUA_USE_wxIcon\"",
    "type": "statement:assign"
  }, {
    "id": 627,
    "text": "preprocConditionTable[\"wxLUA_USE_wxID_XXX\"]                = \"wxLUA_USE_wxID_XXX\"",
    "type": "statement:assign"
  }, {
    "id": 628,
    "text": "preprocConditionTable[\"wxLUA_USE_wxImage\"]                 = \"wxLUA_USE_wxImage\"",
    "type": "statement:assign"
  }, {
    "id": 629,
    "text": "preprocConditionTable[\"wxLUA_USE_wxImageList\"]             = \"wxLUA_USE_wxImageList\"",
    "type": "statement:assign"
  }, {
    "id": 630,
    "text": "preprocConditionTable[\"wxLUA_USE_wxJoystick\"]              = \"wxLUA_USE_wxJoystick\"",
    "type": "statement:assign"
  }, {
    "id": 631,
    "text": "preprocConditionTable[\"wxLUA_USE_wxLayoutConstraints\"]     = \"wxLUA_USE_wxLayoutConstraints\"",
    "type": "statement:assign"
  }, {
    "id": 632,
    "text": "preprocConditionTable[\"wxLUA_USE_wxList\"]                  = \"wxLUA_USE_wxList\"",
    "type": "statement:assign"
  }, {
    "id": 633,
    "text": "preprocConditionTable[\"wxLUA_USE_wxListBox\"]               = \"wxLUA_USE_wxListBox\"",
    "type": "statement:assign"
  }, {
    "id": 634,
    "text": "preprocConditionTable[\"wxLUA_USE_wxListCtrl\"]              = \"wxLUA_USE_wxListCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 635,
    "text": "preprocConditionTable[\"wxLUA_USE_wxLog\"]                   = \"wxLUA_USE_wxLog\"",
    "type": "statement:assign"
  }, {
    "id": 636,
    "text": "preprocConditionTable[\"wxLUA_USE_wxLogWindow\"]             = \"wxLUA_USE_wxLogWindow\"",
    "type": "statement:assign"
  }, {
    "id": 637,
    "text": "preprocConditionTable[\"wxLUA_USE_wxLuaHtmlWindow\"]         = \"wxLUA_USE_wxLuaHtmlWindow\"",
    "type": "statement:assign"
  }, {
    "id": 638,
    "text": "preprocConditionTable[\"wxLUA_USE_wxLuaPrintout\"]           = \"wxLUA_USE_wxLuaPrintout\"",
    "type": "statement:assign"
  }, {
    "id": 639,
    "text": "preprocConditionTable[\"wxLUA_USE_wxMask\"]                  = \"wxLUA_USE_wxMask\"",
    "type": "statement:assign"
  }, {
    "id": 640,
    "text": "preprocConditionTable[\"wxLUA_USE_wxMediaCtrl\"]             = \"wxLUA_USE_wxMediaCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 641,
    "text": "preprocConditionTable[\"wxLUA_USE_wxMenu\"]                  = \"wxLUA_USE_wxMenu\"",
    "type": "statement:assign"
  }, {
    "id": 642,
    "text": "preprocConditionTable[\"wxLUA_USE_wxMessageDialog\"]         = \"wxLUA_USE_wxMessageDialog\"",
    "type": "statement:assign"
  }, {
    "id": 643,
    "text": "preprocConditionTable[\"wxLUA_USE_wxMetafile\"]              = \"wxLUA_USE_wxMetafile\"",
    "type": "statement:assign"
  }, {
    "id": 644,
    "text": "preprocConditionTable[\"wxLUA_USE_wxMiniFrame\"]             = \"wxLUA_USE_wxMiniFrame\"",
    "type": "statement:assign"
  }, {
    "id": 645,
    "text": "preprocConditionTable[\"wxLUA_USE_wxMultiChoiceDialog\"]     = \"wxLUA_USE_wxMultiChoiceDialog\"",
    "type": "statement:assign"
  }, {
    "id": 646,
    "text": "preprocConditionTable[\"wxLUA_USE_wxNotebook\"]              = \"wxLUA_USE_wxNotebook\"",
    "type": "statement:assign"
  }, {
    "id": 647,
    "text": "preprocConditionTable[\"wxLUA_USE_wxObject\"]                = \"wxLUA_USE_wxObject\"",
    "type": "statement:assign"
  }, {
    "id": 648,
    "text": "preprocConditionTable[\"wxLUA_USE_wxPalette\"]               = \"wxLUA_USE_wxPalette\"",
    "type": "statement:assign"
  }, {
    "id": 649,
    "text": "preprocConditionTable[\"wxLUA_USE_wxPenList\"]               = \"wxLUA_USE_wxPenList\"",
    "type": "statement:assign"
  }, {
    "id": 650,
    "text": "preprocConditionTable[\"wxLUA_USE_wxPicker\"]                = \"wxLUA_USE_wxPicker\"",
    "type": "statement:assign"
  }, {
    "id": 651,
    "text": "preprocConditionTable[\"wxLUA_USE_wxPointSizeRect\"]         = \"wxLUA_USE_wxPointSizeRect\"",
    "type": "statement:assign"
  }, {
    "id": 652,
    "text": "preprocConditionTable[\"wxLUA_USE_wxPrint\"]                 = \"wxLUA_USE_wxPrint\"",
    "type": "statement:assign"
  }, {
    "id": 653,
    "text": "preprocConditionTable[\"wxLUA_USE_wxProcess\"]               = \"wxLUA_USE_wxProcess\"",
    "type": "statement:assign"
  }, {
    "id": 654,
    "text": "preprocConditionTable[\"wxLUA_USE_wxProgressDialog\"]        = \"wxLUA_USE_wxProgressDialog\"",
    "type": "statement:assign"
  }, {
    "id": 655,
    "text": "preprocConditionTable[\"wxLUA_USE_wxRadioBox\"]              = \"wxLUA_USE_wxRadioBox\"",
    "type": "statement:assign"
  }, {
    "id": 656,
    "text": "preprocConditionTable[\"wxLUA_USE_wxRadioButton\"]           = \"wxLUA_USE_wxRadioButton\"",
    "type": "statement:assign"
  }, {
    "id": 657,
    "text": "preprocConditionTable[\"wxLUA_USE_wxRegEx\"]                 = \"wxLUA_USE_wxRegEx\"",
    "type": "statement:assign"
  }, {
    "id": 658,
    "text": "preprocConditionTable[\"wxLUA_USE_wxRegion\"]                = \"wxLUA_USE_wxRegion\"",
    "type": "statement:assign"
  }, {
    "id": 659,
    "text": "preprocConditionTable[\"wxLUA_USE_wxRenderer\"]              = \"wxLUA_USE_wxRenderer\"",
    "type": "statement:assign"
  }, {
    "id": 660,
    "text": "preprocConditionTable[\"wxLUA_USE_wxRichText\"]              = \"wxLUA_USE_wxRichText\"",
    "type": "statement:assign"
  }, {
    "id": 661,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSashWindow\"]            = \"wxLUA_USE_wxSashWindow\"",
    "type": "statement:assign"
  }, {
    "id": 662,
    "text": "preprocConditionTable[\"wxLUA_USE_wxScrollBar\"]             = \"wxLUA_USE_wxScrollBar\"",
    "type": "statement:assign"
  }, {
    "id": 663,
    "text": "preprocConditionTable[\"wxLUA_USE_wxScrolledWindow\"]        = \"wxLUA_USE_wxScrolledWindow\"",
    "type": "statement:assign"
  }, {
    "id": 664,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSingleChoiceDialog\"]    = \"wxLUA_USE_wxSingleChoiceDialog\"",
    "type": "statement:assign"
  }, {
    "id": 665,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSizer\"]                 = \"wxLUA_USE_wxSizer\"",
    "type": "statement:assign"
  }, {
    "id": 666,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSlider\"]                = \"wxLUA_USE_wxSlider\"",
    "type": "statement:assign"
  }, {
    "id": 667,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSocket\"]                = \"wxLUA_USE_wxSocket\"",
    "type": "statement:assign"
  }, {
    "id": 668,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSpinButton\"]            = \"wxLUA_USE_wxSpinButton\"",
    "type": "statement:assign"
  }, {
    "id": 669,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSpinCtrl\"]              = \"wxLUA_USE_wxSpinCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 670,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSplashScreen\"]          = \"wxLUA_USE_wxSplashScreen\"",
    "type": "statement:assign"
  }, {
    "id": 671,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSplitterWindow\"]        = \"wxLUA_USE_wxSplitterWindow\"",
    "type": "statement:assign"
  }, {
    "id": 672,
    "text": "preprocConditionTable[\"wxLUA_USE_wxStandardPaths\"]         = \"wxLUA_USE_wxStandardPaths\"",
    "type": "statement:assign"
  }, {
    "id": 673,
    "text": "preprocConditionTable[\"wxLUA_USE_wxStaticBitmap\"]          = \"wxLUA_USE_wxStaticBitmap\"",
    "type": "statement:assign"
  }, {
    "id": 674,
    "text": "preprocConditionTable[\"wxLUA_USE_wxStaticBox\"]             = \"wxLUA_USE_wxStaticBox\"",
    "type": "statement:assign"
  }, {
    "id": 675,
    "text": "preprocConditionTable[\"wxLUA_USE_wxStaticLine\"]            = \"wxLUA_USE_wxStaticLine\"",
    "type": "statement:assign"
  }, {
    "id": 676,
    "text": "preprocConditionTable[\"wxLUA_USE_wxStaticText\"]            = \"wxLUA_USE_wxStaticText\"",
    "type": "statement:assign"
  }, {
    "id": 677,
    "text": "preprocConditionTable[\"wxLUA_USE_wxStatusBar\"]             = \"wxLUA_USE_wxStatusBar\"",
    "type": "statement:assign"
  }, {
    "id": 678,
    "text": "preprocConditionTable[\"wxLUA_USE_wxStopWatch\"]             = \"wxLUA_USE_wxStopWatch\"",
    "type": "statement:assign"
  }, {
    "id": 679,
    "text": "preprocConditionTable[\"wxLUA_USE_wxStringList\"]            = \"wxLUA_USE_wxStringList\"",
    "type": "statement:assign"
  }, {
    "id": 680,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSystemOptions\"]         = \"wxLUA_USE_wxSystemOptions\"",
    "type": "statement:assign"
  }, {
    "id": 681,
    "text": "preprocConditionTable[\"wxLUA_USE_wxSystemSettings\"]        = \"wxLUA_USE_wxSystemSettings\"",
    "type": "statement:assign"
  }, {
    "id": 682,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTabCtrl\"]               = \"wxLUA_USE_wxTabCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 683,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTaskBarIcon\"]           = \"wxLUA_USE_wxTaskBarIcon\"",
    "type": "statement:assign"
  }, {
    "id": 684,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTextCtrl\"]              = \"wxLUA_USE_wxTextCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 685,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTextEntryDialog\"]       = \"wxLUA_USE_wxTextEntryDialog\"",
    "type": "statement:assign"
  }, {
    "id": 686,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTextValidator\"]         = \"wxLUA_USE_wxTextValidator\"",
    "type": "statement:assign"
  }, {
    "id": 687,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTimer\"]                 = \"wxLUA_USE_wxTimer\"",
    "type": "statement:assign"
  }, {
    "id": 688,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTimeSpan\"]              = \"wxLUA_USE_wxTimeSpan\"",
    "type": "statement:assign"
  }, {
    "id": 689,
    "text": "preprocConditionTable[\"wxLUA_USE_wxToggleButton\"]          = \"wxLUA_USE_wxToggleButton\"",
    "type": "statement:assign"
  }, {
    "id": 690,
    "text": "preprocConditionTable[\"wxLUA_USE_wxToolbar\"]               = \"wxLUA_USE_wxToolbar\"",
    "type": "statement:assign"
  }, {
    "id": 691,
    "text": "preprocConditionTable[\"wxLUA_USE_wxToolbook\"]              = \"wxLUA_USE_wxToolbook\"",
    "type": "statement:assign"
  }, {
    "id": 692,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTooltip\"]               = \"wxLUA_USE_wxTooltip\"",
    "type": "statement:assign"
  }, {
    "id": 693,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTreebook\"]              = \"wxLUA_USE_wxTreebook\"",
    "type": "statement:assign"
  }, {
    "id": 694,
    "text": "preprocConditionTable[\"wxLUA_USE_wxTreeCtrl\"]              = \"wxLUA_USE_wxTreeCtrl\"",
    "type": "statement:assign"
  }, {
    "id": 695,
    "text": "preprocConditionTable[\"wxLUA_USE_wxValidator\"]             = \"wxLUA_USE_wxValidator\"",
    "type": "statement:assign"
  }, {
    "id": 696,
    "text": "preprocConditionTable[\"wxLUA_USE_wxWave\"]                  = \"wxLUA_USE_wxWave\"",
    "type": "statement:assign"
  }, {
    "id": 697,
    "text": "preprocConditionTable[\"wxLUA_USE_wxWindowList\"]            = \"wxLUA_USE_wxWindowList\"",
    "type": "statement:assign"
  }, {
    "id": 698,
    "text": "preprocConditionTable[\"wxLUA_USE_wxWizard\"]                = \"wxLUA_USE_wxWizard\"",
    "type": "statement:assign"
  }, {
    "id": 699,
    "text": "preprocConditionTable[\"wxLUA_USE_wxXML\"]                   = \"wxLUA_USE_wxXML\"",
    "type": "statement:assign"
  }, {
    "id": 700,
    "text": "preprocConditionTable[\"wxLUA_USE_wxXRC\"]                   = \"wxLUA_USE_wxXRC\"",
    "type": "statement:assign"
  }, {
    "id": 701,
    "text": "preprocOperatorTable[\"|\"]  = \"||\"",
    "type": "statement:assign"
  }, {
    "id": 702,
    "text": "preprocOperatorTable[\"||\"] = \"||\"",
    "type": "statement:assign"
  }, {
    "id": 703,
    "text": "preprocOperatorTable[\"&\"]  = \"&&\"",
    "type": "statement:assign"
  }, {
    "id": 704,
    "text": "preprocOperatorTable[\"&&\"] = \"&&\"",
    "type": "statement:assign"
  }, {
    "id": 705,
    "text": "preprocOperatorTable[\"!\"]  = \"!\"",
    "type": "statement:assign"
  }, {
    "id": 706,
    "text": "preprocOperatorTable[\"(\"]  = \"(\"",
    "type": "statement:assign"
  }, {
    "id": 707,
    "text": "preprocOperatorTable[\")\"]  = \")\"",
    "type": "statement:assign"
  }, {
    "id": 708,
    "text": "bindingOperatorTable[\"==\"]  = \"op_eq\"",
    "type": "statement:assign"
  }, {
    "id": 709,
    "text": "bindingOperatorTable[\"!=\"]  = \"op_ne\"",
    "type": "statement:assign"
  }, {
    "id": 710,
    "text": "bindingOperatorTable[\"<\"]   = \"op_lt\"",
    "type": "statement:assign"
  }, {
    "id": 711,
    "text": "bindingOperatorTable[\">\"]   = \"op_gt\"",
    "type": "statement:assign"
  }, {
    "id": 712,
    "text": "bindingOperatorTable[\"<=\"]  = \"op_le\"",
    "type": "statement:assign"
  }, {
    "id": 713,
    "text": "bindingOperatorTable[\">=\"]  = \"op_ge\"",
    "type": "statement:assign"
  }, {
    "id": 714,
    "text": "bindingOperatorTable[\"||\"]  = \"op_lor\"",
    "type": "statement:assign"
  }, {
    "id": 715,
    "text": "bindingOperatorTable[\"&&\"]  = \"op_land\"",
    "type": "statement:assign"
  }, {
    "id": 716,
    "text": "bindingOperatorTable[\"!\"]   = \"op_not\"",
    "type": "statement:assign"
  }, {
    "id": 717,
    "text": "bindingOperatorTable[\"|\"]   = \"op_or\"",
    "type": "statement:assign"
  }, {
    "id": 718,
    "text": "bindingOperatorTable[\"&\"]   = \"op_and\"",
    "type": "statement:assign"
  }, {
    "id": 719,
    "text": "bindingOperatorTable[\"^\"]   = \"op_xor\"",
    "type": "statement:assign"
  }, {
    "id": 720,
    "text": "bindingOperatorTable[\"<<\"]  = \"op_lshift\"",
    "type": "statement:assign"
  }, {
    "id": 721,
    "text": "bindingOperatorTable[\">>\"]  = \"op_rshift\"",
    "type": "statement:assign"
  }, {
    "id": 722,
    "text": "bindingOperatorTable[\"|=\"]  = \"op_ior\"",
    "type": "statement:assign"
  }, {
    "id": 723,
    "text": "bindingOperatorTable[\"&=\"]  = \"op_iand\"",
    "type": "statement:assign"
  }, {
    "id": 724,
    "text": "bindingOperatorTable[\"^=\"]  = \"op_ixor\"",
    "type": "statement:assign"
  }, {
    "id": 725,
    "text": "bindingOperatorTable[\"<<=\"] = \"op_ilshift\"",
    "type": "statement:assign"
  }, {
    "id": 726,
    "text": "bindingOperatorTable[\">>=\"] = \"op_irshift\"",
    "type": "statement:assign"
  }, {
    "id": 727,
    "text": "bindingOperatorTable[\"=\"]  = \"op_set\"",
    "type": "statement:assign"
  }, {
    "id": 728,
    "text": "bindingOperatorTable[\"()\"] = \"op_func\"",
    "type": "statement:assign"
  }, {
    "id": 729,
    "text": "bindingOperatorTable[\"[]\"] = \"op_index\"",
    "type": "statement:assign"
  }, {
    "id": 730,
    "text": "bindingOperatorTable[\"++\"] = \"op_inc\"",
    "type": "statement:assign"
  }, {
    "id": 731,
    "text": "bindingOperatorTable[\"--\"] = \"op_dec\"",
    "type": "statement:assign"
  }, {
    "id": 732,
    "text": "bindingOperatorTable[\"~\"]  = \"op_comp\"",
    "type": "statement:assign"
  }, {
    "id": 733,
    "text": "bindingOperatorTable[\"+\"]  = \"op_add\"",
    "type": "statement:assign"
  }, {
    "id": 734,
    "text": "bindingOperatorTable[\"-\"]  = \"op_sub\"",
    "type": "statement:assign"
  }, {
    "id": 735,
    "text": "bindingOperatorTable[\"*\"]  = \"op_mul\"",
    "type": "statement:assign"
  }, {
    "id": 736,
    "text": "bindingOperatorTable[\"/\"]  = \"op_div\"",
    "type": "statement:assign"
  }, {
    "id": 737,
    "text": "bindingOperatorTable[\"%\"]  = \"op_mod\"",
    "type": "statement:assign"
  }, {
    "id": 738,
    "text": "bindingOperatorTable[\"+=\"] = \"op_iadd\"",
    "type": "statement:assign"
  }, {
    "id": 739,
    "text": "bindingOperatorTable[\"-=\"] = \"op_isub\"",
    "type": "statement:assign"
  }, {
    "id": 740,
    "text": "bindingOperatorTable[\"*=\"] = \"op_imul\"",
    "type": "statement:assign"
  }, {
    "id": 741,
    "text": "bindingOperatorTable[\"/=\"] = \"op_idiv\"",
    "type": "statement:assign"
  }, {
    "id": 742,
    "text": "bindingOperatorTable[\"%=\"] = \"op_imod\"",
    "type": "statement:assign"
  }, {
    "id": 743,
    "text": "bindingKeywordTable[\"%if\"]          = true",
    "type": "statement:assign"
  }, {
    "id": 744,
    "text": "bindingKeywordTable[\"%endif\"]       = true",
    "type": "statement:assign"
  }, {
    "id": 745,
    "text": "bindingKeywordTable[\"%rename\"]      = true",
    "type": "statement:assign"
  }, {
    "id": 746,
    "text": "bindingKeywordTable[\"%class\"]       = true",
    "type": "statement:assign"
  }, {
    "id": 747,
    "text": "bindingKeywordTable[\"%delete\"]      = true",
    "type": "statement:assign"
  }, {
    "id": 748,
    "text": "bindingKeywordTable[\"%noclassinfo\"] = true",
    "type": "statement:assign"
  }, {
    "id": 749,
    "text": "bindingKeywordTable[\"%encapsulate\"] = true",
    "type": "statement:assign"
  }, {
    "id": 750,
    "text": "bindingKeywordTable[\"%constructor\"] = true",
    "type": "statement:assign"
  }, {
    "id": 751,
    "text": "bindingKeywordTable[\"%member\"]      = true",
    "type": "statement:assign"
  }, {
    "id": 752,
    "text": "bindingKeywordTable[\"%member_func\"] = true",
    "type": "statement:assign"
  }, {
    "id": 753,
    "text": "bindingKeywordTable[\"%operator\"]    = true",
    "type": "statement:assign"
  }, {
    "id": 754,
    "text": "bindingKeywordTable[\"%property\"]    = true",
    "type": "statement:assign"
  }, {
    "id": 755,
    "text": "bindingKeywordTable[\"%private\"]     = true",
    "type": "statement:assign"
  }, {
    "id": 756,
    "text": "bindingKeywordTable[\"%protected\"]   = true",
    "type": "statement:assign"
  }, {
    "id": 757,
    "text": "bindingKeywordTable[\"%endclass\"]    = true",
    "type": "statement:assign"
  }, {
    "id": 758,
    "text": "bindingKeywordTable[\"%abstract\"]    = true",
    "type": "statement:assign"
  }, {
    "id": 759,
    "text": "bindingKeywordTable[\"%struct\"]      = true",
    "type": "statement:assign"
  }, {
    "id": 760,
    "text": "bindingKeywordTable[\"%endstruct\"]   = true",
    "type": "statement:assign"
  }, {
    "id": 761,
    "text": "bindingKeywordTable[\"%enum\"]        = true",
    "type": "statement:assign"
  }, {
    "id": 762,
    "text": "bindingKeywordTable[\"%endenum\"]     = true",
    "type": "statement:assign"
  }, {
    "id": 763,
    "text": "bindingKeywordTable[\"%function\"]    = true",
    "type": "statement:assign"
  }, {
    "id": 764,
    "text": "bindingKeywordTable[\"%override\"]    = true",
    "type": "statement:assign"
  }, {
    "id": 765,
    "text": "bindingKeywordTable[\"%override_name\"] = true",
    "type": "statement:assign"
  }, {
    "id": 766,
    "text": "bindingKeywordTable[\"%not_overload\"] = true",
    "type": "statement:assign"
  }, {
    "id": 767,
    "text": "bindingKeywordTable[\"%typedef\"]     = true",
    "type": "statement:assign"
  }, {
    "id": 768,
    "text": "bindingKeywordTable[\"%include\"]     = true",
    "type": "statement:assign"
  }, {
    "id": 769,
    "text": "bindingKeywordTable[\"%includefile\"] = true",
    "type": "statement:assign"
  }, {
    "id": 770,
    "text": "bindingKeywordTable[\"%gc_this\"]     = true",
    "type": "statement:assign"
  }, {
    "id": 771,
    "text": "bindingKeywordTable[\"%ungc_this\"]   = true",
    "type": "statement:assign"
  }, {
    "id": 772,
    "text": "bindingKeywordTable[\"%define\"]         = true",
    "type": "statement:assign"
  }, {
    "id": 773,
    "text": "bindingKeywordTable[\"%define_string\"]  = true",
    "type": "statement:assign"
  }, {
    "id": 774,
    "text": "bindingKeywordTable[\"%define_event\"]   = true",
    "type": "statement:assign"
  }, {
    "id": 775,
    "text": "bindingKeywordTable[\"%define_object\"]  = true",
    "type": "statement:assign"
  }, {
    "id": 776,
    "text": "bindingKeywordTable[\"%define_pointer\"] = true",
    "type": "statement:assign"
  }, {
    "id": 777,
    "text": "bindingKeywordTable[\"//\"]           = true",
    "type": "statement:assign"
  }, {
    "id": 778,
    "text": "bindingKeywordTable[\"/*\"]           = true",
    "type": "statement:assign"
  }, {
    "id": 779,
    "text": "bindingKeywordTable[\"*/\"]           = true",
    "type": "statement:assign"
  }, {
    "id": 780,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 781,
    "text": "function SpaceSeparateStrings(str1, str2)\r\n    if str1 and str2 then\r\n        return str1..\" \"..str2\r\n    end\r\n\r\n    return str1 or str2\r\nend",
    "type": "function"
  }, {
    "id": 782,
    "text": "if str1 and str2 then\r\n        return str1..\" \"..str2\r\n    end",
    "type": "statement:if"
  }, {
    "id": 783,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 784,
    "text": "function SplitString(str, delimTable, keepTable, stringliterals, lineTable)\r\n    assert(str, \"Error: input string is nil in SplitString \"..LineTableErrString(lineTable))\r\n\r\n    local len = string_len(str)\r\n    local tokens = {}\r\n\r\n    if len == 0 then return tokens end\r\n\r\n    local wordStart = nil\r\n    local wordEnd   = nil\r\n    local inStringLiteral = false\r\n    local escapedQuote = false\r\n\r\n\r\n    -- Trim out unused delimiters using faster C find function\r\n    local delimTable_start = {} -- starting char of the delimiters\r\n    local delimTable_char  = {} -- single char delims in this string\r\n    local delimTable_str   = {} -- multichar delimiters in this string\r\n    local delimTable_len   = {} -- lengths of the delimTable_str strings\r\n    for n = 1, #delimTable do\r\n        local delim = delimTable[n]\r\n        if string.find(str, delim, 1, 1) then\r\n            local delim_len = string_len(delim)\r\n            local char = string_byte(delim)\r\n            delimTable_start[char] = true\r\n            if delim_len == 1 then\r\n                delimTable_char[char] = delim\r\n            else\r\n                table.insert(delimTable_str, delim)\r\n                table.insert(delimTable_len, delim_len)\r\n            end\r\n        end\r\n    end\r\n\r\n    -- create a hash table of the keepTable strings\r\n    local keepTable_hash = {}\r\n    if keepTable then\r\n        for n = 1, #keepTable do\r\n            keepTable_hash[keepTable[n]] = true\r\n        end\r\n    end\r\n\r\n    local i = 1\r\n    while i <= len do\r\n        local delim = nil\r\n        local keepDelim = false\r\n        local char = string_byte(str, i)\r\n\r\n        if stringliterals then\r\n            if inStringLiteral then\r\n                if (char == char_BACKSLASH) and (string_byte(str, i+2) == char_DOUBLEQUOTE) then\r\n                    i = i + 1 -- skip \\\"\r\n                    char = char_DOUBLEQUOTE\r\n                elseif (char == char_DOUBLEQUOTE) then\r\n                    inStringLiteral = false\r\n                end\r\n            elseif char == char_DOUBLEQUOTE then\r\n                inStringLiteral = true\r\n            end\r\n        end\r\n\r\n        if (not inStringLiteral) and delimTable_start[char] then\r\n            -- check multichar delimiters\r\n            for n = 1, #delimTable_str do\r\n                --if string.find(str, delimTable_str[n], i, 1) == i then\r\n                if string_sub(str, i, i+delimTable_len[n]-1) == delimTable_str[n] then\r\n                    delim = delimTable_str[n]\r\n                    break\r\n                end\r\n            end\r\n            -- check single char delimiters\r\n            if not delim and delimTable_char[char] then\r\n                delim = delimTable_char[char]\r\n            end\r\n            -- keep delimiter in list\r\n            if delim and keepTable and keepTable_hash[delim] then\r\n                keepDelim = true\r\n            end\r\n        end\r\n\r\n        if not delim then\r\n            if not wordStart then\r\n                wordStart = i\r\n            end\r\n\r\n            wordEnd = i\r\n            i = i + 1\r\n        else\r\n            if wordStart then\r\n                table.insert(tokens, string_sub(str, wordStart, wordEnd))\r\n            end\r\n            if keepDelim then\r\n                table.insert(tokens, delim)\r\n            end\r\n\r\n            wordStart = nil\r\n            i = i + string_len(delim)\r\n        end\r\n    end\r\n\r\n    if wordStart then\r\n        table.insert(tokens, string_sub(str, wordStart))\r\n    end\r\n\r\n    if inStringLiteral then\r\n        print(\"ERROR: Couldn't find closing quote for string literal. \"..LineTableErrString(lineTable))\r\n        print(str)\r\n    end\r\n\r\n    return tokens;\r\nend",
    "type": "function"
  }, {
    "id": 785,
    "text": "assert(str, \"Error: input string is nil in SplitString \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 786,
    "text": "local len = string_len(str)",
    "type": "statement:localassign"
  }, {
    "id": 787,
    "text": "local tokens = {}",
    "type": "statement:localassign"
  }, {
    "id": 788,
    "text": "if len == 0 then return tokens end",
    "type": "statement:if"
  }, {
    "id": 789,
    "text": "local wordStart = nil",
    "type": "statement:localassign"
  }, {
    "id": 790,
    "text": "local wordEnd   = nil",
    "type": "statement:localassign"
  }, {
    "id": 791,
    "text": "local inStringLiteral = false",
    "type": "statement:localassign"
  }, {
    "id": 792,
    "text": "local escapedQuote = false",
    "type": "statement:localassign"
  }, {
    "id": 793,
    "text": "local delimTable_start = {}",
    "type": "statement:localassign"
  }, {
    "id": 794,
    "text": "local delimTable_char  = {}",
    "type": "statement:localassign"
  }, {
    "id": 795,
    "text": "local delimTable_str   = {}",
    "type": "statement:localassign"
  }, {
    "id": 796,
    "text": "local delimTable_len   = {}",
    "type": "statement:localassign"
  }, {
    "id": 797,
    "text": "for n = 1, #delimTable do\r\n        local delim = delimTable[n]\r\n        if string.find(str, delim, 1, 1) then\r\n            local delim_len = string_len(delim)\r\n            local char = string_byte(delim)\r\n            delimTable_start[char] = true\r\n            if delim_len == 1 then\r\n                delimTable_char[char] = delim\r\n            else\r\n                table.insert(delimTable_str, delim)\r\n                table.insert(delimTable_len, delim_len)\r\n            end\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 798,
    "text": "local delim = delimTable[n]",
    "type": "statement:localassign"
  }, {
    "id": 799,
    "text": "if string.find(str, delim, 1, 1) then\r\n            local delim_len = string_len(delim)\r\n            local char = string_byte(delim)\r\n            delimTable_start[char] = true\r\n            if delim_len == 1 then\r\n                delimTable_char[char] = delim\r\n            else\r\n                table.insert(delimTable_str, delim)\r\n                table.insert(delimTable_len, delim_len)\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 800,
    "text": "local delim_len = string_len(delim)",
    "type": "statement:localassign"
  }, {
    "id": 801,
    "text": "local char = string_byte(delim)",
    "type": "statement:localassign"
  }, {
    "id": 802,
    "text": "delimTable_start[char] = true",
    "type": "statement:assign"
  }, {
    "id": 803,
    "text": "if delim_len == 1 then\r\n                delimTable_char[char] = delim\r\n            else\r\n                table.insert(delimTable_str, delim)\r\n                table.insert(delimTable_len, delim_len)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 804,
    "text": "delimTable_char[char] = delim",
    "type": "statement:assign"
  }, {
    "id": 805,
    "text": "table.insert(delimTable_str, delim)",
    "type": "statement:functioncall"
  }, {
    "id": 806,
    "text": "table.insert(delimTable_len, delim_len)",
    "type": "statement:functioncall"
  }, {
    "id": 807,
    "text": "local keepTable_hash = {}",
    "type": "statement:localassign"
  }, {
    "id": 808,
    "text": "if keepTable then\r\n        for n = 1, #keepTable do\r\n            keepTable_hash[keepTable[n]] = true\r\n        end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 809,
    "text": "for n = 1, #keepTable do\r\n            keepTable_hash[keepTable[n]] = true\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 810,
    "text": "keepTable_hash[keepTable[n]] = true",
    "type": "statement:assign"
  }, {
    "id": 811,
    "text": "local i = 1",
    "type": "statement:localassign"
  }, {
    "id": 812,
    "text": "while i <= len do\r\n        local delim = nil\r\n        local keepDelim = false\r\n        local char = string_byte(str, i)\r\n\r\n        if stringliterals then\r\n            if inStringLiteral then\r\n                if (char == char_BACKSLASH) and (string_byte(str, i+2) == char_DOUBLEQUOTE) then\r\n                    i = i + 1 -- skip \\\"\r\n                    char = char_DOUBLEQUOTE\r\n                elseif (char == char_DOUBLEQUOTE) then\r\n                    inStringLiteral = false\r\n                end\r\n            elseif char == char_DOUBLEQUOTE then\r\n                inStringLiteral = true\r\n            end\r\n        end\r\n\r\n        if (not inStringLiteral) and delimTable_start[char] then\r\n            -- check multichar delimiters\r\n            for n = 1, #delimTable_str do\r\n                --if string.find(str, delimTable_str[n], i, 1) == i then\r\n                if string_sub(str, i, i+delimTable_len[n]-1) == delimTable_str[n] then\r\n                    delim = delimTable_str[n]\r\n                    break\r\n                end\r\n            end\r\n            -- check single char delimiters\r\n            if not delim and delimTable_char[char] then\r\n                delim = delimTable_char[char]\r\n            end\r\n            -- keep delimiter in list\r\n            if delim and keepTable and keepTable_hash[delim] then\r\n                keepDelim = true\r\n            end\r\n        end\r\n\r\n        if not delim then\r\n            if not wordStart then\r\n                wordStart = i\r\n            end\r\n\r\n            wordEnd = i\r\n            i = i + 1\r\n        else\r\n            if wordStart then\r\n                table.insert(tokens, string_sub(str, wordStart, wordEnd))\r\n            end\r\n            if keepDelim then\r\n                table.insert(tokens, delim)\r\n            end\r\n\r\n            wordStart = nil\r\n            i = i + string_len(delim)\r\n        end\r\n    end",
    "type": "statement:while"
  }, {
    "id": 813,
    "text": "local delim = nil",
    "type": "statement:localassign"
  }, {
    "id": 814,
    "text": "local keepDelim = false",
    "type": "statement:localassign"
  }, {
    "id": 815,
    "text": "local char = string_byte(str, i)",
    "type": "statement:localassign"
  }, {
    "id": 816,
    "text": "if stringliterals then\r\n            if inStringLiteral then\r\n                if (char == char_BACKSLASH) and (string_byte(str, i+2) == char_DOUBLEQUOTE) then\r\n                    i = i + 1 -- skip \\\"\r\n                    char = char_DOUBLEQUOTE\r\n                elseif (char == char_DOUBLEQUOTE) then\r\n                    inStringLiteral = false\r\n                end\r\n            elseif char == char_DOUBLEQUOTE then\r\n                inStringLiteral = true\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 817,
    "text": "if inStringLiteral then\r\n                if (char == char_BACKSLASH) and (string_byte(str, i+2) == char_DOUBLEQUOTE) then\r\n                    i = i + 1 -- skip \\\"\r\n                    char = char_DOUBLEQUOTE\r\n                elseif (char == char_DOUBLEQUOTE) then\r\n                    inStringLiteral = false\r\n                end\r\n            elseif char == char_DOUBLEQUOTE then\r\n                inStringLiteral = true\r\n            end",
    "type": "statement:if"
  }, {
    "id": 818,
    "text": "if (char == char_BACKSLASH) and (string_byte(str, i+2) == char_DOUBLEQUOTE) then\r\n                    i = i + 1 -- skip \\\"\r\n                    char = char_DOUBLEQUOTE\r\n                elseif (char == char_DOUBLEQUOTE) then\r\n                    inStringLiteral = false\r\n                end",
    "type": "statement:if"
  }, {
    "id": 819,
    "text": "char = char_DOUBLEQUOTE",
    "type": "statement:assign"
  }, {
    "id": 820,
    "text": "inStringLiteral = false",
    "type": "statement:assign"
  }, {
    "id": 821,
    "text": "inStringLiteral = true",
    "type": "statement:assign"
  }, {
    "id": 822,
    "text": "if (not inStringLiteral) and delimTable_start[char] then\r\n            -- check multichar delimiters\r\n            for n = 1, #delimTable_str do\r\n                --if string.find(str, delimTable_str[n], i, 1) == i then\r\n                if string_sub(str, i, i+delimTable_len[n]-1) == delimTable_str[n] then\r\n                    delim = delimTable_str[n]\r\n                    break\r\n                end\r\n            end\r\n            -- check single char delimiters\r\n            if not delim and delimTable_char[char] then\r\n                delim = delimTable_char[char]\r\n            end\r\n            -- keep delimiter in list\r\n            if delim and keepTable and keepTable_hash[delim] then\r\n                keepDelim = true\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 823,
    "text": "for n = 1, #delimTable_str do\r\n                --if string.find(str, delimTable_str[n], i, 1) == i then\r\n                if string_sub(str, i, i+delimTable_len[n]-1) == delimTable_str[n] then\r\n                    delim = delimTable_str[n]\r\n                    break\r\n                end\r\n            end",
    "type": "statement:numericfor"
  }, {
    "id": 824,
    "text": "if string_sub(str, i, i+delimTable_len[n]-1) == delimTable_str[n] then\r\n                    delim = delimTable_str[n]\r\n                    break\r\n                end",
    "type": "statement:if"
  }, {
    "id": 825,
    "text": "delim = delimTable_str[n]",
    "type": "statement:assign"
  }, {
    "id": 826,
    "text": "if not delim and delimTable_char[char] then\r\n                delim = delimTable_char[char]\r\n            end",
    "type": "statement:if"
  }, {
    "id": 827,
    "text": "delim = delimTable_char[char]",
    "type": "statement:assign"
  }, {
    "id": 828,
    "text": "if delim and keepTable and keepTable_hash[delim] then\r\n                keepDelim = true\r\n            end",
    "type": "statement:if"
  }, {
    "id": 829,
    "text": "keepDelim = true",
    "type": "statement:assign"
  }, {
    "id": 830,
    "text": "if not delim then\r\n            if not wordStart then\r\n                wordStart = i\r\n            end\r\n\r\n            wordEnd = i\r\n            i = i + 1\r\n        else\r\n            if wordStart then\r\n                table.insert(tokens, string_sub(str, wordStart, wordEnd))\r\n            end\r\n            if keepDelim then\r\n                table.insert(tokens, delim)\r\n            end\r\n\r\n            wordStart = nil\r\n            i = i + string_len(delim)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 831,
    "text": "if not wordStart then\r\n                wordStart = i\r\n            end",
    "type": "statement:if"
  }, {
    "id": 832,
    "text": "wordStart = i",
    "type": "statement:assign"
  }, {
    "id": 833,
    "text": "wordEnd = i",
    "type": "statement:assign"
  }, {
    "id": 834,
    "text": "if wordStart then\r\n                table.insert(tokens, string_sub(str, wordStart, wordEnd))\r\n            end",
    "type": "statement:if"
  }, {
    "id": 835,
    "text": "table.insert(tokens, string_sub(str, wordStart, wordEnd))",
    "type": "statement:functioncall"
  }, {
    "id": 836,
    "text": "if keepDelim then\r\n                table.insert(tokens, delim)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 837,
    "text": "table.insert(tokens, delim)",
    "type": "statement:functioncall"
  }, {
    "id": 838,
    "text": "wordStart = nil",
    "type": "statement:assign"
  }, {
    "id": 839,
    "text": "i = i + string_len(delim)",
    "type": "statement:assign"
  }, {
    "id": 840,
    "text": "if wordStart then\r\n        table.insert(tokens, string_sub(str, wordStart))\r\n    end",
    "type": "statement:if"
  }, {
    "id": 841,
    "text": "table.insert(tokens, string_sub(str, wordStart))",
    "type": "statement:functioncall"
  }, {
    "id": 842,
    "text": "if inStringLiteral then\r\n        print(\"ERROR: Couldn't find closing quote for string literal. \"..LineTableErrString(lineTable))\r\n        print(str)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 843,
    "text": "print(\"ERROR: Couldn't find closing quote for string literal. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 844,
    "text": "print(str)",
    "type": "statement:functioncall"
  }, {
    "id": 845,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 846,
    "text": "function ReadOverrideFile(override_file)\r\n    local inOverride   = false\r\n    local inComment    = false\r\n    local filename     = interface_filepath..\"/\"..override_file\r\n    local linenumber   = 0\r\n    local OverrideFunc = nil\r\n    local delimiters   = {\" \", \"\\t\"}\r\n\r\n    if not FileExists(filename) then\r\n        print(\"ERROR: Missing override file:'\"..filename..\"'\")\r\n        return\r\n    end\r\n\r\n    for line in io.lines(filename) do\r\n        local lineData = SplitString(line, delimiters)\r\n        local isOverride = false\r\n        local isEnd = false\r\n\r\n        linenumber = linenumber + 1\r\n\r\n        -- %override or %end\r\n        for i = 1, #lineData do\r\n            local tag = lineData[i]\r\n\r\n            if (not inOverride) and (tag == \"/*\") then\r\n                inComment = true\r\n            elseif (not inOverride) and (tag == \"*/\") then\r\n                inComment = false\r\n            elseif tag == \"//\" then\r\n                break\r\n            elseif tag == \"%override\" then\r\n                isOverride = true\r\n            elseif tag == \"%end\" then\r\n                isEnd = true\r\n            elseif isOverride and (not inComment) then\r\n                OverrideFunc = tag\r\n                break\r\n            end\r\n        end\r\n\r\n        if isOverride and (not inComment) then\r\n            if inOverride then\r\n                print(\"ERROR: Expected %end. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n            elseif not OverrideFunc then\r\n                print(\"ERROR: Expected Override Function Name. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n            end\r\n        elseif isEnd and (not inOverride) and (not inComment) then\r\n            print(\"ERROR: Expected %override. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n        end\r\n\r\n        if isOverride and (not inComment) then\r\n            if not overrideTable[OverrideFunc] then overrideTable[OverrideFunc] = {} end\r\n            if not overrideTableUsed[OverrideFunc] then overrideTableUsed[OverrideFunc] = false end\r\n            inOverride = true\r\n\r\n            table.insert(overrideTable[OverrideFunc], \"// \"..line..\"\\n\")\r\n        elseif isEnd and (not inComment) then\r\n            table.insert(overrideTable[OverrideFunc], \"\\n\")\r\n\r\n            inOverride = false\r\n            OverrideFunc = nil\r\n        elseif inOverride and (not inComment) then\r\n            table.insert(overrideTable[OverrideFunc], line..\"\\n\")\r\n        end\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 847,
    "text": "local inOverride   = false",
    "type": "statement:localassign"
  }, {
    "id": 848,
    "text": "local inComment    = false",
    "type": "statement:localassign"
  }, {
    "id": 849,
    "text": "local filename     = interface_filepath..\"/\"..override_file",
    "type": "statement:localassign"
  }, {
    "id": 850,
    "text": "local linenumber   = 0",
    "type": "statement:localassign"
  }, {
    "id": 851,
    "text": "local OverrideFunc = nil",
    "type": "statement:localassign"
  }, {
    "id": 852,
    "text": "local delimiters   = {\" \", \"\\t\"}",
    "type": "statement:localassign"
  }, {
    "id": 853,
    "text": "if not FileExists(filename) then\r\n        print(\"ERROR: Missing override file:'\"..filename..\"'\")\r\n        return\r\n    end",
    "type": "statement:if"
  }, {
    "id": 854,
    "text": "print(\"ERROR: Missing override file:'\"..filename..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 855,
    "text": "for line in io.lines(filename) do\r\n        local lineData = SplitString(line, delimiters)\r\n        local isOverride = false\r\n        local isEnd = false\r\n\r\n        linenumber = linenumber + 1\r\n\r\n        -- %override or %end\r\n        for i = 1, #lineData do\r\n            local tag = lineData[i]\r\n\r\n            if (not inOverride) and (tag == \"/*\") then\r\n                inComment = true\r\n            elseif (not inOverride) and (tag == \"*/\") then\r\n                inComment = false\r\n            elseif tag == \"//\" then\r\n                break\r\n            elseif tag == \"%override\" then\r\n                isOverride = true\r\n            elseif tag == \"%end\" then\r\n                isEnd = true\r\n            elseif isOverride and (not inComment) then\r\n                OverrideFunc = tag\r\n                break\r\n            end\r\n        end\r\n\r\n        if isOverride and (not inComment) then\r\n            if inOverride then\r\n                print(\"ERROR: Expected %end. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n            elseif not OverrideFunc then\r\n                print(\"ERROR: Expected Override Function Name. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n            end\r\n        elseif isEnd and (not inOverride) and (not inComment) then\r\n            print(\"ERROR: Expected %override. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n        end\r\n\r\n        if isOverride and (not inComment) then\r\n            if not overrideTable[OverrideFunc] then overrideTable[OverrideFunc] = {} end\r\n            if not overrideTableUsed[OverrideFunc] then overrideTableUsed[OverrideFunc] = false end\r\n            inOverride = true\r\n\r\n            table.insert(overrideTable[OverrideFunc], \"// \"..line..\"\\n\")\r\n        elseif isEnd and (not inComment) then\r\n            table.insert(overrideTable[OverrideFunc], \"\\n\")\r\n\r\n            inOverride = false\r\n            OverrideFunc = nil\r\n        elseif inOverride and (not inComment) then\r\n            table.insert(overrideTable[OverrideFunc], line..\"\\n\")\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 856,
    "text": "local lineData = SplitString(line, delimiters)",
    "type": "statement:localassign"
  }, {
    "id": 857,
    "text": "local isOverride = false",
    "type": "statement:localassign"
  }, {
    "id": 858,
    "text": "local isEnd = false",
    "type": "statement:localassign"
  }, {
    "id": 859,
    "text": "linenumber = linenumber + 1",
    "type": "statement:assign"
  }, {
    "id": 860,
    "text": "for i = 1, #lineData do\r\n            local tag = lineData[i]\r\n\r\n            if (not inOverride) and (tag == \"/*\") then\r\n                inComment = true\r\n            elseif (not inOverride) and (tag == \"*/\") then\r\n                inComment = false\r\n            elseif tag == \"//\" then\r\n                break\r\n            elseif tag == \"%override\" then\r\n                isOverride = true\r\n            elseif tag == \"%end\" then\r\n                isEnd = true\r\n            elseif isOverride and (not inComment) then\r\n                OverrideFunc = tag\r\n                break\r\n            end\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 861,
    "text": "local tag = lineData[i]",
    "type": "statement:localassign"
  }, {
    "id": 862,
    "text": "if (not inOverride) and (tag == \"/*\") then\r\n                inComment = true\r\n            elseif (not inOverride) and (tag == \"*/\") then\r\n                inComment = false\r\n            elseif tag == \"//\" then\r\n                break\r\n            elseif tag == \"%override\" then\r\n                isOverride = true\r\n            elseif tag == \"%end\" then\r\n                isEnd = true\r\n            elseif isOverride and (not inComment) then\r\n                OverrideFunc = tag\r\n                break\r\n            end",
    "type": "statement:if"
  }, {
    "id": 863,
    "text": "inComment = true",
    "type": "statement:assign"
  }, {
    "id": 864,
    "text": "inComment = false",
    "type": "statement:assign"
  }, {
    "id": 865,
    "text": "isOverride = true",
    "type": "statement:assign"
  }, {
    "id": 866,
    "text": "isEnd = true",
    "type": "statement:assign"
  }, {
    "id": 867,
    "text": "OverrideFunc = tag",
    "type": "statement:assign"
  }, {
    "id": 868,
    "text": "if isOverride and (not inComment) then\r\n            if inOverride then\r\n                print(\"ERROR: Expected %end. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n            elseif not OverrideFunc then\r\n                print(\"ERROR: Expected Override Function Name. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n            end\r\n        elseif isEnd and (not inOverride) and (not inComment) then\r\n            print(\"ERROR: Expected %override. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 869,
    "text": "if inOverride then\r\n                print(\"ERROR: Expected %end. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n            elseif not OverrideFunc then\r\n                print(\"ERROR: Expected Override Function Name. File: \"..filename..\" (Line: \"..linenumber..\")\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 870,
    "text": "print(\"ERROR: Expected %end. File: \"..filename..\" (Line: \"..linenumber..\")\")",
    "type": "statement:functioncall"
  }, {
    "id": 871,
    "text": "print(\"ERROR: Expected Override Function Name. File: \"..filename..\" (Line: \"..linenumber..\")\")",
    "type": "statement:functioncall"
  }, {
    "id": 872,
    "text": "print(\"ERROR: Expected %override. File: \"..filename..\" (Line: \"..linenumber..\")\")",
    "type": "statement:functioncall"
  }, {
    "id": 873,
    "text": "if isOverride and (not inComment) then\r\n            if not overrideTable[OverrideFunc] then overrideTable[OverrideFunc] = {} end\r\n            if not overrideTableUsed[OverrideFunc] then overrideTableUsed[OverrideFunc] = false end\r\n            inOverride = true\r\n\r\n            table.insert(overrideTable[OverrideFunc], \"// \"..line..\"\\n\")\r\n        elseif isEnd and (not inComment) then\r\n            table.insert(overrideTable[OverrideFunc], \"\\n\")\r\n\r\n            inOverride = false\r\n            OverrideFunc = nil\r\n        elseif inOverride and (not inComment) then\r\n            table.insert(overrideTable[OverrideFunc], line..\"\\n\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 874,
    "text": "if not overrideTable[OverrideFunc] then overrideTable[OverrideFunc] = {} end",
    "type": "statement:if"
  }, {
    "id": 875,
    "text": "overrideTable[OverrideFunc] = {}",
    "type": "statement:assign"
  }, {
    "id": 876,
    "text": "if not overrideTableUsed[OverrideFunc] then overrideTableUsed[OverrideFunc] = false end",
    "type": "statement:if"
  }, {
    "id": 877,
    "text": "overrideTableUsed[OverrideFunc] = false",
    "type": "statement:assign"
  }, {
    "id": 878,
    "text": "inOverride = true",
    "type": "statement:assign"
  }, {
    "id": 879,
    "text": "table.insert(overrideTable[OverrideFunc], \"// \"..line..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 880,
    "text": "table.insert(overrideTable[OverrideFunc], \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 881,
    "text": "inOverride = false",
    "type": "statement:assign"
  }, {
    "id": 882,
    "text": "OverrideFunc = nil",
    "type": "statement:assign"
  }, {
    "id": 883,
    "text": "table.insert(overrideTable[OverrideFunc], line..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 884,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 885,
    "text": "function GetCPPFileName(filename)\r\n    local splitpath = SplitString(filename, { \"/\", \"\\\\\" })\r\n    local name = SplitString(splitpath[#splitpath], { \".\" })\r\n    return output_cpp_filepath..\"/\"..name[1]..\".cpp\"\r\nend",
    "type": "function"
  }, {
    "id": 886,
    "text": "local splitpath = SplitString(filename, { \"/\", \"\\\\\" })",
    "type": "statement:localassign"
  }, {
    "id": 887,
    "text": "local name = SplitString(splitpath[#splitpath], { \".\" })",
    "type": "statement:localassign"
  }, {
    "id": 888,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 889,
    "text": "function GetCPPHeaderFileName(filename)\r\n    local splitpath = SplitString(filename, { \"/\", \"\\\\\" })\r\n    local name = SplitString(splitpath[#splitpath], { \".\" })\r\n\r\n    if not output_cpp_header_filepath then\r\n        output_cpp_header_filepath = output_cpp_filepath\r\n    end\r\n\r\n    return output_cpp_header_filepath..\"/\"..name[1]..\".h\"\r\nend",
    "type": "function"
  }, {
    "id": 890,
    "text": "if not output_cpp_header_filepath then\r\n        output_cpp_header_filepath = output_cpp_filepath\r\n    end",
    "type": "statement:if"
  }, {
    "id": 891,
    "text": "output_cpp_header_filepath = output_cpp_filepath",
    "type": "statement:assign"
  }, {
    "id": 892,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 893,
    "text": "function ReadInterfaceFile(filename)\r\n    local fileData   = {}\r\n    local linenumber = 0\r\n\r\n    for line in io.lines(filename) do\r\n        linenumber = linenumber + 1\r\n\r\n        local lineTable =\r\n        {\r\n            FileName   = filename,\r\n            LineNumber = linenumber,\r\n            LineText   = line,\r\n            Tags       = SplitString(line, bindingDelimiters, bindingDelimsToKeep, true, lineTable)\r\n        }\r\n\r\n        table.insert(fileData, lineTable)\r\n    end\r\n\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 894,
    "text": "local fileData   = {}",
    "type": "statement:localassign"
  }, {
    "id": 895,
    "text": "local linenumber = 0",
    "type": "statement:localassign"
  }, {
    "id": 896,
    "text": "for line in io.lines(filename) do\r\n        linenumber = linenumber + 1\r\n\r\n        local lineTable =\r\n        {\r\n            FileName   = filename,\r\n            LineNumber = linenumber,\r\n            LineText   = line,\r\n            Tags       = SplitString(line, bindingDelimiters, bindingDelimsToKeep, true, lineTable)\r\n        }\r\n\r\n        table.insert(fileData, lineTable)\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 897,
    "text": "local lineTable =\r\n        {\r\n            FileName   = filename,\r\n            LineNumber = linenumber,\r\n            LineText   = line,\r\n            Tags       = SplitString(line, bindingDelimiters, bindingDelimsToKeep, true, lineTable)\r\n        }",
    "type": "statement:localassign"
  }, {
    "id": 898,
    "text": "table.insert(fileData, lineTable)",
    "type": "statement:functioncall"
  }, {
    "id": 899,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 900,
    "text": "function LineTableErrString(lineTable)\r\n    if type(lineTable) == \"table\" then\r\n        return \"File: '\"..lineTable.FileName..\"':(line \"..lineTable.LineNumber..\")\\n    '\"..lineTable.LineText..\"'\"\r\n    else\r\n        return \"\"\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 901,
    "text": "if type(lineTable) == \"table\" then\r\n        return \"File: '\"..lineTable.FileName..\"':(line \"..lineTable.LineNumber..\")\\n    '\"..lineTable.LineText..\"'\"\r\n    else\r\n        return \"\"\r\n    end",
    "type": "statement:if"
  }, {
    "id": 902,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 903,
    "text": "function GenerateInterfaceData()\r\n    local interfaceFileDataList = {}\r\n    local interfaceList = {}\r\n\r\n    local time1 = os.time()\r\n\r\n    -- read all interface files and build DataType Table\r\n    for i = 1, #interface_fileTable do\r\n        local filename = interface_filepath..\"/\"..interface_fileTable[i]\r\n\r\n        if FileExists(filename) then\r\n            -- read the interface .i file into a table\r\n            local interfaceFileData = ReadInterfaceFile(filename)\r\n            -- find and add data types to the dataTypeTable table\r\n            BuildDataTypeTable(interfaceFileData)\r\n\r\n            table.insert(interfaceFileDataList, { FileName=filename, Data=interfaceFileData })\r\n        else\r\n            print(\"ERROR: Interface file does not exist : '\"..filename..\"'\")\r\n        end\r\n    end\r\n\r\n    local time2 = os.time()\r\n    print(\"Timing: BuildDataTypeTable \"..os.difftime(time2, time1)..\" seconds.\")\r\n    time1 = time2\r\n\r\n    for i = 1, #interfaceFileDataList do\r\n        -- Parse interface file data into a structured object list\r\n        local objectList = ParseData(interfaceFileDataList[i].Data)\r\n\r\n        if objectList then\r\n            local interface =\r\n            {\r\n                CPPFileName         = GetCPPFileName(interfaceFileDataList[i].FileName),\r\n                includeBindingTable = {},\r\n                includeFiles        = {},\r\n                objectData          = objectList,\r\n                lineData            = interfaceFileDataList[i].Data\r\n            }\r\n\r\n            table.insert(interfaceList, interface)\r\n        end\r\n    end\r\n\r\n    local time2 = os.time()\r\n    print(\"Timing: ParseData \"..os.difftime(time2, time1)..\" seconds.\")\r\n\r\n    return interfaceList\r\nend",
    "type": "function"
  }, {
    "id": 904,
    "text": "local interfaceFileDataList = {}",
    "type": "statement:localassign"
  }, {
    "id": 905,
    "text": "local interfaceList = {}",
    "type": "statement:localassign"
  }, {
    "id": 906,
    "text": "local time1 = os.time()",
    "type": "statement:localassign"
  }, {
    "id": 907,
    "text": "for i = 1, #interface_fileTable do\r\n        local filename = interface_filepath..\"/\"..interface_fileTable[i]\r\n\r\n        if FileExists(filename) then\r\n            -- read the interface .i file into a table\r\n            local interfaceFileData = ReadInterfaceFile(filename)\r\n            -- find and add data types to the dataTypeTable table\r\n            BuildDataTypeTable(interfaceFileData)\r\n\r\n            table.insert(interfaceFileDataList, { FileName=filename, Data=interfaceFileData })\r\n        else\r\n            print(\"ERROR: Interface file does not exist : '\"..filename..\"'\")\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 908,
    "text": "local filename = interface_filepath..\"/\"..interface_fileTable[i]",
    "type": "statement:localassign"
  }, {
    "id": 909,
    "text": "if FileExists(filename) then\r\n            -- read the interface .i file into a table\r\n            local interfaceFileData = ReadInterfaceFile(filename)\r\n            -- find and add data types to the dataTypeTable table\r\n            BuildDataTypeTable(interfaceFileData)\r\n\r\n            table.insert(interfaceFileDataList, { FileName=filename, Data=interfaceFileData })\r\n        else\r\n            print(\"ERROR: Interface file does not exist : '\"..filename..\"'\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 910,
    "text": "local interfaceFileData = ReadInterfaceFile(filename)",
    "type": "statement:localassign"
  }, {
    "id": 911,
    "text": "BuildDataTypeTable(interfaceFileData)",
    "type": "statement:functioncall"
  }, {
    "id": 912,
    "text": "table.insert(interfaceFileDataList, { FileName=filename, Data=interfaceFileData })",
    "type": "statement:functioncall"
  }, {
    "id": 913,
    "text": "print(\"ERROR: Interface file does not exist : '\"..filename..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 914,
    "text": "local time2 = os.time()",
    "type": "statement:localassign"
  }, {
    "id": 915,
    "text": "print(\"Timing: BuildDataTypeTable \"..os.difftime(time2, time1)..\" seconds.\")",
    "type": "statement:functioncall"
  }, {
    "id": 916,
    "text": "time1 = time2",
    "type": "statement:assign"
  }, {
    "id": 917,
    "text": "for i = 1, #interfaceFileDataList do\r\n        -- Parse interface file data into a structured object list\r\n        local objectList = ParseData(interfaceFileDataList[i].Data)\r\n\r\n        if objectList then\r\n            local interface =\r\n            {\r\n                CPPFileName         = GetCPPFileName(interfaceFileDataList[i].FileName),\r\n                includeBindingTable = {},\r\n                includeFiles        = {},\r\n                objectData          = objectList,\r\n                lineData            = interfaceFileDataList[i].Data\r\n            }\r\n\r\n            table.insert(interfaceList, interface)\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 918,
    "text": "local objectList = ParseData(interfaceFileDataList[i].Data)",
    "type": "statement:localassign"
  }, {
    "id": 919,
    "text": "if objectList then\r\n            local interface =\r\n            {\r\n                CPPFileName         = GetCPPFileName(interfaceFileDataList[i].FileName),\r\n                includeBindingTable = {},\r\n                includeFiles        = {},\r\n                objectData          = objectList,\r\n                lineData            = interfaceFileDataList[i].Data\r\n            }\r\n\r\n            table.insert(interfaceList, interface)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 920,
    "text": "local interface =\r\n            {\r\n                CPPFileName         = GetCPPFileName(interfaceFileDataList[i].FileName),\r\n                includeBindingTable = {},\r\n                includeFiles        = {},\r\n                objectData          = objectList,\r\n                lineData            = interfaceFileDataList[i].Data\r\n            }",
    "type": "statement:localassign"
  }, {
    "id": 921,
    "text": "table.insert(interfaceList, interface)",
    "type": "statement:functioncall"
  }, {
    "id": 922,
    "text": "print(\"Timing: ParseData \"..os.difftime(time2, time1)..\" seconds.\")",
    "type": "statement:functioncall"
  }, {
    "id": 923,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 924,
    "text": "function WriteWrapperFiles(interfaceList)\r\n    local time1 = os.time()\r\n\r\n    local monolithicFileData = {}\r\n    local updated_files = 0\r\n\r\n    -- generatelanguage binding, binding is stored in objectList\r\n    for i = 1, #interfaceList do\r\n        local interface = interfaceList[i]\r\n\r\n        -- theoretically you could write other language binding generators\r\n        -- using parsed interface data\r\n        GenerateLuaLanguageBinding(interface)\r\n\r\n        -- create c/c++ file\r\n        local fileData = {}\r\n        local add_includes = true\r\n        if output_single_cpp_binding_file then\r\n            fileData = monolithicFileData\r\n            add_includes = (i == 1)\r\n        end\r\n\r\n        fileData = GenerateBindingFileTable(interface, fileData, add_includes)\r\n\r\n        if output_single_cpp_binding_file then\r\n            monolithicFileData[#monolithicFileData+1] = \"\\n\\n\"\r\n        else\r\n            local written = WriteTableToFile(interface.CPPFileName, fileData, false)\r\n            if written then\r\n                updated_files = updated_files + 1\r\n            end\r\n        end\r\n    end\r\n\r\n    local fileData = GenerateHookHeaderFileTable()\r\n    local written = WriteTableToFile(GetCPPHeaderFileName(hook_cpp_header_filename), fileData, false)\r\n    if written then\r\n        updated_files = updated_files + 1\r\n    end\r\n\r\n    local fileData = {} -- reset to empty table\r\n    if output_single_cpp_binding_file then\r\n        fileData = monolithicFileData\r\n    end\r\n\r\n    fileData = GenerateHookCppFileHeader(fileData, GetCPPFileName(hook_cpp_binding_filename), not output_single_cpp_binding_file)\r\n    table.insert(fileData, (hook_cpp_binding_source_includes or \"\")..\"\\n\")\r\n    fileData = GenerateHookEventFileTable(fileData)\r\n    fileData = GenerateHookDefineFileTable(fileData)\r\n    fileData = GenerateHookObjectFileTable(fileData)\r\n    fileData = GenerateHookCFunctionFileTable(fileData)\r\n    fileData = GenerateHookClassFileTable(fileData)\r\n    written = WriteTableToFile(GetCPPFileName(hook_cpp_binding_filename), fileData, false)\r\n    if written then\r\n        updated_files = updated_files + 1\r\n    end\r\n\r\n    local time2 = os.time()\r\n    --print(\"Timing: GenerateLuaLanguageBinding and write files \"..os.difftime(time2, time1)..\" seconds.\")\r\n    return updated_files\r\nend",
    "type": "function"
  }, {
    "id": 925,
    "text": "local monolithicFileData = {}",
    "type": "statement:localassign"
  }, {
    "id": 926,
    "text": "local updated_files = 0",
    "type": "statement:localassign"
  }, {
    "id": 927,
    "text": "for i = 1, #interfaceList do\r\n        local interface = interfaceList[i]\r\n\r\n        -- theoretically you could write other language binding generators\r\n        -- using parsed interface data\r\n        GenerateLuaLanguageBinding(interface)\r\n\r\n        -- create c/c++ file\r\n        local fileData = {}\r\n        local add_includes = true\r\n        if output_single_cpp_binding_file then\r\n            fileData = monolithicFileData\r\n            add_includes = (i == 1)\r\n        end\r\n\r\n        fileData = GenerateBindingFileTable(interface, fileData, add_includes)\r\n\r\n        if output_single_cpp_binding_file then\r\n            monolithicFileData[#monolithicFileData+1] = \"\\n\\n\"\r\n        else\r\n            local written = WriteTableToFile(interface.CPPFileName, fileData, false)\r\n            if written then\r\n                updated_files = updated_files + 1\r\n            end\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 928,
    "text": "local interface = interfaceList[i]",
    "type": "statement:localassign"
  }, {
    "id": 929,
    "text": "GenerateLuaLanguageBinding(interface)",
    "type": "statement:functioncall"
  }, {
    "id": 930,
    "text": "local fileData = {}",
    "type": "statement:localassign"
  }, {
    "id": 931,
    "text": "local add_includes = true",
    "type": "statement:localassign"
  }, {
    "id": 932,
    "text": "if output_single_cpp_binding_file then\r\n            fileData = monolithicFileData\r\n            add_includes = (i == 1)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 933,
    "text": "fileData = monolithicFileData",
    "type": "statement:assign"
  }, {
    "id": 934,
    "text": "add_includes = (i == 1)",
    "type": "statement:assign"
  }, {
    "id": 935,
    "text": "fileData = GenerateBindingFileTable(interface, fileData, add_includes)",
    "type": "statement:assign"
  }, {
    "id": 936,
    "text": "if output_single_cpp_binding_file then\r\n            monolithicFileData[#monolithicFileData+1] = \"\\n\\n\"\r\n        else\r\n            local written = WriteTableToFile(interface.CPPFileName, fileData, false)\r\n            if written then\r\n                updated_files = updated_files + 1\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 937,
    "text": "monolithicFileData[#monolithicFileData+1] = \"\\n\\n\"",
    "type": "statement:assign"
  }, {
    "id": 938,
    "text": "local written = WriteTableToFile(interface.CPPFileName, fileData, false)",
    "type": "statement:localassign"
  }, {
    "id": 939,
    "text": "if written then\r\n                updated_files = updated_files + 1\r\n            end",
    "type": "statement:if"
  }, {
    "id": 940,
    "text": "updated_files = updated_files + 1",
    "type": "statement:assign"
  }, {
    "id": 941,
    "text": "local fileData = GenerateHookHeaderFileTable()",
    "type": "statement:localassign"
  }, {
    "id": 942,
    "text": "local written = WriteTableToFile(GetCPPHeaderFileName(hook_cpp_header_filename), fileData, false)",
    "type": "statement:localassign"
  }, {
    "id": 943,
    "text": "if written then\r\n        updated_files = updated_files + 1\r\n    end",
    "type": "statement:if"
  }, {
    "id": 944,
    "text": "if output_single_cpp_binding_file then\r\n        fileData = monolithicFileData\r\n    end",
    "type": "statement:if"
  }, {
    "id": 945,
    "text": "fileData = GenerateHookCppFileHeader(fileData, GetCPPFileName(hook_cpp_binding_filename), not output_single_cpp_binding_file)",
    "type": "statement:assign"
  }, {
    "id": 946,
    "text": "table.insert(fileData, (hook_cpp_binding_source_includes or \"\")..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 947,
    "text": "fileData = GenerateHookEventFileTable(fileData)",
    "type": "statement:assign"
  }, {
    "id": 948,
    "text": "fileData = GenerateHookDefineFileTable(fileData)",
    "type": "statement:assign"
  }, {
    "id": 949,
    "text": "fileData = GenerateHookObjectFileTable(fileData)",
    "type": "statement:assign"
  }, {
    "id": 950,
    "text": "fileData = GenerateHookCFunctionFileTable(fileData)",
    "type": "statement:assign"
  }, {
    "id": 951,
    "text": "fileData = GenerateHookClassFileTable(fileData)",
    "type": "statement:assign"
  }, {
    "id": 952,
    "text": "written = WriteTableToFile(GetCPPFileName(hook_cpp_binding_filename), fileData, false)",
    "type": "statement:assign"
  }, {
    "id": 953,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 954,
    "text": "function AllocParseObject(obj_type)\r\n    local parseObject =\r\n    {\r\n        Name             = \"<\"..obj_type..\">\",\r\n        ObjType          = obj_type,\r\n        TagDeclaration   = nil,\r\n        BindTable        = {},\r\n        BaseClasses      = {},\r\n        Members          = {},\r\n        [\"%delete\"]      = false,\r\n        [\"%noclassinfo\"] = false,\r\n        [\"%encapsulate\"] = false,\r\n        Condition        = nil,\r\n    }\r\n\r\n    return parseObject\r\nend",
    "type": "function"
  }, {
    "id": 955,
    "text": "local parseObject =\r\n    {\r\n        Name             = \"<\"..obj_type..\">\",\r\n        ObjType          = obj_type,\r\n        TagDeclaration   = nil,\r\n        BindTable        = {},\r\n        BaseClasses      = {},\r\n        Members          = {},\r\n        [\"%delete\"]      = false,\r\n        [\"%noclassinfo\"] = false,\r\n        [\"%encapsulate\"] = false,\r\n        Condition        = nil,\r\n    }",
    "type": "statement:localassign"
  }, {
    "id": 956,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 957,
    "text": "function AllocMember(lineState, extraCondition)\r\n    local member =\r\n    {\r\n        DefType                 = lineState.DefType,\r\n        DataType                = lineState.DataType,\r\n        DataTypeWithAttrib      = lineState.DataTypeWithAttrib,\r\n        DataTypePointer         = lineState.DataTypePointer,\r\n        TypedDataType           = lineState.DataType,\r\n        TypedDataTypeWithAttrib = lineState.DataTypeWithAttrib,\r\n        TypedDataTypePointer    = lineState.DataTypePointer,\r\n        Name                    = lineState.Name,\r\n        [\"%rename\"]             = lineState[\"%rename\"],\r\n        Value                   = lineState.Value,\r\n        [\"%function\"]           = lineState[\"%function\"],\r\n        IsConstructor           = lineState.IsConstructor,\r\n        [\"%operator\"]           = lineState[\"%operator\"],\r\n        IsFunction              = lineState.IsFunction,\r\n        IsConstFunction         = lineState.IsConstFunction,\r\n        IsStaticFunction        = lineState.IsStaticFunction,\r\n        IsVirtualFunction       = lineState.IsVirtualFunction,\r\n        IsPureVirtualFunction   = lineState.IsPureVirtualFunction,\r\n        NotOverload             = lineState.NotOverload,\r\n        override_name           = lineState.override_name,\r\n        Condition               = lineState.Condition,\r\n        ExtraCondition          = extraCondition,\r\n        Params                  = lineState.Params,\r\n        FileName                = lineState.FileName,\r\n        LineNumber              = lineState.LineNumber,\r\n        LineText                = lineState.LineText,\r\n        [\"%gc_this\"]            = lineState[\"%gc_this\"],\r\n        [\"%ungc_this\"]          = lineState[\"%ungc_this\"],\r\n    }\r\n\r\n    return member\r\nend",
    "type": "function"
  }, {
    "id": 958,
    "text": "local member =\r\n    {\r\n        DefType                 = lineState.DefType,\r\n        DataType                = lineState.DataType,\r\n        DataTypeWithAttrib      = lineState.DataTypeWithAttrib,\r\n        DataTypePointer         = lineState.DataTypePointer,\r\n        TypedDataType           = lineState.DataType,\r\n        TypedDataTypeWithAttrib = lineState.DataTypeWithAttrib,\r\n        TypedDataTypePointer    = lineState.DataTypePointer,\r\n        Name                    = lineState.Name,\r\n        [\"%rename\"]             = lineState[\"%rename\"],\r\n        Value                   = lineState.Value,\r\n        [\"%function\"]           = lineState[\"%function\"],\r\n        IsConstructor           = lineState.IsConstructor,\r\n        [\"%operator\"]           = lineState[\"%operator\"],\r\n        IsFunction              = lineState.IsFunction,\r\n        IsConstFunction         = lineState.IsConstFunction,\r\n        IsStaticFunction        = lineState.IsStaticFunction,\r\n        IsVirtualFunction       = lineState.IsVirtualFunction,\r\n        IsPureVirtualFunction   = lineState.IsPureVirtualFunction,\r\n        NotOverload             = lineState.NotOverload,\r\n        override_name           = lineState.override_name,\r\n        Condition               = lineState.Condition,\r\n        ExtraCondition          = extraCondition,\r\n        Params                  = lineState.Params,\r\n        FileName                = lineState.FileName,\r\n        LineNumber              = lineState.LineNumber,\r\n        LineText                = lineState.LineText,\r\n        [\"%gc_this\"]            = lineState[\"%gc_this\"],\r\n        [\"%ungc_this\"]          = lineState[\"%ungc_this\"],\r\n    }",
    "type": "statement:localassign"
  }, {
    "id": 959,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 960,
    "text": "function AllocParam()\r\n    local member =\r\n    {\r\n        DataType                = nil,\r\n        DataTypeWithAttrib      = nil,\r\n        DataTypePointer         = {},\r\n        TypedDataType           = nil,\r\n        TypedDataTypeWithAttrib = nil,\r\n        TypedDataTypePointer    = {},\r\n        Name                    = nil,\r\n        DefaultValue            = nil,\r\n        ParamObjectDeclared     = nil,\r\n        Binding                 = nil\r\n    }\r\n\r\n    return member\r\nend",
    "type": "function"
  }, {
    "id": 961,
    "text": "local member =\r\n    {\r\n        DataType                = nil,\r\n        DataTypeWithAttrib      = nil,\r\n        DataTypePointer         = {},\r\n        TypedDataType           = nil,\r\n        TypedDataTypeWithAttrib = nil,\r\n        TypedDataTypePointer    = {},\r\n        Name                    = nil,\r\n        DefaultValue            = nil,\r\n        ParamObjectDeclared     = nil,\r\n        Binding                 = nil\r\n    }",
    "type": "statement:localassign"
  }, {
    "id": 962,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 963,
    "text": "function InsertParamState(Params, ParamState)\r\n    -- don't insert func(void) parameters\r\n    if ParamState.DataType and ((ParamState.DataTypeWithAttrib ~= \"void\") or (#ParamState.DataTypePointer > 0)) then\r\n        table.insert(Params, ParamState)\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 964,
    "text": "if ParamState.DataType and ((ParamState.DataTypeWithAttrib ~= \"void\") or (#ParamState.DataTypePointer > 0)) then\r\n        table.insert(Params, ParamState)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 965,
    "text": "table.insert(Params, ParamState)",
    "type": "statement:functioncall"
  }, {
    "id": 966,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 967,
    "text": "function BuildDataTypeTable(interfaceData)\r\n    local in_block_comment = 0\r\n\r\n    for l = 1, #interfaceData do\r\n        local lineTable = interfaceData[l]\r\n        local lineTags  = lineTable.Tags\r\n\r\n        local classname = nil -- current classname if any\r\n        local action    = nil -- what to look for next\r\n\r\n        local typedefTable = {}\r\n\r\n        for t = 1, #lineTags do\r\n            local tag = lineTags[t]\r\n\r\n            if bindingKeywordTable[tag] then\r\n\r\n                -- block comment (start)\r\n                if tag == \"/*\" then\r\n                    in_block_comment = in_block_comment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    in_block_comment = in_block_comment - 1\r\n                end\r\n\r\n                -- ignore until end of block comment\r\n                if in_block_comment == 0 then\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    elseif tag == \"%class\" then\r\n                        action = \"find_classname\"\r\n                    elseif tag == \"%struct\" then\r\n                        action = \"find_structname\"\r\n                    elseif tag == \"%enum\" then\r\n                        action = \"find_enumname\"\r\n                    elseif tag == \"%typedef\" then\r\n                        action = \"find_typedef\"\r\n                    end\r\n                end\r\n            elseif (in_block_comment == 0) and action and\r\n                   (not preprocOperatorTable[tag]) and (not FindOrCreateCondition(tag)) and\r\n                   (not skipBindingKeywordTable[tag]) then\r\n\r\n                if action == \"find_classname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    classname = tag\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_classcomma\" then\r\n                    if tag ~= \",\" then\r\n                        print(\"WARNING: Expected comma (',') after class name : '\"..classname..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                    action = \"find_classbase\"\r\n                elseif action == \"find_classbase\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    -- set class's BaseClass\r\n                    if not dataTypeTable[classname].BaseClasses then\r\n                        dataTypeTable[classname].BaseClasses = {}\r\n                    end\r\n\r\n                    table.insert(dataTypeTable[classname].BaseClasses, tag)\r\n\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_structname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"struct\", false)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_enumname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"enum\", true)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_typedef\" then\r\n                    table.insert(typedefTable, tag)\r\n\r\n                end\r\n            end\r\n        end\r\n\r\n        if #typedefTable > 0 then\r\n            local typedef_name = typedefTable[#typedefTable]\r\n            local typedef_type = table.concat(typedefTable, \" \", 1, #typedefTable-1)\r\n            local dt = false\r\n            for i = 1,#typedefTable-1 do\r\n                -- increment forward until we know the type, skipping const and other attribs\r\n                dt = dataTypeTable[table.concat(typedefTable, \" \", i, #typedefTable-1)]\r\n                if dt then\r\n                    AllocDataType(typedef_name, dt.ValueType, dt.IsNumber)\r\n                    break\r\n                end\r\n            end\r\n        end\r\n\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 968,
    "text": "local in_block_comment = 0",
    "type": "statement:localassign"
  }, {
    "id": 969,
    "text": "for l = 1, #interfaceData do\r\n        local lineTable = interfaceData[l]\r\n        local lineTags  = lineTable.Tags\r\n\r\n        local classname = nil -- current classname if any\r\n        local action    = nil -- what to look for next\r\n\r\n        local typedefTable = {}\r\n\r\n        for t = 1, #lineTags do\r\n            local tag = lineTags[t]\r\n\r\n            if bindingKeywordTable[tag] then\r\n\r\n                -- block comment (start)\r\n                if tag == \"/*\" then\r\n                    in_block_comment = in_block_comment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    in_block_comment = in_block_comment - 1\r\n                end\r\n\r\n                -- ignore until end of block comment\r\n                if in_block_comment == 0 then\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    elseif tag == \"%class\" then\r\n                        action = \"find_classname\"\r\n                    elseif tag == \"%struct\" then\r\n                        action = \"find_structname\"\r\n                    elseif tag == \"%enum\" then\r\n                        action = \"find_enumname\"\r\n                    elseif tag == \"%typedef\" then\r\n                        action = \"find_typedef\"\r\n                    end\r\n                end\r\n            elseif (in_block_comment == 0) and action and\r\n                   (not preprocOperatorTable[tag]) and (not FindOrCreateCondition(tag)) and\r\n                   (not skipBindingKeywordTable[tag]) then\r\n\r\n                if action == \"find_classname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    classname = tag\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_classcomma\" then\r\n                    if tag ~= \",\" then\r\n                        print(\"WARNING: Expected comma (',') after class name : '\"..classname..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                    action = \"find_classbase\"\r\n                elseif action == \"find_classbase\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    -- set class's BaseClass\r\n                    if not dataTypeTable[classname].BaseClasses then\r\n                        dataTypeTable[classname].BaseClasses = {}\r\n                    end\r\n\r\n                    table.insert(dataTypeTable[classname].BaseClasses, tag)\r\n\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_structname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"struct\", false)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_enumname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"enum\", true)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_typedef\" then\r\n                    table.insert(typedefTable, tag)\r\n\r\n                end\r\n            end\r\n        end\r\n\r\n        if #typedefTable > 0 then\r\n            local typedef_name = typedefTable[#typedefTable]\r\n            local typedef_type = table.concat(typedefTable, \" \", 1, #typedefTable-1)\r\n            local dt = false\r\n            for i = 1,#typedefTable-1 do\r\n                -- increment forward until we know the type, skipping const and other attribs\r\n                dt = dataTypeTable[table.concat(typedefTable, \" \", i, #typedefTable-1)]\r\n                if dt then\r\n                    AllocDataType(typedef_name, dt.ValueType, dt.IsNumber)\r\n                    break\r\n                end\r\n            end\r\n        end\r\n\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 970,
    "text": "local lineTable = interfaceData[l]",
    "type": "statement:localassign"
  }, {
    "id": 971,
    "text": "local lineTags  = lineTable.Tags",
    "type": "statement:localassign"
  }, {
    "id": 972,
    "text": "local classname = nil",
    "type": "statement:localassign"
  }, {
    "id": 973,
    "text": "local action    = nil",
    "type": "statement:localassign"
  }, {
    "id": 974,
    "text": "local typedefTable = {}",
    "type": "statement:localassign"
  }, {
    "id": 975,
    "text": "for t = 1, #lineTags do\r\n            local tag = lineTags[t]\r\n\r\n            if bindingKeywordTable[tag] then\r\n\r\n                -- block comment (start)\r\n                if tag == \"/*\" then\r\n                    in_block_comment = in_block_comment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    in_block_comment = in_block_comment - 1\r\n                end\r\n\r\n                -- ignore until end of block comment\r\n                if in_block_comment == 0 then\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    elseif tag == \"%class\" then\r\n                        action = \"find_classname\"\r\n                    elseif tag == \"%struct\" then\r\n                        action = \"find_structname\"\r\n                    elseif tag == \"%enum\" then\r\n                        action = \"find_enumname\"\r\n                    elseif tag == \"%typedef\" then\r\n                        action = \"find_typedef\"\r\n                    end\r\n                end\r\n            elseif (in_block_comment == 0) and action and\r\n                   (not preprocOperatorTable[tag]) and (not FindOrCreateCondition(tag)) and\r\n                   (not skipBindingKeywordTable[tag]) then\r\n\r\n                if action == \"find_classname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    classname = tag\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_classcomma\" then\r\n                    if tag ~= \",\" then\r\n                        print(\"WARNING: Expected comma (',') after class name : '\"..classname..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                    action = \"find_classbase\"\r\n                elseif action == \"find_classbase\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    -- set class's BaseClass\r\n                    if not dataTypeTable[classname].BaseClasses then\r\n                        dataTypeTable[classname].BaseClasses = {}\r\n                    end\r\n\r\n                    table.insert(dataTypeTable[classname].BaseClasses, tag)\r\n\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_structname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"struct\", false)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_enumname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"enum\", true)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_typedef\" then\r\n                    table.insert(typedefTable, tag)\r\n\r\n                end\r\n            end\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 976,
    "text": "local tag = lineTags[t]",
    "type": "statement:localassign"
  }, {
    "id": 977,
    "text": "if bindingKeywordTable[tag] then\r\n\r\n                -- block comment (start)\r\n                if tag == \"/*\" then\r\n                    in_block_comment = in_block_comment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    in_block_comment = in_block_comment - 1\r\n                end\r\n\r\n                -- ignore until end of block comment\r\n                if in_block_comment == 0 then\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    elseif tag == \"%class\" then\r\n                        action = \"find_classname\"\r\n                    elseif tag == \"%struct\" then\r\n                        action = \"find_structname\"\r\n                    elseif tag == \"%enum\" then\r\n                        action = \"find_enumname\"\r\n                    elseif tag == \"%typedef\" then\r\n                        action = \"find_typedef\"\r\n                    end\r\n                end\r\n            elseif (in_block_comment == 0) and action and\r\n                   (not preprocOperatorTable[tag]) and (not FindOrCreateCondition(tag)) and\r\n                   (not skipBindingKeywordTable[tag]) then\r\n\r\n                if action == \"find_classname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    classname = tag\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_classcomma\" then\r\n                    if tag ~= \",\" then\r\n                        print(\"WARNING: Expected comma (',') after class name : '\"..classname..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                    action = \"find_classbase\"\r\n                elseif action == \"find_classbase\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    -- set class's BaseClass\r\n                    if not dataTypeTable[classname].BaseClasses then\r\n                        dataTypeTable[classname].BaseClasses = {}\r\n                    end\r\n\r\n                    table.insert(dataTypeTable[classname].BaseClasses, tag)\r\n\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_structname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"struct\", false)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_enumname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"enum\", true)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_typedef\" then\r\n                    table.insert(typedefTable, tag)\r\n\r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 978,
    "text": "if tag == \"/*\" then\r\n                    in_block_comment = in_block_comment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    in_block_comment = in_block_comment - 1\r\n                end",
    "type": "statement:if"
  }, {
    "id": 979,
    "text": "in_block_comment = in_block_comment + 1",
    "type": "statement:assign"
  }, {
    "id": 980,
    "text": "in_block_comment = in_block_comment - 1",
    "type": "statement:assign"
  }, {
    "id": 981,
    "text": "if in_block_comment == 0 then\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    elseif tag == \"%class\" then\r\n                        action = \"find_classname\"\r\n                    elseif tag == \"%struct\" then\r\n                        action = \"find_structname\"\r\n                    elseif tag == \"%enum\" then\r\n                        action = \"find_enumname\"\r\n                    elseif tag == \"%typedef\" then\r\n                        action = \"find_typedef\"\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 982,
    "text": "if tag == \"//\" then\r\n                        break\r\n\r\n                    elseif tag == \"%class\" then\r\n                        action = \"find_classname\"\r\n                    elseif tag == \"%struct\" then\r\n                        action = \"find_structname\"\r\n                    elseif tag == \"%enum\" then\r\n                        action = \"find_enumname\"\r\n                    elseif tag == \"%typedef\" then\r\n                        action = \"find_typedef\"\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 983,
    "text": "action = \"find_classname\"",
    "type": "statement:assign"
  }, {
    "id": 984,
    "text": "action = \"find_structname\"",
    "type": "statement:assign"
  }, {
    "id": 985,
    "text": "action = \"find_enumname\"",
    "type": "statement:assign"
  }, {
    "id": 986,
    "text": "action = \"find_typedef\"",
    "type": "statement:assign"
  }, {
    "id": 987,
    "text": "if action == \"find_classname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    classname = tag\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_classcomma\" then\r\n                    if tag ~= \",\" then\r\n                        print(\"WARNING: Expected comma (',') after class name : '\"..classname..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                    action = \"find_classbase\"\r\n                elseif action == \"find_classbase\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end\r\n\r\n                    -- set class's BaseClass\r\n                    if not dataTypeTable[classname].BaseClasses then\r\n                        dataTypeTable[classname].BaseClasses = {}\r\n                    end\r\n\r\n                    table.insert(dataTypeTable[classname].BaseClasses, tag)\r\n\r\n                    action = \"find_classcomma\"\r\n                elseif action == \"find_structname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"struct\", false)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_enumname\" then\r\n                    if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"enum\", true)\r\n                    end\r\n\r\n                    action = nil\r\n                elseif action == \"find_typedef\" then\r\n                    table.insert(typedefTable, tag)\r\n\r\n                end",
    "type": "statement:if"
  }, {
    "id": 988,
    "text": "if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"class\", false)\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 989,
    "text": "AllocDataType(tag, \"class\", false)",
    "type": "statement:functioncall"
  }, {
    "id": 990,
    "text": "classname = tag",
    "type": "statement:assign"
  }, {
    "id": 991,
    "text": "action = \"find_classcomma\"",
    "type": "statement:assign"
  }, {
    "id": 992,
    "text": "if tag ~= \",\" then\r\n                        print(\"WARNING: Expected comma (',') after class name : '\"..classname..\"' in \"..LineTableErrString(lineTable))\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 993,
    "text": "print(\"WARNING: Expected comma (',') after class name : '\"..classname..\"' in \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 994,
    "text": "action = \"find_classbase\"",
    "type": "statement:assign"
  }, {
    "id": 995,
    "text": "if not dataTypeTable[classname].BaseClasses then\r\n                        dataTypeTable[classname].BaseClasses = {}\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 996,
    "text": "dataTypeTable[classname].BaseClasses = {}",
    "type": "statement:assign"
  }, {
    "id": 997,
    "text": "table.insert(dataTypeTable[classname].BaseClasses, tag)",
    "type": "statement:functioncall"
  }, {
    "id": 998,
    "text": "if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"struct\", false)\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 999,
    "text": "AllocDataType(tag, \"struct\", false)",
    "type": "statement:functioncall"
  }, {
    "id": 1000,
    "text": "action = nil",
    "type": "statement:assign"
  }, {
    "id": 1001,
    "text": "if not dataTypeTable[tag] then\r\n                        AllocDataType(tag, \"enum\", true)\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1002,
    "text": "AllocDataType(tag, \"enum\", true)",
    "type": "statement:functioncall"
  }, {
    "id": 1003,
    "text": "table.insert(typedefTable, tag)",
    "type": "statement:functioncall"
  }, {
    "id": 1004,
    "text": "if #typedefTable > 0 then\r\n            local typedef_name = typedefTable[#typedefTable]\r\n            local typedef_type = table.concat(typedefTable, \" \", 1, #typedefTable-1)\r\n            local dt = false\r\n            for i = 1,#typedefTable-1 do\r\n                -- increment forward until we know the type, skipping const and other attribs\r\n                dt = dataTypeTable[table.concat(typedefTable, \" \", i, #typedefTable-1)]\r\n                if dt then\r\n                    AllocDataType(typedef_name, dt.ValueType, dt.IsNumber)\r\n                    break\r\n                end\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1005,
    "text": "local typedef_name = typedefTable[#typedefTable]",
    "type": "statement:localassign"
  }, {
    "id": 1006,
    "text": "local typedef_type = table.concat(typedefTable, \" \", 1, #typedefTable-1)",
    "type": "statement:localassign"
  }, {
    "id": 1007,
    "text": "local dt = false",
    "type": "statement:localassign"
  }, {
    "id": 1008,
    "text": "for i = 1,#typedefTable-1 do\r\n                -- increment forward until we know the type, skipping const and other attribs\r\n                dt = dataTypeTable[table.concat(typedefTable, \" \", i, #typedefTable-1)]\r\n                if dt then\r\n                    AllocDataType(typedef_name, dt.ValueType, dt.IsNumber)\r\n                    break\r\n                end\r\n            end",
    "type": "statement:numericfor"
  }, {
    "id": 1009,
    "text": "dt = dataTypeTable[table.concat(typedefTable, \" \", i, #typedefTable-1)]",
    "type": "statement:assign"
  }, {
    "id": 1010,
    "text": "if dt then\r\n                    AllocDataType(typedef_name, dt.ValueType, dt.IsNumber)\r\n                    break\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1011,
    "text": "AllocDataType(typedef_name, dt.ValueType, dt.IsNumber)",
    "type": "statement:functioncall"
  }, {
    "id": 1012,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1013,
    "text": "function ParseData(interfaceData)\r\n\r\n    local objectList = {}\r\n    local parseState =\r\n    {\r\n        ObjectStack    = {},\r\n        ConditionStack = {}, -- stack of conditions\r\n        IsBlockComment = 0,  -- /* then +1 else */ then -1, 0 == not in comment\r\n    }\r\n\r\n    local globals = AllocParseObject(\"objtype_globals\") -- Global Objects\r\n    globals.Name = \"globals\"\r\n\r\n    table.insert(parseState.ObjectStack, 1, globals)\r\n\r\n    local enumType = \"\" -- FIXME temp fix to remember named enums\r\n\r\n    local l = 0\r\n    while interfaceData[l+1] do -- not for loop so we can adjust l\r\n        l = l + 1\r\n\r\n        local lineTable = interfaceData[l]\r\n        local lineTags  = interfaceData[l].Tags\r\n\r\n        local lineState =\r\n        {\r\n            Skip                  = false, -- skip rest of line\r\n            InlineConditionIf     = false, -- single line condition\r\n            Action                = nil,\r\n            ActionAttributes      = {},\r\n            ActionMandatory       = false,\r\n            PopParseObject        = nil,\r\n            ParamState            = AllocParam(),\r\n            BaseClasses           = {},\r\n            RValue                = nil,\r\n\r\n            DefType               = nil, -- below are copied by AllocMember\r\n            DataType              = nil,\r\n            DataTypeWithAttrib    = nil,\r\n            DataTypePointer       = {},\r\n            Name                  = nil,\r\n            [\"%rename\"]           = nil,\r\n            Value                 = nil,\r\n            [\"%gc_this\"]          = nil,\r\n            [\"%ungc_this\"]        = nil,\r\n            [\"%function\"]         = nil,\r\n            IsConstructor         = nil,\r\n            [\"%operator\"]         = nil,\r\n            IsFunction            = nil,\r\n            IsConstFunction       = nil,\r\n            IsStaticFunction      = nil,\r\n            IsVirtualFunction     = nil,\r\n            IsPureVirtualFunction = nil,\r\n            override_name         = nil,\r\n            NotOverload           = nil,\r\n            Condition             = nil,\r\n            Params                = {},\r\n            FileName              = lineTable.FileName,\r\n            LineNumber            = lineTable.LineNumber,\r\n            LineText              = lineTable.LineText,\r\n        }\r\n\r\n        local t = 0\r\n        while lineTags[t+1] do\r\n            t = t + 1\r\n            local tag = lineTags[t]\r\n\r\n            if lineState.Skip then\r\n                break\r\n            end\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- Is this tag a binding keyword, e.g. %XXX\r\n            -- ---------------------------------------------------------------\r\n            if bindingKeywordTable[tag] then\r\n                -- block comment (start)\r\n                if tag == \"/*\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment - 1\r\n\r\n                -- ignore until end of block comment\r\n                elseif parseState.IsBlockComment == 0 then\r\n\r\n                    -- warn if we're expecting something and it's not there\r\n                    if not lineState.ActionAttributes[tag] and lineState.ActionMandatory then\r\n                        print(\"ERROR: Expected Line Action '\"..lineState.Action..\"', got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- end inline conditionals since we should have handled it already\r\n                    if lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = false\r\n                    end\r\n\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    -- %if wxLUA_USE_xxx ... %endif\r\n                    elseif tag == \"%if\" then\r\n                        lineState.DefType = \"deftype_%if\"\r\n\r\n                    elseif tag == \"%endif\" then\r\n                        table.remove(parseState.ConditionStack, #parseState.ConditionStack) -- pop last %if\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%rename\" then\r\n                        lineState.Action = \"action_rename\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%function\" then\r\n                        lineState[\"%function\"] = true\r\n\r\n                    elseif tag == \"%gc_this\" then\r\n                        lineState[\"%gc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %gc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%ungc_this\" then\r\n                        lineState[\"%ungc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %ungc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%class\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%class\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%class\"\r\n                        lineState.Action = \"action_classname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endclass\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %endclass does not have matching %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endclass. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        lineState.Action = \"action_keyword\"\r\n                        lineState.ActionMandatory = true\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%delete\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%delete\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %delete is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%noclassinfo\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %noclassinfo is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%abstract\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %abstract is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%encapsulate\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %encapsulate is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%protected\" then -- skip %protected functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%private\" then -- skip %private functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%property\" then -- FIXME removed properties\r\n                        lineState.Skip = true\r\n                        print(\"WARNING: the %property tag is ignored and properties are generated at runtime.\")\r\n                        break\r\n\r\n                    elseif tag == \"%member\" then\r\n                        lineState.DefType = \"deftype_%member\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%member_func\" then\r\n                        lineState.DefType = \"deftype_%member_func\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member_func is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%constructor\" then\r\n                        lineState.IsConstructor = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %constructor is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%operator\" then\r\n                        lineState[\"%operator\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %operator is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%struct\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%struct\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        lineState.DefType = \"deftype_%struct\"\r\n                        lineState.Action = \"action_structname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endstruct\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\" then\r\n                            print(\"ERROR: %endstruct does not have matching %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endstruct. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%enum\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%enum\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%enum\"\r\n                        lineState.Action = \"action_enumname\"\r\n                        lineState.ActionMandatory = false -- not all enums have a name\r\n\r\n                    elseif tag == \"%endenum\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%enum\" then\r\n                            print(\"ERROR: %endenum does not have matching %enum. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        enumType = \"\"\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endenum. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%include\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%include\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%include\"\r\n                        lineState.Action = \"action_include\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%includefile\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%includefile\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%includefile\"\r\n                        lineState.Action = \"action_includefile\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%typedef\" then\r\n                        lineState.DefType = \"deftype_%typedef\"\r\n                        lineState.Action = \"action_typedef\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%override_name\" then\r\n                        lineState.Action = \"action_override_name\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%not_overload\" then\r\n                        lineState.NotOverload = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%define\" then\r\n                        lineState.DefType = \"deftype_%define\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_string\" then\r\n                        lineState.DefType = \"deftype_%define_string\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_event\" then\r\n                        lineState.DefType = \"deftype_%define_event\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_object\" then\r\n                        lineState.DefType = \"deftype_%define_object\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_pointer\" then\r\n                        lineState.DefType = \"deftype_%define_pointer\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    else\r\n                        print(\"WARNING: Unhandled keyword '\"..tag..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                end\r\n            -- ---------------------------------------------------------------\r\n            -- else !keyword[tag]\r\n            -- ---------------------------------------------------------------\r\n            elseif parseState.IsBlockComment == 0 then\r\n                -- handle condition operators, note can have leading ! for not\r\n                if (tag == \"!\") or (((lineState.DefType == \"deftype_%if\") or lineState.InlineConditionIf) and preprocOperatorTable[tag]) then\r\n                    if lineState.Condition or (preprocOperatorTable[tag] == \"!\") or (preprocOperatorTable[tag] == \"(\") then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = preprocOperatorTable[tag]\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if ((c ~= \"(\") and (preprocOperatorTable[tag] ~= \")\")) or\r\n                               ((c ~= \")\") and (preprocOperatorTable[tag] == \")\")) then\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n\r\n                            -- add c operator\r\n                            lineState.Condition = lineState.Condition..preprocOperatorTable[tag]\r\n                        end\r\n                    else\r\n                        print(\"ERROR: Unexpected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                elseif FindOrCreateCondition(tag) then\r\n                    if (lineState.DefType ~= \"deftype_%if\") and not lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = true\r\n                    end\r\n\r\n                    if not lineState.Condition then\r\n                        lineState.Condition = \"\"\r\n                    else\r\n                        local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                        if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                            if not preprocOperatorTable[c] then\r\n                                print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Condition = lineState.Condition..\" \"\r\n                        end\r\n                    end\r\n\r\n                    lineState.Condition = lineState.Condition..FindOrCreateCondition(tag)\r\n\r\n                elseif not skipBindingKeywordTable[tag] then\r\n                    -- -------------------------------------------------------\r\n                    --  Process Interface Data\r\n                    -- -------------------------------------------------------\r\n                    if (lineState.Action == \"action_keyword\") and lineState.ActionMandatory then\r\n                        print(\"ERROR: Invalid Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- add block condition\r\n                    -- -------------------------------------------------------\r\n                    if lineState.DefType == \"deftype_%if\" then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = \"\"\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                                if not preprocOperatorTable[c] then\r\n                                    print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n                        end\r\n\r\n                        lineState.Condition = lineState.Condition..tag\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- apply tag to lineState.Action\r\n                    -- -------------------------------------------------------\r\n                    else\r\n                        -- end inline conditionals\r\n                        if lineState.InlineConditionIf then\r\n                            lineState.InlineConditionIf = false\r\n                        end\r\n\r\n                        if not lineState.Action then\r\n                            -- no actions specified\r\n\r\n                            -- -----------------------------------------------\r\n                            -- enum parseObject\r\n                            if parseState.ObjectStack[1].ObjType == \"objtype_%enum\" then\r\n                                if IsDataType(tag) or dataTypeAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                    print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                elseif tag ~= \",\" then -- ignore trailing commas\r\n                                    lineState.DefType = \"deftype_%enum\"\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = enumType\r\n\r\n                                    local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))\r\n                                    table.insert(parseState.ObjectStack[1].Members, member)\r\n                                end\r\n\r\n                            -- -----------------------------------------------\r\n                            -- class or function parseObject\r\n                            elseif (parseState.ObjectStack[1].ObjType == \"objtype_%class\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_%struct\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_globals\") then\r\n                                if IsDataType(tag) then\r\n                                    lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif dataTypeAttribTable[tag] then\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"virtual\" then\r\n                                    lineState.IsVirtualFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"static\" then\r\n                                    lineState.IsStaticFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"inline\" then\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif lineState.IsConstructor then\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n\r\n                                else\r\n                                    print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n                            else\r\n                                print(\"ERROR: Unexpected parseObject :\"..parseState.ObjectStack[1].ObjType..\" \"..parseState.ObjectStack[1].Name..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n                        elseif lineState.Action == \"action_classname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_classcomma\" then\r\n                            if tag ~= \",\" then\r\n                                print(\"ERROR: %class tag expected ','. \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Action = \"action_classbase\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_classbase\" then\r\n                            table.insert(parseState.ObjectStack[1].BaseClasses, tag)\r\n\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_structname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_enumname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            enumType = tag\r\n                            lineState.DataType = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_include\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_includefile\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_override_name\" then\r\n                            lineState.override_name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_typedef\" then\r\n                            lineState.Name = tag\r\n                            lineState.RValue = {}\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_typedefvalue\" then\r\n                            --lineState.RValue = SpaceSeparateStrings(lineState.RValue, tag)\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\" -- allow more than one word\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_rename\" then\r\n                            lineState[\"%rename\"] = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_define\" then\r\n                            lineState.Name = tag\r\n                            -- if they specify a value after the tag use it, unless a keyword\r\n                            while (lineTags[t+1] ~= nil) and (bindingKeywordTable[lineTags[t+1]] == nil) do\r\n                                lineState.Value = (lineState.Value or \"\")..lineTags[t+1]\r\n                                t = t + 1\r\n                            end\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_member\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Member Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"virtual\" then\r\n                                lineState.IsVirtualFunction = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif lineState[\"%operator\"] and string.find(tag, \"operator\", 1, 1) then\r\n                                -- eat the rest of the \"operator+=(...)\" symbols which may be split before (\r\n                                if (string.sub(tag, -1) == \"r\") and (lineTags[t+1] == \"(\") and (lineTags[t+2] == \")\") then -- op_func\r\n                                    tag = tag..lineTags[t+1]..lineTags[t+2]\r\n                                    t = t + 2\r\n                                else\r\n                                    while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end\r\n                                end\r\n\r\n                                local a, b = string.find(tag, \"operator\", 1, 1)\r\n                                local op = string.sub(tag, b+1)\r\n                                lineState[\"%operator\"] = op\r\n\r\n                                lineState.Action = \"action_methodbracket\" -- next char should be (\r\n                                lineState.Name = bindingOperatorTable[op]\r\n\r\n                            elseif tag == \"(\" then\r\n                                if lineState.DataType == parseState.ObjectStack[1].Name then\r\n                                    lineState.IsConstructor = true\r\n                                end\r\n\r\n                                if lineState.IsConstructor then\r\n                                    if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n\r\n                                    if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end\r\n                                else\r\n                                    print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) then\r\n                                print(\"ERROR: Expected Method Name, got delimiter Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if lineState.IsConstructor then\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                end\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodbracket\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodbracket\" then\r\n                                if tag ~= \"(\" then\r\n                                    local msg = \"(Name=\"..tostring(lineState.Name)..\"; DataType=\"..tostring(lineState.DataType)..\")\"\r\n                                    print(\"ERROR: Expected Method Tag '(', got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.IsFunction = true\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                        elseif lineState.Action == \"action_methodparam\" then\r\n                            lineState.IsFunction = true\r\n\r\n                            if IsDataType(tag) then\r\n                                lineState.ParamState.DataType = SpaceSeparateStrings(lineState.ParamState.DataType, tag)\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                table.insert(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if lineState.ParamState.DataType then\r\n                                    InsertParamState(lineState.Params, lineState.ParamState)\r\n                                    lineState.ParamState = AllocParam()\r\n                                end\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Method Param Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.Name = tag\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_defaultvalue\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n                            elseif IsDataType(tag) or dataTypeAttribTable[tag] or functionAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") or IsDelimiter(tag) and (tag ~= \"|\") and (tag ~= \"&\") then\r\n                                print(\"ERROR: Expected Parameter Default Value, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.DefaultValue = SpaceSeparateStrings(lineState.ParamState.DefaultValue, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_paramdelimiter\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n                            elseif tag == \")\" then\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"[]\" then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            else\r\n                                local msg = \"(Name=\"..tostring(lineState.ParamState.Name)..\r\n                                            \"; DataType=\"..tostring(lineState.ParamState.DataType)..\")\"\r\n                                print(\"ERROR: Expected Parameter '=', ')', or ',' got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method_body\" then\r\n                            if tag == \"const\" then\r\n                                lineState.IsConstFunction = true\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.IsPureVirtualFunction = true\r\n                                parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            elseif (tag == \"{\") or (tag == \";\") then\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            else\r\n                                print(\"ERROR: Expected Parameter 'const', '=', ';', or '{' got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n            end\r\n        end\r\n\r\n        -- set line definition data\r\n        if lineState.DefType == \"deftype_%typedef\" then\r\n            -- line is in the form: typedef [unsigned int] wxUInt32\r\n            local typedef_name = lineState.RValue[#lineState.RValue]\r\n            local typedef_type = table.concat(lineState.RValue, \" \", 1, #lineState.RValue-1)\r\n\r\n            typedefTable[typedef_name] = typedef_type\r\n\r\n        elseif lineState.DefType == \"deftype_%if\" then\r\n            -- line is a block condition, push onto condition stack\r\n            table.insert(parseState.ConditionStack, lineState.Condition)\r\n\r\n        elseif (lineState.DefType == \"deftype_%member\") or (lineState.DefType == \"deftype_%member_func\") then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_string\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_event\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_object\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_pointer\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_method\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n        end\r\n\r\n        -- line is an object declaration\r\n        if lineState.ParseObjectDeclaration then\r\n            -- push inline condition onto condition stack\r\n            if not lineState.IsBlockCondition and lineState.Condition then\r\n                table.insert(parseState.ConditionStack, 1, lineState.Condition)\r\n            end\r\n\r\n            -- Set Parse Object Condition\r\n            parseState.ObjectStack[1].Condition = BuildCondition(parseState.ConditionStack)\r\n\r\n            -- Set Condition for DataType\r\n            if dataTypeTable[parseState.ObjectStack[1].Name] and parseState.ObjectStack[1].Condition then\r\n                dataTypeTable[parseState.ObjectStack[1].Name].Condition = parseState.ObjectStack[1].Condition\r\n            end\r\n\r\n            -- Set if this data type should be Encapsulated\r\n            if dataTypeTable[parseState.ObjectStack[1].Name] and parseState.ObjectStack[1][\"%encapsulate\"] then\r\n                dataTypeTable[parseState.ObjectStack[1].Name][\"%encapsulate\"] = parseState.ObjectStack[1][\"%encapsulate\"]\r\n            end\r\n\r\n            -- pop inline condition onto condition stack\r\n            if not lineState.IsBlockCondition and lineState.Condition then\r\n                table.remove(parseState.ConditionStack, 1)\r\n            end\r\n        end\r\n\r\n        -- pop parseObject off objectStack\r\n        if lineState.PopParseObject then\r\n            table.insert(objectList, parseState.ObjectStack[1])\r\n\r\n            table.remove(parseState.ObjectStack, 1)\r\n\r\n            if #parseState.ObjectStack == 0 then\r\n                print(\"ERROR: parseState.ObjectStack is unexpectedly empty. \"..LineTableErrString(lineTable))\r\n            end\r\n        end\r\n    end\r\n\r\n    -- pop globals parseObject that was put in first\r\n    table.insert(objectList, 1, parseState.ObjectStack[1])\r\n    table.remove(parseState.ObjectStack, 1)\r\n\r\n    if #parseState.ObjectStack ~= 0 then\r\n        print(\"ERROR: parseState.ObjectStack should be empty, has \"..#parseState.ObjectStack..\" items left.\")\r\n        TableDump(parseState.ObjectStack, \"parseState.ObjectStack\")\r\n    end\r\n\r\n    return objectList\r\nend",
    "type": "function"
  }, {
    "id": 1014,
    "text": "local objectList = {}",
    "type": "statement:localassign"
  }, {
    "id": 1015,
    "text": "local parseState =\r\n    {\r\n        ObjectStack    = {},\r\n        ConditionStack = {}, -- stack of conditions\r\n        IsBlockComment = 0,  -- /* then +1 else */ then -1, 0 == not in comment\r\n    }",
    "type": "statement:localassign"
  }, {
    "id": 1016,
    "text": "local globals = AllocParseObject(\"objtype_globals\")",
    "type": "statement:localassign"
  }, {
    "id": 1017,
    "text": "globals.Name = \"globals\"",
    "type": "statement:assign"
  }, {
    "id": 1018,
    "text": "table.insert(parseState.ObjectStack, 1, globals)",
    "type": "statement:functioncall"
  }, {
    "id": 1019,
    "text": "local enumType = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1020,
    "text": "local l = 0",
    "type": "statement:localassign"
  }, {
    "id": 1021,
    "text": "while interfaceData[l+1] do -- not for loop so we can adjust l\r\n        l = l + 1\r\n\r\n        local lineTable = interfaceData[l]\r\n        local lineTags  = interfaceData[l].Tags\r\n\r\n        local lineState =\r\n        {\r\n            Skip                  = false, -- skip rest of line\r\n            InlineConditionIf     = false, -- single line condition\r\n            Action                = nil,\r\n            ActionAttributes      = {},\r\n            ActionMandatory       = false,\r\n            PopParseObject        = nil,\r\n            ParamState            = AllocParam(),\r\n            BaseClasses           = {},\r\n            RValue                = nil,\r\n\r\n            DefType               = nil, -- below are copied by AllocMember\r\n            DataType              = nil,\r\n            DataTypeWithAttrib    = nil,\r\n            DataTypePointer       = {},\r\n            Name                  = nil,\r\n            [\"%rename\"]           = nil,\r\n            Value                 = nil,\r\n            [\"%gc_this\"]          = nil,\r\n            [\"%ungc_this\"]        = nil,\r\n            [\"%function\"]         = nil,\r\n            IsConstructor         = nil,\r\n            [\"%operator\"]         = nil,\r\n            IsFunction            = nil,\r\n            IsConstFunction       = nil,\r\n            IsStaticFunction      = nil,\r\n            IsVirtualFunction     = nil,\r\n            IsPureVirtualFunction = nil,\r\n            override_name         = nil,\r\n            NotOverload           = nil,\r\n            Condition             = nil,\r\n            Params                = {},\r\n            FileName              = lineTable.FileName,\r\n            LineNumber            = lineTable.LineNumber,\r\n            LineText              = lineTable.LineText,\r\n        }\r\n\r\n        local t = 0\r\n        while lineTags[t+1] do\r\n            t = t + 1\r\n            local tag = lineTags[t]\r\n\r\n            if lineState.Skip then\r\n                break\r\n            end\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- Is this tag a binding keyword, e.g. %XXX\r\n            -- ---------------------------------------------------------------\r\n            if bindingKeywordTable[tag] then\r\n                -- block comment (start)\r\n                if tag == \"/*\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment - 1\r\n\r\n                -- ignore until end of block comment\r\n                elseif parseState.IsBlockComment == 0 then\r\n\r\n                    -- warn if we're expecting something and it's not there\r\n                    if not lineState.ActionAttributes[tag] and lineState.ActionMandatory then\r\n                        print(\"ERROR: Expected Line Action '\"..lineState.Action..\"', got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- end inline conditionals since we should have handled it already\r\n                    if lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = false\r\n                    end\r\n\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    -- %if wxLUA_USE_xxx ... %endif\r\n                    elseif tag == \"%if\" then\r\n                        lineState.DefType = \"deftype_%if\"\r\n\r\n                    elseif tag == \"%endif\" then\r\n                        table.remove(parseState.ConditionStack, #parseState.ConditionStack) -- pop last %if\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%rename\" then\r\n                        lineState.Action = \"action_rename\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%function\" then\r\n                        lineState[\"%function\"] = true\r\n\r\n                    elseif tag == \"%gc_this\" then\r\n                        lineState[\"%gc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %gc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%ungc_this\" then\r\n                        lineState[\"%ungc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %ungc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%class\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%class\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%class\"\r\n                        lineState.Action = \"action_classname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endclass\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %endclass does not have matching %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endclass. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        lineState.Action = \"action_keyword\"\r\n                        lineState.ActionMandatory = true\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%delete\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%delete\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %delete is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%noclassinfo\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %noclassinfo is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%abstract\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %abstract is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%encapsulate\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %encapsulate is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%protected\" then -- skip %protected functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%private\" then -- skip %private functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%property\" then -- FIXME removed properties\r\n                        lineState.Skip = true\r\n                        print(\"WARNING: the %property tag is ignored and properties are generated at runtime.\")\r\n                        break\r\n\r\n                    elseif tag == \"%member\" then\r\n                        lineState.DefType = \"deftype_%member\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%member_func\" then\r\n                        lineState.DefType = \"deftype_%member_func\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member_func is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%constructor\" then\r\n                        lineState.IsConstructor = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %constructor is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%operator\" then\r\n                        lineState[\"%operator\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %operator is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%struct\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%struct\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        lineState.DefType = \"deftype_%struct\"\r\n                        lineState.Action = \"action_structname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endstruct\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\" then\r\n                            print(\"ERROR: %endstruct does not have matching %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endstruct. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%enum\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%enum\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%enum\"\r\n                        lineState.Action = \"action_enumname\"\r\n                        lineState.ActionMandatory = false -- not all enums have a name\r\n\r\n                    elseif tag == \"%endenum\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%enum\" then\r\n                            print(\"ERROR: %endenum does not have matching %enum. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        enumType = \"\"\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endenum. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%include\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%include\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%include\"\r\n                        lineState.Action = \"action_include\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%includefile\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%includefile\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%includefile\"\r\n                        lineState.Action = \"action_includefile\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%typedef\" then\r\n                        lineState.DefType = \"deftype_%typedef\"\r\n                        lineState.Action = \"action_typedef\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%override_name\" then\r\n                        lineState.Action = \"action_override_name\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%not_overload\" then\r\n                        lineState.NotOverload = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%define\" then\r\n                        lineState.DefType = \"deftype_%define\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_string\" then\r\n                        lineState.DefType = \"deftype_%define_string\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_event\" then\r\n                        lineState.DefType = \"deftype_%define_event\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_object\" then\r\n                        lineState.DefType = \"deftype_%define_object\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_pointer\" then\r\n                        lineState.DefType = \"deftype_%define_pointer\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    else\r\n                        print(\"WARNING: Unhandled keyword '\"..tag..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                end\r\n            -- ---------------------------------------------------------------\r\n            -- else !keyword[tag]\r\n            -- ---------------------------------------------------------------\r\n            elseif parseState.IsBlockComment == 0 then\r\n                -- handle condition operators, note can have leading ! for not\r\n                if (tag == \"!\") or (((lineState.DefType == \"deftype_%if\") or lineState.InlineConditionIf) and preprocOperatorTable[tag]) then\r\n                    if lineState.Condition or (preprocOperatorTable[tag] == \"!\") or (preprocOperatorTable[tag] == \"(\") then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = preprocOperatorTable[tag]\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if ((c ~= \"(\") and (preprocOperatorTable[tag] ~= \")\")) or\r\n                               ((c ~= \")\") and (preprocOperatorTable[tag] == \")\")) then\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n\r\n                            -- add c operator\r\n                            lineState.Condition = lineState.Condition..preprocOperatorTable[tag]\r\n                        end\r\n                    else\r\n                        print(\"ERROR: Unexpected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                elseif FindOrCreateCondition(tag) then\r\n                    if (lineState.DefType ~= \"deftype_%if\") and not lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = true\r\n                    end\r\n\r\n                    if not lineState.Condition then\r\n                        lineState.Condition = \"\"\r\n                    else\r\n                        local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                        if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                            if not preprocOperatorTable[c] then\r\n                                print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Condition = lineState.Condition..\" \"\r\n                        end\r\n                    end\r\n\r\n                    lineState.Condition = lineState.Condition..FindOrCreateCondition(tag)\r\n\r\n                elseif not skipBindingKeywordTable[tag] then\r\n                    -- -------------------------------------------------------\r\n                    --  Process Interface Data\r\n                    -- -------------------------------------------------------\r\n                    if (lineState.Action == \"action_keyword\") and lineState.ActionMandatory then\r\n                        print(\"ERROR: Invalid Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- add block condition\r\n                    -- -------------------------------------------------------\r\n                    if lineState.DefType == \"deftype_%if\" then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = \"\"\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                                if not preprocOperatorTable[c] then\r\n                                    print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n                        end\r\n\r\n                        lineState.Condition = lineState.Condition..tag\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- apply tag to lineState.Action\r\n                    -- -------------------------------------------------------\r\n                    else\r\n                        -- end inline conditionals\r\n                        if lineState.InlineConditionIf then\r\n                            lineState.InlineConditionIf = false\r\n                        end\r\n\r\n                        if not lineState.Action then\r\n                            -- no actions specified\r\n\r\n                            -- -----------------------------------------------\r\n                            -- enum parseObject\r\n                            if parseState.ObjectStack[1].ObjType == \"objtype_%enum\" then\r\n                                if IsDataType(tag) or dataTypeAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                    print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                elseif tag ~= \",\" then -- ignore trailing commas\r\n                                    lineState.DefType = \"deftype_%enum\"\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = enumType\r\n\r\n                                    local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))\r\n                                    table.insert(parseState.ObjectStack[1].Members, member)\r\n                                end\r\n\r\n                            -- -----------------------------------------------\r\n                            -- class or function parseObject\r\n                            elseif (parseState.ObjectStack[1].ObjType == \"objtype_%class\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_%struct\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_globals\") then\r\n                                if IsDataType(tag) then\r\n                                    lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif dataTypeAttribTable[tag] then\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"virtual\" then\r\n                                    lineState.IsVirtualFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"static\" then\r\n                                    lineState.IsStaticFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"inline\" then\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif lineState.IsConstructor then\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n\r\n                                else\r\n                                    print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n                            else\r\n                                print(\"ERROR: Unexpected parseObject :\"..parseState.ObjectStack[1].ObjType..\" \"..parseState.ObjectStack[1].Name..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n                        elseif lineState.Action == \"action_classname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_classcomma\" then\r\n                            if tag ~= \",\" then\r\n                                print(\"ERROR: %class tag expected ','. \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Action = \"action_classbase\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_classbase\" then\r\n                            table.insert(parseState.ObjectStack[1].BaseClasses, tag)\r\n\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_structname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_enumname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            enumType = tag\r\n                            lineState.DataType = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_include\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_includefile\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_override_name\" then\r\n                            lineState.override_name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_typedef\" then\r\n                            lineState.Name = tag\r\n                            lineState.RValue = {}\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_typedefvalue\" then\r\n                            --lineState.RValue = SpaceSeparateStrings(lineState.RValue, tag)\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\" -- allow more than one word\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_rename\" then\r\n                            lineState[\"%rename\"] = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_define\" then\r\n                            lineState.Name = tag\r\n                            -- if they specify a value after the tag use it, unless a keyword\r\n                            while (lineTags[t+1] ~= nil) and (bindingKeywordTable[lineTags[t+1]] == nil) do\r\n                                lineState.Value = (lineState.Value or \"\")..lineTags[t+1]\r\n                                t = t + 1\r\n                            end\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_member\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Member Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"virtual\" then\r\n                                lineState.IsVirtualFunction = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif lineState[\"%operator\"] and string.find(tag, \"operator\", 1, 1) then\r\n                                -- eat the rest of the \"operator+=(...)\" symbols which may be split before (\r\n                                if (string.sub(tag, -1) == \"r\") and (lineTags[t+1] == \"(\") and (lineTags[t+2] == \")\") then -- op_func\r\n                                    tag = tag..lineTags[t+1]..lineTags[t+2]\r\n                                    t = t + 2\r\n                                else\r\n                                    while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end\r\n                                end\r\n\r\n                                local a, b = string.find(tag, \"operator\", 1, 1)\r\n                                local op = string.sub(tag, b+1)\r\n                                lineState[\"%operator\"] = op\r\n\r\n                                lineState.Action = \"action_methodbracket\" -- next char should be (\r\n                                lineState.Name = bindingOperatorTable[op]\r\n\r\n                            elseif tag == \"(\" then\r\n                                if lineState.DataType == parseState.ObjectStack[1].Name then\r\n                                    lineState.IsConstructor = true\r\n                                end\r\n\r\n                                if lineState.IsConstructor then\r\n                                    if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n\r\n                                    if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end\r\n                                else\r\n                                    print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) then\r\n                                print(\"ERROR: Expected Method Name, got delimiter Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if lineState.IsConstructor then\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                end\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodbracket\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodbracket\" then\r\n                                if tag ~= \"(\" then\r\n                                    local msg = \"(Name=\"..tostring(lineState.Name)..\"; DataType=\"..tostring(lineState.DataType)..\")\"\r\n                                    print(\"ERROR: Expected Method Tag '(', got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.IsFunction = true\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                        elseif lineState.Action == \"action_methodparam\" then\r\n                            lineState.IsFunction = true\r\n\r\n                            if IsDataType(tag) then\r\n                                lineState.ParamState.DataType = SpaceSeparateStrings(lineState.ParamState.DataType, tag)\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                table.insert(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if lineState.ParamState.DataType then\r\n                                    InsertParamState(lineState.Params, lineState.ParamState)\r\n                                    lineState.ParamState = AllocParam()\r\n                                end\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Method Param Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.Name = tag\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_defaultvalue\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n                            elseif IsDataType(tag) or dataTypeAttribTable[tag] or functionAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") or IsDelimiter(tag) and (tag ~= \"|\") and (tag ~= \"&\") then\r\n                                print(\"ERROR: Expected Parameter Default Value, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.DefaultValue = SpaceSeparateStrings(lineState.ParamState.DefaultValue, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_paramdelimiter\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n                            elseif tag == \")\" then\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"[]\" then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            else\r\n                                local msg = \"(Name=\"..tostring(lineState.ParamState.Name)..\r\n                                            \"; DataType=\"..tostring(lineState.ParamState.DataType)..\")\"\r\n                                print(\"ERROR: Expected Parameter '=', ')', or ',' got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method_body\" then\r\n                            if tag == \"const\" then\r\n                                lineState.IsConstFunction = true\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.IsPureVirtualFunction = true\r\n                                parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            elseif (tag == \"{\") or (tag == \";\") then\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            else\r\n                                print(\"ERROR: Expected Parameter 'const', '=', ';', or '{' got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n            end\r\n        end\r\n\r\n        -- set line definition data\r\n        if lineState.DefType == \"deftype_%typedef\" then\r\n            -- line is in the form: typedef [unsigned int] wxUInt32\r\n            local typedef_name = lineState.RValue[#lineState.RValue]\r\n            local typedef_type = table.concat(lineState.RValue, \" \", 1, #lineState.RValue-1)\r\n\r\n            typedefTable[typedef_name] = typedef_type\r\n\r\n        elseif lineState.DefType == \"deftype_%if\" then\r\n            -- line is a block condition, push onto condition stack\r\n            table.insert(parseState.ConditionStack, lineState.Condition)\r\n\r\n        elseif (lineState.DefType == \"deftype_%member\") or (lineState.DefType == \"deftype_%member_func\") then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_string\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_event\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_object\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_pointer\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_method\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n        end\r\n\r\n        -- line is an object declaration\r\n        if lineState.ParseObjectDeclaration then\r\n            -- push inline condition onto condition stack\r\n            if not lineState.IsBlockCondition and lineState.Condition then\r\n                table.insert(parseState.ConditionStack, 1, lineState.Condition)\r\n            end\r\n\r\n            -- Set Parse Object Condition\r\n            parseState.ObjectStack[1].Condition = BuildCondition(parseState.ConditionStack)\r\n\r\n            -- Set Condition for DataType\r\n            if dataTypeTable[parseState.ObjectStack[1].Name] and parseState.ObjectStack[1].Condition then\r\n                dataTypeTable[parseState.ObjectStack[1].Name].Condition = parseState.ObjectStack[1].Condition\r\n            end\r\n\r\n            -- Set if this data type should be Encapsulated\r\n            if dataTypeTable[parseState.ObjectStack[1].Name] and parseState.ObjectStack[1][\"%encapsulate\"] then\r\n                dataTypeTable[parseState.ObjectStack[1].Name][\"%encapsulate\"] = parseState.ObjectStack[1][\"%encapsulate\"]\r\n            end\r\n\r\n            -- pop inline condition onto condition stack\r\n            if not lineState.IsBlockCondition and lineState.Condition then\r\n                table.remove(parseState.ConditionStack, 1)\r\n            end\r\n        end\r\n\r\n        -- pop parseObject off objectStack\r\n        if lineState.PopParseObject then\r\n            table.insert(objectList, parseState.ObjectStack[1])\r\n\r\n            table.remove(parseState.ObjectStack, 1)\r\n\r\n            if #parseState.ObjectStack == 0 then\r\n                print(\"ERROR: parseState.ObjectStack is unexpectedly empty. \"..LineTableErrString(lineTable))\r\n            end\r\n        end\r\n    end",
    "type": "statement:while"
  }, {
    "id": 1022,
    "text": "l = l + 1",
    "type": "statement:assign"
  }, {
    "id": 1023,
    "text": "local lineTags  = interfaceData[l].Tags",
    "type": "statement:localassign"
  }, {
    "id": 1024,
    "text": "local lineState =\r\n        {\r\n            Skip                  = false, -- skip rest of line\r\n            InlineConditionIf     = false, -- single line condition\r\n            Action                = nil,\r\n            ActionAttributes      = {},\r\n            ActionMandatory       = false,\r\n            PopParseObject        = nil,\r\n            ParamState            = AllocParam(),\r\n            BaseClasses           = {},\r\n            RValue                = nil,\r\n\r\n            DefType               = nil, -- below are copied by AllocMember\r\n            DataType              = nil,\r\n            DataTypeWithAttrib    = nil,\r\n            DataTypePointer       = {},\r\n            Name                  = nil,\r\n            [\"%rename\"]           = nil,\r\n            Value                 = nil,\r\n            [\"%gc_this\"]          = nil,\r\n            [\"%ungc_this\"]        = nil,\r\n            [\"%function\"]         = nil,\r\n            IsConstructor         = nil,\r\n            [\"%operator\"]         = nil,\r\n            IsFunction            = nil,\r\n            IsConstFunction       = nil,\r\n            IsStaticFunction      = nil,\r\n            IsVirtualFunction     = nil,\r\n            IsPureVirtualFunction = nil,\r\n            override_name         = nil,\r\n            NotOverload           = nil,\r\n            Condition             = nil,\r\n            Params                = {},\r\n            FileName              = lineTable.FileName,\r\n            LineNumber            = lineTable.LineNumber,\r\n            LineText              = lineTable.LineText,\r\n        }",
    "type": "statement:localassign"
  }, {
    "id": 1025,
    "text": "local t = 0",
    "type": "statement:localassign"
  }, {
    "id": 1026,
    "text": "while lineTags[t+1] do\r\n            t = t + 1\r\n            local tag = lineTags[t]\r\n\r\n            if lineState.Skip then\r\n                break\r\n            end\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- Is this tag a binding keyword, e.g. %XXX\r\n            -- ---------------------------------------------------------------\r\n            if bindingKeywordTable[tag] then\r\n                -- block comment (start)\r\n                if tag == \"/*\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment - 1\r\n\r\n                -- ignore until end of block comment\r\n                elseif parseState.IsBlockComment == 0 then\r\n\r\n                    -- warn if we're expecting something and it's not there\r\n                    if not lineState.ActionAttributes[tag] and lineState.ActionMandatory then\r\n                        print(\"ERROR: Expected Line Action '\"..lineState.Action..\"', got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- end inline conditionals since we should have handled it already\r\n                    if lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = false\r\n                    end\r\n\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    -- %if wxLUA_USE_xxx ... %endif\r\n                    elseif tag == \"%if\" then\r\n                        lineState.DefType = \"deftype_%if\"\r\n\r\n                    elseif tag == \"%endif\" then\r\n                        table.remove(parseState.ConditionStack, #parseState.ConditionStack) -- pop last %if\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%rename\" then\r\n                        lineState.Action = \"action_rename\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%function\" then\r\n                        lineState[\"%function\"] = true\r\n\r\n                    elseif tag == \"%gc_this\" then\r\n                        lineState[\"%gc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %gc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%ungc_this\" then\r\n                        lineState[\"%ungc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %ungc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%class\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%class\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%class\"\r\n                        lineState.Action = \"action_classname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endclass\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %endclass does not have matching %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endclass. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        lineState.Action = \"action_keyword\"\r\n                        lineState.ActionMandatory = true\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%delete\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%delete\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %delete is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%noclassinfo\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %noclassinfo is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%abstract\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %abstract is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%encapsulate\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %encapsulate is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%protected\" then -- skip %protected functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%private\" then -- skip %private functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%property\" then -- FIXME removed properties\r\n                        lineState.Skip = true\r\n                        print(\"WARNING: the %property tag is ignored and properties are generated at runtime.\")\r\n                        break\r\n\r\n                    elseif tag == \"%member\" then\r\n                        lineState.DefType = \"deftype_%member\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%member_func\" then\r\n                        lineState.DefType = \"deftype_%member_func\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member_func is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%constructor\" then\r\n                        lineState.IsConstructor = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %constructor is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%operator\" then\r\n                        lineState[\"%operator\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %operator is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%struct\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%struct\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        lineState.DefType = \"deftype_%struct\"\r\n                        lineState.Action = \"action_structname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endstruct\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\" then\r\n                            print(\"ERROR: %endstruct does not have matching %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endstruct. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%enum\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%enum\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%enum\"\r\n                        lineState.Action = \"action_enumname\"\r\n                        lineState.ActionMandatory = false -- not all enums have a name\r\n\r\n                    elseif tag == \"%endenum\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%enum\" then\r\n                            print(\"ERROR: %endenum does not have matching %enum. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        enumType = \"\"\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endenum. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%include\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%include\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%include\"\r\n                        lineState.Action = \"action_include\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%includefile\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%includefile\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%includefile\"\r\n                        lineState.Action = \"action_includefile\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%typedef\" then\r\n                        lineState.DefType = \"deftype_%typedef\"\r\n                        lineState.Action = \"action_typedef\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%override_name\" then\r\n                        lineState.Action = \"action_override_name\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%not_overload\" then\r\n                        lineState.NotOverload = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%define\" then\r\n                        lineState.DefType = \"deftype_%define\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_string\" then\r\n                        lineState.DefType = \"deftype_%define_string\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_event\" then\r\n                        lineState.DefType = \"deftype_%define_event\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_object\" then\r\n                        lineState.DefType = \"deftype_%define_object\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_pointer\" then\r\n                        lineState.DefType = \"deftype_%define_pointer\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    else\r\n                        print(\"WARNING: Unhandled keyword '\"..tag..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                end\r\n            -- ---------------------------------------------------------------\r\n            -- else !keyword[tag]\r\n            -- ---------------------------------------------------------------\r\n            elseif parseState.IsBlockComment == 0 then\r\n                -- handle condition operators, note can have leading ! for not\r\n                if (tag == \"!\") or (((lineState.DefType == \"deftype_%if\") or lineState.InlineConditionIf) and preprocOperatorTable[tag]) then\r\n                    if lineState.Condition or (preprocOperatorTable[tag] == \"!\") or (preprocOperatorTable[tag] == \"(\") then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = preprocOperatorTable[tag]\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if ((c ~= \"(\") and (preprocOperatorTable[tag] ~= \")\")) or\r\n                               ((c ~= \")\") and (preprocOperatorTable[tag] == \")\")) then\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n\r\n                            -- add c operator\r\n                            lineState.Condition = lineState.Condition..preprocOperatorTable[tag]\r\n                        end\r\n                    else\r\n                        print(\"ERROR: Unexpected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                elseif FindOrCreateCondition(tag) then\r\n                    if (lineState.DefType ~= \"deftype_%if\") and not lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = true\r\n                    end\r\n\r\n                    if not lineState.Condition then\r\n                        lineState.Condition = \"\"\r\n                    else\r\n                        local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                        if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                            if not preprocOperatorTable[c] then\r\n                                print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Condition = lineState.Condition..\" \"\r\n                        end\r\n                    end\r\n\r\n                    lineState.Condition = lineState.Condition..FindOrCreateCondition(tag)\r\n\r\n                elseif not skipBindingKeywordTable[tag] then\r\n                    -- -------------------------------------------------------\r\n                    --  Process Interface Data\r\n                    -- -------------------------------------------------------\r\n                    if (lineState.Action == \"action_keyword\") and lineState.ActionMandatory then\r\n                        print(\"ERROR: Invalid Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- add block condition\r\n                    -- -------------------------------------------------------\r\n                    if lineState.DefType == \"deftype_%if\" then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = \"\"\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                                if not preprocOperatorTable[c] then\r\n                                    print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n                        end\r\n\r\n                        lineState.Condition = lineState.Condition..tag\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- apply tag to lineState.Action\r\n                    -- -------------------------------------------------------\r\n                    else\r\n                        -- end inline conditionals\r\n                        if lineState.InlineConditionIf then\r\n                            lineState.InlineConditionIf = false\r\n                        end\r\n\r\n                        if not lineState.Action then\r\n                            -- no actions specified\r\n\r\n                            -- -----------------------------------------------\r\n                            -- enum parseObject\r\n                            if parseState.ObjectStack[1].ObjType == \"objtype_%enum\" then\r\n                                if IsDataType(tag) or dataTypeAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                    print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                elseif tag ~= \",\" then -- ignore trailing commas\r\n                                    lineState.DefType = \"deftype_%enum\"\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = enumType\r\n\r\n                                    local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))\r\n                                    table.insert(parseState.ObjectStack[1].Members, member)\r\n                                end\r\n\r\n                            -- -----------------------------------------------\r\n                            -- class or function parseObject\r\n                            elseif (parseState.ObjectStack[1].ObjType == \"objtype_%class\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_%struct\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_globals\") then\r\n                                if IsDataType(tag) then\r\n                                    lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif dataTypeAttribTable[tag] then\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"virtual\" then\r\n                                    lineState.IsVirtualFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"static\" then\r\n                                    lineState.IsStaticFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"inline\" then\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif lineState.IsConstructor then\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n\r\n                                else\r\n                                    print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n                            else\r\n                                print(\"ERROR: Unexpected parseObject :\"..parseState.ObjectStack[1].ObjType..\" \"..parseState.ObjectStack[1].Name..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n                        elseif lineState.Action == \"action_classname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_classcomma\" then\r\n                            if tag ~= \",\" then\r\n                                print(\"ERROR: %class tag expected ','. \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Action = \"action_classbase\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_classbase\" then\r\n                            table.insert(parseState.ObjectStack[1].BaseClasses, tag)\r\n\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_structname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_enumname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            enumType = tag\r\n                            lineState.DataType = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_include\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_includefile\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_override_name\" then\r\n                            lineState.override_name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_typedef\" then\r\n                            lineState.Name = tag\r\n                            lineState.RValue = {}\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_typedefvalue\" then\r\n                            --lineState.RValue = SpaceSeparateStrings(lineState.RValue, tag)\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\" -- allow more than one word\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_rename\" then\r\n                            lineState[\"%rename\"] = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_define\" then\r\n                            lineState.Name = tag\r\n                            -- if they specify a value after the tag use it, unless a keyword\r\n                            while (lineTags[t+1] ~= nil) and (bindingKeywordTable[lineTags[t+1]] == nil) do\r\n                                lineState.Value = (lineState.Value or \"\")..lineTags[t+1]\r\n                                t = t + 1\r\n                            end\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_member\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Member Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"virtual\" then\r\n                                lineState.IsVirtualFunction = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif lineState[\"%operator\"] and string.find(tag, \"operator\", 1, 1) then\r\n                                -- eat the rest of the \"operator+=(...)\" symbols which may be split before (\r\n                                if (string.sub(tag, -1) == \"r\") and (lineTags[t+1] == \"(\") and (lineTags[t+2] == \")\") then -- op_func\r\n                                    tag = tag..lineTags[t+1]..lineTags[t+2]\r\n                                    t = t + 2\r\n                                else\r\n                                    while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end\r\n                                end\r\n\r\n                                local a, b = string.find(tag, \"operator\", 1, 1)\r\n                                local op = string.sub(tag, b+1)\r\n                                lineState[\"%operator\"] = op\r\n\r\n                                lineState.Action = \"action_methodbracket\" -- next char should be (\r\n                                lineState.Name = bindingOperatorTable[op]\r\n\r\n                            elseif tag == \"(\" then\r\n                                if lineState.DataType == parseState.ObjectStack[1].Name then\r\n                                    lineState.IsConstructor = true\r\n                                end\r\n\r\n                                if lineState.IsConstructor then\r\n                                    if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n\r\n                                    if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end\r\n                                else\r\n                                    print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) then\r\n                                print(\"ERROR: Expected Method Name, got delimiter Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if lineState.IsConstructor then\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                end\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodbracket\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodbracket\" then\r\n                                if tag ~= \"(\" then\r\n                                    local msg = \"(Name=\"..tostring(lineState.Name)..\"; DataType=\"..tostring(lineState.DataType)..\")\"\r\n                                    print(\"ERROR: Expected Method Tag '(', got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.IsFunction = true\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                        elseif lineState.Action == \"action_methodparam\" then\r\n                            lineState.IsFunction = true\r\n\r\n                            if IsDataType(tag) then\r\n                                lineState.ParamState.DataType = SpaceSeparateStrings(lineState.ParamState.DataType, tag)\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                table.insert(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if lineState.ParamState.DataType then\r\n                                    InsertParamState(lineState.Params, lineState.ParamState)\r\n                                    lineState.ParamState = AllocParam()\r\n                                end\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Method Param Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.Name = tag\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_defaultvalue\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n                            elseif IsDataType(tag) or dataTypeAttribTable[tag] or functionAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") or IsDelimiter(tag) and (tag ~= \"|\") and (tag ~= \"&\") then\r\n                                print(\"ERROR: Expected Parameter Default Value, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.DefaultValue = SpaceSeparateStrings(lineState.ParamState.DefaultValue, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_paramdelimiter\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n                            elseif tag == \")\" then\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"[]\" then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            else\r\n                                local msg = \"(Name=\"..tostring(lineState.ParamState.Name)..\r\n                                            \"; DataType=\"..tostring(lineState.ParamState.DataType)..\")\"\r\n                                print(\"ERROR: Expected Parameter '=', ')', or ',' got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method_body\" then\r\n                            if tag == \"const\" then\r\n                                lineState.IsConstFunction = true\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.IsPureVirtualFunction = true\r\n                                parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            elseif (tag == \"{\") or (tag == \";\") then\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            else\r\n                                print(\"ERROR: Expected Parameter 'const', '=', ';', or '{' got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n            end\r\n        end",
    "type": "statement:while"
  }, {
    "id": 1027,
    "text": "t = t + 1",
    "type": "statement:assign"
  }, {
    "id": 1028,
    "text": "if lineState.Skip then\r\n                break\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1029,
    "text": "if bindingKeywordTable[tag] then\r\n                -- block comment (start)\r\n                if tag == \"/*\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment - 1\r\n\r\n                -- ignore until end of block comment\r\n                elseif parseState.IsBlockComment == 0 then\r\n\r\n                    -- warn if we're expecting something and it's not there\r\n                    if not lineState.ActionAttributes[tag] and lineState.ActionMandatory then\r\n                        print(\"ERROR: Expected Line Action '\"..lineState.Action..\"', got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- end inline conditionals since we should have handled it already\r\n                    if lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = false\r\n                    end\r\n\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    -- %if wxLUA_USE_xxx ... %endif\r\n                    elseif tag == \"%if\" then\r\n                        lineState.DefType = \"deftype_%if\"\r\n\r\n                    elseif tag == \"%endif\" then\r\n                        table.remove(parseState.ConditionStack, #parseState.ConditionStack) -- pop last %if\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%rename\" then\r\n                        lineState.Action = \"action_rename\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%function\" then\r\n                        lineState[\"%function\"] = true\r\n\r\n                    elseif tag == \"%gc_this\" then\r\n                        lineState[\"%gc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %gc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%ungc_this\" then\r\n                        lineState[\"%ungc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %ungc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%class\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%class\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%class\"\r\n                        lineState.Action = \"action_classname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endclass\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %endclass does not have matching %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endclass. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        lineState.Action = \"action_keyword\"\r\n                        lineState.ActionMandatory = true\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%delete\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%delete\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %delete is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%noclassinfo\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %noclassinfo is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%abstract\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %abstract is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%encapsulate\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %encapsulate is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%protected\" then -- skip %protected functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%private\" then -- skip %private functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%property\" then -- FIXME removed properties\r\n                        lineState.Skip = true\r\n                        print(\"WARNING: the %property tag is ignored and properties are generated at runtime.\")\r\n                        break\r\n\r\n                    elseif tag == \"%member\" then\r\n                        lineState.DefType = \"deftype_%member\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%member_func\" then\r\n                        lineState.DefType = \"deftype_%member_func\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member_func is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%constructor\" then\r\n                        lineState.IsConstructor = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %constructor is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%operator\" then\r\n                        lineState[\"%operator\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %operator is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%struct\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%struct\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        lineState.DefType = \"deftype_%struct\"\r\n                        lineState.Action = \"action_structname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endstruct\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\" then\r\n                            print(\"ERROR: %endstruct does not have matching %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endstruct. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%enum\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%enum\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%enum\"\r\n                        lineState.Action = \"action_enumname\"\r\n                        lineState.ActionMandatory = false -- not all enums have a name\r\n\r\n                    elseif tag == \"%endenum\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%enum\" then\r\n                            print(\"ERROR: %endenum does not have matching %enum. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        enumType = \"\"\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endenum. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%include\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%include\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%include\"\r\n                        lineState.Action = \"action_include\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%includefile\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%includefile\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%includefile\"\r\n                        lineState.Action = \"action_includefile\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%typedef\" then\r\n                        lineState.DefType = \"deftype_%typedef\"\r\n                        lineState.Action = \"action_typedef\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%override_name\" then\r\n                        lineState.Action = \"action_override_name\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%not_overload\" then\r\n                        lineState.NotOverload = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%define\" then\r\n                        lineState.DefType = \"deftype_%define\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_string\" then\r\n                        lineState.DefType = \"deftype_%define_string\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_event\" then\r\n                        lineState.DefType = \"deftype_%define_event\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_object\" then\r\n                        lineState.DefType = \"deftype_%define_object\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_pointer\" then\r\n                        lineState.DefType = \"deftype_%define_pointer\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    else\r\n                        print(\"WARNING: Unhandled keyword '\"..tag..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                end\r\n            -- ---------------------------------------------------------------\r\n            -- else !keyword[tag]\r\n            -- ---------------------------------------------------------------\r\n            elseif parseState.IsBlockComment == 0 then\r\n                -- handle condition operators, note can have leading ! for not\r\n                if (tag == \"!\") or (((lineState.DefType == \"deftype_%if\") or lineState.InlineConditionIf) and preprocOperatorTable[tag]) then\r\n                    if lineState.Condition or (preprocOperatorTable[tag] == \"!\") or (preprocOperatorTable[tag] == \"(\") then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = preprocOperatorTable[tag]\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if ((c ~= \"(\") and (preprocOperatorTable[tag] ~= \")\")) or\r\n                               ((c ~= \")\") and (preprocOperatorTable[tag] == \")\")) then\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n\r\n                            -- add c operator\r\n                            lineState.Condition = lineState.Condition..preprocOperatorTable[tag]\r\n                        end\r\n                    else\r\n                        print(\"ERROR: Unexpected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                elseif FindOrCreateCondition(tag) then\r\n                    if (lineState.DefType ~= \"deftype_%if\") and not lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = true\r\n                    end\r\n\r\n                    if not lineState.Condition then\r\n                        lineState.Condition = \"\"\r\n                    else\r\n                        local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                        if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                            if not preprocOperatorTable[c] then\r\n                                print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Condition = lineState.Condition..\" \"\r\n                        end\r\n                    end\r\n\r\n                    lineState.Condition = lineState.Condition..FindOrCreateCondition(tag)\r\n\r\n                elseif not skipBindingKeywordTable[tag] then\r\n                    -- -------------------------------------------------------\r\n                    --  Process Interface Data\r\n                    -- -------------------------------------------------------\r\n                    if (lineState.Action == \"action_keyword\") and lineState.ActionMandatory then\r\n                        print(\"ERROR: Invalid Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- add block condition\r\n                    -- -------------------------------------------------------\r\n                    if lineState.DefType == \"deftype_%if\" then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = \"\"\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                                if not preprocOperatorTable[c] then\r\n                                    print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n                        end\r\n\r\n                        lineState.Condition = lineState.Condition..tag\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- apply tag to lineState.Action\r\n                    -- -------------------------------------------------------\r\n                    else\r\n                        -- end inline conditionals\r\n                        if lineState.InlineConditionIf then\r\n                            lineState.InlineConditionIf = false\r\n                        end\r\n\r\n                        if not lineState.Action then\r\n                            -- no actions specified\r\n\r\n                            -- -----------------------------------------------\r\n                            -- enum parseObject\r\n                            if parseState.ObjectStack[1].ObjType == \"objtype_%enum\" then\r\n                                if IsDataType(tag) or dataTypeAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                    print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                elseif tag ~= \",\" then -- ignore trailing commas\r\n                                    lineState.DefType = \"deftype_%enum\"\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = enumType\r\n\r\n                                    local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))\r\n                                    table.insert(parseState.ObjectStack[1].Members, member)\r\n                                end\r\n\r\n                            -- -----------------------------------------------\r\n                            -- class or function parseObject\r\n                            elseif (parseState.ObjectStack[1].ObjType == \"objtype_%class\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_%struct\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_globals\") then\r\n                                if IsDataType(tag) then\r\n                                    lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif dataTypeAttribTable[tag] then\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"virtual\" then\r\n                                    lineState.IsVirtualFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"static\" then\r\n                                    lineState.IsStaticFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"inline\" then\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif lineState.IsConstructor then\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n\r\n                                else\r\n                                    print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n                            else\r\n                                print(\"ERROR: Unexpected parseObject :\"..parseState.ObjectStack[1].ObjType..\" \"..parseState.ObjectStack[1].Name..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n                        elseif lineState.Action == \"action_classname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_classcomma\" then\r\n                            if tag ~= \",\" then\r\n                                print(\"ERROR: %class tag expected ','. \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Action = \"action_classbase\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_classbase\" then\r\n                            table.insert(parseState.ObjectStack[1].BaseClasses, tag)\r\n\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_structname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_enumname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            enumType = tag\r\n                            lineState.DataType = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_include\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_includefile\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_override_name\" then\r\n                            lineState.override_name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_typedef\" then\r\n                            lineState.Name = tag\r\n                            lineState.RValue = {}\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_typedefvalue\" then\r\n                            --lineState.RValue = SpaceSeparateStrings(lineState.RValue, tag)\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\" -- allow more than one word\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_rename\" then\r\n                            lineState[\"%rename\"] = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_define\" then\r\n                            lineState.Name = tag\r\n                            -- if they specify a value after the tag use it, unless a keyword\r\n                            while (lineTags[t+1] ~= nil) and (bindingKeywordTable[lineTags[t+1]] == nil) do\r\n                                lineState.Value = (lineState.Value or \"\")..lineTags[t+1]\r\n                                t = t + 1\r\n                            end\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_member\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Member Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"virtual\" then\r\n                                lineState.IsVirtualFunction = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif lineState[\"%operator\"] and string.find(tag, \"operator\", 1, 1) then\r\n                                -- eat the rest of the \"operator+=(...)\" symbols which may be split before (\r\n                                if (string.sub(tag, -1) == \"r\") and (lineTags[t+1] == \"(\") and (lineTags[t+2] == \")\") then -- op_func\r\n                                    tag = tag..lineTags[t+1]..lineTags[t+2]\r\n                                    t = t + 2\r\n                                else\r\n                                    while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end\r\n                                end\r\n\r\n                                local a, b = string.find(tag, \"operator\", 1, 1)\r\n                                local op = string.sub(tag, b+1)\r\n                                lineState[\"%operator\"] = op\r\n\r\n                                lineState.Action = \"action_methodbracket\" -- next char should be (\r\n                                lineState.Name = bindingOperatorTable[op]\r\n\r\n                            elseif tag == \"(\" then\r\n                                if lineState.DataType == parseState.ObjectStack[1].Name then\r\n                                    lineState.IsConstructor = true\r\n                                end\r\n\r\n                                if lineState.IsConstructor then\r\n                                    if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n\r\n                                    if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end\r\n                                else\r\n                                    print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) then\r\n                                print(\"ERROR: Expected Method Name, got delimiter Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if lineState.IsConstructor then\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                end\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodbracket\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodbracket\" then\r\n                                if tag ~= \"(\" then\r\n                                    local msg = \"(Name=\"..tostring(lineState.Name)..\"; DataType=\"..tostring(lineState.DataType)..\")\"\r\n                                    print(\"ERROR: Expected Method Tag '(', got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.IsFunction = true\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                        elseif lineState.Action == \"action_methodparam\" then\r\n                            lineState.IsFunction = true\r\n\r\n                            if IsDataType(tag) then\r\n                                lineState.ParamState.DataType = SpaceSeparateStrings(lineState.ParamState.DataType, tag)\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                table.insert(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if lineState.ParamState.DataType then\r\n                                    InsertParamState(lineState.Params, lineState.ParamState)\r\n                                    lineState.ParamState = AllocParam()\r\n                                end\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Method Param Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.Name = tag\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_defaultvalue\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n                            elseif IsDataType(tag) or dataTypeAttribTable[tag] or functionAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") or IsDelimiter(tag) and (tag ~= \"|\") and (tag ~= \"&\") then\r\n                                print(\"ERROR: Expected Parameter Default Value, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.DefaultValue = SpaceSeparateStrings(lineState.ParamState.DefaultValue, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_paramdelimiter\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n                            elseif tag == \")\" then\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"[]\" then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            else\r\n                                local msg = \"(Name=\"..tostring(lineState.ParamState.Name)..\r\n                                            \"; DataType=\"..tostring(lineState.ParamState.DataType)..\")\"\r\n                                print(\"ERROR: Expected Parameter '=', ')', or ',' got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method_body\" then\r\n                            if tag == \"const\" then\r\n                                lineState.IsConstFunction = true\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.IsPureVirtualFunction = true\r\n                                parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            elseif (tag == \"{\") or (tag == \";\") then\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            else\r\n                                print(\"ERROR: Expected Parameter 'const', '=', ';', or '{' got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1030,
    "text": "if tag == \"/*\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment + 1\r\n\r\n                -- block comment (end)\r\n                elseif tag == \"*/\" then\r\n                    parseState.IsBlockComment = parseState.IsBlockComment - 1\r\n\r\n                -- ignore until end of block comment\r\n                elseif parseState.IsBlockComment == 0 then\r\n\r\n                    -- warn if we're expecting something and it's not there\r\n                    if not lineState.ActionAttributes[tag] and lineState.ActionMandatory then\r\n                        print(\"ERROR: Expected Line Action '\"..lineState.Action..\"', got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- end inline conditionals since we should have handled it already\r\n                    if lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = false\r\n                    end\r\n\r\n                    -- rest of line comment\r\n                    if tag == \"//\" then\r\n                        break\r\n\r\n                    -- %if wxLUA_USE_xxx ... %endif\r\n                    elseif tag == \"%if\" then\r\n                        lineState.DefType = \"deftype_%if\"\r\n\r\n                    elseif tag == \"%endif\" then\r\n                        table.remove(parseState.ConditionStack, #parseState.ConditionStack) -- pop last %if\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%rename\" then\r\n                        lineState.Action = \"action_rename\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%function\" then\r\n                        lineState[\"%function\"] = true\r\n\r\n                    elseif tag == \"%gc_this\" then\r\n                        lineState[\"%gc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %gc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%ungc_this\" then\r\n                        lineState[\"%ungc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %ungc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%class\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%class\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%class\"\r\n                        lineState.Action = \"action_classname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endclass\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %endclass does not have matching %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endclass. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        lineState.Action = \"action_keyword\"\r\n                        lineState.ActionMandatory = true\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%delete\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%delete\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %delete is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%noclassinfo\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %noclassinfo is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%abstract\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %abstract is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%encapsulate\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %encapsulate is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%protected\" then -- skip %protected functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%private\" then -- skip %private functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%property\" then -- FIXME removed properties\r\n                        lineState.Skip = true\r\n                        print(\"WARNING: the %property tag is ignored and properties are generated at runtime.\")\r\n                        break\r\n\r\n                    elseif tag == \"%member\" then\r\n                        lineState.DefType = \"deftype_%member\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%member_func\" then\r\n                        lineState.DefType = \"deftype_%member_func\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member_func is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%constructor\" then\r\n                        lineState.IsConstructor = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %constructor is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%operator\" then\r\n                        lineState[\"%operator\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %operator is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%struct\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%struct\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        lineState.DefType = \"deftype_%struct\"\r\n                        lineState.Action = \"action_structname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endstruct\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\" then\r\n                            print(\"ERROR: %endstruct does not have matching %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endstruct. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%enum\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%enum\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%enum\"\r\n                        lineState.Action = \"action_enumname\"\r\n                        lineState.ActionMandatory = false -- not all enums have a name\r\n\r\n                    elseif tag == \"%endenum\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%enum\" then\r\n                            print(\"ERROR: %endenum does not have matching %enum. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        enumType = \"\"\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endenum. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%include\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%include\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%include\"\r\n                        lineState.Action = \"action_include\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%includefile\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%includefile\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%includefile\"\r\n                        lineState.Action = \"action_includefile\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%typedef\" then\r\n                        lineState.DefType = \"deftype_%typedef\"\r\n                        lineState.Action = \"action_typedef\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%override_name\" then\r\n                        lineState.Action = \"action_override_name\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%not_overload\" then\r\n                        lineState.NotOverload = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%define\" then\r\n                        lineState.DefType = \"deftype_%define\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_string\" then\r\n                        lineState.DefType = \"deftype_%define_string\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_event\" then\r\n                        lineState.DefType = \"deftype_%define_event\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_object\" then\r\n                        lineState.DefType = \"deftype_%define_object\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_pointer\" then\r\n                        lineState.DefType = \"deftype_%define_pointer\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    else\r\n                        print(\"WARNING: Unhandled keyword '\"..tag..\"' in \"..LineTableErrString(lineTable))\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1031,
    "text": "parseState.IsBlockComment = parseState.IsBlockComment + 1",
    "type": "statement:assign"
  }, {
    "id": 1032,
    "text": "parseState.IsBlockComment = parseState.IsBlockComment - 1",
    "type": "statement:assign"
  }, {
    "id": 1033,
    "text": "if not lineState.ActionAttributes[tag] and lineState.ActionMandatory then\r\n                        print(\"ERROR: Expected Line Action '\"..lineState.Action..\"', got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1034,
    "text": "print(\"ERROR: Expected Line Action '\"..lineState.Action..\"', got '\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1035,
    "text": "if lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = false\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1036,
    "text": "lineState.InlineConditionIf = false",
    "type": "statement:assign"
  }, {
    "id": 1037,
    "text": "if tag == \"//\" then\r\n                        break\r\n\r\n                    -- %if wxLUA_USE_xxx ... %endif\r\n                    elseif tag == \"%if\" then\r\n                        lineState.DefType = \"deftype_%if\"\r\n\r\n                    elseif tag == \"%endif\" then\r\n                        table.remove(parseState.ConditionStack, #parseState.ConditionStack) -- pop last %if\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%rename\" then\r\n                        lineState.Action = \"action_rename\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%function\" then\r\n                        lineState[\"%function\"] = true\r\n\r\n                    elseif tag == \"%gc_this\" then\r\n                        lineState[\"%gc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %gc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%ungc_this\" then\r\n                        lineState[\"%ungc_this\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %ungc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%class\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%class\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%class\"\r\n                        lineState.Action = \"action_classname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endclass\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %endclass does not have matching %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endclass. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        lineState.Action = \"action_keyword\"\r\n                        lineState.ActionMandatory = true\r\n                        break -- we can stop processing line\r\n\r\n                    elseif tag == \"%delete\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%delete\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %delete is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%noclassinfo\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %noclassinfo is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%abstract\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %abstract is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%encapsulate\" then -- tag for %class\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %encapsulate is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%protected\" then -- skip %protected functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%private\" then -- skip %private functions\r\n                        lineState.Skip = true\r\n                        break\r\n\r\n                    elseif tag == \"%property\" then -- FIXME removed properties\r\n                        lineState.Skip = true\r\n                        print(\"WARNING: the %property tag is ignored and properties are generated at runtime.\")\r\n                        break\r\n\r\n                    elseif tag == \"%member\" then\r\n                        lineState.DefType = \"deftype_%member\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%member_func\" then\r\n                        lineState.DefType = \"deftype_%member_func\"\r\n                        lineState.Action = \"action_member\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                        if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member_func is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%constructor\" then\r\n                        lineState.IsConstructor = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %constructor is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    elseif tag == \"%operator\" then\r\n                        lineState[\"%operator\"] = true\r\n\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %operator is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%struct\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%struct\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n                        parseState.ObjectStack[1][\"%noclassinfo\"] = true\r\n                        parseState.ObjectStack[1][\"%encapsulate\"] = true\r\n\r\n                        lineState.DefType = \"deftype_%struct\"\r\n                        lineState.Action = \"action_structname\"\r\n                        lineState.ActionMandatory = true\r\n                        lineState.ActionAttributes[\"%delete\"] = true\r\n                        lineState.ActionAttributes[\"%noclassinfo\"] = true\r\n                        lineState.ActionAttributes[\"%abstract\"] = true\r\n                        lineState.ActionAttributes[\"%encapsulate\"] = true\r\n\r\n                    elseif tag == \"%endstruct\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\" then\r\n                            print(\"ERROR: %endstruct does not have matching %struct. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endstruct. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%enum\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%enum\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.DefType = \"deftype_%enum\"\r\n                        lineState.Action = \"action_enumname\"\r\n                        lineState.ActionMandatory = false -- not all enums have a name\r\n\r\n                    elseif tag == \"%endenum\" then\r\n                        if parseState.ObjectStack[1].ObjType ~= \"objtype_%enum\" then\r\n                            print(\"ERROR: %endenum does not have matching %enum. \"..LineTableErrString(lineTable))\r\n                        end\r\n\r\n                        enumType = \"\"\r\n\r\n                        table.insert(objectList, parseState.ObjectStack[1])\r\n                        table.remove(parseState.ObjectStack, 1)\r\n\r\n                        if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endenum. \"..LineTableErrString(lineTable))\r\n                        end\r\n                        break -- we can stop processing line\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%include\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%include\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%include\"\r\n                        lineState.Action = \"action_include\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%includefile\" then\r\n                        local parseObject = AllocParseObject(\"objtype_%includefile\")\r\n                        table.insert(parseState.ObjectStack, 1, parseObject)\r\n                        lineState.ParseObjectDeclaration = true\r\n\r\n                        lineState.PopParseObject = true -- pop parseObject off stack at end of line\r\n\r\n                        lineState.DefType = \"deftype_%includefile\"\r\n                        lineState.Action = \"action_includefile\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%typedef\" then\r\n                        lineState.DefType = \"deftype_%typedef\"\r\n                        lineState.Action = \"action_typedef\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%override_name\" then\r\n                        lineState.Action = \"action_override_name\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%not_overload\" then\r\n                        lineState.NotOverload = true\r\n\r\n                    -- -------------------------------------------------------\r\n                    elseif tag == \"%define\" then\r\n                        lineState.DefType = \"deftype_%define\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_string\" then\r\n                        lineState.DefType = \"deftype_%define_string\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_event\" then\r\n                        lineState.DefType = \"deftype_%define_event\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_object\" then\r\n                        lineState.DefType = \"deftype_%define_object\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    elseif tag == \"%define_pointer\" then\r\n                        lineState.DefType = \"deftype_%define_pointer\"\r\n                        lineState.Action = \"action_define\"\r\n                        lineState.ActionMandatory = true\r\n\r\n                    else\r\n                        print(\"WARNING: Unhandled keyword '\"..tag..\"' in \"..LineTableErrString(lineTable))\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1038,
    "text": "lineState.DefType = \"deftype_%if\"",
    "type": "statement:assign"
  }, {
    "id": 1039,
    "text": "table.remove(parseState.ConditionStack, #parseState.ConditionStack)",
    "type": "statement:functioncall"
  }, {
    "id": 1040,
    "text": "lineState.Action = \"action_rename\"",
    "type": "statement:assign"
  }, {
    "id": 1041,
    "text": "lineState.ActionMandatory = true",
    "type": "statement:assign"
  }, {
    "id": 1042,
    "text": "lineState[\"%function\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1043,
    "text": "lineState[\"%gc_this\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1044,
    "text": "if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %gc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1045,
    "text": "print(\"ERROR: %gc_this is not used for a %class member function. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1046,
    "text": "lineState[\"%ungc_this\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1047,
    "text": "if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %ungc_this is not used for a %class member function. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1048,
    "text": "print(\"ERROR: %ungc_this is not used for a %class member function. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1049,
    "text": "local parseObject = AllocParseObject(\"objtype_%class\")",
    "type": "statement:localassign"
  }, {
    "id": 1050,
    "text": "table.insert(parseState.ObjectStack, 1, parseObject)",
    "type": "statement:functioncall"
  }, {
    "id": 1051,
    "text": "lineState.ParseObjectDeclaration = true",
    "type": "statement:assign"
  }, {
    "id": 1052,
    "text": "lineState.DefType = \"deftype_%class\"",
    "type": "statement:assign"
  }, {
    "id": 1053,
    "text": "lineState.Action = \"action_classname\"",
    "type": "statement:assign"
  }, {
    "id": 1054,
    "text": "lineState.ActionAttributes[\"%delete\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1055,
    "text": "lineState.ActionAttributes[\"%noclassinfo\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1056,
    "text": "lineState.ActionAttributes[\"%abstract\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1057,
    "text": "lineState.ActionAttributes[\"%encapsulate\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1058,
    "text": "if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %endclass does not have matching %class. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1059,
    "text": "print(\"ERROR: %endclass does not have matching %class. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1060,
    "text": "table.insert(objectList, parseState.ObjectStack[1])",
    "type": "statement:functioncall"
  }, {
    "id": 1061,
    "text": "table.remove(parseState.ObjectStack, 1)",
    "type": "statement:functioncall"
  }, {
    "id": 1062,
    "text": "if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endclass. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1063,
    "text": "print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endclass. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1064,
    "text": "lineState.Action = \"action_keyword\"",
    "type": "statement:assign"
  }, {
    "id": 1065,
    "text": "parseState.ObjectStack[1][\"%delete\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1066,
    "text": "if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %delete is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1067,
    "text": "print(\"ERROR: %delete is not used for a %class. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1068,
    "text": "parseState.ObjectStack[1][\"%noclassinfo\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1069,
    "text": "if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %noclassinfo is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1070,
    "text": "print(\"ERROR: %noclassinfo is not used for a %class. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1071,
    "text": "parseState.ObjectStack[1][\"%abstract\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1072,
    "text": "if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %abstract is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1073,
    "text": "print(\"ERROR: %abstract is not used for a %class. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1074,
    "text": "parseState.ObjectStack[1][\"%encapsulate\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1075,
    "text": "if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %encapsulate is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1076,
    "text": "print(\"ERROR: %encapsulate is not used for a %class. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1077,
    "text": "lineState.Skip = true",
    "type": "statement:assign"
  }, {
    "id": 1078,
    "text": "print(\"WARNING: the %property tag is ignored and properties are generated at runtime.\")",
    "type": "statement:functioncall"
  }, {
    "id": 1079,
    "text": "lineState.DefType = \"deftype_%member\"",
    "type": "statement:assign"
  }, {
    "id": 1080,
    "text": "lineState.Action = \"action_member\"",
    "type": "statement:assign"
  }, {
    "id": 1081,
    "text": "if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1082,
    "text": "print(\"ERROR: %member is not used for a %class or %struct. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1083,
    "text": "lineState.DefType = \"deftype_%member_func\"",
    "type": "statement:assign"
  }, {
    "id": 1084,
    "text": "if (parseState.ObjectStack[1].ObjType ~= \"objtype_%class\") and (parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\") then\r\n                            print(\"ERROR: %member_func is not used for a %class or %struct. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1085,
    "text": "print(\"ERROR: %member_func is not used for a %class or %struct. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1086,
    "text": "lineState.IsConstructor = true",
    "type": "statement:assign"
  }, {
    "id": 1087,
    "text": "if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %constructor is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1088,
    "text": "print(\"ERROR: %constructor is not used for a %class. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1089,
    "text": "lineState[\"%operator\"] = true",
    "type": "statement:assign"
  }, {
    "id": 1090,
    "text": "if parseState.ObjectStack[1].ObjType ~= \"objtype_%class\" then\r\n                            print(\"ERROR: %operator is not used for a %class. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1091,
    "text": "print(\"ERROR: %operator is not used for a %class. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1092,
    "text": "local parseObject = AllocParseObject(\"objtype_%struct\")",
    "type": "statement:localassign"
  }, {
    "id": 1093,
    "text": "lineState.DefType = \"deftype_%struct\"",
    "type": "statement:assign"
  }, {
    "id": 1094,
    "text": "lineState.Action = \"action_structname\"",
    "type": "statement:assign"
  }, {
    "id": 1095,
    "text": "if parseState.ObjectStack[1].ObjType ~= \"objtype_%struct\" then\r\n                            print(\"ERROR: %endstruct does not have matching %struct. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1096,
    "text": "print(\"ERROR: %endstruct does not have matching %struct. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1097,
    "text": "if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endstruct. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1098,
    "text": "print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endstruct. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1099,
    "text": "local parseObject = AllocParseObject(\"objtype_%enum\")",
    "type": "statement:localassign"
  }, {
    "id": 1100,
    "text": "lineState.DefType = \"deftype_%enum\"",
    "type": "statement:assign"
  }, {
    "id": 1101,
    "text": "lineState.Action = \"action_enumname\"",
    "type": "statement:assign"
  }, {
    "id": 1102,
    "text": "lineState.ActionMandatory = false",
    "type": "statement:assign"
  }, {
    "id": 1103,
    "text": "if parseState.ObjectStack[1].ObjType ~= \"objtype_%enum\" then\r\n                            print(\"ERROR: %endenum does not have matching %enum. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1104,
    "text": "print(\"ERROR: %endenum does not have matching %enum. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1105,
    "text": "enumType = \"\"",
    "type": "statement:assign"
  }, {
    "id": 1106,
    "text": "if #parseState.ObjectStack == 0 then\r\n                            print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endenum. \"..LineTableErrString(lineTable))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1107,
    "text": "print(\"ERROR: parseState.ObjectStack is unexpectedly empty on %endenum. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1108,
    "text": "local parseObject = AllocParseObject(\"objtype_%include\")",
    "type": "statement:localassign"
  }, {
    "id": 1109,
    "text": "lineState.PopParseObject = true",
    "type": "statement:assign"
  }, {
    "id": 1110,
    "text": "lineState.DefType = \"deftype_%include\"",
    "type": "statement:assign"
  }, {
    "id": 1111,
    "text": "lineState.Action = \"action_include\"",
    "type": "statement:assign"
  }, {
    "id": 1112,
    "text": "local parseObject = AllocParseObject(\"objtype_%includefile\")",
    "type": "statement:localassign"
  }, {
    "id": 1113,
    "text": "lineState.DefType = \"deftype_%includefile\"",
    "type": "statement:assign"
  }, {
    "id": 1114,
    "text": "lineState.Action = \"action_includefile\"",
    "type": "statement:assign"
  }, {
    "id": 1115,
    "text": "lineState.DefType = \"deftype_%typedef\"",
    "type": "statement:assign"
  }, {
    "id": 1116,
    "text": "lineState.Action = \"action_typedef\"",
    "type": "statement:assign"
  }, {
    "id": 1117,
    "text": "lineState.Action = \"action_override_name\"",
    "type": "statement:assign"
  }, {
    "id": 1118,
    "text": "lineState.NotOverload = true",
    "type": "statement:assign"
  }, {
    "id": 1119,
    "text": "lineState.DefType = \"deftype_%define\"",
    "type": "statement:assign"
  }, {
    "id": 1120,
    "text": "lineState.Action = \"action_define\"",
    "type": "statement:assign"
  }, {
    "id": 1121,
    "text": "lineState.DefType = \"deftype_%define_string\"",
    "type": "statement:assign"
  }, {
    "id": 1122,
    "text": "lineState.DefType = \"deftype_%define_event\"",
    "type": "statement:assign"
  }, {
    "id": 1123,
    "text": "lineState.DefType = \"deftype_%define_object\"",
    "type": "statement:assign"
  }, {
    "id": 1124,
    "text": "lineState.DefType = \"deftype_%define_pointer\"",
    "type": "statement:assign"
  }, {
    "id": 1125,
    "text": "print(\"WARNING: Unhandled keyword '\"..tag..\"' in \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1126,
    "text": "if (tag == \"!\") or (((lineState.DefType == \"deftype_%if\") or lineState.InlineConditionIf) and preprocOperatorTable[tag]) then\r\n                    if lineState.Condition or (preprocOperatorTable[tag] == \"!\") or (preprocOperatorTable[tag] == \"(\") then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = preprocOperatorTable[tag]\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if ((c ~= \"(\") and (preprocOperatorTable[tag] ~= \")\")) or\r\n                               ((c ~= \")\") and (preprocOperatorTable[tag] == \")\")) then\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n\r\n                            -- add c operator\r\n                            lineState.Condition = lineState.Condition..preprocOperatorTable[tag]\r\n                        end\r\n                    else\r\n                        print(\"ERROR: Unexpected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                elseif FindOrCreateCondition(tag) then\r\n                    if (lineState.DefType ~= \"deftype_%if\") and not lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = true\r\n                    end\r\n\r\n                    if not lineState.Condition then\r\n                        lineState.Condition = \"\"\r\n                    else\r\n                        local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                        if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                            if not preprocOperatorTable[c] then\r\n                                print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Condition = lineState.Condition..\" \"\r\n                        end\r\n                    end\r\n\r\n                    lineState.Condition = lineState.Condition..FindOrCreateCondition(tag)\r\n\r\n                elseif not skipBindingKeywordTable[tag] then\r\n                    -- -------------------------------------------------------\r\n                    --  Process Interface Data\r\n                    -- -------------------------------------------------------\r\n                    if (lineState.Action == \"action_keyword\") and lineState.ActionMandatory then\r\n                        print(\"ERROR: Invalid Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- add block condition\r\n                    -- -------------------------------------------------------\r\n                    if lineState.DefType == \"deftype_%if\" then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = \"\"\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                                if not preprocOperatorTable[c] then\r\n                                    print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n                        end\r\n\r\n                        lineState.Condition = lineState.Condition..tag\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- apply tag to lineState.Action\r\n                    -- -------------------------------------------------------\r\n                    else\r\n                        -- end inline conditionals\r\n                        if lineState.InlineConditionIf then\r\n                            lineState.InlineConditionIf = false\r\n                        end\r\n\r\n                        if not lineState.Action then\r\n                            -- no actions specified\r\n\r\n                            -- -----------------------------------------------\r\n                            -- enum parseObject\r\n                            if parseState.ObjectStack[1].ObjType == \"objtype_%enum\" then\r\n                                if IsDataType(tag) or dataTypeAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                    print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                elseif tag ~= \",\" then -- ignore trailing commas\r\n                                    lineState.DefType = \"deftype_%enum\"\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = enumType\r\n\r\n                                    local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))\r\n                                    table.insert(parseState.ObjectStack[1].Members, member)\r\n                                end\r\n\r\n                            -- -----------------------------------------------\r\n                            -- class or function parseObject\r\n                            elseif (parseState.ObjectStack[1].ObjType == \"objtype_%class\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_%struct\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_globals\") then\r\n                                if IsDataType(tag) then\r\n                                    lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif dataTypeAttribTable[tag] then\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"virtual\" then\r\n                                    lineState.IsVirtualFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"static\" then\r\n                                    lineState.IsStaticFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"inline\" then\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif lineState.IsConstructor then\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n\r\n                                else\r\n                                    print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n                            else\r\n                                print(\"ERROR: Unexpected parseObject :\"..parseState.ObjectStack[1].ObjType..\" \"..parseState.ObjectStack[1].Name..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n                        elseif lineState.Action == \"action_classname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_classcomma\" then\r\n                            if tag ~= \",\" then\r\n                                print(\"ERROR: %class tag expected ','. \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Action = \"action_classbase\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_classbase\" then\r\n                            table.insert(parseState.ObjectStack[1].BaseClasses, tag)\r\n\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_structname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_enumname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            enumType = tag\r\n                            lineState.DataType = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_include\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_includefile\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_override_name\" then\r\n                            lineState.override_name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_typedef\" then\r\n                            lineState.Name = tag\r\n                            lineState.RValue = {}\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_typedefvalue\" then\r\n                            --lineState.RValue = SpaceSeparateStrings(lineState.RValue, tag)\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\" -- allow more than one word\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_rename\" then\r\n                            lineState[\"%rename\"] = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_define\" then\r\n                            lineState.Name = tag\r\n                            -- if they specify a value after the tag use it, unless a keyword\r\n                            while (lineTags[t+1] ~= nil) and (bindingKeywordTable[lineTags[t+1]] == nil) do\r\n                                lineState.Value = (lineState.Value or \"\")..lineTags[t+1]\r\n                                t = t + 1\r\n                            end\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_member\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Member Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"virtual\" then\r\n                                lineState.IsVirtualFunction = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif lineState[\"%operator\"] and string.find(tag, \"operator\", 1, 1) then\r\n                                -- eat the rest of the \"operator+=(...)\" symbols which may be split before (\r\n                                if (string.sub(tag, -1) == \"r\") and (lineTags[t+1] == \"(\") and (lineTags[t+2] == \")\") then -- op_func\r\n                                    tag = tag..lineTags[t+1]..lineTags[t+2]\r\n                                    t = t + 2\r\n                                else\r\n                                    while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end\r\n                                end\r\n\r\n                                local a, b = string.find(tag, \"operator\", 1, 1)\r\n                                local op = string.sub(tag, b+1)\r\n                                lineState[\"%operator\"] = op\r\n\r\n                                lineState.Action = \"action_methodbracket\" -- next char should be (\r\n                                lineState.Name = bindingOperatorTable[op]\r\n\r\n                            elseif tag == \"(\" then\r\n                                if lineState.DataType == parseState.ObjectStack[1].Name then\r\n                                    lineState.IsConstructor = true\r\n                                end\r\n\r\n                                if lineState.IsConstructor then\r\n                                    if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n\r\n                                    if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end\r\n                                else\r\n                                    print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) then\r\n                                print(\"ERROR: Expected Method Name, got delimiter Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if lineState.IsConstructor then\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                end\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodbracket\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodbracket\" then\r\n                                if tag ~= \"(\" then\r\n                                    local msg = \"(Name=\"..tostring(lineState.Name)..\"; DataType=\"..tostring(lineState.DataType)..\")\"\r\n                                    print(\"ERROR: Expected Method Tag '(', got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.IsFunction = true\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                        elseif lineState.Action == \"action_methodparam\" then\r\n                            lineState.IsFunction = true\r\n\r\n                            if IsDataType(tag) then\r\n                                lineState.ParamState.DataType = SpaceSeparateStrings(lineState.ParamState.DataType, tag)\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                table.insert(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if lineState.ParamState.DataType then\r\n                                    InsertParamState(lineState.Params, lineState.ParamState)\r\n                                    lineState.ParamState = AllocParam()\r\n                                end\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Method Param Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.Name = tag\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_defaultvalue\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n                            elseif IsDataType(tag) or dataTypeAttribTable[tag] or functionAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") or IsDelimiter(tag) and (tag ~= \"|\") and (tag ~= \"&\") then\r\n                                print(\"ERROR: Expected Parameter Default Value, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.DefaultValue = SpaceSeparateStrings(lineState.ParamState.DefaultValue, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_paramdelimiter\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n                            elseif tag == \")\" then\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"[]\" then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            else\r\n                                local msg = \"(Name=\"..tostring(lineState.ParamState.Name)..\r\n                                            \"; DataType=\"..tostring(lineState.ParamState.DataType)..\")\"\r\n                                print(\"ERROR: Expected Parameter '=', ')', or ',' got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method_body\" then\r\n                            if tag == \"const\" then\r\n                                lineState.IsConstFunction = true\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.IsPureVirtualFunction = true\r\n                                parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            elseif (tag == \"{\") or (tag == \";\") then\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            else\r\n                                print(\"ERROR: Expected Parameter 'const', '=', ';', or '{' got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            end\r\n                        end\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1127,
    "text": "if lineState.Condition or (preprocOperatorTable[tag] == \"!\") or (preprocOperatorTable[tag] == \"(\") then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = preprocOperatorTable[tag]\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if ((c ~= \"(\") and (preprocOperatorTable[tag] ~= \")\")) or\r\n                               ((c ~= \")\") and (preprocOperatorTable[tag] == \")\")) then\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n\r\n                            -- add c operator\r\n                            lineState.Condition = lineState.Condition..preprocOperatorTable[tag]\r\n                        end\r\n                    else\r\n                        print(\"ERROR: Unexpected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1128,
    "text": "if not lineState.Condition then\r\n                            lineState.Condition = preprocOperatorTable[tag]\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if ((c ~= \"(\") and (preprocOperatorTable[tag] ~= \")\")) or\r\n                               ((c ~= \")\") and (preprocOperatorTable[tag] == \")\")) then\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n\r\n                            -- add c operator\r\n                            lineState.Condition = lineState.Condition..preprocOperatorTable[tag]\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1129,
    "text": "lineState.Condition = preprocOperatorTable[tag]",
    "type": "statement:assign"
  }, {
    "id": 1130,
    "text": "local c = string.sub(lineState.Condition, -1, -1)",
    "type": "statement:localassign"
  }, {
    "id": 1131,
    "text": "if ((c ~= \"(\") and (preprocOperatorTable[tag] ~= \")\")) or\r\n                               ((c ~= \")\") and (preprocOperatorTable[tag] == \")\")) then\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1132,
    "text": "lineState.Condition = lineState.Condition..\" \"",
    "type": "statement:assign"
  }, {
    "id": 1133,
    "text": "lineState.Condition = lineState.Condition..preprocOperatorTable[tag]",
    "type": "statement:assign"
  }, {
    "id": 1134,
    "text": "print(\"ERROR: Unexpected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1135,
    "text": "if (lineState.DefType ~= \"deftype_%if\") and not lineState.InlineConditionIf then\r\n                        lineState.InlineConditionIf = true\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1136,
    "text": "lineState.InlineConditionIf = true",
    "type": "statement:assign"
  }, {
    "id": 1137,
    "text": "if not lineState.Condition then\r\n                        lineState.Condition = \"\"\r\n                    else\r\n                        local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                        if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                            if not preprocOperatorTable[c] then\r\n                                print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Condition = lineState.Condition..\" \"\r\n                        end\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1138,
    "text": "lineState.Condition = \"\"",
    "type": "statement:assign"
  }, {
    "id": 1139,
    "text": "if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                            if not preprocOperatorTable[c] then\r\n                                print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Condition = lineState.Condition..\" \"\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1140,
    "text": "if not preprocOperatorTable[c] then\r\n                                print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1141,
    "text": "print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1142,
    "text": "lineState.Condition = lineState.Condition..FindOrCreateCondition(tag)",
    "type": "statement:assign"
  }, {
    "id": 1143,
    "text": "if (lineState.Action == \"action_keyword\") and lineState.ActionMandatory then\r\n                        print(\"ERROR: Invalid Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1144,
    "text": "print(\"ERROR: Invalid Token '\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1145,
    "text": "if lineState.DefType == \"deftype_%if\" then\r\n                        if not lineState.Condition then\r\n                            lineState.Condition = \"\"\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                                if not preprocOperatorTable[c] then\r\n                                    print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n                        end\r\n\r\n                        lineState.Condition = lineState.Condition..tag\r\n\r\n                    -- -------------------------------------------------------\r\n                    -- apply tag to lineState.Action\r\n                    -- -------------------------------------------------------\r\n                    else\r\n                        -- end inline conditionals\r\n                        if lineState.InlineConditionIf then\r\n                            lineState.InlineConditionIf = false\r\n                        end\r\n\r\n                        if not lineState.Action then\r\n                            -- no actions specified\r\n\r\n                            -- -----------------------------------------------\r\n                            -- enum parseObject\r\n                            if parseState.ObjectStack[1].ObjType == \"objtype_%enum\" then\r\n                                if IsDataType(tag) or dataTypeAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                    print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                elseif tag ~= \",\" then -- ignore trailing commas\r\n                                    lineState.DefType = \"deftype_%enum\"\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = enumType\r\n\r\n                                    local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))\r\n                                    table.insert(parseState.ObjectStack[1].Members, member)\r\n                                end\r\n\r\n                            -- -----------------------------------------------\r\n                            -- class or function parseObject\r\n                            elseif (parseState.ObjectStack[1].ObjType == \"objtype_%class\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_%struct\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_globals\") then\r\n                                if IsDataType(tag) then\r\n                                    lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif dataTypeAttribTable[tag] then\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"virtual\" then\r\n                                    lineState.IsVirtualFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"static\" then\r\n                                    lineState.IsStaticFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"inline\" then\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif lineState.IsConstructor then\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n\r\n                                else\r\n                                    print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n                            else\r\n                                print(\"ERROR: Unexpected parseObject :\"..parseState.ObjectStack[1].ObjType..\" \"..parseState.ObjectStack[1].Name..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n                        elseif lineState.Action == \"action_classname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_classcomma\" then\r\n                            if tag ~= \",\" then\r\n                                print(\"ERROR: %class tag expected ','. \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Action = \"action_classbase\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_classbase\" then\r\n                            table.insert(parseState.ObjectStack[1].BaseClasses, tag)\r\n\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_structname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_enumname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            enumType = tag\r\n                            lineState.DataType = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_include\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_includefile\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_override_name\" then\r\n                            lineState.override_name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_typedef\" then\r\n                            lineState.Name = tag\r\n                            lineState.RValue = {}\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_typedefvalue\" then\r\n                            --lineState.RValue = SpaceSeparateStrings(lineState.RValue, tag)\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\" -- allow more than one word\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_rename\" then\r\n                            lineState[\"%rename\"] = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_define\" then\r\n                            lineState.Name = tag\r\n                            -- if they specify a value after the tag use it, unless a keyword\r\n                            while (lineTags[t+1] ~= nil) and (bindingKeywordTable[lineTags[t+1]] == nil) do\r\n                                lineState.Value = (lineState.Value or \"\")..lineTags[t+1]\r\n                                t = t + 1\r\n                            end\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_member\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Member Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"virtual\" then\r\n                                lineState.IsVirtualFunction = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif lineState[\"%operator\"] and string.find(tag, \"operator\", 1, 1) then\r\n                                -- eat the rest of the \"operator+=(...)\" symbols which may be split before (\r\n                                if (string.sub(tag, -1) == \"r\") and (lineTags[t+1] == \"(\") and (lineTags[t+2] == \")\") then -- op_func\r\n                                    tag = tag..lineTags[t+1]..lineTags[t+2]\r\n                                    t = t + 2\r\n                                else\r\n                                    while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end\r\n                                end\r\n\r\n                                local a, b = string.find(tag, \"operator\", 1, 1)\r\n                                local op = string.sub(tag, b+1)\r\n                                lineState[\"%operator\"] = op\r\n\r\n                                lineState.Action = \"action_methodbracket\" -- next char should be (\r\n                                lineState.Name = bindingOperatorTable[op]\r\n\r\n                            elseif tag == \"(\" then\r\n                                if lineState.DataType == parseState.ObjectStack[1].Name then\r\n                                    lineState.IsConstructor = true\r\n                                end\r\n\r\n                                if lineState.IsConstructor then\r\n                                    if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n\r\n                                    if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end\r\n                                else\r\n                                    print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) then\r\n                                print(\"ERROR: Expected Method Name, got delimiter Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if lineState.IsConstructor then\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                end\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodbracket\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodbracket\" then\r\n                                if tag ~= \"(\" then\r\n                                    local msg = \"(Name=\"..tostring(lineState.Name)..\"; DataType=\"..tostring(lineState.DataType)..\")\"\r\n                                    print(\"ERROR: Expected Method Tag '(', got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.IsFunction = true\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                        elseif lineState.Action == \"action_methodparam\" then\r\n                            lineState.IsFunction = true\r\n\r\n                            if IsDataType(tag) then\r\n                                lineState.ParamState.DataType = SpaceSeparateStrings(lineState.ParamState.DataType, tag)\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                table.insert(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if lineState.ParamState.DataType then\r\n                                    InsertParamState(lineState.Params, lineState.ParamState)\r\n                                    lineState.ParamState = AllocParam()\r\n                                end\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Method Param Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.Name = tag\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_defaultvalue\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n                            elseif IsDataType(tag) or dataTypeAttribTable[tag] or functionAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") or IsDelimiter(tag) and (tag ~= \"|\") and (tag ~= \"&\") then\r\n                                print(\"ERROR: Expected Parameter Default Value, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.DefaultValue = SpaceSeparateStrings(lineState.ParamState.DefaultValue, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_paramdelimiter\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n                            elseif tag == \")\" then\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"[]\" then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            else\r\n                                local msg = \"(Name=\"..tostring(lineState.ParamState.Name)..\r\n                                            \"; DataType=\"..tostring(lineState.ParamState.DataType)..\")\"\r\n                                print(\"ERROR: Expected Parameter '=', ')', or ',' got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method_body\" then\r\n                            if tag == \"const\" then\r\n                                lineState.IsConstFunction = true\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.IsPureVirtualFunction = true\r\n                                parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            elseif (tag == \"{\") or (tag == \";\") then\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            else\r\n                                print(\"ERROR: Expected Parameter 'const', '=', ';', or '{' got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            end\r\n                        end\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1146,
    "text": "if not lineState.Condition then\r\n                            lineState.Condition = \"\"\r\n                        else\r\n                            local c = string.sub(lineState.Condition, -1, -1) -- get last char\r\n                            if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                                if not preprocOperatorTable[c] then\r\n                                    print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1147,
    "text": "if (c ~= \"(\") and (c ~= \"!\") then -- eg. not start of condition\r\n                                if not preprocOperatorTable[c] then\r\n                                    print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Condition = lineState.Condition..\" \"\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1148,
    "text": "if not preprocOperatorTable[c] then\r\n                                    print(\"ERROR: Expected Conditional Operator \"..tag..\". \"..LineTableErrString(lineTable))\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1149,
    "text": "lineState.Condition = lineState.Condition..tag",
    "type": "statement:assign"
  }, {
    "id": 1150,
    "text": "if lineState.InlineConditionIf then\r\n                            lineState.InlineConditionIf = false\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1151,
    "text": "if not lineState.Action then\r\n                            -- no actions specified\r\n\r\n                            -- -----------------------------------------------\r\n                            -- enum parseObject\r\n                            if parseState.ObjectStack[1].ObjType == \"objtype_%enum\" then\r\n                                if IsDataType(tag) or dataTypeAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                    print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                elseif tag ~= \",\" then -- ignore trailing commas\r\n                                    lineState.DefType = \"deftype_%enum\"\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = enumType\r\n\r\n                                    local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))\r\n                                    table.insert(parseState.ObjectStack[1].Members, member)\r\n                                end\r\n\r\n                            -- -----------------------------------------------\r\n                            -- class or function parseObject\r\n                            elseif (parseState.ObjectStack[1].ObjType == \"objtype_%class\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_%struct\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_globals\") then\r\n                                if IsDataType(tag) then\r\n                                    lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif dataTypeAttribTable[tag] then\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"virtual\" then\r\n                                    lineState.IsVirtualFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"static\" then\r\n                                    lineState.IsStaticFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"inline\" then\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif lineState.IsConstructor then\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n\r\n                                else\r\n                                    print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n                            else\r\n                                print(\"ERROR: Unexpected parseObject :\"..parseState.ObjectStack[1].ObjType..\" \"..parseState.ObjectStack[1].Name..\". \"..LineTableErrString(lineTable))\r\n                            end\r\n                        elseif lineState.Action == \"action_classname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_classcomma\" then\r\n                            if tag ~= \",\" then\r\n                                print(\"ERROR: %class tag expected ','. \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                            lineState.Action = \"action_classbase\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_classbase\" then\r\n                            table.insert(parseState.ObjectStack[1].BaseClasses, tag)\r\n\r\n                            lineState.Action = \"action_classcomma\"\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_structname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_enumname\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            enumType = tag\r\n                            lineState.DataType = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_include\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_includefile\" then\r\n                            parseState.ObjectStack[1].Name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_override_name\" then\r\n                            lineState.override_name = tag\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n                        elseif lineState.Action == \"action_typedef\" then\r\n                            lineState.Name = tag\r\n                            lineState.RValue = {}\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\"\r\n                            lineState.ActionMandatory = true\r\n                        elseif lineState.Action == \"action_typedefvalue\" then\r\n                            --lineState.RValue = SpaceSeparateStrings(lineState.RValue, tag)\r\n                            table.insert(lineState.RValue, tag)\r\n\r\n                            lineState.Action = \"action_typedefvalue\" -- allow more than one word\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_rename\" then\r\n                            lineState[\"%rename\"] = tag\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_define\" then\r\n                            lineState.Name = tag\r\n                            -- if they specify a value after the tag use it, unless a keyword\r\n                            while (lineTags[t+1] ~= nil) and (bindingKeywordTable[lineTags[t+1]] == nil) do\r\n                                lineState.Value = (lineState.Value or \"\")..lineTags[t+1]\r\n                                t = t + 1\r\n                            end\r\n\r\n                            lineState.Action = nil\r\n                            lineState.ActionMandatory = false\r\n\r\n                        elseif lineState.Action == \"action_member\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Member Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method\" then\r\n                            if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"virtual\" then\r\n                                lineState.IsVirtualFunction = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif lineState[\"%operator\"] and string.find(tag, \"operator\", 1, 1) then\r\n                                -- eat the rest of the \"operator+=(...)\" symbols which may be split before (\r\n                                if (string.sub(tag, -1) == \"r\") and (lineTags[t+1] == \"(\") and (lineTags[t+2] == \")\") then -- op_func\r\n                                    tag = tag..lineTags[t+1]..lineTags[t+2]\r\n                                    t = t + 2\r\n                                else\r\n                                    while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end\r\n                                end\r\n\r\n                                local a, b = string.find(tag, \"operator\", 1, 1)\r\n                                local op = string.sub(tag, b+1)\r\n                                lineState[\"%operator\"] = op\r\n\r\n                                lineState.Action = \"action_methodbracket\" -- next char should be (\r\n                                lineState.Name = bindingOperatorTable[op]\r\n\r\n                            elseif tag == \"(\" then\r\n                                if lineState.DataType == parseState.ObjectStack[1].Name then\r\n                                    lineState.IsConstructor = true\r\n                                end\r\n\r\n                                if lineState.IsConstructor then\r\n                                    if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n\r\n                                    if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end\r\n                                else\r\n                                    print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) then\r\n                                print(\"ERROR: Expected Method Name, got delimiter Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if lineState.IsConstructor then\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                end\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodbracket\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodbracket\" then\r\n                                if tag ~= \"(\" then\r\n                                    local msg = \"(Name=\"..tostring(lineState.Name)..\"; DataType=\"..tostring(lineState.DataType)..\")\"\r\n                                    print(\"ERROR: Expected Method Tag '(', got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.IsFunction = true\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                        elseif lineState.Action == \"action_methodparam\" then\r\n                            lineState.IsFunction = true\r\n\r\n                            if IsDataType(tag) then\r\n                                lineState.ParamState.DataType = SpaceSeparateStrings(lineState.ParamState.DataType, tag)\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                table.insert(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if lineState.ParamState.DataType then\r\n                                    InsertParamState(lineState.Params, lineState.ParamState)\r\n                                    lineState.ParamState = AllocParam()\r\n                                end\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Method Param Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.Name = tag\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_defaultvalue\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n                            elseif IsDataType(tag) or dataTypeAttribTable[tag] or functionAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") or IsDelimiter(tag) and (tag ~= \"|\") and (tag ~= \"&\") then\r\n                                print(\"ERROR: Expected Parameter Default Value, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.DefaultValue = SpaceSeparateStrings(lineState.ParamState.DefaultValue, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_methodparam_paramdelimiter\" then\r\n                            if tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n                            elseif tag == \")\" then\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"[]\" then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            else\r\n                                local msg = \"(Name=\"..tostring(lineState.ParamState.Name)..\r\n                                            \"; DataType=\"..tostring(lineState.ParamState.DataType)..\")\"\r\n                                print(\"ERROR: Expected Parameter '=', ')', or ',' got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                            end\r\n\r\n                        elseif lineState.Action == \"action_method_body\" then\r\n                            if tag == \"const\" then\r\n                                lineState.IsConstFunction = true\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.IsPureVirtualFunction = true\r\n                                parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            elseif (tag == \"{\") or (tag == \";\") then\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            else\r\n                                print(\"ERROR: Expected Parameter 'const', '=', ';', or '{' got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            end\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1152,
    "text": "if parseState.ObjectStack[1].ObjType == \"objtype_%enum\" then\r\n                                if IsDataType(tag) or dataTypeAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                    print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                elseif tag ~= \",\" then -- ignore trailing commas\r\n                                    lineState.DefType = \"deftype_%enum\"\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = enumType\r\n\r\n                                    local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))\r\n                                    table.insert(parseState.ObjectStack[1].Members, member)\r\n                                end\r\n\r\n                            -- -----------------------------------------------\r\n                            -- class or function parseObject\r\n                            elseif (parseState.ObjectStack[1].ObjType == \"objtype_%class\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_%struct\") or\r\n                                   (parseState.ObjectStack[1].ObjType == \"objtype_globals\") then\r\n                                if IsDataType(tag) then\r\n                                    lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif dataTypeAttribTable[tag] then\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"virtual\" then\r\n                                    lineState.IsVirtualFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"static\" then\r\n                                    lineState.IsStaticFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"inline\" then\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif lineState.IsConstructor then\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n\r\n                                else\r\n                                    print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n                            else\r\n                                print(\"ERROR: Unexpected parseObject :\"..parseState.ObjectStack[1].ObjType..\" \"..parseState.ObjectStack[1].Name..\". \"..LineTableErrString(lineTable))\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1153,
    "text": "if IsDataType(tag) or dataTypeAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                    print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                elseif tag ~= \",\" then -- ignore trailing commas\r\n                                    lineState.DefType = \"deftype_%enum\"\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = enumType\r\n\r\n                                    local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))\r\n                                    table.insert(parseState.ObjectStack[1].Members, member)\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1154,
    "text": "print(\"ERROR: Invalid Enum Token '\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1155,
    "text": "lineState.Name = tag",
    "type": "statement:assign"
  }, {
    "id": 1156,
    "text": "lineState.DataType = enumType",
    "type": "statement:assign"
  }, {
    "id": 1157,
    "text": "local member = AllocMember(lineState, BuildCondition(parseState.ConditionStack))",
    "type": "statement:localassign"
  }, {
    "id": 1158,
    "text": "table.insert(parseState.ObjectStack[1].Members, member)",
    "type": "statement:functioncall"
  }, {
    "id": 1159,
    "text": "if IsDataType(tag) then\r\n                                    lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif dataTypeAttribTable[tag] then\r\n                                    lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"virtual\" then\r\n                                    lineState.IsVirtualFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"static\" then\r\n                                    lineState.IsStaticFunction = true\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif tag == \"inline\" then\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n                                    lineState.ActionMandatory = true\r\n\r\n                                elseif lineState.IsConstructor then\r\n                                    lineState.Name = tag\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                    lineState.DefType = \"deftype_method\"\r\n                                    lineState.Action = \"action_method\"\r\n\r\n                                else\r\n                                    print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1160,
    "text": "lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)",
    "type": "statement:assign"
  }, {
    "id": 1161,
    "text": "lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)",
    "type": "statement:assign"
  }, {
    "id": 1162,
    "text": "lineState.DefType = \"deftype_method\"",
    "type": "statement:assign"
  }, {
    "id": 1163,
    "text": "lineState.Action = \"action_method\"",
    "type": "statement:assign"
  }, {
    "id": 1164,
    "text": "lineState.IsVirtualFunction = true",
    "type": "statement:assign"
  }, {
    "id": 1165,
    "text": "lineState.IsStaticFunction = true",
    "type": "statement:assign"
  }, {
    "id": 1166,
    "text": "lineState.DataType = parseState.ObjectStack[1].Name",
    "type": "statement:assign"
  }, {
    "id": 1167,
    "text": "lineState.DataTypeWithAttrib = lineState.DataType",
    "type": "statement:assign"
  }, {
    "id": 1168,
    "text": "print(\"ERROR: Expected DataType, got '\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1169,
    "text": "print(\"ERROR: Unexpected parseObject :\"..parseState.ObjectStack[1].ObjType..\" \"..parseState.ObjectStack[1].Name..\". \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1170,
    "text": "parseState.ObjectStack[1].Name = tag",
    "type": "statement:assign"
  }, {
    "id": 1171,
    "text": "lineState.Action = \"action_classcomma\"",
    "type": "statement:assign"
  }, {
    "id": 1172,
    "text": "if tag ~= \",\" then\r\n                                print(\"ERROR: %class tag expected ','. \"..LineTableErrString(lineTable))\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1173,
    "text": "print(\"ERROR: %class tag expected ','. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1174,
    "text": "lineState.Action = \"action_classbase\"",
    "type": "statement:assign"
  }, {
    "id": 1175,
    "text": "table.insert(parseState.ObjectStack[1].BaseClasses, tag)",
    "type": "statement:functioncall"
  }, {
    "id": 1176,
    "text": "lineState.Action = nil",
    "type": "statement:assign"
  }, {
    "id": 1177,
    "text": "enumType = tag",
    "type": "statement:assign"
  }, {
    "id": 1178,
    "text": "lineState.DataType = tag",
    "type": "statement:assign"
  }, {
    "id": 1179,
    "text": "lineState.override_name = tag",
    "type": "statement:assign"
  }, {
    "id": 1180,
    "text": "lineState.RValue = {}",
    "type": "statement:assign"
  }, {
    "id": 1181,
    "text": "table.insert(lineState.RValue, tag)",
    "type": "statement:functioncall"
  }, {
    "id": 1182,
    "text": "lineState.Action = \"action_typedefvalue\"",
    "type": "statement:assign"
  }, {
    "id": 1183,
    "text": "lineState[\"%rename\"] = tag",
    "type": "statement:assign"
  }, {
    "id": 1184,
    "text": "while (lineTags[t+1] ~= nil) and (bindingKeywordTable[lineTags[t+1]] == nil) do\r\n                                lineState.Value = (lineState.Value or \"\")..lineTags[t+1]\r\n                                t = t + 1\r\n                            end",
    "type": "statement:while"
  }, {
    "id": 1185,
    "text": "lineState.Value = (lineState.Value or \"\")..lineTags[t+1]",
    "type": "statement:assign"
  }, {
    "id": 1186,
    "text": "if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_member\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Member Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1187,
    "text": "table.insert(lineState.DataTypePointer, tag)",
    "type": "statement:functioncall"
  }, {
    "id": 1188,
    "text": "print(\"ERROR: Expected Member Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1189,
    "text": "if not lineState.DataType then\r\n                                    print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1190,
    "text": "print(\"ERROR: %member requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1191,
    "text": "if IsDataType(tag) then\r\n                                lineState.DataType = SpaceSeparateStrings(lineState.DataType, tag)\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_method\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"virtual\" then\r\n                                lineState.IsVirtualFunction = true\r\n\r\n                            elseif tag == \"static\" then\r\n                                lineState.IsStaticFunction = true\r\n\r\n                            elseif lineState[\"%operator\"] and string.find(tag, \"operator\", 1, 1) then\r\n                                -- eat the rest of the \"operator+=(...)\" symbols which may be split before (\r\n                                if (string.sub(tag, -1) == \"r\") and (lineTags[t+1] == \"(\") and (lineTags[t+2] == \")\") then -- op_func\r\n                                    tag = tag..lineTags[t+1]..lineTags[t+2]\r\n                                    t = t + 2\r\n                                else\r\n                                    while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end\r\n                                end\r\n\r\n                                local a, b = string.find(tag, \"operator\", 1, 1)\r\n                                local op = string.sub(tag, b+1)\r\n                                lineState[\"%operator\"] = op\r\n\r\n                                lineState.Action = \"action_methodbracket\" -- next char should be (\r\n                                lineState.Name = bindingOperatorTable[op]\r\n\r\n                            elseif tag == \"(\" then\r\n                                if lineState.DataType == parseState.ObjectStack[1].Name then\r\n                                    lineState.IsConstructor = true\r\n                                end\r\n\r\n                                if lineState.IsConstructor then\r\n                                    if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n\r\n                                    if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end\r\n                                else\r\n                                    print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) then\r\n                                print(\"ERROR: Expected Method Name, got delimiter Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.Name = tag\r\n\r\n                                if lineState.IsConstructor then\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                end\r\n\r\n                                if not lineState.DataType then\r\n                                    print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                lineState.Action = \"action_methodbracket\"\r\n                                lineState.ActionMandatory = true\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1192,
    "text": "if (string.sub(tag, -1) == \"r\") and (lineTags[t+1] == \"(\") and (lineTags[t+2] == \")\") then -- op_func\r\n                                    tag = tag..lineTags[t+1]..lineTags[t+2]\r\n                                    t = t + 2\r\n                                else\r\n                                    while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1193,
    "text": "tag = tag..lineTags[t+1]..lineTags[t+2]",
    "type": "statement:assign"
  }, {
    "id": 1194,
    "text": "t = t + 2",
    "type": "statement:assign"
  }, {
    "id": 1195,
    "text": "while lineTags[t+1] and (lineTags[t+1] ~= \"(\") do\r\n                                        tag = tag..lineTags[t+1]\r\n                                        t = t + 1\r\n                                    end",
    "type": "statement:while"
  }, {
    "id": 1196,
    "text": "tag = tag..lineTags[t+1]",
    "type": "statement:assign"
  }, {
    "id": 1197,
    "text": "local a, b = string.find(tag, \"operator\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 1198,
    "text": "local op = string.sub(tag, b+1)",
    "type": "statement:localassign"
  }, {
    "id": 1199,
    "text": "lineState[\"%operator\"] = op",
    "type": "statement:assign"
  }, {
    "id": 1200,
    "text": "lineState.Action = \"action_methodbracket\"",
    "type": "statement:assign"
  }, {
    "id": 1201,
    "text": "lineState.Name = bindingOperatorTable[op]",
    "type": "statement:assign"
  }, {
    "id": 1202,
    "text": "if lineState.DataType == parseState.ObjectStack[1].Name then\r\n                                    lineState.IsConstructor = true\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1203,
    "text": "if lineState.IsConstructor then\r\n                                    if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n\r\n                                    if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end\r\n                                else\r\n                                    print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1204,
    "text": "if not lineState.Name then\r\n                                        lineState.Name = lineState.DataType\r\n                                    end",
    "type": "statement:if"
  }, {
    "id": 1205,
    "text": "lineState.Name = lineState.DataType",
    "type": "statement:assign"
  }, {
    "id": 1206,
    "text": "if IsDataType(lineState.Name) and (lineState.Name ~= parseState.ObjectStack[1].Name) then\r\n                                        if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end\r\n                                    end",
    "type": "statement:if"
  }, {
    "id": 1207,
    "text": "if not IsDataTypeEnum(lineState.Name) then\r\n                                            print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))\r\n                                        else\r\n                                            print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))\r\n                                        end",
    "type": "statement:if"
  }, {
    "id": 1208,
    "text": "print(\"ERROR: Constructor Name (\"..lineState.Name..\") conflicts with datatype definition. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1209,
    "text": "print(\"WARNING: Constructor Name (\"..lineState.Name..\") also used by enum definition. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1210,
    "text": "print(\"ERROR: Expected Method Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1211,
    "text": "lineState.Action = \"action_methodparam\"",
    "type": "statement:assign"
  }, {
    "id": 1212,
    "text": "print(\"ERROR: Expected Method Name, got delimiter Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1213,
    "text": "if lineState.IsConstructor then\r\n                                    lineState.DataType = parseState.ObjectStack[1].Name\r\n                                    lineState.DataTypeWithAttrib = lineState.DataType\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1214,
    "text": "if not lineState.DataType then\r\n                                    print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1215,
    "text": "print(\"ERROR: Method requires DataType to be assigned. Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1216,
    "text": "if tag ~= \"(\" then\r\n                                    local msg = \"(Name=\"..tostring(lineState.Name)..\"; DataType=\"..tostring(lineState.DataType)..\")\"\r\n                                    print(\"ERROR: Expected Method Tag '(', got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1217,
    "text": "local msg = \"(Name=\"..tostring(lineState.Name)..\"; DataType=\"..tostring(lineState.DataType)..\")\"",
    "type": "statement:localassign"
  }, {
    "id": 1218,
    "text": "print(\"ERROR: Expected Method Tag '(', got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1219,
    "text": "lineState.IsFunction = true",
    "type": "statement:assign"
  }, {
    "id": 1220,
    "text": "if IsDataType(tag) then\r\n                                lineState.ParamState.DataType = SpaceSeparateStrings(lineState.ParamState.DataType, tag)\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif dataTypeAttribTable[tag] then\r\n                                lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                table.insert(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if lineState.ParamState.DataType then\r\n                                    InsertParamState(lineState.Params, lineState.ParamState)\r\n                                    lineState.ParamState = AllocParam()\r\n                                end\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif IsDelimiter(tag) or functionAttribTable[tag] then\r\n                                print(\"ERROR: Expected Method Param Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.Name = tag\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1221,
    "text": "lineState.ParamState.DataType = SpaceSeparateStrings(lineState.ParamState.DataType, tag)",
    "type": "statement:assign"
  }, {
    "id": 1222,
    "text": "lineState.ParamState.DataTypeWithAttrib = SpaceSeparateStrings(lineState.ParamState.DataTypeWithAttrib, tag)",
    "type": "statement:assign"
  }, {
    "id": 1223,
    "text": "table.insert(lineState.ParamState.DataTypePointer, tag)",
    "type": "statement:functioncall"
  }, {
    "id": 1224,
    "text": "if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1225,
    "text": "print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1226,
    "text": "table.insert(lineState.Params, lineState.ParamState)",
    "type": "statement:functioncall"
  }, {
    "id": 1227,
    "text": "lineState.ParamState = AllocParam()",
    "type": "statement:assign"
  }, {
    "id": 1228,
    "text": "if lineState.ParamState.DataType then\r\n                                    InsertParamState(lineState.Params, lineState.ParamState)\r\n                                    lineState.ParamState = AllocParam()\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1229,
    "text": "InsertParamState(lineState.Params, lineState.ParamState)",
    "type": "statement:functioncall"
  }, {
    "id": 1230,
    "text": "lineState.Action = \"action_method_body\"",
    "type": "statement:assign"
  }, {
    "id": 1231,
    "text": "lineState.Action = \"action_methodparam_defaultvalue\"",
    "type": "statement:assign"
  }, {
    "id": 1232,
    "text": "print(\"ERROR: Expected Method Param Name, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1233,
    "text": "lineState.ParamState.Name = tag",
    "type": "statement:assign"
  }, {
    "id": 1234,
    "text": "lineState.Action = \"action_methodparam_paramdelimiter\"",
    "type": "statement:assign"
  }, {
    "id": 1235,
    "text": "if tag == \",\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \")\" then\r\n                                if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n                            elseif IsDataType(tag) or dataTypeAttribTable[tag] or functionAttribTable[tag] or (tag == \"*\") or (tag == \"&\") or (tag == \"[]\") or IsDelimiter(tag) and (tag ~= \"|\") and (tag ~= \"&\") then\r\n                                print(\"ERROR: Expected Parameter Default Value, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            else\r\n                                lineState.ParamState.DefaultValue = SpaceSeparateStrings(lineState.ParamState.DefaultValue, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1236,
    "text": "if not lineState.ParamState.DefaultValue then\r\n                                    print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1237,
    "text": "print(\"ERROR: Method Parameter requires DefaultValue to be assigned. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1238,
    "text": "print(\"ERROR: Expected Parameter Default Value, got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1239,
    "text": "lineState.ParamState.DefaultValue = SpaceSeparateStrings(lineState.ParamState.DefaultValue, tag)",
    "type": "statement:assign"
  }, {
    "id": 1240,
    "text": "if tag == \",\" then\r\n                                if not lineState.ParamState.DataType then\r\n                                    print(\"ERROR: Method Parameter requires DataType to be assigned. \"..LineTableErrString(lineTable))\r\n                                end\r\n\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_methodparam\"\r\n                                lineState.ActionMandatory = true\r\n                            elseif tag == \")\" then\r\n                                InsertParamState(lineState.Params, lineState.ParamState)\r\n                                lineState.ParamState = AllocParam()\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.Action = \"action_methodparam_defaultvalue\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            elseif tag == \"[]\" then\r\n                                table.insert(lineState.ParamState.DataTypePointer, tag)\r\n\r\n                                lineState.Action = \"action_methodparam_paramdelimiter\"\r\n                                lineState.ActionMandatory = true\r\n\r\n                            else\r\n                                local msg = \"(Name=\"..tostring(lineState.ParamState.Name)..\r\n                                            \"; DataType=\"..tostring(lineState.ParamState.DataType)..\")\"\r\n                                print(\"ERROR: Expected Parameter '=', ')', or ',' got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1241,
    "text": "local msg = \"(Name=\"..tostring(lineState.ParamState.Name)..\r\n                                            \"; DataType=\"..tostring(lineState.ParamState.DataType)..\")\"",
    "type": "statement:localassign"
  }, {
    "id": 1242,
    "text": "print(\"ERROR: Expected Parameter '=', ')', or ',' got Tag='\"..tag..\"'. \"..msg..\" \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1243,
    "text": "if tag == \"const\" then\r\n                                lineState.IsConstFunction = true\r\n\r\n                                lineState.Action = \"action_method_body\"\r\n                                lineState.ActionMandatory = false\r\n\r\n                            elseif tag == \"=\" then\r\n                                lineState.IsPureVirtualFunction = true\r\n                                parseState.ObjectStack[1][\"%abstract\"] = true\r\n\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            elseif (tag == \"{\") or (tag == \";\") then\r\n                                -- junk rest of line\r\n                                lineState.Action = nil\r\n                                lineState.ActionMandatory = false\r\n\r\n                                lineState.Skip = true\r\n\r\n                            else\r\n                                print(\"ERROR: Expected Parameter 'const', '=', ';', or '{' got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1244,
    "text": "lineState.IsConstFunction = true",
    "type": "statement:assign"
  }, {
    "id": 1245,
    "text": "lineState.IsPureVirtualFunction = true",
    "type": "statement:assign"
  }, {
    "id": 1246,
    "text": "print(\"ERROR: Expected Parameter 'const', '=', ';', or '{' got Tag='\"..tag..\"'. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1247,
    "text": "if lineState.DefType == \"deftype_%typedef\" then\r\n            -- line is in the form: typedef [unsigned int] wxUInt32\r\n            local typedef_name = lineState.RValue[#lineState.RValue]\r\n            local typedef_type = table.concat(lineState.RValue, \" \", 1, #lineState.RValue-1)\r\n\r\n            typedefTable[typedef_name] = typedef_type\r\n\r\n        elseif lineState.DefType == \"deftype_%if\" then\r\n            -- line is a block condition, push onto condition stack\r\n            table.insert(parseState.ConditionStack, lineState.Condition)\r\n\r\n        elseif (lineState.DefType == \"deftype_%member\") or (lineState.DefType == \"deftype_%member_func\") then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_string\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_event\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_object\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_%define_pointer\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n\r\n        elseif lineState.DefType == \"deftype_method\" then\r\n            table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1248,
    "text": "local typedef_name = lineState.RValue[#lineState.RValue]",
    "type": "statement:localassign"
  }, {
    "id": 1249,
    "text": "local typedef_type = table.concat(lineState.RValue, \" \", 1, #lineState.RValue-1)",
    "type": "statement:localassign"
  }, {
    "id": 1250,
    "text": "typedefTable[typedef_name] = typedef_type",
    "type": "statement:assign"
  }, {
    "id": 1251,
    "text": "table.insert(parseState.ConditionStack, lineState.Condition)",
    "type": "statement:functioncall"
  }, {
    "id": 1252,
    "text": "table.insert(parseState.ObjectStack[1].Members, AllocMember(lineState, BuildCondition(parseState.ConditionStack)))",
    "type": "statement:functioncall"
  }, {
    "id": 1253,
    "text": "if lineState.ParseObjectDeclaration then\r\n            -- push inline condition onto condition stack\r\n            if not lineState.IsBlockCondition and lineState.Condition then\r\n                table.insert(parseState.ConditionStack, 1, lineState.Condition)\r\n            end\r\n\r\n            -- Set Parse Object Condition\r\n            parseState.ObjectStack[1].Condition = BuildCondition(parseState.ConditionStack)\r\n\r\n            -- Set Condition for DataType\r\n            if dataTypeTable[parseState.ObjectStack[1].Name] and parseState.ObjectStack[1].Condition then\r\n                dataTypeTable[parseState.ObjectStack[1].Name].Condition = parseState.ObjectStack[1].Condition\r\n            end\r\n\r\n            -- Set if this data type should be Encapsulated\r\n            if dataTypeTable[parseState.ObjectStack[1].Name] and parseState.ObjectStack[1][\"%encapsulate\"] then\r\n                dataTypeTable[parseState.ObjectStack[1].Name][\"%encapsulate\"] = parseState.ObjectStack[1][\"%encapsulate\"]\r\n            end\r\n\r\n            -- pop inline condition onto condition stack\r\n            if not lineState.IsBlockCondition and lineState.Condition then\r\n                table.remove(parseState.ConditionStack, 1)\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1254,
    "text": "if not lineState.IsBlockCondition and lineState.Condition then\r\n                table.insert(parseState.ConditionStack, 1, lineState.Condition)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1255,
    "text": "table.insert(parseState.ConditionStack, 1, lineState.Condition)",
    "type": "statement:functioncall"
  }, {
    "id": 1256,
    "text": "parseState.ObjectStack[1].Condition = BuildCondition(parseState.ConditionStack)",
    "type": "statement:assign"
  }, {
    "id": 1257,
    "text": "if dataTypeTable[parseState.ObjectStack[1].Name] and parseState.ObjectStack[1].Condition then\r\n                dataTypeTable[parseState.ObjectStack[1].Name].Condition = parseState.ObjectStack[1].Condition\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1258,
    "text": "dataTypeTable[parseState.ObjectStack[1].Name].Condition = parseState.ObjectStack[1].Condition",
    "type": "statement:assign"
  }, {
    "id": 1259,
    "text": "if dataTypeTable[parseState.ObjectStack[1].Name] and parseState.ObjectStack[1][\"%encapsulate\"] then\r\n                dataTypeTable[parseState.ObjectStack[1].Name][\"%encapsulate\"] = parseState.ObjectStack[1][\"%encapsulate\"]\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1260,
    "text": "dataTypeTable[parseState.ObjectStack[1].Name][\"%encapsulate\"] = parseState.ObjectStack[1][\"%encapsulate\"]",
    "type": "statement:assign"
  }, {
    "id": 1261,
    "text": "if not lineState.IsBlockCondition and lineState.Condition then\r\n                table.remove(parseState.ConditionStack, 1)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1262,
    "text": "table.remove(parseState.ConditionStack, 1)",
    "type": "statement:functioncall"
  }, {
    "id": 1263,
    "text": "if lineState.PopParseObject then\r\n            table.insert(objectList, parseState.ObjectStack[1])\r\n\r\n            table.remove(parseState.ObjectStack, 1)\r\n\r\n            if #parseState.ObjectStack == 0 then\r\n                print(\"ERROR: parseState.ObjectStack is unexpectedly empty. \"..LineTableErrString(lineTable))\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1264,
    "text": "if #parseState.ObjectStack == 0 then\r\n                print(\"ERROR: parseState.ObjectStack is unexpectedly empty. \"..LineTableErrString(lineTable))\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1265,
    "text": "print(\"ERROR: parseState.ObjectStack is unexpectedly empty. \"..LineTableErrString(lineTable))",
    "type": "statement:functioncall"
  }, {
    "id": 1266,
    "text": "table.insert(objectList, 1, parseState.ObjectStack[1])",
    "type": "statement:functioncall"
  }, {
    "id": 1267,
    "text": "if #parseState.ObjectStack ~= 0 then\r\n        print(\"ERROR: parseState.ObjectStack should be empty, has \"..#parseState.ObjectStack..\" items left.\")\r\n        TableDump(parseState.ObjectStack, \"parseState.ObjectStack\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 1268,
    "text": "print(\"ERROR: parseState.ObjectStack should be empty, has \"..#parseState.ObjectStack..\" items left.\")",
    "type": "statement:functioncall"
  }, {
    "id": 1269,
    "text": "TableDump(parseState.ObjectStack, \"parseState.ObjectStack\")",
    "type": "statement:functioncall"
  }, {
    "id": 1270,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1271,
    "text": "function MakeVar(type)\r\n    local split = SplitString(type, { \"::\" })\r\n\r\n    local var = split[1]\r\n    for i = 2, #split do\r\n        var = var..\"_\"..split[i]\r\n    end\r\n\r\n    return var\r\nend",
    "type": "function"
  }, {
    "id": 1272,
    "text": "local split = SplitString(type, { \"::\" })",
    "type": "statement:localassign"
  }, {
    "id": 1273,
    "text": "local var = split[1]",
    "type": "statement:localassign"
  }, {
    "id": 1274,
    "text": "for i = 2, #split do\r\n        var = var..\"_\"..split[i]\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 1275,
    "text": "var = var..\"_\"..split[i]",
    "type": "statement:assign"
  }, {
    "id": 1276,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1277,
    "text": "function MakeClassVar(datatype)\r\n    local vartype = datatype\r\n\r\n    -- use underlying TypeDef DataType?\r\n    if  typedefTable[datatype] then\r\n        local type = GetDataTypeOnly(typedefTable[datatype])\r\n        if type and dataTypeTable[type] then\r\n            vartype = type\r\n        end\r\n    end\r\n\r\n    return MakeVar(vartype)\r\nend",
    "type": "function"
  }, {
    "id": 1278,
    "text": "local vartype = datatype",
    "type": "statement:localassign"
  }, {
    "id": 1279,
    "text": "if  typedefTable[datatype] then\r\n        local type = GetDataTypeOnly(typedefTable[datatype])\r\n        if type and dataTypeTable[type] then\r\n            vartype = type\r\n        end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 1280,
    "text": "local type = GetDataTypeOnly(typedefTable[datatype])",
    "type": "statement:localassign"
  }, {
    "id": 1281,
    "text": "if type and dataTypeTable[type] then\r\n            vartype = type\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1282,
    "text": "vartype = type",
    "type": "statement:assign"
  }, {
    "id": 1283,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1284,
    "text": "function MakeImpExpData(data_type)\r\n    if output_cpp_impexpdatasymbol and (string.len(output_cpp_impexpdatasymbol) > 0) then\r\n        return output_cpp_impexpdatasymbol..\"(\"..data_type..\")\"\r\n    end\r\n    return data_type\r\nend",
    "type": "function"
  }, {
    "id": 1285,
    "text": "if output_cpp_impexpdatasymbol and (string.len(output_cpp_impexpdatasymbol) > 0) then\r\n        return output_cpp_impexpdatasymbol..\"(\"..data_type..\")\"\r\n    end",
    "type": "statement:if"
  }, {
    "id": 1286,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1287,
    "text": "function RemovewxLuaStateIfNotUsed(codeList)\r\n    -- remove the wxLuaState if we don't use it\r\n    local needs_wxluastate = -1\r\n    for i = 1, #codeList do\r\n        if string.find(codeList[i], \"wxLuaState wxl\", 1, 1) then\r\n            needs_wxluastate = i\r\n        elseif string.find(codeList[i], \"wxlState\", 1, 1) then\r\n            needs_wxluastate = -1\r\n            break\r\n        end\r\n    end\r\n    if (needs_wxluastate > 0) then\r\n        table.remove(codeList, needs_wxluastate)\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 1288,
    "text": "local needs_wxluastate = -1",
    "type": "statement:localassign"
  }, {
    "id": 1289,
    "text": "for i = 1, #codeList do\r\n        if string.find(codeList[i], \"wxLuaState wxl\", 1, 1) then\r\n            needs_wxluastate = i\r\n        elseif string.find(codeList[i], \"wxlState\", 1, 1) then\r\n            needs_wxluastate = -1\r\n            break\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 1290,
    "text": "if string.find(codeList[i], \"wxLuaState wxl\", 1, 1) then\r\n            needs_wxluastate = i\r\n        elseif string.find(codeList[i], \"wxlState\", 1, 1) then\r\n            needs_wxluastate = -1\r\n            break\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1291,
    "text": "needs_wxluastate = i",
    "type": "statement:assign"
  }, {
    "id": 1292,
    "text": "needs_wxluastate = -1",
    "type": "statement:assign"
  }, {
    "id": 1293,
    "text": "if (needs_wxluastate > 0) then\r\n        table.remove(codeList, needs_wxluastate)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 1294,
    "text": "table.remove(codeList, needs_wxluastate)",
    "type": "statement:functioncall"
  }, {
    "id": 1295,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1296,
    "text": "function GenerateLuaLanguageBinding(interface)\r\n    local overloadCount = {} -- overloadCount[methodName] = count #\r\n\r\n    for o = 1, #interface.objectData do\r\n        local parseObject = interface.objectData[o]\r\n\r\n        -- -------------------------------------------------------------------\r\n        -- de-duplicates include references, must generate them first, no .Members\r\n        if parseObject.ObjType == \"objtype_%include\" then\r\n\r\n            local includecondition = FixCondition(parseObject.Condition)\r\n            local includeBinding =\r\n            {\r\n                Include   = \"#include \".. parseObject.Name..\"\\n\",\r\n                Condition = includecondition\r\n            }\r\n\r\n            if not interface.includeBindingTable[includecondition] then\r\n                interface.includeBindingTable[includecondition] = {}\r\n            end\r\n\r\n            interface.includeBindingTable[includecondition][parseObject.Name] = includeBinding\r\n        elseif parseObject.ObjType == \"objtype_%includefile\" then\r\n            table.insert(interface.includeFiles, parseObject.Name)\r\n        end\r\n\r\n        -- -------------------------------------------------------------------\r\n        -- encapsulate non-wxObject objects with a tracked wxObject\r\n        if parseObject[\"%encapsulate\"] then\r\n\r\n            local encapcondition = FixCondition(parseObject.Condition)\r\n            local encapsulationBinding =\r\n            {\r\n                Declaration    = \"wxLUA_DECLARE_ENCAPSULATION(\"..output_cpp_impexpsymbol..\", \"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\",\r\n                Implementation = \"wxLUA_IMPLEMENT_ENCAPSULATION(\"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\",\r\n                Condition      = encapcondition\r\n            }\r\n\r\n            if IsDerivedClass(parseObject.Name, \"wxGridCellWorker\") or\r\n               IsDerivedClass(parseObject.Name, \"wxGridCellAttr\") then\r\n                encapsulationBinding.Implementation = \"wxLUA_IMPLEMENT_wxGridCellWorker_ENCAPSULATION(\"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\"\r\n            end\r\n\r\n            if not encapsulationBindingTable[encapcondition] then\r\n                encapsulationBindingTable[encapcondition] = {}\r\n            end\r\n\r\n            if parseObject[\"%encapsulate\"] then\r\n                encapsulationBindingTable[encapcondition][parseObject.Name] = encapsulationBinding\r\n            end\r\n        end\r\n\r\n        -- parseObject member binding\r\n        for m = 1, #parseObject.Members do\r\n            local member = parseObject.Members[m]\r\n\r\n            local fullcondition = FixCondition(AddCondition(member.Condition, member.ExtraCondition))\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- member binding\r\n            -- ---------------------------------------------------------------\r\n            if (member.DefType == \"deftype_%member\") or (member.DefType == \"deftype_%member_func\") then\r\n                local memberType    = member.DataType\r\n                local memberGetFunc = \"Get_\"..member.Name\r\n                local memberSetFunc = \"Set_\"..member.Name\r\n                if member[\"%rename\"] then\r\n                    memberGetFunc = \"Get\"..member[\"%rename\"]\r\n                    memberSetFunc = \"Set\"..member[\"%rename\"]\r\n                end\r\n\r\n                local funcType = \"WXLUAMETHOD_METHOD\"\r\n                local propType = \"\"\r\n                if member.IsStaticFunction then\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    propType = \"|WXLUAMETHOD_STATIC\"\r\n                end\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                local memberPtr = member.DataTypePointer[1]\r\n                local indirectionCount = #member.DataTypePointer\r\n                local numeric = IsDataTypeNumeric(member.DataType)\r\n\r\n                -- conditions for member are dependent on return type, argument types, and inline conditions\r\n                local dependConditions = {}\r\n\r\n                if HasCondition(fullcondition) then\r\n                    dependConditions[fullcondition] = fullcondition\r\n                end\r\n\r\n                local returnCondition = GetDataTypeCondition(member.DataType)\r\n                if returnCondition then\r\n                    dependConditions[returnCondition] = returnCondition\r\n                end\r\n\r\n                -- build member condition\r\n                local membercondition = nil\r\n                for idx, condition in pairs(dependConditions) do\r\n                    membercondition = AddCondition(membercondition, condition)\r\n                end\r\n                membercondition = FixCondition(membercondition)\r\n\r\n                -- GET MEMBER CODE\r\n                local codeList = {}\r\n                local overload_argList = \"\"\r\n                local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberGetFunc\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                local self_name = \"self->\"\r\n                if member.IsStaticFunction then\r\n                    self_name = parseObject.Name..\"::\"\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n                end\r\n\r\n                if memberType == \"wxString\" then\r\n                    CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                    table.insert(codeList, \"    wxlua_pushwxString(L, \"..self_name..member.Name..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\")) then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n\r\n--                    if string.find(member.Name, \"::\") then\r\n--                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    else\r\n                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, &\"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    end\r\n                elseif not numeric then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n\r\n                elseif IsDataTypeBool(memberType) then\r\n                    CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                    table.insert(codeList, \"    lua_pushboolean(L, \"..self_name..member.Name..\");\\n\")\r\n\r\n                else\r\n                    CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                    table.insert(codeList, \"    lua_pushnumber(L, \"..self_name..member.Name..\");\\n\")\r\n                end\r\n\r\n                CommentBindingTable(codeList, \"    // return the number of values\\n\")\r\n                table.insert(codeList, \"    return 1;\\n\")\r\n                table.insert(codeList, \"}\\n\")\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\"..funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                -- bind method\r\n                local methodBinding =\r\n                {\r\n                    LuaName       = memberGetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberGetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }\r\n\r\n                -- bind property\r\n                local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_GETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_GETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                -- rem out the Get function if not %member_func, but we need the code for the property\r\n                if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                table.insert(interface.objectData[o].BindTable, propertyBinding)\r\n\r\n                -- SET MEMBER CODE, not for const members\r\n                if not string.find(member.DataTypeWithAttrib, \"const \", 1, 1) then\r\n\r\n                codeList = {}\r\n                overload_argList = \"\"\r\n                local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberSetFunc\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                local stack_idx = iff(member.IsStaticFunction, \"1\", \"2\")\r\n\r\n                if memberType == \"wxString\" then\r\n                    overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                    CommentBindingTable(codeList, \"    // get the string value\\n\")\r\n                    table.insert(codeList, \"    wxString val = wxlua_getwxStringtype(L, \"..stack_idx..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif not numeric then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif IsDataTypeBool(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                    CommentBindingTable(codeList, \"    // get the boolean value\\n\")\r\n                    table.insert(codeList, \"    bool val = wxlua_getbooleantype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeEnum(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the enum value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getenumtype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeUInt(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the unsigned integer value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getuintegertype(L, \"..stack_idx..\");\\n\")\r\n                else\r\n                    overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                    CommentBindingTable(codeList, \"    // get the number value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getnumbertype(L, \"..stack_idx..\");\\n\")\r\n                end\r\n\r\n                if member.IsStaticFunction then\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                end\r\n\r\n                CommentBindingTable(codeList, \"    // return the number of values\\n\")\r\n                table.insert(codeList, \"    return 0;\\n\")\r\n                table.insert(codeList, \"}\\n\")\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                -- bind method\r\n                local methodBinding =\r\n                {\r\n                    LuaName       = memberSetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 2, 2, \"..overload_argListName..\" }\", -- FIXME make sure this is right\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberSetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }\r\n\r\n                -- bind property\r\n                local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_SETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_SETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                -- rem out the Set function if not %member_func, but we need the code for the property\r\n                if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                table.insert(interface.objectData[o].BindTable, propertyBinding)\r\n\r\n                end\r\n            -- ---------------------------------------------------------------\r\n            -- enum binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%enum\" then\r\n                -- if we have wxDateTime::TZ, only take the wxDateTime part\r\n                local dataType = member.DataType or \"\"\r\n                local namespace = \"\"\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local classname = \"\"\r\n                local enumname = luaname\r\n\r\n                local pos = string.find(dataType, \"::\", 1, 1)\r\n                if pos then\r\n                    -- search for last ::, eg. ns1::ns2::enumName -> ns1::ns2 is namespace\r\n                    classname = string.sub(dataType, 0, pos - 1)\r\n                    while pos do\r\n                        local p = string.find(dataType, \"::\", pos+2, 1)\r\n                        if p then pos = p else break end\r\n                    end\r\n\r\n                    namespace = string.sub(dataType, 0, pos - 1)\r\n                    if not member[\"%rename\"] then\r\n                        luaname = MakeVar(namespace)..\"_\"..luaname -- wxFile::read -> wxFile_read\r\n                    end\r\n\r\n                    namespace = namespace..\"::\"\r\n                end\r\n\r\n                if (string.len(classname) > 0) then\r\n                    if not enumClassBindingTable[classname] then\r\n                        enumClassBindingTable[classname] = {}\r\n                    end\r\n\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = enumname,\r\n                        Map       = \"        { \\\"\"..enumname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumClassBindingTable[classname], enumBinding)\r\n                else\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = luaname,\r\n                        Map       = \"        { \\\"\"..luaname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumBindingTable, enumBinding)\r\n                end\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local value = member.Value or member.Name\r\n\r\n                local defineBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(defineBindingTable, defineBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_string binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_string\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local value = member.Value or member.Name\r\n\r\n                local stringBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(stringBindingTable, stringBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_object binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_object\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local objectBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", &\"..member.Name..\", NULL },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(objectBindingTable, objectBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_pointer binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_pointer\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local pointerBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL, (const void **) &\"..member.Name..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(pointerBindingTable, pointerBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_event binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_event\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local eventBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &\"..member.Name..\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(eventBindingTable, eventBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- method binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_method\" then\r\n                local argList = \"\"\r\n                local overload_argList = \"\"\r\n                local gcList = {}\r\n\r\n                local arg = 0\r\n\r\n                if (member[\"%operator\"] == \"++\") and (#member.Params > 0) then\r\n                    member.Name = \"op_preinc\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"--\") and (#member.Params > 0) then\r\n                    member.Name = \"op_predec\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"*\") and (#member.Params == 0) then\r\n                    member.Name = \"op_deref\"\r\n                    member.Params = {}\r\n                end\r\n\r\n                while member.Params[arg+1] do\r\n                    arg = arg + 1\r\n                    local param = member.Params[arg]\r\n\r\n                    -- See if we're supposed to track or untrack the parameter\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%gc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+4)\r\n                        param.GC = true\r\n                    end\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%ungc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+6)\r\n                        param.UnGC = true\r\n                    end\r\n\r\n                    local declare = nil\r\n                    local argType = param.DataType\r\n                    local argTypeWithAttrib = param.DataTypeWithAttrib\r\n                    local argPtr = param.DataTypePointer[1]\r\n                    local argName = param.Name\r\n                    local argNum = nil\r\n                    local opt = param.DefaultValue\r\n                    local numeric = IsDataTypeNumeric(param.DataType)\r\n\r\n                    if member.IsConstructor or member[\"%function\"] or member.IsStaticFunction then\r\n                        argNum = arg -- don't have self\r\n                    else\r\n                        argNum = arg + 1\r\n                    end\r\n\r\n                    if not argName then\r\n                        argName = \"arg\"..arg\r\n\r\n                        param.Name = argName\r\n                    end\r\n\r\n                    if arg > 1 then\r\n                        argList = argList..\", \"\r\n                    end\r\n\r\n                    local indirectionCount = #param.DataTypePointer\r\n\r\n                    local isTranslated = nil\r\n                    local origArgType =  argType\r\n                    local origArgTypeWithAttrib = argTypeWithAttrib\r\n                    local origArgPtr = argPtr\r\n                    local origIndirectionCount = indirectionCount\r\n                    local argCast = nil\r\n                    local argListOverride = nil\r\n\r\n                    -- Does DataType need to be translated from typeDef\r\n                    TranslateDataType(param)\r\n                    if #param.TypedDataTypePointer ~= indirectionCount then\r\n                        indirectionCount = #param.TypedDataTypePointer\r\n\r\n                        -- translated datatype\r\n                        argType = param.TypedDataType\r\n                        argTypeWithAttrib = param.TypedDataTypeWithAttrib\r\n                        argPtr = param.TypedDataTypePointer[1]\r\n\r\n                        isTranslated = true\r\n                    end\r\n\r\n\r\n                    -- the function takes (void*), but we just pass a long\r\n                    if argType == \"voidptr_long\" then\r\n                        argType = \"long\"\r\n                        argTypeWithAttrib = \"long\"\r\n                        argCast = \"void*\"\r\n                    end\r\n\r\n                    -- our special notation to get wxString/IntArray from a Lua table of strings\r\n                    -- BUT! it has to be const wxArrayString& arr or wxArrayString arr\r\n                    --      and NOT wxArrayString& arr or wxArrayString* arr\r\n                    if ((argType == \"wxArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayString, \"\r\n                        argItem = \"wxlua_getwxArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayString\"\r\n                    elseif ((argType == \"wxSortedArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxSortedArrayString, \"\r\n                        argItem = \"wxlua_getwxSortedArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxSortedArrayString\"\r\n                    elseif ((argType == \"wxArrayInt\") and\r\n                            ((indirectionCount == 0) or\r\n                             ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayInt, \"\r\n                        argItem = \"wxlua_getwxArrayInt(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayInt\"\r\n                    elseif argType == \"IntArray_FromLuaTable\" then\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"NULL; ptr = \"..argName..\" = wxlua_getintarray(L, \"..argNum..\", count_)\"\r\n                        declare = \"int count_ = 0; wxLuaSmartIntArray ptr; int*\"\r\n                        argList = argList..\"count_, \"\r\n                    elseif argType == \"LuaTable\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif argType == \"LuaFunction\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TFUNCTION, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif (indirectionCount == 1) and (argPtr == \"[]\") then\r\n                        argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n\r\n                        if argType == \"wxString\" then\r\n                            -- overload_argList = overload_argList..\"&s_wxluaarg_StringArray, \" FIXME!\r\n                            -- Un 'const' strings\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getwxStringarray(\"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartStringArray \"\r\n                        elseif argType == \"int\" then\r\n                            -- Un 'const' ints\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getintarray(L, \"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartIntArray \"\r\n                        elseif not numeric then\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"*\") then\r\n                        if (argType == \"wxString\") or (argType == \"wxChar\") then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxT(\"..opt..\")\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n\r\n                            if (argType == \"wxChar\") then\r\n                                argTypeWithAttrib = \"wxString \"\r\n                                argListOverride = argName..\".IsEmpty() ? NULL : \"..argName..\".c_str()\"\r\n                            end\r\n\r\n                        elseif argType == \"char\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getstringtype(L, \"..argNum..\")\"\r\n\r\n                            argTypeWithAttrib = \"wxCharBuffer\"\r\n                            argCast = \"const char*\" -- allows for \"unsigned char*\"\r\n                        else\r\n                            if isTranslated and (origIndirectionCount == 0) then\r\n                                argTypeWithAttrib = origArgTypeWithAttrib\r\n                                argCast = origArgTypeWithAttrib\r\n                            else\r\n                                argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            end\r\n\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            if param.GC then\r\n                                if dataTypeTable[argType][\"%encapsulate\"] then\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")\r\n                                else\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")\r\n                                end\r\n                            elseif param.UnGC then\r\n                                table.insert(gcList, \"    if (wxluaO_isgcobject(L, \"..argName..\")) wxluaO_undeletegcobject(L, \"..argName..\");\\n\")\r\n                            end\r\n\r\n                        end\r\n                    elseif (indirectionCount == 2) and (argPtr == \"*\") then\r\n                        if not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" **\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"&\") then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        else\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            -- Default Value\r\n                            if opt then opt = \"&\"..opt end\r\n\r\n                            argList = argList..\"*\"\r\n                        end\r\n                    elseif indirectionCount == 0 then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        elseif IsDataTypeBool(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                            argItem = \"wxlua_getbooleantype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeEnum(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getenumtype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeUInt(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getuintegertype(L, \"..argNum..\")\"\r\n                        elseif not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argItem = \"*(\"..argTypeWithAttrib..\"*)wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getnumbertype(L, \"..argNum..\")\"\r\n                        end\r\n                    else\r\n                        local point = \"\"\r\n                        for z = 1, #param.TypedDataTypePointer do\r\n                            point = point..param.TypedDataTypePointer[z]\r\n                        end\r\n                        print(\"ERROR: Unsupported pointer indirection '\"..point..\"' \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    if argCast then\r\n                        argList = argList..\"(\"..argCast..\")\"\r\n                    end\r\n\r\n                    argList = argList..(argListOverride or argName)\r\n\r\n                    -- except for string arrays, the declare is the argType\r\n                    if not declare then\r\n                        declare = argTypeWithAttrib\r\n                    end\r\n\r\n                    if not param.Name then\r\n                        print(\"ERROR: No Param Name: \"..member.LineText..\" \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- interface.objectData[o].Members[m].Params[p]\r\n                    codeList = {}\r\n\r\n                    if opt then\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\" = \"..param.DefaultValue..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = (argCount >= \"..argNum..\" ? \"..argItem..\" : \"..opt..\");\\n\")\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = \"..argItem..\";\\n\")\r\n                    end\r\n\r\n                    local paramBinding =\r\n                    {\r\n                        ParamName = argName,\r\n                        ParamType = argType,\r\n                        ParamCast = argCast,\r\n                        ParamCode = codeList,\r\n                    }\r\n\r\n                    -- set param binding\r\n                    interface.objectData[o].Members[m].Params[arg].Binding = paramBinding\r\n                end\r\n\r\n                -- //////////////////////////////////////////////////////////////////////////////////\r\n                -- method binding\r\n                codeList = {}\r\n\r\n                local numeric = IsDataTypeNumeric(member.DataType)\r\n\r\n                -- function name\r\n                local funcType = nil\r\n                local funcName = nil\r\n                local funcNameBase = nil\r\n                local funcLuaCall = nil\r\n                if member.IsConstructor or (member.Name == parseObject.Name) then\r\n                    member.IsConstructor = true\r\n                    funcName = \"wxLua_\"..MakeVar(member[\"%rename\"] or member.Name)..\"_constructor\"\r\n                    funcNameBase = funcName\r\n\r\n                    funcType = \"WXLUAMETHOD_CONSTRUCTOR\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif member.Name == \"~\"..parseObject.Name then\r\n                    print(\"WARNING: Unhandled ~ destructor \", member.Name, parseObject.Name);\r\n                elseif member.IsStaticFunction then\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif (parseObject.Name == \"globals\") or member[\"%function\"] then\r\n                    funcName = \"wxLua_function_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_CFUNCTION\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                else\r\n                    if not parseObject.Name then\r\n                        print(\"ERROR: parseObject.Name = nil \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- special case for unary -, convert from op_sub to op_neg if necessary\r\n                    if member[\"%operator\"] and (#member.Params == 0) and (member.Name == \"op_sub\") then\r\n                        member.Name = \"op_neg\"\r\n                        if member[\"%rename\"] == \"op_sub\" then -- maybe they renamed it?\r\n                            member[\"%rename\"] = \"op_neg\"\r\n                        end\r\n                    end\r\n\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n\r\n                    funcType = \"WXLUAMETHOD_METHOD\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                end\r\n\r\n                if not funcNameBase then funcNameBase = funcName end\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                -- if they declared this, the conditions must be exclusive\r\n                -- since the functions will have the same names\r\n                if (member.NotOverload ~= true) then\r\n                    if overloadCount[funcName] then\r\n                        overloadCount[funcName] = overloadCount[funcName] + 1\r\n                        funcName = funcName..tostring(overloadCount[funcName]-1)\r\n                    else\r\n                        overloadCount[funcName] = 1\r\n                    end\r\n                end\r\n\r\n                -- function\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                -- See if we're supposed to track or untrack the return value\r\n                local a = string.find(member.DataTypeWithAttrib, \"%gc\", 1, 1)\r\n                if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+4)\r\n                    member.GC = true\r\n                end\r\n                local a = string.find(member.DataTypeWithAttrib, \"%ungc\", 1, 1)\r\n                if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+6)\r\n                    member.UnGC = true\r\n                end\r\n\r\n                -- determine function return type\r\n                local memberType = member.DataType\r\n                local memberTypeWithAttrib = member.DataTypeWithAttrib\r\n                local memberPtr = member.DataTypePointer[1]\r\n\r\n                local indirectionCount = #member.DataTypePointer\r\n\r\n                local isTranslated = nil\r\n                local origMemberType =  memberType\r\n                local origMemberTypeWithAttrib = memberTypeWithAttrib\r\n                local origMemberPtr = memberPtr\r\n                local origIndirectionCount = indirectionCount\r\n                local memberCast = nil\r\n\r\n                -- Does DataType need to be translated from typeDef\r\n                TranslateDataType(member)\r\n                if #member.TypedDataTypePointer ~= indirectionCount then\r\n                    indirectionCount = #member.TypedDataTypePointer\r\n\r\n                    -- translated datatype\r\n                    memberType = member.TypedDataType\r\n                    memberTypeWithAttrib = member.TypedDataTypeWithAttrib\r\n                    memberPtr = member.TypedDataTypePointer[1]\r\n\r\n                    isTranslated = true\r\n                end\r\n\r\n                local returnPtr = \"*\";\r\n\r\n                if (memberType ~= \"void\") or (indirectionCount > 0) then\r\n                    if numeric and ((indirectionCount == 0) or (memberPtr == \"&\"))  then\r\n                        returnPtr = \"\"\r\n                    end\r\n\r\n                    if isTranslated and (indirectionCount == 1) and (origIndirectionCount == 0) then\r\n                        memberTypeWithAttrib = origMemberTypeWithAttrib..\" \"\r\n                        memberCast = origMemberTypeWithAttrib\r\n                    else\r\n                        memberTypeWithAttrib = memberTypeWithAttrib..returnPtr\r\n                    end\r\n\r\n                    -- Un 'const' strings and non-pointer datatypes\r\n                    if (string.sub(memberTypeWithAttrib, 1, 6) == \"const \") and ((memberType == \"wxString\") or (returnPtr == \"\") or member.IsConstructor) then\r\n                        memberTypeWithAttrib = string.sub(memberTypeWithAttrib, 7)\r\n                    end\r\n\r\n                    if string.find(\"voidptr_long\", memberTypeWithAttrib, 1, 1) then\r\n                        memberTypeWithAttrib = \"long \"\r\n                    end\r\n                end\r\n\r\n                -- conditions for method are dependent on return type, argument types, and inline conditions\r\n                local dependConditions = {}\r\n\r\n                if HasCondition(fullcondition) then\r\n                    dependConditions[fullcondition] = fullcondition\r\n                end\r\n\r\n                local returnCondition = GetDataTypeCondition(memberType)\r\n                if returnCondition then\r\n                    dependConditions[returnCondition] = returnCondition\r\n                end\r\n\r\n                -- get args\r\n                local requiredParamCount = 0\r\n                local paramCount = #member.Params\r\n                if  paramCount > 0 then\r\n                    for arg=1, paramCount do\r\n                        if not member.Params[arg].DefaultValue then\r\n                            requiredParamCount = requiredParamCount + 1\r\n                        elseif member.Params[arg+1] and (not member.Params[arg+1].DefaultValue) then\r\n                            print(\"ERROR: Missing default arg #\"..tostring(arg+1)..\" in function. \"..LineTableErrString(member))\r\n                        end\r\n                    end\r\n\r\n                    if requiredParamCount ~= paramCount then\r\n                        CommentBindingTable(codeList, \"    // get number of arguments\\n\")\r\n                        table.insert(codeList, \"    int argCount = lua_gettop(L);\\n\")\r\n                    end\r\n\r\n                    for arg = 1, paramCount do\r\n                        -- add function code to get args (in reverse order)\r\n                        local paramLineCount = #(member.Params[paramCount + 1 - arg].Binding.ParamCode)\r\n                        for paramLine=1, paramLineCount do\r\n                            table.insert(codeList, member.Params[paramCount + 1 - arg].Binding.ParamCode[paramLine])\r\n                        end\r\n\r\n                        -- param conditions\r\n                        local paramCondition = GetDataTypeCondition(member.Params[arg].DataType)\r\n                        if paramCondition then\r\n                            dependConditions[paramCondition] = paramCondition\r\n                        end\r\n                    end\r\n                end\r\n\r\n                for i = 1, #gcList do\r\n                    table.insert(codeList, gcList[i])\r\n                end\r\n\r\n                -- constructor?\r\n                if member.IsConstructor then\r\n                    CommentBindingTable(codeList, \"    // call constructor\\n\")\r\n                    table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..parseObject.Name..\"(\"..argList..\");\\n\")\r\n\r\n                    if parseObject[\"%gc_this\"] or (parseObject[\"%delete\"] and (not parseObject[\"%ungc_this\"])) then\r\n                        CommentBindingTable(codeList, \"    // add to tracked memory list\\n\")\r\n\r\n                        -- Un 'const' AddTrackedObject\r\n                        local returnCast = memberTypeWithAttrib\r\n                        if string.sub(returnCast, 1, 6) == \"const \" then\r\n                            returnCast = string.sub(returnCast, 7)\r\n                        end\r\n\r\n                        if parseObject[\"%encapsulate\"] then\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(parseObject.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                        else\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, returns);\\n\")\r\n                        end\r\n                    elseif not parseObject[\"%noclassinfo\"] then\r\n                        CommentBindingTable(codeList, \"    // add to tracked window list, it will check validity\\n\")\r\n                        table.insert(codeList, \"    wxluaW_addtrackedwindow(L, returns);\\n\")\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // push the constructed class pointer\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n\r\n                    table.insert(codeList, \"\\n    return 1;\\n\")\r\n                    table.insert(codeList, \"}\\n\")\r\n                else\r\n                    -- how we call c-function\r\n                    if parseObject.Name == \"globals\" then\r\n                        functor = member.Name   -- global\r\n                    elseif member.IsStaticFunction then\r\n                        functor = parseObject.Name..\"::\"..member.Name -- static member function\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // get this\\n\")\r\n\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\" * self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                        overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                        if parseObject[\"%ungc_this\"] then\r\n                            table.insert(codeList, \"    wxluaO_undeletegcobject(L, self);\\n\")\r\n                        elseif parseObject[\"%gc_this\"] then\r\n                            if parseObject[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    if (!wxluaO_isgcobject(L, self)) wxluaO_addgcobject(L, (void*)self, new wxLua_wxObject_\"..MakeClassVar(parseObject.Name)..\"(self));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, self);\\n\")\r\n                            end\r\n                        end\r\n\r\n                        requiredParamCount = requiredParamCount + 1\r\n                        paramCount = paramCount + 1\r\n\r\n                        if member[\"%operator\"] then\r\n                            if (member.Name == \"op_preinc\") or (member.Name == \"op_predec\") then\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            elseif (member.Name == \"op_inc\") or (member.Name == \"op_dec\") then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            elseif member[\"%operator\"] == \"[]\" then     -- op_index\r\n                                functor = \"(*self)[\"\r\n                            elseif member[\"%operator\"] == \"()\" then -- op_func\r\n                                functor = \"(*self)\"\r\n                            elseif paramCount > 1 then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            else\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            end\r\n                        -- static member function?\r\n                        elseif string.find(member.Name, \"::\") then\r\n                            functor = member.Name\r\n                        else\r\n                            functor = \"self->\"..member.Name\r\n                        end\r\n                    end\r\n\r\n                    -- need cast?\r\n                    if memberCast then\r\n                        functor  = \"(\"..memberCast..\")\"..functor\r\n                    end\r\n\r\n                    local is_func = iff(not member[\"%operator\"] and member.IsFunction, true, false)\r\n\r\n                    -- Add Function Argument List\r\n                    if (argList ~= \"\") or is_func then\r\n                        functor = functor..\"(\"..argList..\")\"\r\n                    end\r\n\r\n                    if member[\"%operator\"] == \"[]\" then -- op_index\r\n                        functor = functor..\"]\"\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // call \"..member.Name..\"\\n\")\r\n\r\n                    if not memberType or (memberTypeWithAttrib == \"void\") then\r\n                        -- call (void) function\r\n                        table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                        table.insert(codeList, \"\\n    return 0;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    else\r\n                        -- call function, get return value\r\n                        if member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and string.find(member[\"%operator\"], \"=\", 1, 1) then\r\n                            table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = self;\\n\")\r\n                        elseif member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and (string.find(member[\"%operator\"], \"=\", 1, 1) == nil) then\r\n                            if string.find(memberTypeWithAttrib or \"\", \"*\", 1, 1) then\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &(\"..functor..\");\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = \"..functor..\";\\n\")\r\n                            end\r\n                        elseif (not numeric) and (not memberPtr) then\r\n                            CommentBindingTable(codeList, \"    // allocate a new object using the copy constructor\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..memberType..\"(\"..functor..\");\\n\")\r\n                            CommentBindingTable(codeList, \"    // add the new object to the tracked memory list\\n\")\r\n\r\n                            -- Un 'const' AddTrackedObject\r\n                            local returnCast = memberTypeWithAttrib\r\n                            if string.sub(returnCast, 1, 6) == \"const \" then\r\n                                returnCast = string.sub(returnCast, 7)\r\n                            end\r\n\r\n                            local member_DataType = GetDataTypedefBase(memberType)\r\n\r\n                            if member_DataType[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(member_DataType.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (\"..returnCast..\")returns);\\n\")\r\n                            end\r\n\r\n                        elseif (not member[\"%operator\"]) and (memberPtr == \"&\") and string.find(memberTypeWithAttrib, \"*\") and (memberType ~= \"wxString\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &\"..functor..\";\\n\")\r\n                        elseif (memberPtr == \"*\") or (memberType == \"voidptr_long\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..memberTypeWithAttrib..\")\"..functor..\";\\n\")\r\n\r\n                            if member.GC then\r\n                                if dataTypeTable[memberType][\"%encapsulate\"] then\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")\r\n                                else\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")\r\n                                end\r\n                            elseif member.UnGC then\r\n                                table.insert(codeList, \"    if (wxluaO_isgcobject(L, returns)) wxluaO_undeletegcobject(L, returns);\\n\")\r\n                            end\r\n\r\n                        else\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..functor..\");\\n\")\r\n                        end\r\n\r\n                        -- bind return value\r\n                        if memberType == \"wxString\" then\r\n                            CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                            table.insert(codeList, \"    wxlua_pushwxString(L, \"..returnPtr..\"returns);\\n\")\r\n                        elseif not numeric then\r\n                            CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                            table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                        elseif IsDataTypeBool(member.DataType) then\r\n                            CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                            table.insert(codeList, \"    lua_pushboolean(L, returns);\\n\")\r\n                        elseif returnPtr == \"*\" then\r\n                            CommentBindingTable(codeList, \"    // push the result pointer\\n\")\r\n                            table.insert(codeList, \"    lua_pushlightuserdata(L, (void *)returns);\\n\")\r\n                        else -- Number\r\n                            CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                            table.insert(codeList, \"    lua_pushnumber(L, returns);\\n\")\r\n                        end\r\n\r\n                        table.insert(codeList, \"\\n    return 1;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    end\r\n                end\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                -- add function map only once for the base function name overload\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n                local funcMap   = \"{ \"..funcName..\", \"..funcType..\", \"..tostring(requiredParamCount)..\", \"..tostring(paramCount)..\", \"..overload_argListName..\" }\"\r\n                local methodMap = \"    { \\\"\"..funcLuaCall..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\"\r\n\r\n                -- build method condition\r\n                local methodcondition = nil\r\n                for idx, condition in pairs(dependConditions) do\r\n                    methodcondition = AddCondition(methodcondition, condition)\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                methodcondition = FixCondition(methodcondition)\r\n\r\n                -- bind method\r\n                methodBinding =\r\n                {\r\n                    ClassName          = parseObject.Name,\r\n                    FuncType           = funcType,\r\n                    LuaName            = funcLuaCall,\r\n                    CFunctionName      = funcName,\r\n                    CFunctionNameBase  = funcNameBase,\r\n                    Method             = codeList,\r\n                    ArgArray           = overload_argList,\r\n                    ArgArrayName       = overload_argListName,\r\n                    ParamCount         = paramCount,\r\n                    RequiredParamCount = requiredParamCount,\r\n                    FuncMap            = funcMap,\r\n                    FuncMapName        = funcMapName,\r\n                    Map                = methodMap,\r\n                    NotOverload        = member.NotOverload,\r\n                    Condition          = methodcondition,\r\n                    PreDefineCode      = nil, -- set later if necessary\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if (member.override_name and overrideTable[member.override_name]) then\r\n                    methodBinding.Method = overrideTable[member.override_name]\r\n                    methodBinding.PreDefineCode = \"#define \"..funcName..\" \"..member.override_name..\"\\n\"\r\n                    overrideTableUsed[member.override_name] = true\r\n                elseif ((member.override_name == nil) and overrideTable[methodBinding.CFunctionName]) then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                if member[\"%function\"] then\r\n                    table.insert(functionBindingTable, methodBinding)\r\n                elseif not (member.IsConstructor and parseObject[\"%abstract\"]) then\r\n                    table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                end\r\n            end\r\n        end\r\n\r\n        if (parseObject.ObjType == \"objtype_%class\") or (parseObject.ObjType == \"objtype_%struct\") then\r\n            -- Class Includes\r\n            for condition, includeBindingList in pairs(interface.includeBindingTable) do\r\n                if not classIncludeBindingTable[condition] then classIncludeBindingTable[condition] = {} end\r\n\r\n                for idx, includeBinding in pairs(includeBindingList) do\r\n                    classIncludeBindingTable[condition][idx] = includeBinding\r\n                end\r\n            end\r\n\r\n            -- Figure out if we really need to have member enums for the class\r\n                local enumArrayName = \"g_wxluanumberArray_None\"\r\n                local enumArrayCountName = 0\r\n                local ExternEnumDeclaration = \"\"\r\n                local ExternEnumCountDeclaration = \"\"\r\n\r\n            if enumClassBindingTable[MakeVar(parseObject.Name)] ~= nil then\r\n                enumArrayName = MakeVar(parseObject.Name)..\"_enums\"\r\n                enumArrayCountName = MakeVar(parseObject.Name)..\"_enumCount\"\r\n                --ExternEnumDeclaration = \"extern \"..output_cpp_impexpsymbol..\" wxLuaBindNumber \"..enumArrayName..\"[];\\n\"\r\n                --ExternEnumCountDeclaration = \"extern \"..MakeImpExpData(\"int\")..\" \"..enumArrayCountName..\";\\n\"\r\n                ExternEnumDeclaration = \"extern wxLuaBindNumber \"..enumArrayName..\"[];\\n\"\r\n                ExternEnumCountDeclaration = \"extern int \"..enumArrayCountName..\";\\n\"\r\n            end\r\n\r\n\r\n            -- Extern Class Tag Declaration\r\n            local tagcondition = FixCondition(parseObject.Condition)\r\n            local classTypeBinding =\r\n            {\r\n                ExternDeclaration            = \"extern \"..MakeImpExpData(\"int\")..\" wxluatype_\"..MakeClassVar(parseObject.Name)..\";\\n\",\r\n                --ExternMethodDeclaration      = \"extern \"..output_cpp_impexpsymbol..\" wxLuaBindMethod \"..MakeVar(parseObject.Name)..\"_methods[];\\n\",\r\n                --ExternMethodCountDeclaration = \"extern \"..MakeImpExpData(\"int\")..\" \"..MakeVar(parseObject.Name)..\"_methodCount;\\n\",\r\n                ExternMethodDeclaration      = \"extern wxLuaBindMethod \"..MakeVar(parseObject.Name)..\"_methods[];\\n\",\r\n                ExternMethodCountDeclaration = \"extern int \"..MakeVar(parseObject.Name)..\"_methodCount;\\n\",\r\n                ExternEnumDeclaration        = ExternEnumDeclaration,\r\n                ExternEnumCountDeclaration   = ExternEnumCountDeclaration,\r\n                Condition                    = tagcondition\r\n            }\r\n\r\n            if not classTypeBindingTable[tagcondition] then classTypeBindingTable[tagcondition] = {} end\r\n            classTypeBindingTable[tagcondition][parseObject.Name] = classTypeBinding\r\n\r\n            -- Class Tag Declaration\r\n            local decl = \"\";\r\n            if comment_cpp_binding_code then\r\n                decl = decl..\"// Lua MetaTable Tag for Class '\"..parseObject.Name..\"'\\n\"\r\n            end\r\n            decl = decl..\"int wxluatype_\"..MakeClassVar(parseObject.Name)..\" = WXLUA_TUNKNOWN;\\n\"\r\n\r\n            interface.objectData[o].TagDeclaration = decl\r\n\r\n            -- Class Binding\r\n            local baseclassNames = \"NULL\"\r\n            local baseclassBinds = \"NULL\"\r\n            if dataTypeTable[parseObject.Name].BaseClasses then\r\n                baseclassNames = \"wxluabaseclassnames_\"..MakeVar(parseObject.Name)\r\n                baseclassBinds = \"wxluabaseclassbinds_\"..MakeVar(parseObject.Name)\r\n            end\r\n\r\n            local classinfo = \"NULL\"\r\n            if not parseObject[\"%noclassinfo\"] then\r\n                classinfo = \"CLASSINFO(\"..parseObject.Name..\")\"\r\n            end\r\n\r\n            -- Class Functions\r\n            if parseObject[\"%delete\"] then\r\n                -- delete routine\r\n                codeList = {}\r\n                local funcName  = \"wxLua_\"..MakeVar(parseObject.Name)..\"_delete\"\r\n                local funcName_ = funcName\r\n\r\n                if not overrideTable[funcName] then\r\n                    funcName_ = \"wxlua_userdata_delete\"\r\n                end\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                local overload_argList = \"{ &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL }\"\r\n\r\n                local condition = FixCondition(parseObject.Condition)\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcType = \"WXLUAMETHOD_METHOD\"\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                local delMethodBinding =\r\n                {\r\n                    LuaName         = \"delete\",\r\n                    CFunctionName   = funcName_,\r\n                    Method          = codeList,\r\n                    FuncType        = funcType,\r\n                    FuncMap         = \"{ \"..funcName_..\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName     = funcMapName,\r\n                    ArgArray        = overload_argList,\r\n                    ArgArrayName    = overload_argListName,\r\n                    ParamCount      = 1,\r\n                    RequiredParamCount = 1,\r\n                    Map             = \"    { \\\"delete\\\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition       = condition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[funcName] then\r\n                    delMethodBinding.Method = overrideTable[funcName]\r\n                    overrideTableUsed[funcName] = true\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, delMethodBinding)\r\n            end\r\n\r\n            local classcondition = FixCondition(parseObject.Condition)\r\n            local classBinding =\r\n            {\r\n                LuaName = MakeVar(parseObject.Name),\r\n                Map = \"    { wxluaclassname_\"..MakeVar(parseObject.Name)..\", \"\r\n                                ..MakeVar(parseObject.Name)..\"_methods, \"\r\n                                ..MakeVar(parseObject.Name)..\"_methodCount, \"\r\n                                ..classinfo..\", \"\r\n                                ..\"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"\r\n                                ..baseclassNames..\", \"\r\n                                ..baseclassBinds..\", \"\r\n                                ..enumArrayName..\", \"\r\n                                ..enumArrayCountName..\", \"\r\n                                ..\"}, \\n\",\r\n                BaseClasses = dataTypeTable[parseObject.Name].BaseClasses,\r\n                Condition = classcondition\r\n            }\r\n\r\n            table.insert(classBindingTable, classBinding)\r\n        end\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 1297,
    "text": "local overloadCount = {}",
    "type": "statement:localassign"
  }, {
    "id": 1298,
    "text": "for o = 1, #interface.objectData do\r\n        local parseObject = interface.objectData[o]\r\n\r\n        -- -------------------------------------------------------------------\r\n        -- de-duplicates include references, must generate them first, no .Members\r\n        if parseObject.ObjType == \"objtype_%include\" then\r\n\r\n            local includecondition = FixCondition(parseObject.Condition)\r\n            local includeBinding =\r\n            {\r\n                Include   = \"#include \".. parseObject.Name..\"\\n\",\r\n                Condition = includecondition\r\n            }\r\n\r\n            if not interface.includeBindingTable[includecondition] then\r\n                interface.includeBindingTable[includecondition] = {}\r\n            end\r\n\r\n            interface.includeBindingTable[includecondition][parseObject.Name] = includeBinding\r\n        elseif parseObject.ObjType == \"objtype_%includefile\" then\r\n            table.insert(interface.includeFiles, parseObject.Name)\r\n        end\r\n\r\n        -- -------------------------------------------------------------------\r\n        -- encapsulate non-wxObject objects with a tracked wxObject\r\n        if parseObject[\"%encapsulate\"] then\r\n\r\n            local encapcondition = FixCondition(parseObject.Condition)\r\n            local encapsulationBinding =\r\n            {\r\n                Declaration    = \"wxLUA_DECLARE_ENCAPSULATION(\"..output_cpp_impexpsymbol..\", \"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\",\r\n                Implementation = \"wxLUA_IMPLEMENT_ENCAPSULATION(\"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\",\r\n                Condition      = encapcondition\r\n            }\r\n\r\n            if IsDerivedClass(parseObject.Name, \"wxGridCellWorker\") or\r\n               IsDerivedClass(parseObject.Name, \"wxGridCellAttr\") then\r\n                encapsulationBinding.Implementation = \"wxLUA_IMPLEMENT_wxGridCellWorker_ENCAPSULATION(\"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\"\r\n            end\r\n\r\n            if not encapsulationBindingTable[encapcondition] then\r\n                encapsulationBindingTable[encapcondition] = {}\r\n            end\r\n\r\n            if parseObject[\"%encapsulate\"] then\r\n                encapsulationBindingTable[encapcondition][parseObject.Name] = encapsulationBinding\r\n            end\r\n        end\r\n\r\n        -- parseObject member binding\r\n        for m = 1, #parseObject.Members do\r\n            local member = parseObject.Members[m]\r\n\r\n            local fullcondition = FixCondition(AddCondition(member.Condition, member.ExtraCondition))\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- member binding\r\n            -- ---------------------------------------------------------------\r\n            if (member.DefType == \"deftype_%member\") or (member.DefType == \"deftype_%member_func\") then\r\n                local memberType    = member.DataType\r\n                local memberGetFunc = \"Get_\"..member.Name\r\n                local memberSetFunc = \"Set_\"..member.Name\r\n                if member[\"%rename\"] then\r\n                    memberGetFunc = \"Get\"..member[\"%rename\"]\r\n                    memberSetFunc = \"Set\"..member[\"%rename\"]\r\n                end\r\n\r\n                local funcType = \"WXLUAMETHOD_METHOD\"\r\n                local propType = \"\"\r\n                if member.IsStaticFunction then\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    propType = \"|WXLUAMETHOD_STATIC\"\r\n                end\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                local memberPtr = member.DataTypePointer[1]\r\n                local indirectionCount = #member.DataTypePointer\r\n                local numeric = IsDataTypeNumeric(member.DataType)\r\n\r\n                -- conditions for member are dependent on return type, argument types, and inline conditions\r\n                local dependConditions = {}\r\n\r\n                if HasCondition(fullcondition) then\r\n                    dependConditions[fullcondition] = fullcondition\r\n                end\r\n\r\n                local returnCondition = GetDataTypeCondition(member.DataType)\r\n                if returnCondition then\r\n                    dependConditions[returnCondition] = returnCondition\r\n                end\r\n\r\n                -- build member condition\r\n                local membercondition = nil\r\n                for idx, condition in pairs(dependConditions) do\r\n                    membercondition = AddCondition(membercondition, condition)\r\n                end\r\n                membercondition = FixCondition(membercondition)\r\n\r\n                -- GET MEMBER CODE\r\n                local codeList = {}\r\n                local overload_argList = \"\"\r\n                local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberGetFunc\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                local self_name = \"self->\"\r\n                if member.IsStaticFunction then\r\n                    self_name = parseObject.Name..\"::\"\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n                end\r\n\r\n                if memberType == \"wxString\" then\r\n                    CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                    table.insert(codeList, \"    wxlua_pushwxString(L, \"..self_name..member.Name..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\")) then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n\r\n--                    if string.find(member.Name, \"::\") then\r\n--                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    else\r\n                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, &\"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    end\r\n                elseif not numeric then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n\r\n                elseif IsDataTypeBool(memberType) then\r\n                    CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                    table.insert(codeList, \"    lua_pushboolean(L, \"..self_name..member.Name..\");\\n\")\r\n\r\n                else\r\n                    CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                    table.insert(codeList, \"    lua_pushnumber(L, \"..self_name..member.Name..\");\\n\")\r\n                end\r\n\r\n                CommentBindingTable(codeList, \"    // return the number of values\\n\")\r\n                table.insert(codeList, \"    return 1;\\n\")\r\n                table.insert(codeList, \"}\\n\")\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\"..funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                -- bind method\r\n                local methodBinding =\r\n                {\r\n                    LuaName       = memberGetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberGetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }\r\n\r\n                -- bind property\r\n                local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_GETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_GETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                -- rem out the Get function if not %member_func, but we need the code for the property\r\n                if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                table.insert(interface.objectData[o].BindTable, propertyBinding)\r\n\r\n                -- SET MEMBER CODE, not for const members\r\n                if not string.find(member.DataTypeWithAttrib, \"const \", 1, 1) then\r\n\r\n                codeList = {}\r\n                overload_argList = \"\"\r\n                local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberSetFunc\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                local stack_idx = iff(member.IsStaticFunction, \"1\", \"2\")\r\n\r\n                if memberType == \"wxString\" then\r\n                    overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                    CommentBindingTable(codeList, \"    // get the string value\\n\")\r\n                    table.insert(codeList, \"    wxString val = wxlua_getwxStringtype(L, \"..stack_idx..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif not numeric then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif IsDataTypeBool(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                    CommentBindingTable(codeList, \"    // get the boolean value\\n\")\r\n                    table.insert(codeList, \"    bool val = wxlua_getbooleantype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeEnum(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the enum value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getenumtype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeUInt(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the unsigned integer value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getuintegertype(L, \"..stack_idx..\");\\n\")\r\n                else\r\n                    overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                    CommentBindingTable(codeList, \"    // get the number value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getnumbertype(L, \"..stack_idx..\");\\n\")\r\n                end\r\n\r\n                if member.IsStaticFunction then\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                end\r\n\r\n                CommentBindingTable(codeList, \"    // return the number of values\\n\")\r\n                table.insert(codeList, \"    return 0;\\n\")\r\n                table.insert(codeList, \"}\\n\")\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                -- bind method\r\n                local methodBinding =\r\n                {\r\n                    LuaName       = memberSetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 2, 2, \"..overload_argListName..\" }\", -- FIXME make sure this is right\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberSetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }\r\n\r\n                -- bind property\r\n                local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_SETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_SETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                -- rem out the Set function if not %member_func, but we need the code for the property\r\n                if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                table.insert(interface.objectData[o].BindTable, propertyBinding)\r\n\r\n                end\r\n            -- ---------------------------------------------------------------\r\n            -- enum binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%enum\" then\r\n                -- if we have wxDateTime::TZ, only take the wxDateTime part\r\n                local dataType = member.DataType or \"\"\r\n                local namespace = \"\"\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local classname = \"\"\r\n                local enumname = luaname\r\n\r\n                local pos = string.find(dataType, \"::\", 1, 1)\r\n                if pos then\r\n                    -- search for last ::, eg. ns1::ns2::enumName -> ns1::ns2 is namespace\r\n                    classname = string.sub(dataType, 0, pos - 1)\r\n                    while pos do\r\n                        local p = string.find(dataType, \"::\", pos+2, 1)\r\n                        if p then pos = p else break end\r\n                    end\r\n\r\n                    namespace = string.sub(dataType, 0, pos - 1)\r\n                    if not member[\"%rename\"] then\r\n                        luaname = MakeVar(namespace)..\"_\"..luaname -- wxFile::read -> wxFile_read\r\n                    end\r\n\r\n                    namespace = namespace..\"::\"\r\n                end\r\n\r\n                if (string.len(classname) > 0) then\r\n                    if not enumClassBindingTable[classname] then\r\n                        enumClassBindingTable[classname] = {}\r\n                    end\r\n\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = enumname,\r\n                        Map       = \"        { \\\"\"..enumname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumClassBindingTable[classname], enumBinding)\r\n                else\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = luaname,\r\n                        Map       = \"        { \\\"\"..luaname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumBindingTable, enumBinding)\r\n                end\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local value = member.Value or member.Name\r\n\r\n                local defineBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(defineBindingTable, defineBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_string binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_string\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local value = member.Value or member.Name\r\n\r\n                local stringBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(stringBindingTable, stringBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_object binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_object\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local objectBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", &\"..member.Name..\", NULL },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(objectBindingTable, objectBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_pointer binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_pointer\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local pointerBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL, (const void **) &\"..member.Name..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(pointerBindingTable, pointerBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_event binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_event\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local eventBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &\"..member.Name..\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(eventBindingTable, eventBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- method binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_method\" then\r\n                local argList = \"\"\r\n                local overload_argList = \"\"\r\n                local gcList = {}\r\n\r\n                local arg = 0\r\n\r\n                if (member[\"%operator\"] == \"++\") and (#member.Params > 0) then\r\n                    member.Name = \"op_preinc\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"--\") and (#member.Params > 0) then\r\n                    member.Name = \"op_predec\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"*\") and (#member.Params == 0) then\r\n                    member.Name = \"op_deref\"\r\n                    member.Params = {}\r\n                end\r\n\r\n                while member.Params[arg+1] do\r\n                    arg = arg + 1\r\n                    local param = member.Params[arg]\r\n\r\n                    -- See if we're supposed to track or untrack the parameter\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%gc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+4)\r\n                        param.GC = true\r\n                    end\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%ungc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+6)\r\n                        param.UnGC = true\r\n                    end\r\n\r\n                    local declare = nil\r\n                    local argType = param.DataType\r\n                    local argTypeWithAttrib = param.DataTypeWithAttrib\r\n                    local argPtr = param.DataTypePointer[1]\r\n                    local argName = param.Name\r\n                    local argNum = nil\r\n                    local opt = param.DefaultValue\r\n                    local numeric = IsDataTypeNumeric(param.DataType)\r\n\r\n                    if member.IsConstructor or member[\"%function\"] or member.IsStaticFunction then\r\n                        argNum = arg -- don't have self\r\n                    else\r\n                        argNum = arg + 1\r\n                    end\r\n\r\n                    if not argName then\r\n                        argName = \"arg\"..arg\r\n\r\n                        param.Name = argName\r\n                    end\r\n\r\n                    if arg > 1 then\r\n                        argList = argList..\", \"\r\n                    end\r\n\r\n                    local indirectionCount = #param.DataTypePointer\r\n\r\n                    local isTranslated = nil\r\n                    local origArgType =  argType\r\n                    local origArgTypeWithAttrib = argTypeWithAttrib\r\n                    local origArgPtr = argPtr\r\n                    local origIndirectionCount = indirectionCount\r\n                    local argCast = nil\r\n                    local argListOverride = nil\r\n\r\n                    -- Does DataType need to be translated from typeDef\r\n                    TranslateDataType(param)\r\n                    if #param.TypedDataTypePointer ~= indirectionCount then\r\n                        indirectionCount = #param.TypedDataTypePointer\r\n\r\n                        -- translated datatype\r\n                        argType = param.TypedDataType\r\n                        argTypeWithAttrib = param.TypedDataTypeWithAttrib\r\n                        argPtr = param.TypedDataTypePointer[1]\r\n\r\n                        isTranslated = true\r\n                    end\r\n\r\n\r\n                    -- the function takes (void*), but we just pass a long\r\n                    if argType == \"voidptr_long\" then\r\n                        argType = \"long\"\r\n                        argTypeWithAttrib = \"long\"\r\n                        argCast = \"void*\"\r\n                    end\r\n\r\n                    -- our special notation to get wxString/IntArray from a Lua table of strings\r\n                    -- BUT! it has to be const wxArrayString& arr or wxArrayString arr\r\n                    --      and NOT wxArrayString& arr or wxArrayString* arr\r\n                    if ((argType == \"wxArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayString, \"\r\n                        argItem = \"wxlua_getwxArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayString\"\r\n                    elseif ((argType == \"wxSortedArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxSortedArrayString, \"\r\n                        argItem = \"wxlua_getwxSortedArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxSortedArrayString\"\r\n                    elseif ((argType == \"wxArrayInt\") and\r\n                            ((indirectionCount == 0) or\r\n                             ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayInt, \"\r\n                        argItem = \"wxlua_getwxArrayInt(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayInt\"\r\n                    elseif argType == \"IntArray_FromLuaTable\" then\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"NULL; ptr = \"..argName..\" = wxlua_getintarray(L, \"..argNum..\", count_)\"\r\n                        declare = \"int count_ = 0; wxLuaSmartIntArray ptr; int*\"\r\n                        argList = argList..\"count_, \"\r\n                    elseif argType == \"LuaTable\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif argType == \"LuaFunction\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TFUNCTION, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif (indirectionCount == 1) and (argPtr == \"[]\") then\r\n                        argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n\r\n                        if argType == \"wxString\" then\r\n                            -- overload_argList = overload_argList..\"&s_wxluaarg_StringArray, \" FIXME!\r\n                            -- Un 'const' strings\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getwxStringarray(\"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartStringArray \"\r\n                        elseif argType == \"int\" then\r\n                            -- Un 'const' ints\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getintarray(L, \"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartIntArray \"\r\n                        elseif not numeric then\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"*\") then\r\n                        if (argType == \"wxString\") or (argType == \"wxChar\") then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxT(\"..opt..\")\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n\r\n                            if (argType == \"wxChar\") then\r\n                                argTypeWithAttrib = \"wxString \"\r\n                                argListOverride = argName..\".IsEmpty() ? NULL : \"..argName..\".c_str()\"\r\n                            end\r\n\r\n                        elseif argType == \"char\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getstringtype(L, \"..argNum..\")\"\r\n\r\n                            argTypeWithAttrib = \"wxCharBuffer\"\r\n                            argCast = \"const char*\" -- allows for \"unsigned char*\"\r\n                        else\r\n                            if isTranslated and (origIndirectionCount == 0) then\r\n                                argTypeWithAttrib = origArgTypeWithAttrib\r\n                                argCast = origArgTypeWithAttrib\r\n                            else\r\n                                argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            end\r\n\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            if param.GC then\r\n                                if dataTypeTable[argType][\"%encapsulate\"] then\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")\r\n                                else\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")\r\n                                end\r\n                            elseif param.UnGC then\r\n                                table.insert(gcList, \"    if (wxluaO_isgcobject(L, \"..argName..\")) wxluaO_undeletegcobject(L, \"..argName..\");\\n\")\r\n                            end\r\n\r\n                        end\r\n                    elseif (indirectionCount == 2) and (argPtr == \"*\") then\r\n                        if not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" **\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"&\") then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        else\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            -- Default Value\r\n                            if opt then opt = \"&\"..opt end\r\n\r\n                            argList = argList..\"*\"\r\n                        end\r\n                    elseif indirectionCount == 0 then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        elseif IsDataTypeBool(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                            argItem = \"wxlua_getbooleantype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeEnum(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getenumtype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeUInt(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getuintegertype(L, \"..argNum..\")\"\r\n                        elseif not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argItem = \"*(\"..argTypeWithAttrib..\"*)wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getnumbertype(L, \"..argNum..\")\"\r\n                        end\r\n                    else\r\n                        local point = \"\"\r\n                        for z = 1, #param.TypedDataTypePointer do\r\n                            point = point..param.TypedDataTypePointer[z]\r\n                        end\r\n                        print(\"ERROR: Unsupported pointer indirection '\"..point..\"' \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    if argCast then\r\n                        argList = argList..\"(\"..argCast..\")\"\r\n                    end\r\n\r\n                    argList = argList..(argListOverride or argName)\r\n\r\n                    -- except for string arrays, the declare is the argType\r\n                    if not declare then\r\n                        declare = argTypeWithAttrib\r\n                    end\r\n\r\n                    if not param.Name then\r\n                        print(\"ERROR: No Param Name: \"..member.LineText..\" \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- interface.objectData[o].Members[m].Params[p]\r\n                    codeList = {}\r\n\r\n                    if opt then\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\" = \"..param.DefaultValue..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = (argCount >= \"..argNum..\" ? \"..argItem..\" : \"..opt..\");\\n\")\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = \"..argItem..\";\\n\")\r\n                    end\r\n\r\n                    local paramBinding =\r\n                    {\r\n                        ParamName = argName,\r\n                        ParamType = argType,\r\n                        ParamCast = argCast,\r\n                        ParamCode = codeList,\r\n                    }\r\n\r\n                    -- set param binding\r\n                    interface.objectData[o].Members[m].Params[arg].Binding = paramBinding\r\n                end\r\n\r\n                -- //////////////////////////////////////////////////////////////////////////////////\r\n                -- method binding\r\n                codeList = {}\r\n\r\n                local numeric = IsDataTypeNumeric(member.DataType)\r\n\r\n                -- function name\r\n                local funcType = nil\r\n                local funcName = nil\r\n                local funcNameBase = nil\r\n                local funcLuaCall = nil\r\n                if member.IsConstructor or (member.Name == parseObject.Name) then\r\n                    member.IsConstructor = true\r\n                    funcName = \"wxLua_\"..MakeVar(member[\"%rename\"] or member.Name)..\"_constructor\"\r\n                    funcNameBase = funcName\r\n\r\n                    funcType = \"WXLUAMETHOD_CONSTRUCTOR\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif member.Name == \"~\"..parseObject.Name then\r\n                    print(\"WARNING: Unhandled ~ destructor \", member.Name, parseObject.Name);\r\n                elseif member.IsStaticFunction then\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif (parseObject.Name == \"globals\") or member[\"%function\"] then\r\n                    funcName = \"wxLua_function_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_CFUNCTION\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                else\r\n                    if not parseObject.Name then\r\n                        print(\"ERROR: parseObject.Name = nil \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- special case for unary -, convert from op_sub to op_neg if necessary\r\n                    if member[\"%operator\"] and (#member.Params == 0) and (member.Name == \"op_sub\") then\r\n                        member.Name = \"op_neg\"\r\n                        if member[\"%rename\"] == \"op_sub\" then -- maybe they renamed it?\r\n                            member[\"%rename\"] = \"op_neg\"\r\n                        end\r\n                    end\r\n\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n\r\n                    funcType = \"WXLUAMETHOD_METHOD\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                end\r\n\r\n                if not funcNameBase then funcNameBase = funcName end\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                -- if they declared this, the conditions must be exclusive\r\n                -- since the functions will have the same names\r\n                if (member.NotOverload ~= true) then\r\n                    if overloadCount[funcName] then\r\n                        overloadCount[funcName] = overloadCount[funcName] + 1\r\n                        funcName = funcName..tostring(overloadCount[funcName]-1)\r\n                    else\r\n                        overloadCount[funcName] = 1\r\n                    end\r\n                end\r\n\r\n                -- function\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                -- See if we're supposed to track or untrack the return value\r\n                local a = string.find(member.DataTypeWithAttrib, \"%gc\", 1, 1)\r\n                if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+4)\r\n                    member.GC = true\r\n                end\r\n                local a = string.find(member.DataTypeWithAttrib, \"%ungc\", 1, 1)\r\n                if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+6)\r\n                    member.UnGC = true\r\n                end\r\n\r\n                -- determine function return type\r\n                local memberType = member.DataType\r\n                local memberTypeWithAttrib = member.DataTypeWithAttrib\r\n                local memberPtr = member.DataTypePointer[1]\r\n\r\n                local indirectionCount = #member.DataTypePointer\r\n\r\n                local isTranslated = nil\r\n                local origMemberType =  memberType\r\n                local origMemberTypeWithAttrib = memberTypeWithAttrib\r\n                local origMemberPtr = memberPtr\r\n                local origIndirectionCount = indirectionCount\r\n                local memberCast = nil\r\n\r\n                -- Does DataType need to be translated from typeDef\r\n                TranslateDataType(member)\r\n                if #member.TypedDataTypePointer ~= indirectionCount then\r\n                    indirectionCount = #member.TypedDataTypePointer\r\n\r\n                    -- translated datatype\r\n                    memberType = member.TypedDataType\r\n                    memberTypeWithAttrib = member.TypedDataTypeWithAttrib\r\n                    memberPtr = member.TypedDataTypePointer[1]\r\n\r\n                    isTranslated = true\r\n                end\r\n\r\n                local returnPtr = \"*\";\r\n\r\n                if (memberType ~= \"void\") or (indirectionCount > 0) then\r\n                    if numeric and ((indirectionCount == 0) or (memberPtr == \"&\"))  then\r\n                        returnPtr = \"\"\r\n                    end\r\n\r\n                    if isTranslated and (indirectionCount == 1) and (origIndirectionCount == 0) then\r\n                        memberTypeWithAttrib = origMemberTypeWithAttrib..\" \"\r\n                        memberCast = origMemberTypeWithAttrib\r\n                    else\r\n                        memberTypeWithAttrib = memberTypeWithAttrib..returnPtr\r\n                    end\r\n\r\n                    -- Un 'const' strings and non-pointer datatypes\r\n                    if (string.sub(memberTypeWithAttrib, 1, 6) == \"const \") and ((memberType == \"wxString\") or (returnPtr == \"\") or member.IsConstructor) then\r\n                        memberTypeWithAttrib = string.sub(memberTypeWithAttrib, 7)\r\n                    end\r\n\r\n                    if string.find(\"voidptr_long\", memberTypeWithAttrib, 1, 1) then\r\n                        memberTypeWithAttrib = \"long \"\r\n                    end\r\n                end\r\n\r\n                -- conditions for method are dependent on return type, argument types, and inline conditions\r\n                local dependConditions = {}\r\n\r\n                if HasCondition(fullcondition) then\r\n                    dependConditions[fullcondition] = fullcondition\r\n                end\r\n\r\n                local returnCondition = GetDataTypeCondition(memberType)\r\n                if returnCondition then\r\n                    dependConditions[returnCondition] = returnCondition\r\n                end\r\n\r\n                -- get args\r\n                local requiredParamCount = 0\r\n                local paramCount = #member.Params\r\n                if  paramCount > 0 then\r\n                    for arg=1, paramCount do\r\n                        if not member.Params[arg].DefaultValue then\r\n                            requiredParamCount = requiredParamCount + 1\r\n                        elseif member.Params[arg+1] and (not member.Params[arg+1].DefaultValue) then\r\n                            print(\"ERROR: Missing default arg #\"..tostring(arg+1)..\" in function. \"..LineTableErrString(member))\r\n                        end\r\n                    end\r\n\r\n                    if requiredParamCount ~= paramCount then\r\n                        CommentBindingTable(codeList, \"    // get number of arguments\\n\")\r\n                        table.insert(codeList, \"    int argCount = lua_gettop(L);\\n\")\r\n                    end\r\n\r\n                    for arg = 1, paramCount do\r\n                        -- add function code to get args (in reverse order)\r\n                        local paramLineCount = #(member.Params[paramCount + 1 - arg].Binding.ParamCode)\r\n                        for paramLine=1, paramLineCount do\r\n                            table.insert(codeList, member.Params[paramCount + 1 - arg].Binding.ParamCode[paramLine])\r\n                        end\r\n\r\n                        -- param conditions\r\n                        local paramCondition = GetDataTypeCondition(member.Params[arg].DataType)\r\n                        if paramCondition then\r\n                            dependConditions[paramCondition] = paramCondition\r\n                        end\r\n                    end\r\n                end\r\n\r\n                for i = 1, #gcList do\r\n                    table.insert(codeList, gcList[i])\r\n                end\r\n\r\n                -- constructor?\r\n                if member.IsConstructor then\r\n                    CommentBindingTable(codeList, \"    // call constructor\\n\")\r\n                    table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..parseObject.Name..\"(\"..argList..\");\\n\")\r\n\r\n                    if parseObject[\"%gc_this\"] or (parseObject[\"%delete\"] and (not parseObject[\"%ungc_this\"])) then\r\n                        CommentBindingTable(codeList, \"    // add to tracked memory list\\n\")\r\n\r\n                        -- Un 'const' AddTrackedObject\r\n                        local returnCast = memberTypeWithAttrib\r\n                        if string.sub(returnCast, 1, 6) == \"const \" then\r\n                            returnCast = string.sub(returnCast, 7)\r\n                        end\r\n\r\n                        if parseObject[\"%encapsulate\"] then\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(parseObject.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                        else\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, returns);\\n\")\r\n                        end\r\n                    elseif not parseObject[\"%noclassinfo\"] then\r\n                        CommentBindingTable(codeList, \"    // add to tracked window list, it will check validity\\n\")\r\n                        table.insert(codeList, \"    wxluaW_addtrackedwindow(L, returns);\\n\")\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // push the constructed class pointer\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n\r\n                    table.insert(codeList, \"\\n    return 1;\\n\")\r\n                    table.insert(codeList, \"}\\n\")\r\n                else\r\n                    -- how we call c-function\r\n                    if parseObject.Name == \"globals\" then\r\n                        functor = member.Name   -- global\r\n                    elseif member.IsStaticFunction then\r\n                        functor = parseObject.Name..\"::\"..member.Name -- static member function\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // get this\\n\")\r\n\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\" * self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                        overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                        if parseObject[\"%ungc_this\"] then\r\n                            table.insert(codeList, \"    wxluaO_undeletegcobject(L, self);\\n\")\r\n                        elseif parseObject[\"%gc_this\"] then\r\n                            if parseObject[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    if (!wxluaO_isgcobject(L, self)) wxluaO_addgcobject(L, (void*)self, new wxLua_wxObject_\"..MakeClassVar(parseObject.Name)..\"(self));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, self);\\n\")\r\n                            end\r\n                        end\r\n\r\n                        requiredParamCount = requiredParamCount + 1\r\n                        paramCount = paramCount + 1\r\n\r\n                        if member[\"%operator\"] then\r\n                            if (member.Name == \"op_preinc\") or (member.Name == \"op_predec\") then\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            elseif (member.Name == \"op_inc\") or (member.Name == \"op_dec\") then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            elseif member[\"%operator\"] == \"[]\" then     -- op_index\r\n                                functor = \"(*self)[\"\r\n                            elseif member[\"%operator\"] == \"()\" then -- op_func\r\n                                functor = \"(*self)\"\r\n                            elseif paramCount > 1 then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            else\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            end\r\n                        -- static member function?\r\n                        elseif string.find(member.Name, \"::\") then\r\n                            functor = member.Name\r\n                        else\r\n                            functor = \"self->\"..member.Name\r\n                        end\r\n                    end\r\n\r\n                    -- need cast?\r\n                    if memberCast then\r\n                        functor  = \"(\"..memberCast..\")\"..functor\r\n                    end\r\n\r\n                    local is_func = iff(not member[\"%operator\"] and member.IsFunction, true, false)\r\n\r\n                    -- Add Function Argument List\r\n                    if (argList ~= \"\") or is_func then\r\n                        functor = functor..\"(\"..argList..\")\"\r\n                    end\r\n\r\n                    if member[\"%operator\"] == \"[]\" then -- op_index\r\n                        functor = functor..\"]\"\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // call \"..member.Name..\"\\n\")\r\n\r\n                    if not memberType or (memberTypeWithAttrib == \"void\") then\r\n                        -- call (void) function\r\n                        table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                        table.insert(codeList, \"\\n    return 0;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    else\r\n                        -- call function, get return value\r\n                        if member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and string.find(member[\"%operator\"], \"=\", 1, 1) then\r\n                            table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = self;\\n\")\r\n                        elseif member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and (string.find(member[\"%operator\"], \"=\", 1, 1) == nil) then\r\n                            if string.find(memberTypeWithAttrib or \"\", \"*\", 1, 1) then\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &(\"..functor..\");\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = \"..functor..\";\\n\")\r\n                            end\r\n                        elseif (not numeric) and (not memberPtr) then\r\n                            CommentBindingTable(codeList, \"    // allocate a new object using the copy constructor\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..memberType..\"(\"..functor..\");\\n\")\r\n                            CommentBindingTable(codeList, \"    // add the new object to the tracked memory list\\n\")\r\n\r\n                            -- Un 'const' AddTrackedObject\r\n                            local returnCast = memberTypeWithAttrib\r\n                            if string.sub(returnCast, 1, 6) == \"const \" then\r\n                                returnCast = string.sub(returnCast, 7)\r\n                            end\r\n\r\n                            local member_DataType = GetDataTypedefBase(memberType)\r\n\r\n                            if member_DataType[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(member_DataType.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (\"..returnCast..\")returns);\\n\")\r\n                            end\r\n\r\n                        elseif (not member[\"%operator\"]) and (memberPtr == \"&\") and string.find(memberTypeWithAttrib, \"*\") and (memberType ~= \"wxString\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &\"..functor..\";\\n\")\r\n                        elseif (memberPtr == \"*\") or (memberType == \"voidptr_long\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..memberTypeWithAttrib..\")\"..functor..\";\\n\")\r\n\r\n                            if member.GC then\r\n                                if dataTypeTable[memberType][\"%encapsulate\"] then\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")\r\n                                else\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")\r\n                                end\r\n                            elseif member.UnGC then\r\n                                table.insert(codeList, \"    if (wxluaO_isgcobject(L, returns)) wxluaO_undeletegcobject(L, returns);\\n\")\r\n                            end\r\n\r\n                        else\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..functor..\");\\n\")\r\n                        end\r\n\r\n                        -- bind return value\r\n                        if memberType == \"wxString\" then\r\n                            CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                            table.insert(codeList, \"    wxlua_pushwxString(L, \"..returnPtr..\"returns);\\n\")\r\n                        elseif not numeric then\r\n                            CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                            table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                        elseif IsDataTypeBool(member.DataType) then\r\n                            CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                            table.insert(codeList, \"    lua_pushboolean(L, returns);\\n\")\r\n                        elseif returnPtr == \"*\" then\r\n                            CommentBindingTable(codeList, \"    // push the result pointer\\n\")\r\n                            table.insert(codeList, \"    lua_pushlightuserdata(L, (void *)returns);\\n\")\r\n                        else -- Number\r\n                            CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                            table.insert(codeList, \"    lua_pushnumber(L, returns);\\n\")\r\n                        end\r\n\r\n                        table.insert(codeList, \"\\n    return 1;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    end\r\n                end\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                -- add function map only once for the base function name overload\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n                local funcMap   = \"{ \"..funcName..\", \"..funcType..\", \"..tostring(requiredParamCount)..\", \"..tostring(paramCount)..\", \"..overload_argListName..\" }\"\r\n                local methodMap = \"    { \\\"\"..funcLuaCall..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\"\r\n\r\n                -- build method condition\r\n                local methodcondition = nil\r\n                for idx, condition in pairs(dependConditions) do\r\n                    methodcondition = AddCondition(methodcondition, condition)\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                methodcondition = FixCondition(methodcondition)\r\n\r\n                -- bind method\r\n                methodBinding =\r\n                {\r\n                    ClassName          = parseObject.Name,\r\n                    FuncType           = funcType,\r\n                    LuaName            = funcLuaCall,\r\n                    CFunctionName      = funcName,\r\n                    CFunctionNameBase  = funcNameBase,\r\n                    Method             = codeList,\r\n                    ArgArray           = overload_argList,\r\n                    ArgArrayName       = overload_argListName,\r\n                    ParamCount         = paramCount,\r\n                    RequiredParamCount = requiredParamCount,\r\n                    FuncMap            = funcMap,\r\n                    FuncMapName        = funcMapName,\r\n                    Map                = methodMap,\r\n                    NotOverload        = member.NotOverload,\r\n                    Condition          = methodcondition,\r\n                    PreDefineCode      = nil, -- set later if necessary\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if (member.override_name and overrideTable[member.override_name]) then\r\n                    methodBinding.Method = overrideTable[member.override_name]\r\n                    methodBinding.PreDefineCode = \"#define \"..funcName..\" \"..member.override_name..\"\\n\"\r\n                    overrideTableUsed[member.override_name] = true\r\n                elseif ((member.override_name == nil) and overrideTable[methodBinding.CFunctionName]) then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                if member[\"%function\"] then\r\n                    table.insert(functionBindingTable, methodBinding)\r\n                elseif not (member.IsConstructor and parseObject[\"%abstract\"]) then\r\n                    table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                end\r\n            end\r\n        end\r\n\r\n        if (parseObject.ObjType == \"objtype_%class\") or (parseObject.ObjType == \"objtype_%struct\") then\r\n            -- Class Includes\r\n            for condition, includeBindingList in pairs(interface.includeBindingTable) do\r\n                if not classIncludeBindingTable[condition] then classIncludeBindingTable[condition] = {} end\r\n\r\n                for idx, includeBinding in pairs(includeBindingList) do\r\n                    classIncludeBindingTable[condition][idx] = includeBinding\r\n                end\r\n            end\r\n\r\n            -- Figure out if we really need to have member enums for the class\r\n                local enumArrayName = \"g_wxluanumberArray_None\"\r\n                local enumArrayCountName = 0\r\n                local ExternEnumDeclaration = \"\"\r\n                local ExternEnumCountDeclaration = \"\"\r\n\r\n            if enumClassBindingTable[MakeVar(parseObject.Name)] ~= nil then\r\n                enumArrayName = MakeVar(parseObject.Name)..\"_enums\"\r\n                enumArrayCountName = MakeVar(parseObject.Name)..\"_enumCount\"\r\n                --ExternEnumDeclaration = \"extern \"..output_cpp_impexpsymbol..\" wxLuaBindNumber \"..enumArrayName..\"[];\\n\"\r\n                --ExternEnumCountDeclaration = \"extern \"..MakeImpExpData(\"int\")..\" \"..enumArrayCountName..\";\\n\"\r\n                ExternEnumDeclaration = \"extern wxLuaBindNumber \"..enumArrayName..\"[];\\n\"\r\n                ExternEnumCountDeclaration = \"extern int \"..enumArrayCountName..\";\\n\"\r\n            end\r\n\r\n\r\n            -- Extern Class Tag Declaration\r\n            local tagcondition = FixCondition(parseObject.Condition)\r\n            local classTypeBinding =\r\n            {\r\n                ExternDeclaration            = \"extern \"..MakeImpExpData(\"int\")..\" wxluatype_\"..MakeClassVar(parseObject.Name)..\";\\n\",\r\n                --ExternMethodDeclaration      = \"extern \"..output_cpp_impexpsymbol..\" wxLuaBindMethod \"..MakeVar(parseObject.Name)..\"_methods[];\\n\",\r\n                --ExternMethodCountDeclaration = \"extern \"..MakeImpExpData(\"int\")..\" \"..MakeVar(parseObject.Name)..\"_methodCount;\\n\",\r\n                ExternMethodDeclaration      = \"extern wxLuaBindMethod \"..MakeVar(parseObject.Name)..\"_methods[];\\n\",\r\n                ExternMethodCountDeclaration = \"extern int \"..MakeVar(parseObject.Name)..\"_methodCount;\\n\",\r\n                ExternEnumDeclaration        = ExternEnumDeclaration,\r\n                ExternEnumCountDeclaration   = ExternEnumCountDeclaration,\r\n                Condition                    = tagcondition\r\n            }\r\n\r\n            if not classTypeBindingTable[tagcondition] then classTypeBindingTable[tagcondition] = {} end\r\n            classTypeBindingTable[tagcondition][parseObject.Name] = classTypeBinding\r\n\r\n            -- Class Tag Declaration\r\n            local decl = \"\";\r\n            if comment_cpp_binding_code then\r\n                decl = decl..\"// Lua MetaTable Tag for Class '\"..parseObject.Name..\"'\\n\"\r\n            end\r\n            decl = decl..\"int wxluatype_\"..MakeClassVar(parseObject.Name)..\" = WXLUA_TUNKNOWN;\\n\"\r\n\r\n            interface.objectData[o].TagDeclaration = decl\r\n\r\n            -- Class Binding\r\n            local baseclassNames = \"NULL\"\r\n            local baseclassBinds = \"NULL\"\r\n            if dataTypeTable[parseObject.Name].BaseClasses then\r\n                baseclassNames = \"wxluabaseclassnames_\"..MakeVar(parseObject.Name)\r\n                baseclassBinds = \"wxluabaseclassbinds_\"..MakeVar(parseObject.Name)\r\n            end\r\n\r\n            local classinfo = \"NULL\"\r\n            if not parseObject[\"%noclassinfo\"] then\r\n                classinfo = \"CLASSINFO(\"..parseObject.Name..\")\"\r\n            end\r\n\r\n            -- Class Functions\r\n            if parseObject[\"%delete\"] then\r\n                -- delete routine\r\n                codeList = {}\r\n                local funcName  = \"wxLua_\"..MakeVar(parseObject.Name)..\"_delete\"\r\n                local funcName_ = funcName\r\n\r\n                if not overrideTable[funcName] then\r\n                    funcName_ = \"wxlua_userdata_delete\"\r\n                end\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                local overload_argList = \"{ &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL }\"\r\n\r\n                local condition = FixCondition(parseObject.Condition)\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcType = \"WXLUAMETHOD_METHOD\"\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                local delMethodBinding =\r\n                {\r\n                    LuaName         = \"delete\",\r\n                    CFunctionName   = funcName_,\r\n                    Method          = codeList,\r\n                    FuncType        = funcType,\r\n                    FuncMap         = \"{ \"..funcName_..\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName     = funcMapName,\r\n                    ArgArray        = overload_argList,\r\n                    ArgArrayName    = overload_argListName,\r\n                    ParamCount      = 1,\r\n                    RequiredParamCount = 1,\r\n                    Map             = \"    { \\\"delete\\\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition       = condition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[funcName] then\r\n                    delMethodBinding.Method = overrideTable[funcName]\r\n                    overrideTableUsed[funcName] = true\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, delMethodBinding)\r\n            end\r\n\r\n            local classcondition = FixCondition(parseObject.Condition)\r\n            local classBinding =\r\n            {\r\n                LuaName = MakeVar(parseObject.Name),\r\n                Map = \"    { wxluaclassname_\"..MakeVar(parseObject.Name)..\", \"\r\n                                ..MakeVar(parseObject.Name)..\"_methods, \"\r\n                                ..MakeVar(parseObject.Name)..\"_methodCount, \"\r\n                                ..classinfo..\", \"\r\n                                ..\"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"\r\n                                ..baseclassNames..\", \"\r\n                                ..baseclassBinds..\", \"\r\n                                ..enumArrayName..\", \"\r\n                                ..enumArrayCountName..\", \"\r\n                                ..\"}, \\n\",\r\n                BaseClasses = dataTypeTable[parseObject.Name].BaseClasses,\r\n                Condition = classcondition\r\n            }\r\n\r\n            table.insert(classBindingTable, classBinding)\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 1299,
    "text": "local parseObject = interface.objectData[o]",
    "type": "statement:localassign"
  }, {
    "id": 1300,
    "text": "if parseObject.ObjType == \"objtype_%include\" then\r\n\r\n            local includecondition = FixCondition(parseObject.Condition)\r\n            local includeBinding =\r\n            {\r\n                Include   = \"#include \".. parseObject.Name..\"\\n\",\r\n                Condition = includecondition\r\n            }\r\n\r\n            if not interface.includeBindingTable[includecondition] then\r\n                interface.includeBindingTable[includecondition] = {}\r\n            end\r\n\r\n            interface.includeBindingTable[includecondition][parseObject.Name] = includeBinding\r\n        elseif parseObject.ObjType == \"objtype_%includefile\" then\r\n            table.insert(interface.includeFiles, parseObject.Name)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1301,
    "text": "local includecondition = FixCondition(parseObject.Condition)",
    "type": "statement:localassign"
  }, {
    "id": 1302,
    "text": "local includeBinding =\r\n            {\r\n                Include   = \"#include \".. parseObject.Name..\"\\n\",\r\n                Condition = includecondition\r\n            }",
    "type": "statement:localassign"
  }, {
    "id": 1303,
    "text": "if not interface.includeBindingTable[includecondition] then\r\n                interface.includeBindingTable[includecondition] = {}\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1304,
    "text": "interface.includeBindingTable[includecondition] = {}",
    "type": "statement:assign"
  }, {
    "id": 1305,
    "text": "interface.includeBindingTable[includecondition][parseObject.Name] = includeBinding",
    "type": "statement:assign"
  }, {
    "id": 1306,
    "text": "table.insert(interface.includeFiles, parseObject.Name)",
    "type": "statement:functioncall"
  }, {
    "id": 1307,
    "text": "if parseObject[\"%encapsulate\"] then\r\n\r\n            local encapcondition = FixCondition(parseObject.Condition)\r\n            local encapsulationBinding =\r\n            {\r\n                Declaration    = \"wxLUA_DECLARE_ENCAPSULATION(\"..output_cpp_impexpsymbol..\", \"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\",\r\n                Implementation = \"wxLUA_IMPLEMENT_ENCAPSULATION(\"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\",\r\n                Condition      = encapcondition\r\n            }\r\n\r\n            if IsDerivedClass(parseObject.Name, \"wxGridCellWorker\") or\r\n               IsDerivedClass(parseObject.Name, \"wxGridCellAttr\") then\r\n                encapsulationBinding.Implementation = \"wxLUA_IMPLEMENT_wxGridCellWorker_ENCAPSULATION(\"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\"\r\n            end\r\n\r\n            if not encapsulationBindingTable[encapcondition] then\r\n                encapsulationBindingTable[encapcondition] = {}\r\n            end\r\n\r\n            if parseObject[\"%encapsulate\"] then\r\n                encapsulationBindingTable[encapcondition][parseObject.Name] = encapsulationBinding\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1308,
    "text": "local encapcondition = FixCondition(parseObject.Condition)",
    "type": "statement:localassign"
  }, {
    "id": 1309,
    "text": "local encapsulationBinding =\r\n            {\r\n                Declaration    = \"wxLUA_DECLARE_ENCAPSULATION(\"..output_cpp_impexpsymbol..\", \"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\",\r\n                Implementation = \"wxLUA_IMPLEMENT_ENCAPSULATION(\"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\",\r\n                Condition      = encapcondition\r\n            }",
    "type": "statement:localassign"
  }, {
    "id": 1310,
    "text": "if IsDerivedClass(parseObject.Name, \"wxGridCellWorker\") or\r\n               IsDerivedClass(parseObject.Name, \"wxGridCellAttr\") then\r\n                encapsulationBinding.Implementation = \"wxLUA_IMPLEMENT_wxGridCellWorker_ENCAPSULATION(\"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\"\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1311,
    "text": "encapsulationBinding.Implementation = \"wxLUA_IMPLEMENT_wxGridCellWorker_ENCAPSULATION(\"..parseObject.Name..\", \"..MakeVar(parseObject.Name)..\")\\n\"",
    "type": "statement:assign"
  }, {
    "id": 1312,
    "text": "if not encapsulationBindingTable[encapcondition] then\r\n                encapsulationBindingTable[encapcondition] = {}\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1313,
    "text": "encapsulationBindingTable[encapcondition] = {}",
    "type": "statement:assign"
  }, {
    "id": 1314,
    "text": "if parseObject[\"%encapsulate\"] then\r\n                encapsulationBindingTable[encapcondition][parseObject.Name] = encapsulationBinding\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1315,
    "text": "encapsulationBindingTable[encapcondition][parseObject.Name] = encapsulationBinding",
    "type": "statement:assign"
  }, {
    "id": 1316,
    "text": "for m = 1, #parseObject.Members do\r\n            local member = parseObject.Members[m]\r\n\r\n            local fullcondition = FixCondition(AddCondition(member.Condition, member.ExtraCondition))\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- member binding\r\n            -- ---------------------------------------------------------------\r\n            if (member.DefType == \"deftype_%member\") or (member.DefType == \"deftype_%member_func\") then\r\n                local memberType    = member.DataType\r\n                local memberGetFunc = \"Get_\"..member.Name\r\n                local memberSetFunc = \"Set_\"..member.Name\r\n                if member[\"%rename\"] then\r\n                    memberGetFunc = \"Get\"..member[\"%rename\"]\r\n                    memberSetFunc = \"Set\"..member[\"%rename\"]\r\n                end\r\n\r\n                local funcType = \"WXLUAMETHOD_METHOD\"\r\n                local propType = \"\"\r\n                if member.IsStaticFunction then\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    propType = \"|WXLUAMETHOD_STATIC\"\r\n                end\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                local memberPtr = member.DataTypePointer[1]\r\n                local indirectionCount = #member.DataTypePointer\r\n                local numeric = IsDataTypeNumeric(member.DataType)\r\n\r\n                -- conditions for member are dependent on return type, argument types, and inline conditions\r\n                local dependConditions = {}\r\n\r\n                if HasCondition(fullcondition) then\r\n                    dependConditions[fullcondition] = fullcondition\r\n                end\r\n\r\n                local returnCondition = GetDataTypeCondition(member.DataType)\r\n                if returnCondition then\r\n                    dependConditions[returnCondition] = returnCondition\r\n                end\r\n\r\n                -- build member condition\r\n                local membercondition = nil\r\n                for idx, condition in pairs(dependConditions) do\r\n                    membercondition = AddCondition(membercondition, condition)\r\n                end\r\n                membercondition = FixCondition(membercondition)\r\n\r\n                -- GET MEMBER CODE\r\n                local codeList = {}\r\n                local overload_argList = \"\"\r\n                local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberGetFunc\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                local self_name = \"self->\"\r\n                if member.IsStaticFunction then\r\n                    self_name = parseObject.Name..\"::\"\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n                end\r\n\r\n                if memberType == \"wxString\" then\r\n                    CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                    table.insert(codeList, \"    wxlua_pushwxString(L, \"..self_name..member.Name..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\")) then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n\r\n--                    if string.find(member.Name, \"::\") then\r\n--                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    else\r\n                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, &\"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    end\r\n                elseif not numeric then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n\r\n                elseif IsDataTypeBool(memberType) then\r\n                    CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                    table.insert(codeList, \"    lua_pushboolean(L, \"..self_name..member.Name..\");\\n\")\r\n\r\n                else\r\n                    CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                    table.insert(codeList, \"    lua_pushnumber(L, \"..self_name..member.Name..\");\\n\")\r\n                end\r\n\r\n                CommentBindingTable(codeList, \"    // return the number of values\\n\")\r\n                table.insert(codeList, \"    return 1;\\n\")\r\n                table.insert(codeList, \"}\\n\")\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\"..funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                -- bind method\r\n                local methodBinding =\r\n                {\r\n                    LuaName       = memberGetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberGetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }\r\n\r\n                -- bind property\r\n                local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_GETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_GETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                -- rem out the Get function if not %member_func, but we need the code for the property\r\n                if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                table.insert(interface.objectData[o].BindTable, propertyBinding)\r\n\r\n                -- SET MEMBER CODE, not for const members\r\n                if not string.find(member.DataTypeWithAttrib, \"const \", 1, 1) then\r\n\r\n                codeList = {}\r\n                overload_argList = \"\"\r\n                local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberSetFunc\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                local stack_idx = iff(member.IsStaticFunction, \"1\", \"2\")\r\n\r\n                if memberType == \"wxString\" then\r\n                    overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                    CommentBindingTable(codeList, \"    // get the string value\\n\")\r\n                    table.insert(codeList, \"    wxString val = wxlua_getwxStringtype(L, \"..stack_idx..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif not numeric then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif IsDataTypeBool(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                    CommentBindingTable(codeList, \"    // get the boolean value\\n\")\r\n                    table.insert(codeList, \"    bool val = wxlua_getbooleantype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeEnum(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the enum value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getenumtype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeUInt(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the unsigned integer value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getuintegertype(L, \"..stack_idx..\");\\n\")\r\n                else\r\n                    overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                    CommentBindingTable(codeList, \"    // get the number value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getnumbertype(L, \"..stack_idx..\");\\n\")\r\n                end\r\n\r\n                if member.IsStaticFunction then\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                end\r\n\r\n                CommentBindingTable(codeList, \"    // return the number of values\\n\")\r\n                table.insert(codeList, \"    return 0;\\n\")\r\n                table.insert(codeList, \"}\\n\")\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                -- bind method\r\n                local methodBinding =\r\n                {\r\n                    LuaName       = memberSetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 2, 2, \"..overload_argListName..\" }\", -- FIXME make sure this is right\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberSetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }\r\n\r\n                -- bind property\r\n                local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_SETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_SETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                -- rem out the Set function if not %member_func, but we need the code for the property\r\n                if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                table.insert(interface.objectData[o].BindTable, propertyBinding)\r\n\r\n                end\r\n            -- ---------------------------------------------------------------\r\n            -- enum binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%enum\" then\r\n                -- if we have wxDateTime::TZ, only take the wxDateTime part\r\n                local dataType = member.DataType or \"\"\r\n                local namespace = \"\"\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local classname = \"\"\r\n                local enumname = luaname\r\n\r\n                local pos = string.find(dataType, \"::\", 1, 1)\r\n                if pos then\r\n                    -- search for last ::, eg. ns1::ns2::enumName -> ns1::ns2 is namespace\r\n                    classname = string.sub(dataType, 0, pos - 1)\r\n                    while pos do\r\n                        local p = string.find(dataType, \"::\", pos+2, 1)\r\n                        if p then pos = p else break end\r\n                    end\r\n\r\n                    namespace = string.sub(dataType, 0, pos - 1)\r\n                    if not member[\"%rename\"] then\r\n                        luaname = MakeVar(namespace)..\"_\"..luaname -- wxFile::read -> wxFile_read\r\n                    end\r\n\r\n                    namespace = namespace..\"::\"\r\n                end\r\n\r\n                if (string.len(classname) > 0) then\r\n                    if not enumClassBindingTable[classname] then\r\n                        enumClassBindingTable[classname] = {}\r\n                    end\r\n\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = enumname,\r\n                        Map       = \"        { \\\"\"..enumname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumClassBindingTable[classname], enumBinding)\r\n                else\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = luaname,\r\n                        Map       = \"        { \\\"\"..luaname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumBindingTable, enumBinding)\r\n                end\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local value = member.Value or member.Name\r\n\r\n                local defineBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(defineBindingTable, defineBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_string binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_string\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local value = member.Value or member.Name\r\n\r\n                local stringBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(stringBindingTable, stringBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_object binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_object\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local objectBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", &\"..member.Name..\", NULL },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(objectBindingTable, objectBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_pointer binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_pointer\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local pointerBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL, (const void **) &\"..member.Name..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(pointerBindingTable, pointerBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_event binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_event\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local eventBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &\"..member.Name..\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(eventBindingTable, eventBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- method binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_method\" then\r\n                local argList = \"\"\r\n                local overload_argList = \"\"\r\n                local gcList = {}\r\n\r\n                local arg = 0\r\n\r\n                if (member[\"%operator\"] == \"++\") and (#member.Params > 0) then\r\n                    member.Name = \"op_preinc\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"--\") and (#member.Params > 0) then\r\n                    member.Name = \"op_predec\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"*\") and (#member.Params == 0) then\r\n                    member.Name = \"op_deref\"\r\n                    member.Params = {}\r\n                end\r\n\r\n                while member.Params[arg+1] do\r\n                    arg = arg + 1\r\n                    local param = member.Params[arg]\r\n\r\n                    -- See if we're supposed to track or untrack the parameter\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%gc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+4)\r\n                        param.GC = true\r\n                    end\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%ungc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+6)\r\n                        param.UnGC = true\r\n                    end\r\n\r\n                    local declare = nil\r\n                    local argType = param.DataType\r\n                    local argTypeWithAttrib = param.DataTypeWithAttrib\r\n                    local argPtr = param.DataTypePointer[1]\r\n                    local argName = param.Name\r\n                    local argNum = nil\r\n                    local opt = param.DefaultValue\r\n                    local numeric = IsDataTypeNumeric(param.DataType)\r\n\r\n                    if member.IsConstructor or member[\"%function\"] or member.IsStaticFunction then\r\n                        argNum = arg -- don't have self\r\n                    else\r\n                        argNum = arg + 1\r\n                    end\r\n\r\n                    if not argName then\r\n                        argName = \"arg\"..arg\r\n\r\n                        param.Name = argName\r\n                    end\r\n\r\n                    if arg > 1 then\r\n                        argList = argList..\", \"\r\n                    end\r\n\r\n                    local indirectionCount = #param.DataTypePointer\r\n\r\n                    local isTranslated = nil\r\n                    local origArgType =  argType\r\n                    local origArgTypeWithAttrib = argTypeWithAttrib\r\n                    local origArgPtr = argPtr\r\n                    local origIndirectionCount = indirectionCount\r\n                    local argCast = nil\r\n                    local argListOverride = nil\r\n\r\n                    -- Does DataType need to be translated from typeDef\r\n                    TranslateDataType(param)\r\n                    if #param.TypedDataTypePointer ~= indirectionCount then\r\n                        indirectionCount = #param.TypedDataTypePointer\r\n\r\n                        -- translated datatype\r\n                        argType = param.TypedDataType\r\n                        argTypeWithAttrib = param.TypedDataTypeWithAttrib\r\n                        argPtr = param.TypedDataTypePointer[1]\r\n\r\n                        isTranslated = true\r\n                    end\r\n\r\n\r\n                    -- the function takes (void*), but we just pass a long\r\n                    if argType == \"voidptr_long\" then\r\n                        argType = \"long\"\r\n                        argTypeWithAttrib = \"long\"\r\n                        argCast = \"void*\"\r\n                    end\r\n\r\n                    -- our special notation to get wxString/IntArray from a Lua table of strings\r\n                    -- BUT! it has to be const wxArrayString& arr or wxArrayString arr\r\n                    --      and NOT wxArrayString& arr or wxArrayString* arr\r\n                    if ((argType == \"wxArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayString, \"\r\n                        argItem = \"wxlua_getwxArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayString\"\r\n                    elseif ((argType == \"wxSortedArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxSortedArrayString, \"\r\n                        argItem = \"wxlua_getwxSortedArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxSortedArrayString\"\r\n                    elseif ((argType == \"wxArrayInt\") and\r\n                            ((indirectionCount == 0) or\r\n                             ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayInt, \"\r\n                        argItem = \"wxlua_getwxArrayInt(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayInt\"\r\n                    elseif argType == \"IntArray_FromLuaTable\" then\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"NULL; ptr = \"..argName..\" = wxlua_getintarray(L, \"..argNum..\", count_)\"\r\n                        declare = \"int count_ = 0; wxLuaSmartIntArray ptr; int*\"\r\n                        argList = argList..\"count_, \"\r\n                    elseif argType == \"LuaTable\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif argType == \"LuaFunction\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TFUNCTION, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif (indirectionCount == 1) and (argPtr == \"[]\") then\r\n                        argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n\r\n                        if argType == \"wxString\" then\r\n                            -- overload_argList = overload_argList..\"&s_wxluaarg_StringArray, \" FIXME!\r\n                            -- Un 'const' strings\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getwxStringarray(\"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartStringArray \"\r\n                        elseif argType == \"int\" then\r\n                            -- Un 'const' ints\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getintarray(L, \"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartIntArray \"\r\n                        elseif not numeric then\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"*\") then\r\n                        if (argType == \"wxString\") or (argType == \"wxChar\") then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxT(\"..opt..\")\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n\r\n                            if (argType == \"wxChar\") then\r\n                                argTypeWithAttrib = \"wxString \"\r\n                                argListOverride = argName..\".IsEmpty() ? NULL : \"..argName..\".c_str()\"\r\n                            end\r\n\r\n                        elseif argType == \"char\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getstringtype(L, \"..argNum..\")\"\r\n\r\n                            argTypeWithAttrib = \"wxCharBuffer\"\r\n                            argCast = \"const char*\" -- allows for \"unsigned char*\"\r\n                        else\r\n                            if isTranslated and (origIndirectionCount == 0) then\r\n                                argTypeWithAttrib = origArgTypeWithAttrib\r\n                                argCast = origArgTypeWithAttrib\r\n                            else\r\n                                argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            end\r\n\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            if param.GC then\r\n                                if dataTypeTable[argType][\"%encapsulate\"] then\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")\r\n                                else\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")\r\n                                end\r\n                            elseif param.UnGC then\r\n                                table.insert(gcList, \"    if (wxluaO_isgcobject(L, \"..argName..\")) wxluaO_undeletegcobject(L, \"..argName..\");\\n\")\r\n                            end\r\n\r\n                        end\r\n                    elseif (indirectionCount == 2) and (argPtr == \"*\") then\r\n                        if not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" **\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"&\") then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        else\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            -- Default Value\r\n                            if opt then opt = \"&\"..opt end\r\n\r\n                            argList = argList..\"*\"\r\n                        end\r\n                    elseif indirectionCount == 0 then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        elseif IsDataTypeBool(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                            argItem = \"wxlua_getbooleantype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeEnum(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getenumtype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeUInt(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getuintegertype(L, \"..argNum..\")\"\r\n                        elseif not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argItem = \"*(\"..argTypeWithAttrib..\"*)wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getnumbertype(L, \"..argNum..\")\"\r\n                        end\r\n                    else\r\n                        local point = \"\"\r\n                        for z = 1, #param.TypedDataTypePointer do\r\n                            point = point..param.TypedDataTypePointer[z]\r\n                        end\r\n                        print(\"ERROR: Unsupported pointer indirection '\"..point..\"' \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    if argCast then\r\n                        argList = argList..\"(\"..argCast..\")\"\r\n                    end\r\n\r\n                    argList = argList..(argListOverride or argName)\r\n\r\n                    -- except for string arrays, the declare is the argType\r\n                    if not declare then\r\n                        declare = argTypeWithAttrib\r\n                    end\r\n\r\n                    if not param.Name then\r\n                        print(\"ERROR: No Param Name: \"..member.LineText..\" \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- interface.objectData[o].Members[m].Params[p]\r\n                    codeList = {}\r\n\r\n                    if opt then\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\" = \"..param.DefaultValue..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = (argCount >= \"..argNum..\" ? \"..argItem..\" : \"..opt..\");\\n\")\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = \"..argItem..\";\\n\")\r\n                    end\r\n\r\n                    local paramBinding =\r\n                    {\r\n                        ParamName = argName,\r\n                        ParamType = argType,\r\n                        ParamCast = argCast,\r\n                        ParamCode = codeList,\r\n                    }\r\n\r\n                    -- set param binding\r\n                    interface.objectData[o].Members[m].Params[arg].Binding = paramBinding\r\n                end\r\n\r\n                -- //////////////////////////////////////////////////////////////////////////////////\r\n                -- method binding\r\n                codeList = {}\r\n\r\n                local numeric = IsDataTypeNumeric(member.DataType)\r\n\r\n                -- function name\r\n                local funcType = nil\r\n                local funcName = nil\r\n                local funcNameBase = nil\r\n                local funcLuaCall = nil\r\n                if member.IsConstructor or (member.Name == parseObject.Name) then\r\n                    member.IsConstructor = true\r\n                    funcName = \"wxLua_\"..MakeVar(member[\"%rename\"] or member.Name)..\"_constructor\"\r\n                    funcNameBase = funcName\r\n\r\n                    funcType = \"WXLUAMETHOD_CONSTRUCTOR\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif member.Name == \"~\"..parseObject.Name then\r\n                    print(\"WARNING: Unhandled ~ destructor \", member.Name, parseObject.Name);\r\n                elseif member.IsStaticFunction then\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif (parseObject.Name == \"globals\") or member[\"%function\"] then\r\n                    funcName = \"wxLua_function_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_CFUNCTION\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                else\r\n                    if not parseObject.Name then\r\n                        print(\"ERROR: parseObject.Name = nil \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- special case for unary -, convert from op_sub to op_neg if necessary\r\n                    if member[\"%operator\"] and (#member.Params == 0) and (member.Name == \"op_sub\") then\r\n                        member.Name = \"op_neg\"\r\n                        if member[\"%rename\"] == \"op_sub\" then -- maybe they renamed it?\r\n                            member[\"%rename\"] = \"op_neg\"\r\n                        end\r\n                    end\r\n\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n\r\n                    funcType = \"WXLUAMETHOD_METHOD\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                end\r\n\r\n                if not funcNameBase then funcNameBase = funcName end\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                -- if they declared this, the conditions must be exclusive\r\n                -- since the functions will have the same names\r\n                if (member.NotOverload ~= true) then\r\n                    if overloadCount[funcName] then\r\n                        overloadCount[funcName] = overloadCount[funcName] + 1\r\n                        funcName = funcName..tostring(overloadCount[funcName]-1)\r\n                    else\r\n                        overloadCount[funcName] = 1\r\n                    end\r\n                end\r\n\r\n                -- function\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                -- See if we're supposed to track or untrack the return value\r\n                local a = string.find(member.DataTypeWithAttrib, \"%gc\", 1, 1)\r\n                if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+4)\r\n                    member.GC = true\r\n                end\r\n                local a = string.find(member.DataTypeWithAttrib, \"%ungc\", 1, 1)\r\n                if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+6)\r\n                    member.UnGC = true\r\n                end\r\n\r\n                -- determine function return type\r\n                local memberType = member.DataType\r\n                local memberTypeWithAttrib = member.DataTypeWithAttrib\r\n                local memberPtr = member.DataTypePointer[1]\r\n\r\n                local indirectionCount = #member.DataTypePointer\r\n\r\n                local isTranslated = nil\r\n                local origMemberType =  memberType\r\n                local origMemberTypeWithAttrib = memberTypeWithAttrib\r\n                local origMemberPtr = memberPtr\r\n                local origIndirectionCount = indirectionCount\r\n                local memberCast = nil\r\n\r\n                -- Does DataType need to be translated from typeDef\r\n                TranslateDataType(member)\r\n                if #member.TypedDataTypePointer ~= indirectionCount then\r\n                    indirectionCount = #member.TypedDataTypePointer\r\n\r\n                    -- translated datatype\r\n                    memberType = member.TypedDataType\r\n                    memberTypeWithAttrib = member.TypedDataTypeWithAttrib\r\n                    memberPtr = member.TypedDataTypePointer[1]\r\n\r\n                    isTranslated = true\r\n                end\r\n\r\n                local returnPtr = \"*\";\r\n\r\n                if (memberType ~= \"void\") or (indirectionCount > 0) then\r\n                    if numeric and ((indirectionCount == 0) or (memberPtr == \"&\"))  then\r\n                        returnPtr = \"\"\r\n                    end\r\n\r\n                    if isTranslated and (indirectionCount == 1) and (origIndirectionCount == 0) then\r\n                        memberTypeWithAttrib = origMemberTypeWithAttrib..\" \"\r\n                        memberCast = origMemberTypeWithAttrib\r\n                    else\r\n                        memberTypeWithAttrib = memberTypeWithAttrib..returnPtr\r\n                    end\r\n\r\n                    -- Un 'const' strings and non-pointer datatypes\r\n                    if (string.sub(memberTypeWithAttrib, 1, 6) == \"const \") and ((memberType == \"wxString\") or (returnPtr == \"\") or member.IsConstructor) then\r\n                        memberTypeWithAttrib = string.sub(memberTypeWithAttrib, 7)\r\n                    end\r\n\r\n                    if string.find(\"voidptr_long\", memberTypeWithAttrib, 1, 1) then\r\n                        memberTypeWithAttrib = \"long \"\r\n                    end\r\n                end\r\n\r\n                -- conditions for method are dependent on return type, argument types, and inline conditions\r\n                local dependConditions = {}\r\n\r\n                if HasCondition(fullcondition) then\r\n                    dependConditions[fullcondition] = fullcondition\r\n                end\r\n\r\n                local returnCondition = GetDataTypeCondition(memberType)\r\n                if returnCondition then\r\n                    dependConditions[returnCondition] = returnCondition\r\n                end\r\n\r\n                -- get args\r\n                local requiredParamCount = 0\r\n                local paramCount = #member.Params\r\n                if  paramCount > 0 then\r\n                    for arg=1, paramCount do\r\n                        if not member.Params[arg].DefaultValue then\r\n                            requiredParamCount = requiredParamCount + 1\r\n                        elseif member.Params[arg+1] and (not member.Params[arg+1].DefaultValue) then\r\n                            print(\"ERROR: Missing default arg #\"..tostring(arg+1)..\" in function. \"..LineTableErrString(member))\r\n                        end\r\n                    end\r\n\r\n                    if requiredParamCount ~= paramCount then\r\n                        CommentBindingTable(codeList, \"    // get number of arguments\\n\")\r\n                        table.insert(codeList, \"    int argCount = lua_gettop(L);\\n\")\r\n                    end\r\n\r\n                    for arg = 1, paramCount do\r\n                        -- add function code to get args (in reverse order)\r\n                        local paramLineCount = #(member.Params[paramCount + 1 - arg].Binding.ParamCode)\r\n                        for paramLine=1, paramLineCount do\r\n                            table.insert(codeList, member.Params[paramCount + 1 - arg].Binding.ParamCode[paramLine])\r\n                        end\r\n\r\n                        -- param conditions\r\n                        local paramCondition = GetDataTypeCondition(member.Params[arg].DataType)\r\n                        if paramCondition then\r\n                            dependConditions[paramCondition] = paramCondition\r\n                        end\r\n                    end\r\n                end\r\n\r\n                for i = 1, #gcList do\r\n                    table.insert(codeList, gcList[i])\r\n                end\r\n\r\n                -- constructor?\r\n                if member.IsConstructor then\r\n                    CommentBindingTable(codeList, \"    // call constructor\\n\")\r\n                    table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..parseObject.Name..\"(\"..argList..\");\\n\")\r\n\r\n                    if parseObject[\"%gc_this\"] or (parseObject[\"%delete\"] and (not parseObject[\"%ungc_this\"])) then\r\n                        CommentBindingTable(codeList, \"    // add to tracked memory list\\n\")\r\n\r\n                        -- Un 'const' AddTrackedObject\r\n                        local returnCast = memberTypeWithAttrib\r\n                        if string.sub(returnCast, 1, 6) == \"const \" then\r\n                            returnCast = string.sub(returnCast, 7)\r\n                        end\r\n\r\n                        if parseObject[\"%encapsulate\"] then\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(parseObject.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                        else\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, returns);\\n\")\r\n                        end\r\n                    elseif not parseObject[\"%noclassinfo\"] then\r\n                        CommentBindingTable(codeList, \"    // add to tracked window list, it will check validity\\n\")\r\n                        table.insert(codeList, \"    wxluaW_addtrackedwindow(L, returns);\\n\")\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // push the constructed class pointer\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n\r\n                    table.insert(codeList, \"\\n    return 1;\\n\")\r\n                    table.insert(codeList, \"}\\n\")\r\n                else\r\n                    -- how we call c-function\r\n                    if parseObject.Name == \"globals\" then\r\n                        functor = member.Name   -- global\r\n                    elseif member.IsStaticFunction then\r\n                        functor = parseObject.Name..\"::\"..member.Name -- static member function\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // get this\\n\")\r\n\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\" * self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                        overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                        if parseObject[\"%ungc_this\"] then\r\n                            table.insert(codeList, \"    wxluaO_undeletegcobject(L, self);\\n\")\r\n                        elseif parseObject[\"%gc_this\"] then\r\n                            if parseObject[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    if (!wxluaO_isgcobject(L, self)) wxluaO_addgcobject(L, (void*)self, new wxLua_wxObject_\"..MakeClassVar(parseObject.Name)..\"(self));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, self);\\n\")\r\n                            end\r\n                        end\r\n\r\n                        requiredParamCount = requiredParamCount + 1\r\n                        paramCount = paramCount + 1\r\n\r\n                        if member[\"%operator\"] then\r\n                            if (member.Name == \"op_preinc\") or (member.Name == \"op_predec\") then\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            elseif (member.Name == \"op_inc\") or (member.Name == \"op_dec\") then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            elseif member[\"%operator\"] == \"[]\" then     -- op_index\r\n                                functor = \"(*self)[\"\r\n                            elseif member[\"%operator\"] == \"()\" then -- op_func\r\n                                functor = \"(*self)\"\r\n                            elseif paramCount > 1 then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            else\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            end\r\n                        -- static member function?\r\n                        elseif string.find(member.Name, \"::\") then\r\n                            functor = member.Name\r\n                        else\r\n                            functor = \"self->\"..member.Name\r\n                        end\r\n                    end\r\n\r\n                    -- need cast?\r\n                    if memberCast then\r\n                        functor  = \"(\"..memberCast..\")\"..functor\r\n                    end\r\n\r\n                    local is_func = iff(not member[\"%operator\"] and member.IsFunction, true, false)\r\n\r\n                    -- Add Function Argument List\r\n                    if (argList ~= \"\") or is_func then\r\n                        functor = functor..\"(\"..argList..\")\"\r\n                    end\r\n\r\n                    if member[\"%operator\"] == \"[]\" then -- op_index\r\n                        functor = functor..\"]\"\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // call \"..member.Name..\"\\n\")\r\n\r\n                    if not memberType or (memberTypeWithAttrib == \"void\") then\r\n                        -- call (void) function\r\n                        table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                        table.insert(codeList, \"\\n    return 0;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    else\r\n                        -- call function, get return value\r\n                        if member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and string.find(member[\"%operator\"], \"=\", 1, 1) then\r\n                            table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = self;\\n\")\r\n                        elseif member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and (string.find(member[\"%operator\"], \"=\", 1, 1) == nil) then\r\n                            if string.find(memberTypeWithAttrib or \"\", \"*\", 1, 1) then\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &(\"..functor..\");\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = \"..functor..\";\\n\")\r\n                            end\r\n                        elseif (not numeric) and (not memberPtr) then\r\n                            CommentBindingTable(codeList, \"    // allocate a new object using the copy constructor\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..memberType..\"(\"..functor..\");\\n\")\r\n                            CommentBindingTable(codeList, \"    // add the new object to the tracked memory list\\n\")\r\n\r\n                            -- Un 'const' AddTrackedObject\r\n                            local returnCast = memberTypeWithAttrib\r\n                            if string.sub(returnCast, 1, 6) == \"const \" then\r\n                                returnCast = string.sub(returnCast, 7)\r\n                            end\r\n\r\n                            local member_DataType = GetDataTypedefBase(memberType)\r\n\r\n                            if member_DataType[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(member_DataType.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (\"..returnCast..\")returns);\\n\")\r\n                            end\r\n\r\n                        elseif (not member[\"%operator\"]) and (memberPtr == \"&\") and string.find(memberTypeWithAttrib, \"*\") and (memberType ~= \"wxString\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &\"..functor..\";\\n\")\r\n                        elseif (memberPtr == \"*\") or (memberType == \"voidptr_long\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..memberTypeWithAttrib..\")\"..functor..\";\\n\")\r\n\r\n                            if member.GC then\r\n                                if dataTypeTable[memberType][\"%encapsulate\"] then\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")\r\n                                else\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")\r\n                                end\r\n                            elseif member.UnGC then\r\n                                table.insert(codeList, \"    if (wxluaO_isgcobject(L, returns)) wxluaO_undeletegcobject(L, returns);\\n\")\r\n                            end\r\n\r\n                        else\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..functor..\");\\n\")\r\n                        end\r\n\r\n                        -- bind return value\r\n                        if memberType == \"wxString\" then\r\n                            CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                            table.insert(codeList, \"    wxlua_pushwxString(L, \"..returnPtr..\"returns);\\n\")\r\n                        elseif not numeric then\r\n                            CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                            table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                        elseif IsDataTypeBool(member.DataType) then\r\n                            CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                            table.insert(codeList, \"    lua_pushboolean(L, returns);\\n\")\r\n                        elseif returnPtr == \"*\" then\r\n                            CommentBindingTable(codeList, \"    // push the result pointer\\n\")\r\n                            table.insert(codeList, \"    lua_pushlightuserdata(L, (void *)returns);\\n\")\r\n                        else -- Number\r\n                            CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                            table.insert(codeList, \"    lua_pushnumber(L, returns);\\n\")\r\n                        end\r\n\r\n                        table.insert(codeList, \"\\n    return 1;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    end\r\n                end\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                -- add function map only once for the base function name overload\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n                local funcMap   = \"{ \"..funcName..\", \"..funcType..\", \"..tostring(requiredParamCount)..\", \"..tostring(paramCount)..\", \"..overload_argListName..\" }\"\r\n                local methodMap = \"    { \\\"\"..funcLuaCall..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\"\r\n\r\n                -- build method condition\r\n                local methodcondition = nil\r\n                for idx, condition in pairs(dependConditions) do\r\n                    methodcondition = AddCondition(methodcondition, condition)\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                methodcondition = FixCondition(methodcondition)\r\n\r\n                -- bind method\r\n                methodBinding =\r\n                {\r\n                    ClassName          = parseObject.Name,\r\n                    FuncType           = funcType,\r\n                    LuaName            = funcLuaCall,\r\n                    CFunctionName      = funcName,\r\n                    CFunctionNameBase  = funcNameBase,\r\n                    Method             = codeList,\r\n                    ArgArray           = overload_argList,\r\n                    ArgArrayName       = overload_argListName,\r\n                    ParamCount         = paramCount,\r\n                    RequiredParamCount = requiredParamCount,\r\n                    FuncMap            = funcMap,\r\n                    FuncMapName        = funcMapName,\r\n                    Map                = methodMap,\r\n                    NotOverload        = member.NotOverload,\r\n                    Condition          = methodcondition,\r\n                    PreDefineCode      = nil, -- set later if necessary\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if (member.override_name and overrideTable[member.override_name]) then\r\n                    methodBinding.Method = overrideTable[member.override_name]\r\n                    methodBinding.PreDefineCode = \"#define \"..funcName..\" \"..member.override_name..\"\\n\"\r\n                    overrideTableUsed[member.override_name] = true\r\n                elseif ((member.override_name == nil) and overrideTable[methodBinding.CFunctionName]) then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                if member[\"%function\"] then\r\n                    table.insert(functionBindingTable, methodBinding)\r\n                elseif not (member.IsConstructor and parseObject[\"%abstract\"]) then\r\n                    table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                end\r\n            end\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 1317,
    "text": "local member = parseObject.Members[m]",
    "type": "statement:localassign"
  }, {
    "id": 1318,
    "text": "local fullcondition = FixCondition(AddCondition(member.Condition, member.ExtraCondition))",
    "type": "statement:localassign"
  }, {
    "id": 1319,
    "text": "if (member.DefType == \"deftype_%member\") or (member.DefType == \"deftype_%member_func\") then\r\n                local memberType    = member.DataType\r\n                local memberGetFunc = \"Get_\"..member.Name\r\n                local memberSetFunc = \"Set_\"..member.Name\r\n                if member[\"%rename\"] then\r\n                    memberGetFunc = \"Get\"..member[\"%rename\"]\r\n                    memberSetFunc = \"Set\"..member[\"%rename\"]\r\n                end\r\n\r\n                local funcType = \"WXLUAMETHOD_METHOD\"\r\n                local propType = \"\"\r\n                if member.IsStaticFunction then\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    propType = \"|WXLUAMETHOD_STATIC\"\r\n                end\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                local memberPtr = member.DataTypePointer[1]\r\n                local indirectionCount = #member.DataTypePointer\r\n                local numeric = IsDataTypeNumeric(member.DataType)\r\n\r\n                -- conditions for member are dependent on return type, argument types, and inline conditions\r\n                local dependConditions = {}\r\n\r\n                if HasCondition(fullcondition) then\r\n                    dependConditions[fullcondition] = fullcondition\r\n                end\r\n\r\n                local returnCondition = GetDataTypeCondition(member.DataType)\r\n                if returnCondition then\r\n                    dependConditions[returnCondition] = returnCondition\r\n                end\r\n\r\n                -- build member condition\r\n                local membercondition = nil\r\n                for idx, condition in pairs(dependConditions) do\r\n                    membercondition = AddCondition(membercondition, condition)\r\n                end\r\n                membercondition = FixCondition(membercondition)\r\n\r\n                -- GET MEMBER CODE\r\n                local codeList = {}\r\n                local overload_argList = \"\"\r\n                local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberGetFunc\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                local self_name = \"self->\"\r\n                if member.IsStaticFunction then\r\n                    self_name = parseObject.Name..\"::\"\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n                end\r\n\r\n                if memberType == \"wxString\" then\r\n                    CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                    table.insert(codeList, \"    wxlua_pushwxString(L, \"..self_name..member.Name..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\")) then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n\r\n--                    if string.find(member.Name, \"::\") then\r\n--                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    else\r\n                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, &\"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    end\r\n                elseif not numeric then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n\r\n                elseif IsDataTypeBool(memberType) then\r\n                    CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                    table.insert(codeList, \"    lua_pushboolean(L, \"..self_name..member.Name..\");\\n\")\r\n\r\n                else\r\n                    CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                    table.insert(codeList, \"    lua_pushnumber(L, \"..self_name..member.Name..\");\\n\")\r\n                end\r\n\r\n                CommentBindingTable(codeList, \"    // return the number of values\\n\")\r\n                table.insert(codeList, \"    return 1;\\n\")\r\n                table.insert(codeList, \"}\\n\")\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\"..funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                -- bind method\r\n                local methodBinding =\r\n                {\r\n                    LuaName       = memberGetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberGetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }\r\n\r\n                -- bind property\r\n                local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_GETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_GETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                -- rem out the Get function if not %member_func, but we need the code for the property\r\n                if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                table.insert(interface.objectData[o].BindTable, propertyBinding)\r\n\r\n                -- SET MEMBER CODE, not for const members\r\n                if not string.find(member.DataTypeWithAttrib, \"const \", 1, 1) then\r\n\r\n                codeList = {}\r\n                overload_argList = \"\"\r\n                local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberSetFunc\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                local stack_idx = iff(member.IsStaticFunction, \"1\", \"2\")\r\n\r\n                if memberType == \"wxString\" then\r\n                    overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                    CommentBindingTable(codeList, \"    // get the string value\\n\")\r\n                    table.insert(codeList, \"    wxString val = wxlua_getwxStringtype(L, \"..stack_idx..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif not numeric then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif IsDataTypeBool(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                    CommentBindingTable(codeList, \"    // get the boolean value\\n\")\r\n                    table.insert(codeList, \"    bool val = wxlua_getbooleantype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeEnum(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the enum value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getenumtype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeUInt(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the unsigned integer value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getuintegertype(L, \"..stack_idx..\");\\n\")\r\n                else\r\n                    overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                    CommentBindingTable(codeList, \"    // get the number value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getnumbertype(L, \"..stack_idx..\");\\n\")\r\n                end\r\n\r\n                if member.IsStaticFunction then\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                end\r\n\r\n                CommentBindingTable(codeList, \"    // return the number of values\\n\")\r\n                table.insert(codeList, \"    return 0;\\n\")\r\n                table.insert(codeList, \"}\\n\")\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                -- bind method\r\n                local methodBinding =\r\n                {\r\n                    LuaName       = memberSetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 2, 2, \"..overload_argListName..\" }\", -- FIXME make sure this is right\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberSetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }\r\n\r\n                -- bind property\r\n                local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_SETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_SETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                -- rem out the Set function if not %member_func, but we need the code for the property\r\n                if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                table.insert(interface.objectData[o].BindTable, propertyBinding)\r\n\r\n                end\r\n            -- ---------------------------------------------------------------\r\n            -- enum binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%enum\" then\r\n                -- if we have wxDateTime::TZ, only take the wxDateTime part\r\n                local dataType = member.DataType or \"\"\r\n                local namespace = \"\"\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local classname = \"\"\r\n                local enumname = luaname\r\n\r\n                local pos = string.find(dataType, \"::\", 1, 1)\r\n                if pos then\r\n                    -- search for last ::, eg. ns1::ns2::enumName -> ns1::ns2 is namespace\r\n                    classname = string.sub(dataType, 0, pos - 1)\r\n                    while pos do\r\n                        local p = string.find(dataType, \"::\", pos+2, 1)\r\n                        if p then pos = p else break end\r\n                    end\r\n\r\n                    namespace = string.sub(dataType, 0, pos - 1)\r\n                    if not member[\"%rename\"] then\r\n                        luaname = MakeVar(namespace)..\"_\"..luaname -- wxFile::read -> wxFile_read\r\n                    end\r\n\r\n                    namespace = namespace..\"::\"\r\n                end\r\n\r\n                if (string.len(classname) > 0) then\r\n                    if not enumClassBindingTable[classname] then\r\n                        enumClassBindingTable[classname] = {}\r\n                    end\r\n\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = enumname,\r\n                        Map       = \"        { \\\"\"..enumname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumClassBindingTable[classname], enumBinding)\r\n                else\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = luaname,\r\n                        Map       = \"        { \\\"\"..luaname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumBindingTable, enumBinding)\r\n                end\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local value = member.Value or member.Name\r\n\r\n                local defineBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(defineBindingTable, defineBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_string binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_string\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n                local value = member.Value or member.Name\r\n\r\n                local stringBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(stringBindingTable, stringBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_object binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_object\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local objectBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", &\"..member.Name..\", NULL },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(objectBindingTable, objectBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_pointer binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_pointer\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local pointerBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL, (const void **) &\"..member.Name..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(pointerBindingTable, pointerBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- define_event binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_%define_event\" then\r\n                local luaname = member[\"%rename\"] or member.Name -- for %rename\r\n\r\n                local eventBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &\"..member.Name..\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }\r\n\r\n                table.insert(eventBindingTable, eventBinding)\r\n\r\n            -- ---------------------------------------------------------------\r\n            -- method binding\r\n            -- ---------------------------------------------------------------\r\n            elseif member.DefType == \"deftype_method\" then\r\n                local argList = \"\"\r\n                local overload_argList = \"\"\r\n                local gcList = {}\r\n\r\n                local arg = 0\r\n\r\n                if (member[\"%operator\"] == \"++\") and (#member.Params > 0) then\r\n                    member.Name = \"op_preinc\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"--\") and (#member.Params > 0) then\r\n                    member.Name = \"op_predec\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"*\") and (#member.Params == 0) then\r\n                    member.Name = \"op_deref\"\r\n                    member.Params = {}\r\n                end\r\n\r\n                while member.Params[arg+1] do\r\n                    arg = arg + 1\r\n                    local param = member.Params[arg]\r\n\r\n                    -- See if we're supposed to track or untrack the parameter\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%gc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+4)\r\n                        param.GC = true\r\n                    end\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%ungc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+6)\r\n                        param.UnGC = true\r\n                    end\r\n\r\n                    local declare = nil\r\n                    local argType = param.DataType\r\n                    local argTypeWithAttrib = param.DataTypeWithAttrib\r\n                    local argPtr = param.DataTypePointer[1]\r\n                    local argName = param.Name\r\n                    local argNum = nil\r\n                    local opt = param.DefaultValue\r\n                    local numeric = IsDataTypeNumeric(param.DataType)\r\n\r\n                    if member.IsConstructor or member[\"%function\"] or member.IsStaticFunction then\r\n                        argNum = arg -- don't have self\r\n                    else\r\n                        argNum = arg + 1\r\n                    end\r\n\r\n                    if not argName then\r\n                        argName = \"arg\"..arg\r\n\r\n                        param.Name = argName\r\n                    end\r\n\r\n                    if arg > 1 then\r\n                        argList = argList..\", \"\r\n                    end\r\n\r\n                    local indirectionCount = #param.DataTypePointer\r\n\r\n                    local isTranslated = nil\r\n                    local origArgType =  argType\r\n                    local origArgTypeWithAttrib = argTypeWithAttrib\r\n                    local origArgPtr = argPtr\r\n                    local origIndirectionCount = indirectionCount\r\n                    local argCast = nil\r\n                    local argListOverride = nil\r\n\r\n                    -- Does DataType need to be translated from typeDef\r\n                    TranslateDataType(param)\r\n                    if #param.TypedDataTypePointer ~= indirectionCount then\r\n                        indirectionCount = #param.TypedDataTypePointer\r\n\r\n                        -- translated datatype\r\n                        argType = param.TypedDataType\r\n                        argTypeWithAttrib = param.TypedDataTypeWithAttrib\r\n                        argPtr = param.TypedDataTypePointer[1]\r\n\r\n                        isTranslated = true\r\n                    end\r\n\r\n\r\n                    -- the function takes (void*), but we just pass a long\r\n                    if argType == \"voidptr_long\" then\r\n                        argType = \"long\"\r\n                        argTypeWithAttrib = \"long\"\r\n                        argCast = \"void*\"\r\n                    end\r\n\r\n                    -- our special notation to get wxString/IntArray from a Lua table of strings\r\n                    -- BUT! it has to be const wxArrayString& arr or wxArrayString arr\r\n                    --      and NOT wxArrayString& arr or wxArrayString* arr\r\n                    if ((argType == \"wxArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayString, \"\r\n                        argItem = \"wxlua_getwxArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayString\"\r\n                    elseif ((argType == \"wxSortedArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxSortedArrayString, \"\r\n                        argItem = \"wxlua_getwxSortedArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxSortedArrayString\"\r\n                    elseif ((argType == \"wxArrayInt\") and\r\n                            ((indirectionCount == 0) or\r\n                             ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayInt, \"\r\n                        argItem = \"wxlua_getwxArrayInt(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayInt\"\r\n                    elseif argType == \"IntArray_FromLuaTable\" then\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"NULL; ptr = \"..argName..\" = wxlua_getintarray(L, \"..argNum..\", count_)\"\r\n                        declare = \"int count_ = 0; wxLuaSmartIntArray ptr; int*\"\r\n                        argList = argList..\"count_, \"\r\n                    elseif argType == \"LuaTable\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif argType == \"LuaFunction\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TFUNCTION, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif (indirectionCount == 1) and (argPtr == \"[]\") then\r\n                        argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n\r\n                        if argType == \"wxString\" then\r\n                            -- overload_argList = overload_argList..\"&s_wxluaarg_StringArray, \" FIXME!\r\n                            -- Un 'const' strings\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getwxStringarray(\"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartStringArray \"\r\n                        elseif argType == \"int\" then\r\n                            -- Un 'const' ints\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getintarray(L, \"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartIntArray \"\r\n                        elseif not numeric then\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"*\") then\r\n                        if (argType == \"wxString\") or (argType == \"wxChar\") then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxT(\"..opt..\")\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n\r\n                            if (argType == \"wxChar\") then\r\n                                argTypeWithAttrib = \"wxString \"\r\n                                argListOverride = argName..\".IsEmpty() ? NULL : \"..argName..\".c_str()\"\r\n                            end\r\n\r\n                        elseif argType == \"char\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getstringtype(L, \"..argNum..\")\"\r\n\r\n                            argTypeWithAttrib = \"wxCharBuffer\"\r\n                            argCast = \"const char*\" -- allows for \"unsigned char*\"\r\n                        else\r\n                            if isTranslated and (origIndirectionCount == 0) then\r\n                                argTypeWithAttrib = origArgTypeWithAttrib\r\n                                argCast = origArgTypeWithAttrib\r\n                            else\r\n                                argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            end\r\n\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            if param.GC then\r\n                                if dataTypeTable[argType][\"%encapsulate\"] then\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")\r\n                                else\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")\r\n                                end\r\n                            elseif param.UnGC then\r\n                                table.insert(gcList, \"    if (wxluaO_isgcobject(L, \"..argName..\")) wxluaO_undeletegcobject(L, \"..argName..\");\\n\")\r\n                            end\r\n\r\n                        end\r\n                    elseif (indirectionCount == 2) and (argPtr == \"*\") then\r\n                        if not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" **\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"&\") then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        else\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            -- Default Value\r\n                            if opt then opt = \"&\"..opt end\r\n\r\n                            argList = argList..\"*\"\r\n                        end\r\n                    elseif indirectionCount == 0 then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        elseif IsDataTypeBool(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                            argItem = \"wxlua_getbooleantype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeEnum(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getenumtype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeUInt(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getuintegertype(L, \"..argNum..\")\"\r\n                        elseif not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argItem = \"*(\"..argTypeWithAttrib..\"*)wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getnumbertype(L, \"..argNum..\")\"\r\n                        end\r\n                    else\r\n                        local point = \"\"\r\n                        for z = 1, #param.TypedDataTypePointer do\r\n                            point = point..param.TypedDataTypePointer[z]\r\n                        end\r\n                        print(\"ERROR: Unsupported pointer indirection '\"..point..\"' \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    if argCast then\r\n                        argList = argList..\"(\"..argCast..\")\"\r\n                    end\r\n\r\n                    argList = argList..(argListOverride or argName)\r\n\r\n                    -- except for string arrays, the declare is the argType\r\n                    if not declare then\r\n                        declare = argTypeWithAttrib\r\n                    end\r\n\r\n                    if not param.Name then\r\n                        print(\"ERROR: No Param Name: \"..member.LineText..\" \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- interface.objectData[o].Members[m].Params[p]\r\n                    codeList = {}\r\n\r\n                    if opt then\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\" = \"..param.DefaultValue..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = (argCount >= \"..argNum..\" ? \"..argItem..\" : \"..opt..\");\\n\")\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = \"..argItem..\";\\n\")\r\n                    end\r\n\r\n                    local paramBinding =\r\n                    {\r\n                        ParamName = argName,\r\n                        ParamType = argType,\r\n                        ParamCast = argCast,\r\n                        ParamCode = codeList,\r\n                    }\r\n\r\n                    -- set param binding\r\n                    interface.objectData[o].Members[m].Params[arg].Binding = paramBinding\r\n                end\r\n\r\n                -- //////////////////////////////////////////////////////////////////////////////////\r\n                -- method binding\r\n                codeList = {}\r\n\r\n                local numeric = IsDataTypeNumeric(member.DataType)\r\n\r\n                -- function name\r\n                local funcType = nil\r\n                local funcName = nil\r\n                local funcNameBase = nil\r\n                local funcLuaCall = nil\r\n                if member.IsConstructor or (member.Name == parseObject.Name) then\r\n                    member.IsConstructor = true\r\n                    funcName = \"wxLua_\"..MakeVar(member[\"%rename\"] or member.Name)..\"_constructor\"\r\n                    funcNameBase = funcName\r\n\r\n                    funcType = \"WXLUAMETHOD_CONSTRUCTOR\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif member.Name == \"~\"..parseObject.Name then\r\n                    print(\"WARNING: Unhandled ~ destructor \", member.Name, parseObject.Name);\r\n                elseif member.IsStaticFunction then\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif (parseObject.Name == \"globals\") or member[\"%function\"] then\r\n                    funcName = \"wxLua_function_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_CFUNCTION\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                else\r\n                    if not parseObject.Name then\r\n                        print(\"ERROR: parseObject.Name = nil \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- special case for unary -, convert from op_sub to op_neg if necessary\r\n                    if member[\"%operator\"] and (#member.Params == 0) and (member.Name == \"op_sub\") then\r\n                        member.Name = \"op_neg\"\r\n                        if member[\"%rename\"] == \"op_sub\" then -- maybe they renamed it?\r\n                            member[\"%rename\"] = \"op_neg\"\r\n                        end\r\n                    end\r\n\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n\r\n                    funcType = \"WXLUAMETHOD_METHOD\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                end\r\n\r\n                if not funcNameBase then funcNameBase = funcName end\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                -- if they declared this, the conditions must be exclusive\r\n                -- since the functions will have the same names\r\n                if (member.NotOverload ~= true) then\r\n                    if overloadCount[funcName] then\r\n                        overloadCount[funcName] = overloadCount[funcName] + 1\r\n                        funcName = funcName..tostring(overloadCount[funcName]-1)\r\n                    else\r\n                        overloadCount[funcName] = 1\r\n                    end\r\n                end\r\n\r\n                -- function\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                -- See if we're supposed to track or untrack the return value\r\n                local a = string.find(member.DataTypeWithAttrib, \"%gc\", 1, 1)\r\n                if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+4)\r\n                    member.GC = true\r\n                end\r\n                local a = string.find(member.DataTypeWithAttrib, \"%ungc\", 1, 1)\r\n                if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+6)\r\n                    member.UnGC = true\r\n                end\r\n\r\n                -- determine function return type\r\n                local memberType = member.DataType\r\n                local memberTypeWithAttrib = member.DataTypeWithAttrib\r\n                local memberPtr = member.DataTypePointer[1]\r\n\r\n                local indirectionCount = #member.DataTypePointer\r\n\r\n                local isTranslated = nil\r\n                local origMemberType =  memberType\r\n                local origMemberTypeWithAttrib = memberTypeWithAttrib\r\n                local origMemberPtr = memberPtr\r\n                local origIndirectionCount = indirectionCount\r\n                local memberCast = nil\r\n\r\n                -- Does DataType need to be translated from typeDef\r\n                TranslateDataType(member)\r\n                if #member.TypedDataTypePointer ~= indirectionCount then\r\n                    indirectionCount = #member.TypedDataTypePointer\r\n\r\n                    -- translated datatype\r\n                    memberType = member.TypedDataType\r\n                    memberTypeWithAttrib = member.TypedDataTypeWithAttrib\r\n                    memberPtr = member.TypedDataTypePointer[1]\r\n\r\n                    isTranslated = true\r\n                end\r\n\r\n                local returnPtr = \"*\";\r\n\r\n                if (memberType ~= \"void\") or (indirectionCount > 0) then\r\n                    if numeric and ((indirectionCount == 0) or (memberPtr == \"&\"))  then\r\n                        returnPtr = \"\"\r\n                    end\r\n\r\n                    if isTranslated and (indirectionCount == 1) and (origIndirectionCount == 0) then\r\n                        memberTypeWithAttrib = origMemberTypeWithAttrib..\" \"\r\n                        memberCast = origMemberTypeWithAttrib\r\n                    else\r\n                        memberTypeWithAttrib = memberTypeWithAttrib..returnPtr\r\n                    end\r\n\r\n                    -- Un 'const' strings and non-pointer datatypes\r\n                    if (string.sub(memberTypeWithAttrib, 1, 6) == \"const \") and ((memberType == \"wxString\") or (returnPtr == \"\") or member.IsConstructor) then\r\n                        memberTypeWithAttrib = string.sub(memberTypeWithAttrib, 7)\r\n                    end\r\n\r\n                    if string.find(\"voidptr_long\", memberTypeWithAttrib, 1, 1) then\r\n                        memberTypeWithAttrib = \"long \"\r\n                    end\r\n                end\r\n\r\n                -- conditions for method are dependent on return type, argument types, and inline conditions\r\n                local dependConditions = {}\r\n\r\n                if HasCondition(fullcondition) then\r\n                    dependConditions[fullcondition] = fullcondition\r\n                end\r\n\r\n                local returnCondition = GetDataTypeCondition(memberType)\r\n                if returnCondition then\r\n                    dependConditions[returnCondition] = returnCondition\r\n                end\r\n\r\n                -- get args\r\n                local requiredParamCount = 0\r\n                local paramCount = #member.Params\r\n                if  paramCount > 0 then\r\n                    for arg=1, paramCount do\r\n                        if not member.Params[arg].DefaultValue then\r\n                            requiredParamCount = requiredParamCount + 1\r\n                        elseif member.Params[arg+1] and (not member.Params[arg+1].DefaultValue) then\r\n                            print(\"ERROR: Missing default arg #\"..tostring(arg+1)..\" in function. \"..LineTableErrString(member))\r\n                        end\r\n                    end\r\n\r\n                    if requiredParamCount ~= paramCount then\r\n                        CommentBindingTable(codeList, \"    // get number of arguments\\n\")\r\n                        table.insert(codeList, \"    int argCount = lua_gettop(L);\\n\")\r\n                    end\r\n\r\n                    for arg = 1, paramCount do\r\n                        -- add function code to get args (in reverse order)\r\n                        local paramLineCount = #(member.Params[paramCount + 1 - arg].Binding.ParamCode)\r\n                        for paramLine=1, paramLineCount do\r\n                            table.insert(codeList, member.Params[paramCount + 1 - arg].Binding.ParamCode[paramLine])\r\n                        end\r\n\r\n                        -- param conditions\r\n                        local paramCondition = GetDataTypeCondition(member.Params[arg].DataType)\r\n                        if paramCondition then\r\n                            dependConditions[paramCondition] = paramCondition\r\n                        end\r\n                    end\r\n                end\r\n\r\n                for i = 1, #gcList do\r\n                    table.insert(codeList, gcList[i])\r\n                end\r\n\r\n                -- constructor?\r\n                if member.IsConstructor then\r\n                    CommentBindingTable(codeList, \"    // call constructor\\n\")\r\n                    table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..parseObject.Name..\"(\"..argList..\");\\n\")\r\n\r\n                    if parseObject[\"%gc_this\"] or (parseObject[\"%delete\"] and (not parseObject[\"%ungc_this\"])) then\r\n                        CommentBindingTable(codeList, \"    // add to tracked memory list\\n\")\r\n\r\n                        -- Un 'const' AddTrackedObject\r\n                        local returnCast = memberTypeWithAttrib\r\n                        if string.sub(returnCast, 1, 6) == \"const \" then\r\n                            returnCast = string.sub(returnCast, 7)\r\n                        end\r\n\r\n                        if parseObject[\"%encapsulate\"] then\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(parseObject.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                        else\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, returns);\\n\")\r\n                        end\r\n                    elseif not parseObject[\"%noclassinfo\"] then\r\n                        CommentBindingTable(codeList, \"    // add to tracked window list, it will check validity\\n\")\r\n                        table.insert(codeList, \"    wxluaW_addtrackedwindow(L, returns);\\n\")\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // push the constructed class pointer\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n\r\n                    table.insert(codeList, \"\\n    return 1;\\n\")\r\n                    table.insert(codeList, \"}\\n\")\r\n                else\r\n                    -- how we call c-function\r\n                    if parseObject.Name == \"globals\" then\r\n                        functor = member.Name   -- global\r\n                    elseif member.IsStaticFunction then\r\n                        functor = parseObject.Name..\"::\"..member.Name -- static member function\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // get this\\n\")\r\n\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\" * self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                        overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                        if parseObject[\"%ungc_this\"] then\r\n                            table.insert(codeList, \"    wxluaO_undeletegcobject(L, self);\\n\")\r\n                        elseif parseObject[\"%gc_this\"] then\r\n                            if parseObject[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    if (!wxluaO_isgcobject(L, self)) wxluaO_addgcobject(L, (void*)self, new wxLua_wxObject_\"..MakeClassVar(parseObject.Name)..\"(self));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, self);\\n\")\r\n                            end\r\n                        end\r\n\r\n                        requiredParamCount = requiredParamCount + 1\r\n                        paramCount = paramCount + 1\r\n\r\n                        if member[\"%operator\"] then\r\n                            if (member.Name == \"op_preinc\") or (member.Name == \"op_predec\") then\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            elseif (member.Name == \"op_inc\") or (member.Name == \"op_dec\") then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            elseif member[\"%operator\"] == \"[]\" then     -- op_index\r\n                                functor = \"(*self)[\"\r\n                            elseif member[\"%operator\"] == \"()\" then -- op_func\r\n                                functor = \"(*self)\"\r\n                            elseif paramCount > 1 then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            else\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            end\r\n                        -- static member function?\r\n                        elseif string.find(member.Name, \"::\") then\r\n                            functor = member.Name\r\n                        else\r\n                            functor = \"self->\"..member.Name\r\n                        end\r\n                    end\r\n\r\n                    -- need cast?\r\n                    if memberCast then\r\n                        functor  = \"(\"..memberCast..\")\"..functor\r\n                    end\r\n\r\n                    local is_func = iff(not member[\"%operator\"] and member.IsFunction, true, false)\r\n\r\n                    -- Add Function Argument List\r\n                    if (argList ~= \"\") or is_func then\r\n                        functor = functor..\"(\"..argList..\")\"\r\n                    end\r\n\r\n                    if member[\"%operator\"] == \"[]\" then -- op_index\r\n                        functor = functor..\"]\"\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // call \"..member.Name..\"\\n\")\r\n\r\n                    if not memberType or (memberTypeWithAttrib == \"void\") then\r\n                        -- call (void) function\r\n                        table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                        table.insert(codeList, \"\\n    return 0;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    else\r\n                        -- call function, get return value\r\n                        if member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and string.find(member[\"%operator\"], \"=\", 1, 1) then\r\n                            table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = self;\\n\")\r\n                        elseif member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and (string.find(member[\"%operator\"], \"=\", 1, 1) == nil) then\r\n                            if string.find(memberTypeWithAttrib or \"\", \"*\", 1, 1) then\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &(\"..functor..\");\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = \"..functor..\";\\n\")\r\n                            end\r\n                        elseif (not numeric) and (not memberPtr) then\r\n                            CommentBindingTable(codeList, \"    // allocate a new object using the copy constructor\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..memberType..\"(\"..functor..\");\\n\")\r\n                            CommentBindingTable(codeList, \"    // add the new object to the tracked memory list\\n\")\r\n\r\n                            -- Un 'const' AddTrackedObject\r\n                            local returnCast = memberTypeWithAttrib\r\n                            if string.sub(returnCast, 1, 6) == \"const \" then\r\n                                returnCast = string.sub(returnCast, 7)\r\n                            end\r\n\r\n                            local member_DataType = GetDataTypedefBase(memberType)\r\n\r\n                            if member_DataType[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(member_DataType.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (\"..returnCast..\")returns);\\n\")\r\n                            end\r\n\r\n                        elseif (not member[\"%operator\"]) and (memberPtr == \"&\") and string.find(memberTypeWithAttrib, \"*\") and (memberType ~= \"wxString\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &\"..functor..\";\\n\")\r\n                        elseif (memberPtr == \"*\") or (memberType == \"voidptr_long\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..memberTypeWithAttrib..\")\"..functor..\";\\n\")\r\n\r\n                            if member.GC then\r\n                                if dataTypeTable[memberType][\"%encapsulate\"] then\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")\r\n                                else\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")\r\n                                end\r\n                            elseif member.UnGC then\r\n                                table.insert(codeList, \"    if (wxluaO_isgcobject(L, returns)) wxluaO_undeletegcobject(L, returns);\\n\")\r\n                            end\r\n\r\n                        else\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..functor..\");\\n\")\r\n                        end\r\n\r\n                        -- bind return value\r\n                        if memberType == \"wxString\" then\r\n                            CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                            table.insert(codeList, \"    wxlua_pushwxString(L, \"..returnPtr..\"returns);\\n\")\r\n                        elseif not numeric then\r\n                            CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                            table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                        elseif IsDataTypeBool(member.DataType) then\r\n                            CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                            table.insert(codeList, \"    lua_pushboolean(L, returns);\\n\")\r\n                        elseif returnPtr == \"*\" then\r\n                            CommentBindingTable(codeList, \"    // push the result pointer\\n\")\r\n                            table.insert(codeList, \"    lua_pushlightuserdata(L, (void *)returns);\\n\")\r\n                        else -- Number\r\n                            CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                            table.insert(codeList, \"    lua_pushnumber(L, returns);\\n\")\r\n                        end\r\n\r\n                        table.insert(codeList, \"\\n    return 1;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    end\r\n                end\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                -- add function map only once for the base function name overload\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n                local funcMap   = \"{ \"..funcName..\", \"..funcType..\", \"..tostring(requiredParamCount)..\", \"..tostring(paramCount)..\", \"..overload_argListName..\" }\"\r\n                local methodMap = \"    { \\\"\"..funcLuaCall..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\"\r\n\r\n                -- build method condition\r\n                local methodcondition = nil\r\n                for idx, condition in pairs(dependConditions) do\r\n                    methodcondition = AddCondition(methodcondition, condition)\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                methodcondition = FixCondition(methodcondition)\r\n\r\n                -- bind method\r\n                methodBinding =\r\n                {\r\n                    ClassName          = parseObject.Name,\r\n                    FuncType           = funcType,\r\n                    LuaName            = funcLuaCall,\r\n                    CFunctionName      = funcName,\r\n                    CFunctionNameBase  = funcNameBase,\r\n                    Method             = codeList,\r\n                    ArgArray           = overload_argList,\r\n                    ArgArrayName       = overload_argListName,\r\n                    ParamCount         = paramCount,\r\n                    RequiredParamCount = requiredParamCount,\r\n                    FuncMap            = funcMap,\r\n                    FuncMapName        = funcMapName,\r\n                    Map                = methodMap,\r\n                    NotOverload        = member.NotOverload,\r\n                    Condition          = methodcondition,\r\n                    PreDefineCode      = nil, -- set later if necessary\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if (member.override_name and overrideTable[member.override_name]) then\r\n                    methodBinding.Method = overrideTable[member.override_name]\r\n                    methodBinding.PreDefineCode = \"#define \"..funcName..\" \"..member.override_name..\"\\n\"\r\n                    overrideTableUsed[member.override_name] = true\r\n                elseif ((member.override_name == nil) and overrideTable[methodBinding.CFunctionName]) then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                if member[\"%function\"] then\r\n                    table.insert(functionBindingTable, methodBinding)\r\n                elseif not (member.IsConstructor and parseObject[\"%abstract\"]) then\r\n                    table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1320,
    "text": "local memberType    = member.DataType",
    "type": "statement:localassign"
  }, {
    "id": 1321,
    "text": "local memberGetFunc = \"Get_\"..member.Name",
    "type": "statement:localassign"
  }, {
    "id": 1322,
    "text": "local memberSetFunc = \"Set_\"..member.Name",
    "type": "statement:localassign"
  }, {
    "id": 1323,
    "text": "if member[\"%rename\"] then\r\n                    memberGetFunc = \"Get\"..member[\"%rename\"]\r\n                    memberSetFunc = \"Set\"..member[\"%rename\"]\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1324,
    "text": "memberGetFunc = \"Get\"..member[\"%rename\"]",
    "type": "statement:assign"
  }, {
    "id": 1325,
    "text": "memberSetFunc = \"Set\"..member[\"%rename\"]",
    "type": "statement:assign"
  }, {
    "id": 1326,
    "text": "local funcType = \"WXLUAMETHOD_METHOD\"",
    "type": "statement:localassign"
  }, {
    "id": 1327,
    "text": "local propType = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1328,
    "text": "if member.IsStaticFunction then\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    propType = \"|WXLUAMETHOD_STATIC\"\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1329,
    "text": "funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"",
    "type": "statement:assign"
  }, {
    "id": 1330,
    "text": "propType = \"|WXLUAMETHOD_STATIC\"",
    "type": "statement:assign"
  }, {
    "id": 1331,
    "text": "if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1332,
    "text": "local memberPtr = member.DataTypePointer[1]",
    "type": "statement:localassign"
  }, {
    "id": 1333,
    "text": "local indirectionCount = #member.DataTypePointer",
    "type": "statement:localassign"
  }, {
    "id": 1334,
    "text": "local numeric = IsDataTypeNumeric(member.DataType)",
    "type": "statement:localassign"
  }, {
    "id": 1335,
    "text": "local dependConditions = {}",
    "type": "statement:localassign"
  }, {
    "id": 1336,
    "text": "if HasCondition(fullcondition) then\r\n                    dependConditions[fullcondition] = fullcondition\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1337,
    "text": "dependConditions[fullcondition] = fullcondition",
    "type": "statement:assign"
  }, {
    "id": 1338,
    "text": "local returnCondition = GetDataTypeCondition(member.DataType)",
    "type": "statement:localassign"
  }, {
    "id": 1339,
    "text": "if returnCondition then\r\n                    dependConditions[returnCondition] = returnCondition\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1340,
    "text": "dependConditions[returnCondition] = returnCondition",
    "type": "statement:assign"
  }, {
    "id": 1341,
    "text": "local membercondition = nil",
    "type": "statement:localassign"
  }, {
    "id": 1342,
    "text": "for idx, condition in pairs(dependConditions) do\r\n                    membercondition = AddCondition(membercondition, condition)\r\n                end",
    "type": "statement:genericfor"
  }, {
    "id": 1343,
    "text": "membercondition = AddCondition(membercondition, condition)",
    "type": "statement:assign"
  }, {
    "id": 1344,
    "text": "membercondition = FixCondition(membercondition)",
    "type": "statement:assign"
  }, {
    "id": 1345,
    "text": "local codeList = {}",
    "type": "statement:localassign"
  }, {
    "id": 1346,
    "text": "local overload_argList = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1347,
    "text": "local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberGetFunc",
    "type": "statement:localassign"
  }, {
    "id": 1348,
    "text": "CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1349,
    "text": "table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1350,
    "text": "local self_name = \"self->\"",
    "type": "statement:localassign"
  }, {
    "id": 1351,
    "text": "if member.IsStaticFunction then\r\n                    self_name = parseObject.Name..\"::\"\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1352,
    "text": "self_name = parseObject.Name..\"::\"",
    "type": "statement:assign"
  }, {
    "id": 1353,
    "text": "CommentBindingTable(codeList, \"    // get this\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1354,
    "text": "table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1355,
    "text": "overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList",
    "type": "statement:assign"
  }, {
    "id": 1356,
    "text": "if memberType == \"wxString\" then\r\n                    CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                    table.insert(codeList, \"    wxlua_pushwxString(L, \"..self_name..member.Name..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\")) then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n\r\n--                    if string.find(member.Name, \"::\") then\r\n--                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    else\r\n                        table.insert(codeList, \"    wxluaT_pushuserdatatype(L, &\"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n--                    end\r\n                elseif not numeric then\r\n                    CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n\r\n                elseif IsDataTypeBool(memberType) then\r\n                    CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                    table.insert(codeList, \"    lua_pushboolean(L, \"..self_name..member.Name..\");\\n\")\r\n\r\n                else\r\n                    CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                    table.insert(codeList, \"    lua_pushnumber(L, \"..self_name..member.Name..\");\\n\")\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1357,
    "text": "CommentBindingTable(codeList, \"    // push the result string\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1358,
    "text": "table.insert(codeList, \"    wxlua_pushwxString(L, \"..self_name..member.Name..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1359,
    "text": "CommentBindingTable(codeList, \"    // push the result datatype\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1360,
    "text": "table.insert(codeList, \"    wxluaT_pushuserdatatype(L, &\"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1361,
    "text": "table.insert(codeList, \"    wxluaT_pushuserdatatype(L, \"..self_name..member.Name..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1362,
    "text": "CommentBindingTable(codeList, \"    // push the result flag\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1363,
    "text": "table.insert(codeList, \"    lua_pushboolean(L, \"..self_name..member.Name..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1364,
    "text": "CommentBindingTable(codeList, \"    // push the result number\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1365,
    "text": "table.insert(codeList, \"    lua_pushnumber(L, \"..self_name..member.Name..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1366,
    "text": "CommentBindingTable(codeList, \"    // return the number of values\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1367,
    "text": "table.insert(codeList, \"    return 1;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1368,
    "text": "table.insert(codeList, \"}\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1369,
    "text": "local overload_argListName = \"s_wxluatypeArray_\"..funcName",
    "type": "statement:localassign"
  }, {
    "id": 1370,
    "text": "if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1371,
    "text": "overload_argListName = \"g_wxluaargtypeArray_None\"",
    "type": "statement:assign"
  }, {
    "id": 1372,
    "text": "overload_argList = \"{ \"..overload_argList..\"NULL }\"",
    "type": "statement:assign"
  }, {
    "id": 1373,
    "text": "RemovewxLuaStateIfNotUsed(codeList)",
    "type": "statement:functioncall"
  }, {
    "id": 1374,
    "text": "local funcMapName = \"s_wxluafunc_\"..funcName",
    "type": "statement:localassign"
  }, {
    "id": 1375,
    "text": "local methodBinding =\r\n                {\r\n                    LuaName       = memberGetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberGetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1376,
    "text": "local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_GETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_GETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1377,
    "text": "if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1378,
    "text": "methodBinding.Method = overrideTable[methodBinding.CFunctionName]",
    "type": "statement:assign"
  }, {
    "id": 1379,
    "text": "overrideTableUsed[methodBinding.CFunctionName] = true",
    "type": "statement:assign"
  }, {
    "id": 1380,
    "text": "if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1381,
    "text": "methodBinding.Map = \"    // %member\"..methodBinding.Map",
    "type": "statement:assign"
  }, {
    "id": 1382,
    "text": "table.insert(interface.objectData[o].BindTable, methodBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1383,
    "text": "table.insert(interface.objectData[o].BindTable, propertyBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1384,
    "text": "if not string.find(member.DataTypeWithAttrib, \"const \", 1, 1) then\r\n\r\n                codeList = {}\r\n                overload_argList = \"\"\r\n                local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberSetFunc\r\n                CommentBindingTable(codeList, \"// \"..interface.lineData[member.LineNumber].LineText..\"\\n\")\r\n                table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n\r\n                local stack_idx = iff(member.IsStaticFunction, \"1\", \"2\")\r\n\r\n                if memberType == \"wxString\" then\r\n                    overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                    CommentBindingTable(codeList, \"    // get the string value\\n\")\r\n                    table.insert(codeList, \"    wxString val = wxlua_getwxStringtype(L, \"..stack_idx..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif not numeric then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif IsDataTypeBool(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                    CommentBindingTable(codeList, \"    // get the boolean value\\n\")\r\n                    table.insert(codeList, \"    bool val = wxlua_getbooleantype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeEnum(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the enum value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getenumtype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeUInt(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the unsigned integer value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getuintegertype(L, \"..stack_idx..\");\\n\")\r\n                else\r\n                    overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                    CommentBindingTable(codeList, \"    // get the number value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getnumbertype(L, \"..stack_idx..\");\\n\")\r\n                end\r\n\r\n                if member.IsStaticFunction then\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                end\r\n\r\n                CommentBindingTable(codeList, \"    // return the number of values\\n\")\r\n                table.insert(codeList, \"    return 0;\\n\")\r\n                table.insert(codeList, \"}\\n\")\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                if overload_argList == \"\" then\r\n                    overload_argListName = \"g_wxluaargtypeArray_None\"\r\n                else\r\n                    overload_argList = \"{ \"..overload_argList..\"NULL }\"\r\n                end\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                -- bind method\r\n                local methodBinding =\r\n                {\r\n                    LuaName       = memberSetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 2, 2, \"..overload_argListName..\" }\", -- FIXME make sure this is right\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberSetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }\r\n\r\n                -- bind property\r\n                local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_SETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_SETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[methodBinding.CFunctionName] then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end\r\n\r\n                -- rem out the Set function if not %member_func, but we need the code for the property\r\n                if member.DefType == \"deftype_%member\" then\r\n                    methodBinding.Map = \"    // %member\"..methodBinding.Map\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                table.insert(interface.objectData[o].BindTable, propertyBinding)\r\n\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1385,
    "text": "codeList = {}",
    "type": "statement:assign"
  }, {
    "id": 1386,
    "text": "overload_argList = \"\"",
    "type": "statement:assign"
  }, {
    "id": 1387,
    "text": "local funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..memberSetFunc",
    "type": "statement:localassign"
  }, {
    "id": 1388,
    "text": "local stack_idx = iff(member.IsStaticFunction, \"1\", \"2\")",
    "type": "statement:localassign"
  }, {
    "id": 1389,
    "text": "if memberType == \"wxString\" then\r\n                    overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                    CommentBindingTable(codeList, \"    // get the string value\\n\")\r\n                    table.insert(codeList, \"    wxString val = wxlua_getwxStringtype(L, \"..stack_idx..\");\\n\")\r\n                elseif not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif not numeric then\r\n                    overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"\r\n                    CommentBindingTable(codeList, \"    // get the data type value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                elseif IsDataTypeBool(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                    CommentBindingTable(codeList, \"    // get the boolean value\\n\")\r\n                    table.insert(codeList, \"    bool val = wxlua_getbooleantype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeEnum(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the enum value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getenumtype(L, \"..stack_idx..\");\\n\")\r\n                elseif IsDataTypeUInt(memberType) then\r\n                    overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                    CommentBindingTable(codeList, \"    // get the unsigned integer value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getuintegertype(L, \"..stack_idx..\");\\n\")\r\n                else\r\n                    overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                    CommentBindingTable(codeList, \"    // get the number value\\n\")\r\n                    table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getnumbertype(L, \"..stack_idx..\");\\n\")\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1390,
    "text": "overload_argList = overload_argList..\"&wxluatype_TSTRING, \"",
    "type": "statement:assign"
  }, {
    "id": 1391,
    "text": "CommentBindingTable(codeList, \"    // get the string value\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1392,
    "text": "table.insert(codeList, \"    wxString val = wxlua_getwxStringtype(L, \"..stack_idx..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1393,
    "text": "overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(memberType)..\", \"",
    "type": "statement:assign"
  }, {
    "id": 1394,
    "text": "CommentBindingTable(codeList, \"    // get the data type value\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1395,
    "text": "table.insert(codeList, \"    \"..memberType..\"* val = (\"..memberType..\"*)wxluaT_getuserdatatype(L, \"..stack_idx..\", wxluatype_\"..MakeClassVar(memberType)..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1396,
    "text": "overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"",
    "type": "statement:assign"
  }, {
    "id": 1397,
    "text": "CommentBindingTable(codeList, \"    // get the boolean value\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1398,
    "text": "table.insert(codeList, \"    bool val = wxlua_getbooleantype(L, \"..stack_idx..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1399,
    "text": "overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"",
    "type": "statement:assign"
  }, {
    "id": 1400,
    "text": "CommentBindingTable(codeList, \"    // get the enum value\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1401,
    "text": "table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getenumtype(L, \"..stack_idx..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1402,
    "text": "CommentBindingTable(codeList, \"    // get the unsigned integer value\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1403,
    "text": "table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getuintegertype(L, \"..stack_idx..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1404,
    "text": "overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"",
    "type": "statement:assign"
  }, {
    "id": 1405,
    "text": "CommentBindingTable(codeList, \"    // get the number value\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1406,
    "text": "table.insert(codeList, \"    \"..memberType..\" val = (\"..memberType..\")wxlua_getnumbertype(L, \"..stack_idx..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1407,
    "text": "if member.IsStaticFunction then\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                else\r\n                    CommentBindingTable(codeList, \"    // get this\\n\")\r\n                    table.insert(codeList, \"    \"..parseObject.Name..\" *self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                    overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                    if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = val;\\n\")\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1408,
    "text": "if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = val;\\n\")\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1409,
    "text": "table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = *val;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1410,
    "text": "table.insert(codeList, \"    \"..parseObject.Name..\"::\"..member.Name..\" = val;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1411,
    "text": "if not numeric and (not memberPtr or (memberPtr == \"&\"))  then\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = *val;\\n\")\r\n                    else\r\n                        table.insert(codeList, \"    self->\"..member.Name..\" = val;\\n\")\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1412,
    "text": "table.insert(codeList, \"    self->\"..member.Name..\" = *val;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1413,
    "text": "table.insert(codeList, \"    self->\"..member.Name..\" = val;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1414,
    "text": "table.insert(codeList, \"    return 0;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1415,
    "text": "local overload_argListName = \"s_wxluatypeArray_\".. funcName",
    "type": "statement:localassign"
  }, {
    "id": 1416,
    "text": "local methodBinding =\r\n                {\r\n                    LuaName       = memberSetFunc,\r\n                    CFunctionName = funcName,\r\n                    Method        = codeList,\r\n                    ArgArray      = overload_argList,\r\n                    ArgArrayName  = overload_argListName,\r\n                    FuncType      = funcType,\r\n                    FuncMap       = \"{ \"..funcName..\", \"..funcType..\", 2, 2, \"..overload_argListName..\" }\", -- FIXME make sure this is right\r\n                    FuncMapName   = funcMapName,\r\n                    Map           = \"    { \\\"\"..memberSetFunc..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition     = membercondition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1417,
    "text": "local propertyBinding =\r\n                {\r\n                    LuaName   = member.Name,\r\n                    FuncType  = \"WXLUAMETHOD_SETPROP\"..propType,\r\n                    Map       = \"    { \\\"\"..member.Name..\"\\\", WXLUAMETHOD_SETPROP\"..propType..\", \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition = membercondition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1418,
    "text": "local dataType = member.DataType or \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1419,
    "text": "local namespace = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1420,
    "text": "local luaname = member[\"%rename\"] or member.Name",
    "type": "statement:localassign"
  }, {
    "id": 1421,
    "text": "local classname = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1422,
    "text": "local enumname = luaname",
    "type": "statement:localassign"
  }, {
    "id": 1423,
    "text": "local pos = string.find(dataType, \"::\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 1424,
    "text": "if pos then\r\n                    -- search for last ::, eg. ns1::ns2::enumName -> ns1::ns2 is namespace\r\n                    classname = string.sub(dataType, 0, pos - 1)\r\n                    while pos do\r\n                        local p = string.find(dataType, \"::\", pos+2, 1)\r\n                        if p then pos = p else break end\r\n                    end\r\n\r\n                    namespace = string.sub(dataType, 0, pos - 1)\r\n                    if not member[\"%rename\"] then\r\n                        luaname = MakeVar(namespace)..\"_\"..luaname -- wxFile::read -> wxFile_read\r\n                    end\r\n\r\n                    namespace = namespace..\"::\"\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1425,
    "text": "classname = string.sub(dataType, 0, pos - 1)",
    "type": "statement:assign"
  }, {
    "id": 1426,
    "text": "while pos do\r\n                        local p = string.find(dataType, \"::\", pos+2, 1)\r\n                        if p then pos = p else break end\r\n                    end",
    "type": "statement:while"
  }, {
    "id": 1427,
    "text": "local p = string.find(dataType, \"::\", pos+2, 1)",
    "type": "statement:localassign"
  }, {
    "id": 1428,
    "text": "if p then pos = p else break end",
    "type": "statement:if"
  }, {
    "id": 1429,
    "text": "pos = p",
    "type": "statement:assign"
  }, {
    "id": 1430,
    "text": "namespace = string.sub(dataType, 0, pos - 1)",
    "type": "statement:assign"
  }, {
    "id": 1431,
    "text": "if not member[\"%rename\"] then\r\n                        luaname = MakeVar(namespace)..\"_\"..luaname -- wxFile::read -> wxFile_read\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1432,
    "text": "luaname = MakeVar(namespace)..\"_\"..luaname",
    "type": "statement:assign"
  }, {
    "id": 1433,
    "text": "namespace = namespace..\"::\"",
    "type": "statement:assign"
  }, {
    "id": 1434,
    "text": "if (string.len(classname) > 0) then\r\n                    if not enumClassBindingTable[classname] then\r\n                        enumClassBindingTable[classname] = {}\r\n                    end\r\n\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = enumname,\r\n                        Map       = \"        { \\\"\"..enumname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumClassBindingTable[classname], enumBinding)\r\n                else\r\n                    local enumBinding =\r\n                    {\r\n                        LuaName   = luaname,\r\n                        Map       = \"        { \\\"\"..luaname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }\r\n\r\n                    table.insert(enumBindingTable, enumBinding)\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1435,
    "text": "if not enumClassBindingTable[classname] then\r\n                        enumClassBindingTable[classname] = {}\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1436,
    "text": "enumClassBindingTable[classname] = {}",
    "type": "statement:assign"
  }, {
    "id": 1437,
    "text": "local enumBinding =\r\n                    {\r\n                        LuaName   = enumname,\r\n                        Map       = \"        { \\\"\"..enumname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }",
    "type": "statement:localassign"
  }, {
    "id": 1438,
    "text": "table.insert(enumClassBindingTable[classname], enumBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1439,
    "text": "local enumBinding =\r\n                    {\r\n                        LuaName   = luaname,\r\n                        Map       = \"        { \\\"\"..luaname..\"\\\", \"..namespace..member.Name..\" },\\n\",\r\n                        Condition = fullcondition\r\n                    }",
    "type": "statement:localassign"
  }, {
    "id": 1440,
    "text": "table.insert(enumBindingTable, enumBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1441,
    "text": "local value = member.Value or member.Name",
    "type": "statement:localassign"
  }, {
    "id": 1442,
    "text": "local defineBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1443,
    "text": "table.insert(defineBindingTable, defineBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1444,
    "text": "local stringBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", \"..value..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1445,
    "text": "table.insert(stringBindingTable, stringBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1446,
    "text": "local objectBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", &\"..member.Name..\", NULL },\\n\",\r\n                    Condition = fullcondition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1447,
    "text": "table.insert(objectBindingTable, objectBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1448,
    "text": "local pointerBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL, (const void **) &\"..member.Name..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1449,
    "text": "table.insert(pointerBindingTable, pointerBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1450,
    "text": "local eventBinding =\r\n                {\r\n                    LuaName   = luaname,\r\n                    Map       = \"        { \\\"\"..luaname..\"\\\", &\"..member.Name..\", &wxluatype_\"..MakeClassVar(parseObject.Name)..\" },\\n\",\r\n                    Condition = fullcondition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1451,
    "text": "table.insert(eventBindingTable, eventBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1452,
    "text": "local argList = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1453,
    "text": "local gcList = {}",
    "type": "statement:localassign"
  }, {
    "id": 1454,
    "text": "local arg = 0",
    "type": "statement:localassign"
  }, {
    "id": 1455,
    "text": "if (member[\"%operator\"] == \"++\") and (#member.Params > 0) then\r\n                    member.Name = \"op_preinc\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"--\") and (#member.Params > 0) then\r\n                    member.Name = \"op_predec\"\r\n                    member.Params = {}\r\n                elseif (member[\"%operator\"] == \"*\") and (#member.Params == 0) then\r\n                    member.Name = \"op_deref\"\r\n                    member.Params = {}\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1456,
    "text": "member.Name = \"op_preinc\"",
    "type": "statement:assign"
  }, {
    "id": 1457,
    "text": "member.Params = {}",
    "type": "statement:assign"
  }, {
    "id": 1458,
    "text": "member.Name = \"op_predec\"",
    "type": "statement:assign"
  }, {
    "id": 1459,
    "text": "member.Name = \"op_deref\"",
    "type": "statement:assign"
  }, {
    "id": 1460,
    "text": "while member.Params[arg+1] do\r\n                    arg = arg + 1\r\n                    local param = member.Params[arg]\r\n\r\n                    -- See if we're supposed to track or untrack the parameter\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%gc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+4)\r\n                        param.GC = true\r\n                    end\r\n                    local a = string.find(param.DataTypeWithAttrib, \"%ungc\", 1, 1)\r\n                    if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+6)\r\n                        param.UnGC = true\r\n                    end\r\n\r\n                    local declare = nil\r\n                    local argType = param.DataType\r\n                    local argTypeWithAttrib = param.DataTypeWithAttrib\r\n                    local argPtr = param.DataTypePointer[1]\r\n                    local argName = param.Name\r\n                    local argNum = nil\r\n                    local opt = param.DefaultValue\r\n                    local numeric = IsDataTypeNumeric(param.DataType)\r\n\r\n                    if member.IsConstructor or member[\"%function\"] or member.IsStaticFunction then\r\n                        argNum = arg -- don't have self\r\n                    else\r\n                        argNum = arg + 1\r\n                    end\r\n\r\n                    if not argName then\r\n                        argName = \"arg\"..arg\r\n\r\n                        param.Name = argName\r\n                    end\r\n\r\n                    if arg > 1 then\r\n                        argList = argList..\", \"\r\n                    end\r\n\r\n                    local indirectionCount = #param.DataTypePointer\r\n\r\n                    local isTranslated = nil\r\n                    local origArgType =  argType\r\n                    local origArgTypeWithAttrib = argTypeWithAttrib\r\n                    local origArgPtr = argPtr\r\n                    local origIndirectionCount = indirectionCount\r\n                    local argCast = nil\r\n                    local argListOverride = nil\r\n\r\n                    -- Does DataType need to be translated from typeDef\r\n                    TranslateDataType(param)\r\n                    if #param.TypedDataTypePointer ~= indirectionCount then\r\n                        indirectionCount = #param.TypedDataTypePointer\r\n\r\n                        -- translated datatype\r\n                        argType = param.TypedDataType\r\n                        argTypeWithAttrib = param.TypedDataTypeWithAttrib\r\n                        argPtr = param.TypedDataTypePointer[1]\r\n\r\n                        isTranslated = true\r\n                    end\r\n\r\n\r\n                    -- the function takes (void*), but we just pass a long\r\n                    if argType == \"voidptr_long\" then\r\n                        argType = \"long\"\r\n                        argTypeWithAttrib = \"long\"\r\n                        argCast = \"void*\"\r\n                    end\r\n\r\n                    -- our special notation to get wxString/IntArray from a Lua table of strings\r\n                    -- BUT! it has to be const wxArrayString& arr or wxArrayString arr\r\n                    --      and NOT wxArrayString& arr or wxArrayString* arr\r\n                    if ((argType == \"wxArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayString, \"\r\n                        argItem = \"wxlua_getwxArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayString\"\r\n                    elseif ((argType == \"wxSortedArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxSortedArrayString, \"\r\n                        argItem = \"wxlua_getwxSortedArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxSortedArrayString\"\r\n                    elseif ((argType == \"wxArrayInt\") and\r\n                            ((indirectionCount == 0) or\r\n                             ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayInt, \"\r\n                        argItem = \"wxlua_getwxArrayInt(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayInt\"\r\n                    elseif argType == \"IntArray_FromLuaTable\" then\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"NULL; ptr = \"..argName..\" = wxlua_getintarray(L, \"..argNum..\", count_)\"\r\n                        declare = \"int count_ = 0; wxLuaSmartIntArray ptr; int*\"\r\n                        argList = argList..\"count_, \"\r\n                    elseif argType == \"LuaTable\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif argType == \"LuaFunction\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TFUNCTION, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif (indirectionCount == 1) and (argPtr == \"[]\") then\r\n                        argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n\r\n                        if argType == \"wxString\" then\r\n                            -- overload_argList = overload_argList..\"&s_wxluaarg_StringArray, \" FIXME!\r\n                            -- Un 'const' strings\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getwxStringarray(\"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartStringArray \"\r\n                        elseif argType == \"int\" then\r\n                            -- Un 'const' ints\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getintarray(L, \"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartIntArray \"\r\n                        elseif not numeric then\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"*\") then\r\n                        if (argType == \"wxString\") or (argType == \"wxChar\") then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxT(\"..opt..\")\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n\r\n                            if (argType == \"wxChar\") then\r\n                                argTypeWithAttrib = \"wxString \"\r\n                                argListOverride = argName..\".IsEmpty() ? NULL : \"..argName..\".c_str()\"\r\n                            end\r\n\r\n                        elseif argType == \"char\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getstringtype(L, \"..argNum..\")\"\r\n\r\n                            argTypeWithAttrib = \"wxCharBuffer\"\r\n                            argCast = \"const char*\" -- allows for \"unsigned char*\"\r\n                        else\r\n                            if isTranslated and (origIndirectionCount == 0) then\r\n                                argTypeWithAttrib = origArgTypeWithAttrib\r\n                                argCast = origArgTypeWithAttrib\r\n                            else\r\n                                argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            end\r\n\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            if param.GC then\r\n                                if dataTypeTable[argType][\"%encapsulate\"] then\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")\r\n                                else\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")\r\n                                end\r\n                            elseif param.UnGC then\r\n                                table.insert(gcList, \"    if (wxluaO_isgcobject(L, \"..argName..\")) wxluaO_undeletegcobject(L, \"..argName..\");\\n\")\r\n                            end\r\n\r\n                        end\r\n                    elseif (indirectionCount == 2) and (argPtr == \"*\") then\r\n                        if not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" **\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"&\") then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        else\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            -- Default Value\r\n                            if opt then opt = \"&\"..opt end\r\n\r\n                            argList = argList..\"*\"\r\n                        end\r\n                    elseif indirectionCount == 0 then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        elseif IsDataTypeBool(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                            argItem = \"wxlua_getbooleantype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeEnum(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getenumtype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeUInt(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getuintegertype(L, \"..argNum..\")\"\r\n                        elseif not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argItem = \"*(\"..argTypeWithAttrib..\"*)wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getnumbertype(L, \"..argNum..\")\"\r\n                        end\r\n                    else\r\n                        local point = \"\"\r\n                        for z = 1, #param.TypedDataTypePointer do\r\n                            point = point..param.TypedDataTypePointer[z]\r\n                        end\r\n                        print(\"ERROR: Unsupported pointer indirection '\"..point..\"' \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    if argCast then\r\n                        argList = argList..\"(\"..argCast..\")\"\r\n                    end\r\n\r\n                    argList = argList..(argListOverride or argName)\r\n\r\n                    -- except for string arrays, the declare is the argType\r\n                    if not declare then\r\n                        declare = argTypeWithAttrib\r\n                    end\r\n\r\n                    if not param.Name then\r\n                        print(\"ERROR: No Param Name: \"..member.LineText..\" \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- interface.objectData[o].Members[m].Params[p]\r\n                    codeList = {}\r\n\r\n                    if opt then\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\" = \"..param.DefaultValue..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = (argCount >= \"..argNum..\" ? \"..argItem..\" : \"..opt..\");\\n\")\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = \"..argItem..\";\\n\")\r\n                    end\r\n\r\n                    local paramBinding =\r\n                    {\r\n                        ParamName = argName,\r\n                        ParamType = argType,\r\n                        ParamCast = argCast,\r\n                        ParamCode = codeList,\r\n                    }\r\n\r\n                    -- set param binding\r\n                    interface.objectData[o].Members[m].Params[arg].Binding = paramBinding\r\n                end",
    "type": "statement:while"
  }, {
    "id": 1461,
    "text": "arg = arg + 1",
    "type": "statement:assign"
  }, {
    "id": 1462,
    "text": "local param = member.Params[arg]",
    "type": "statement:localassign"
  }, {
    "id": 1463,
    "text": "local a = string.find(param.DataTypeWithAttrib, \"%gc\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 1464,
    "text": "if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+4)\r\n                        param.GC = true\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1465,
    "text": "param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+4)",
    "type": "statement:assign"
  }, {
    "id": 1466,
    "text": "param.GC = true",
    "type": "statement:assign"
  }, {
    "id": 1467,
    "text": "local a = string.find(param.DataTypeWithAttrib, \"%ungc\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 1468,
    "text": "if a then\r\n                        param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+6)\r\n                        param.UnGC = true\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1469,
    "text": "param.DataTypeWithAttrib = string.sub(param.DataTypeWithAttrib, 1, a-1)..string.sub(param.DataTypeWithAttrib, a+6)",
    "type": "statement:assign"
  }, {
    "id": 1470,
    "text": "param.UnGC = true",
    "type": "statement:assign"
  }, {
    "id": 1471,
    "text": "local declare = nil",
    "type": "statement:localassign"
  }, {
    "id": 1472,
    "text": "local argType = param.DataType",
    "type": "statement:localassign"
  }, {
    "id": 1473,
    "text": "local argTypeWithAttrib = param.DataTypeWithAttrib",
    "type": "statement:localassign"
  }, {
    "id": 1474,
    "text": "local argPtr = param.DataTypePointer[1]",
    "type": "statement:localassign"
  }, {
    "id": 1475,
    "text": "local argName = param.Name",
    "type": "statement:localassign"
  }, {
    "id": 1476,
    "text": "local argNum = nil",
    "type": "statement:localassign"
  }, {
    "id": 1477,
    "text": "local opt = param.DefaultValue",
    "type": "statement:localassign"
  }, {
    "id": 1478,
    "text": "local numeric = IsDataTypeNumeric(param.DataType)",
    "type": "statement:localassign"
  }, {
    "id": 1479,
    "text": "if member.IsConstructor or member[\"%function\"] or member.IsStaticFunction then\r\n                        argNum = arg -- don't have self\r\n                    else\r\n                        argNum = arg + 1\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1480,
    "text": "argNum = arg",
    "type": "statement:assign"
  }, {
    "id": 1481,
    "text": "argNum = arg + 1",
    "type": "statement:assign"
  }, {
    "id": 1482,
    "text": "if not argName then\r\n                        argName = \"arg\"..arg\r\n\r\n                        param.Name = argName\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1483,
    "text": "argName = \"arg\"..arg",
    "type": "statement:assign"
  }, {
    "id": 1484,
    "text": "param.Name = argName",
    "type": "statement:assign"
  }, {
    "id": 1485,
    "text": "if arg > 1 then\r\n                        argList = argList..\", \"\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1486,
    "text": "argList = argList..\", \"",
    "type": "statement:assign"
  }, {
    "id": 1487,
    "text": "local indirectionCount = #param.DataTypePointer",
    "type": "statement:localassign"
  }, {
    "id": 1488,
    "text": "local isTranslated = nil",
    "type": "statement:localassign"
  }, {
    "id": 1489,
    "text": "local origArgType =  argType",
    "type": "statement:localassign"
  }, {
    "id": 1490,
    "text": "local origArgTypeWithAttrib = argTypeWithAttrib",
    "type": "statement:localassign"
  }, {
    "id": 1491,
    "text": "local origArgPtr = argPtr",
    "type": "statement:localassign"
  }, {
    "id": 1492,
    "text": "local origIndirectionCount = indirectionCount",
    "type": "statement:localassign"
  }, {
    "id": 1493,
    "text": "local argCast = nil",
    "type": "statement:localassign"
  }, {
    "id": 1494,
    "text": "local argListOverride = nil",
    "type": "statement:localassign"
  }, {
    "id": 1495,
    "text": "TranslateDataType(param)",
    "type": "statement:functioncall"
  }, {
    "id": 1496,
    "text": "if #param.TypedDataTypePointer ~= indirectionCount then\r\n                        indirectionCount = #param.TypedDataTypePointer\r\n\r\n                        -- translated datatype\r\n                        argType = param.TypedDataType\r\n                        argTypeWithAttrib = param.TypedDataTypeWithAttrib\r\n                        argPtr = param.TypedDataTypePointer[1]\r\n\r\n                        isTranslated = true\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1497,
    "text": "indirectionCount = #param.TypedDataTypePointer",
    "type": "statement:assign"
  }, {
    "id": 1498,
    "text": "argType = param.TypedDataType",
    "type": "statement:assign"
  }, {
    "id": 1499,
    "text": "argTypeWithAttrib = param.TypedDataTypeWithAttrib",
    "type": "statement:assign"
  }, {
    "id": 1500,
    "text": "argPtr = param.TypedDataTypePointer[1]",
    "type": "statement:assign"
  }, {
    "id": 1501,
    "text": "isTranslated = true",
    "type": "statement:assign"
  }, {
    "id": 1502,
    "text": "if argType == \"voidptr_long\" then\r\n                        argType = \"long\"\r\n                        argTypeWithAttrib = \"long\"\r\n                        argCast = \"void*\"\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1503,
    "text": "argType = \"long\"",
    "type": "statement:assign"
  }, {
    "id": 1504,
    "text": "argTypeWithAttrib = \"long\"",
    "type": "statement:assign"
  }, {
    "id": 1505,
    "text": "argCast = \"void*\"",
    "type": "statement:assign"
  }, {
    "id": 1506,
    "text": "if ((argType == \"wxArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayString, \"\r\n                        argItem = \"wxlua_getwxArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayString\"\r\n                    elseif ((argType == \"wxSortedArrayString\") and\r\n                        ((indirectionCount == 0) or\r\n                         ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxSortedArrayString, \"\r\n                        argItem = \"wxlua_getwxSortedArrayString(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxSortedArrayString\"\r\n                    elseif ((argType == \"wxArrayInt\") and\r\n                            ((indirectionCount == 0) or\r\n                             ((indirectionCount == 1) and (argPtr == \"&\") and string.find(argTypeWithAttrib, \"const\", 1, 1)))) then\r\n                        overload_argList = overload_argList..\"&wxluatype_wxArrayInt, \"\r\n                        argItem = \"wxlua_getwxArrayInt(L, \"..argNum..\")\"\r\n                        declare = \"wxLuaSmartwxArrayInt\"\r\n                    elseif argType == \"IntArray_FromLuaTable\" then\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"NULL; ptr = \"..argName..\" = wxlua_getintarray(L, \"..argNum..\", count_)\"\r\n                        declare = \"int count_ = 0; wxLuaSmartIntArray ptr; int*\"\r\n                        argList = argList..\"count_, \"\r\n                    elseif argType == \"LuaTable\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif argType == \"LuaFunction\" then\r\n                        -- THIS MUST BE AN OVERRIDE AND HANDLED THERE, we just set overload_argList\r\n                        -- the code genererated here is nonsense\r\n                        overload_argList = overload_argList..\"&wxluatype_TFUNCTION, \"\r\n                        argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                        declare = \"YOU MUST OVERRIDE THIS FUNCTION \"\r\n                    elseif (indirectionCount == 1) and (argPtr == \"[]\") then\r\n                        argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n\r\n                        if argType == \"wxString\" then\r\n                            -- overload_argList = overload_argList..\"&s_wxluaarg_StringArray, \" FIXME!\r\n                            -- Un 'const' strings\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getwxStringarray(\"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartStringArray \"\r\n                        elseif argType == \"int\" then\r\n                            -- Un 'const' ints\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getintarray(L, \"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartIntArray \"\r\n                        elseif not numeric then\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"*\") then\r\n                        if (argType == \"wxString\") or (argType == \"wxChar\") then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxT(\"..opt..\")\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n\r\n                            if (argType == \"wxChar\") then\r\n                                argTypeWithAttrib = \"wxString \"\r\n                                argListOverride = argName..\".IsEmpty() ? NULL : \"..argName..\".c_str()\"\r\n                            end\r\n\r\n                        elseif argType == \"char\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getstringtype(L, \"..argNum..\")\"\r\n\r\n                            argTypeWithAttrib = \"wxCharBuffer\"\r\n                            argCast = \"const char*\" -- allows for \"unsigned char*\"\r\n                        else\r\n                            if isTranslated and (origIndirectionCount == 0) then\r\n                                argTypeWithAttrib = origArgTypeWithAttrib\r\n                                argCast = origArgTypeWithAttrib\r\n                            else\r\n                                argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            end\r\n\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            if param.GC then\r\n                                if dataTypeTable[argType][\"%encapsulate\"] then\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")\r\n                                else\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")\r\n                                end\r\n                            elseif param.UnGC then\r\n                                table.insert(gcList, \"    if (wxluaO_isgcobject(L, \"..argName..\")) wxluaO_undeletegcobject(L, \"..argName..\");\\n\")\r\n                            end\r\n\r\n                        end\r\n                    elseif (indirectionCount == 2) and (argPtr == \"*\") then\r\n                        if not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" **\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end\r\n                    elseif (indirectionCount == 1) and (argPtr == \"&\") then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        else\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            -- Default Value\r\n                            if opt then opt = \"&\"..opt end\r\n\r\n                            argList = argList..\"*\"\r\n                        end\r\n                    elseif indirectionCount == 0 then\r\n                        if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        elseif IsDataTypeBool(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                            argItem = \"wxlua_getbooleantype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeEnum(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getenumtype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeUInt(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getuintegertype(L, \"..argNum..\")\"\r\n                        elseif not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argItem = \"*(\"..argTypeWithAttrib..\"*)wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getnumbertype(L, \"..argNum..\")\"\r\n                        end\r\n                    else\r\n                        local point = \"\"\r\n                        for z = 1, #param.TypedDataTypePointer do\r\n                            point = point..param.TypedDataTypePointer[z]\r\n                        end\r\n                        print(\"ERROR: Unsupported pointer indirection '\"..point..\"' \"..LineTableErrString(member))\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1507,
    "text": "overload_argList = overload_argList..\"&wxluatype_wxArrayString, \"",
    "type": "statement:assign"
  }, {
    "id": 1508,
    "text": "argItem = \"wxlua_getwxArrayString(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1509,
    "text": "declare = \"wxLuaSmartwxArrayString\"",
    "type": "statement:assign"
  }, {
    "id": 1510,
    "text": "overload_argList = overload_argList..\"&wxluatype_wxSortedArrayString, \"",
    "type": "statement:assign"
  }, {
    "id": 1511,
    "text": "argItem = \"wxlua_getwxSortedArrayString(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1512,
    "text": "declare = \"wxLuaSmartwxSortedArrayString\"",
    "type": "statement:assign"
  }, {
    "id": 1513,
    "text": "overload_argList = overload_argList..\"&wxluatype_wxArrayInt, \"",
    "type": "statement:assign"
  }, {
    "id": 1514,
    "text": "argItem = \"wxlua_getwxArrayInt(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1515,
    "text": "declare = \"wxLuaSmartwxArrayInt\"",
    "type": "statement:assign"
  }, {
    "id": 1516,
    "text": "overload_argList = overload_argList..\"&wxluatype_TTABLE, \"",
    "type": "statement:assign"
  }, {
    "id": 1517,
    "text": "argItem = \"NULL; ptr = \"..argName..\" = wxlua_getintarray(L, \"..argNum..\", count_)\"",
    "type": "statement:assign"
  }, {
    "id": 1518,
    "text": "declare = \"int count_ = 0; wxLuaSmartIntArray ptr; int*\"",
    "type": "statement:assign"
  }, {
    "id": 1519,
    "text": "argList = argList..\"count_, \"",
    "type": "statement:assign"
  }, {
    "id": 1520,
    "text": "argItem = \"YOU MUST OVERRIDE THIS FUNCTION \"",
    "type": "statement:assign"
  }, {
    "id": 1521,
    "text": "declare = \"YOU MUST OVERRIDE THIS FUNCTION \"",
    "type": "statement:assign"
  }, {
    "id": 1522,
    "text": "overload_argList = overload_argList..\"&wxluatype_TFUNCTION, \"",
    "type": "statement:assign"
  }, {
    "id": 1523,
    "text": "argTypeWithAttrib = argTypeWithAttrib..\" *\"",
    "type": "statement:assign"
  }, {
    "id": 1524,
    "text": "if argType == \"wxString\" then\r\n                            -- overload_argList = overload_argList..\"&s_wxluaarg_StringArray, \" FIXME!\r\n                            -- Un 'const' strings\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getwxStringarray(\"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartStringArray \"\r\n                        elseif argType == \"int\" then\r\n                            -- Un 'const' ints\r\n                            if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end\r\n\r\n                            overload_argList = overload_argList..\"&wxluatype_TTABLE, \"\r\n                            argItem = \"wxlua_getintarray(L, \"..argNum..\", count)\"\r\n                            declare = \"int count = 0; wxLuaSmartIntArray \"\r\n                        elseif not numeric then\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1525,
    "text": "if string.sub(argTypeWithAttrib, 1, 6) == \"const \" then\r\n                                argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1526,
    "text": "argTypeWithAttrib = string.sub(argTypeWithAttrib, 7)",
    "type": "statement:assign"
  }, {
    "id": 1527,
    "text": "argItem = \"wxlua_getwxStringarray(\"..argNum..\", count)\"",
    "type": "statement:assign"
  }, {
    "id": 1528,
    "text": "declare = \"int count = 0; wxLuaSmartStringArray \"",
    "type": "statement:assign"
  }, {
    "id": 1529,
    "text": "argItem = \"wxlua_getintarray(L, \"..argNum..\", count)\"",
    "type": "statement:assign"
  }, {
    "id": 1530,
    "text": "declare = \"int count = 0; wxLuaSmartIntArray \"",
    "type": "statement:assign"
  }, {
    "id": 1531,
    "text": "argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1532,
    "text": "argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1533,
    "text": "if (argType == \"wxString\") or (argType == \"wxChar\") then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxT(\"..opt..\")\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n\r\n                            if (argType == \"wxChar\") then\r\n                                argTypeWithAttrib = \"wxString \"\r\n                                argListOverride = argName..\".IsEmpty() ? NULL : \"..argName..\".c_str()\"\r\n                            end\r\n\r\n                        elseif argType == \"char\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getstringtype(L, \"..argNum..\")\"\r\n\r\n                            argTypeWithAttrib = \"wxCharBuffer\"\r\n                            argCast = \"const char*\" -- allows for \"unsigned char*\"\r\n                        else\r\n                            if isTranslated and (origIndirectionCount == 0) then\r\n                                argTypeWithAttrib = origArgTypeWithAttrib\r\n                                argCast = origArgTypeWithAttrib\r\n                            else\r\n                                argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            end\r\n\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            if param.GC then\r\n                                if dataTypeTable[argType][\"%encapsulate\"] then\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")\r\n                                else\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")\r\n                                end\r\n                            elseif param.UnGC then\r\n                                table.insert(gcList, \"    if (wxluaO_isgcobject(L, \"..argName..\")) wxluaO_undeletegcobject(L, \"..argName..\");\\n\")\r\n                            end\r\n\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1534,
    "text": "argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1535,
    "text": "if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxT(\"..opt..\")\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1536,
    "text": "if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxT(\"..opt..\")\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1537,
    "text": "opt = \"wxString(wxEmptyString)\"",
    "type": "statement:assign"
  }, {
    "id": 1538,
    "text": "opt = \"wxT(\"..opt..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1539,
    "text": "opt = \"wxString(\"..opt..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1540,
    "text": "if (argType == \"wxChar\") then\r\n                                argTypeWithAttrib = \"wxString \"\r\n                                argListOverride = argName..\".IsEmpty() ? NULL : \"..argName..\".c_str()\"\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1541,
    "text": "argTypeWithAttrib = \"wxString \"",
    "type": "statement:assign"
  }, {
    "id": 1542,
    "text": "argListOverride = argName..\".IsEmpty() ? NULL : \"..argName..\".c_str()\"",
    "type": "statement:assign"
  }, {
    "id": 1543,
    "text": "argItem = \"wxlua_getstringtype(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1544,
    "text": "argTypeWithAttrib = \"wxCharBuffer\"",
    "type": "statement:assign"
  }, {
    "id": 1545,
    "text": "argCast = \"const char*\"",
    "type": "statement:assign"
  }, {
    "id": 1546,
    "text": "if isTranslated and (origIndirectionCount == 0) then\r\n                                argTypeWithAttrib = origArgTypeWithAttrib\r\n                                argCast = origArgTypeWithAttrib\r\n                            else\r\n                                argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1547,
    "text": "argTypeWithAttrib = origArgTypeWithAttrib",
    "type": "statement:assign"
  }, {
    "id": 1548,
    "text": "argCast = origArgTypeWithAttrib",
    "type": "statement:assign"
  }, {
    "id": 1549,
    "text": "if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1550,
    "text": "overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"",
    "type": "statement:assign"
  }, {
    "id": 1551,
    "text": "overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"",
    "type": "statement:assign"
  }, {
    "id": 1552,
    "text": "if param.GC then\r\n                                if dataTypeTable[argType][\"%encapsulate\"] then\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")\r\n                                else\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")\r\n                                end\r\n                            elseif param.UnGC then\r\n                                table.insert(gcList, \"    if (wxluaO_isgcobject(L, \"..argName..\")) wxluaO_undeletegcobject(L, \"..argName..\");\\n\")\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1553,
    "text": "if dataTypeTable[argType][\"%encapsulate\"] then\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")\r\n                                else\r\n                                    table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1554,
    "text": "table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, (void*)\"..argName..\", new wxLua_wxObject_\"..MakeVar(argType)..\"(\"..argName..\"));\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1555,
    "text": "table.insert(gcList, \"    if (!wxluaO_isgcobject(L, \"..argName..\")) wxluaO_addgcobject(L, \"..argName..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1556,
    "text": "table.insert(gcList, \"    if (wxluaO_isgcobject(L, \"..argName..\")) wxluaO_undeletegcobject(L, \"..argName..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1557,
    "text": "if not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" **\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1558,
    "text": "argTypeWithAttrib = argTypeWithAttrib..\" **\"",
    "type": "statement:assign"
  }, {
    "id": 1559,
    "text": "if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        else\r\n                            argTypeWithAttrib = argTypeWithAttrib..\" *\"\r\n                            if not numeric then\r\n                                overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                            else\r\n                                overload_argList = overload_argList..\"&wxluatype_TLIGHTUSERDATA, \"\r\n                                argItem = \"(\"..argTypeWithAttrib..\")wxlua_touserdata(L, \"..argNum..\")\"\r\n                            end\r\n\r\n                            -- Default Value\r\n                            if opt then opt = \"&\"..opt end\r\n\r\n                            argList = argList..\"*\"\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1560,
    "text": "if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1561,
    "text": "if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1562,
    "text": "opt = \"wxString(wxT(\"..opt..\"))\"",
    "type": "statement:assign"
  }, {
    "id": 1563,
    "text": "if opt then opt = \"&\"..opt end",
    "type": "statement:if"
  }, {
    "id": 1564,
    "text": "opt = \"&\"..opt",
    "type": "statement:assign"
  }, {
    "id": 1565,
    "text": "argList = argList..\"*\"",
    "type": "statement:assign"
  }, {
    "id": 1566,
    "text": "if argType == \"wxString\" then\r\n                            overload_argList = overload_argList..\"&wxluatype_TSTRING, \"\r\n                            argItem = \"wxlua_getwxStringtype(L, \"..argNum..\")\"\r\n\r\n                            -- Default String Value\r\n                            if opt then\r\n                                if (opt == \"\\\"\\\"\") or (opt == \"wxEmptyString\") or (opt == \"NULL\") then\r\n                                    opt = \"wxString(wxEmptyString)\"\r\n                                elseif string.sub(opt, 1, 1) == \"\\\"\" then\r\n                                    opt = \"wxString(wxT(\"..opt..\"))\"\r\n                                else\r\n                                    opt = \"wxString(\"..opt..\")\"\r\n                                end\r\n                            end\r\n                        elseif IsDataTypeBool(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TBOOLEAN, \"\r\n                            argItem = \"wxlua_getbooleantype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeEnum(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getenumtype(L, \"..argNum..\")\"\r\n                        elseif IsDataTypeUInt(argTypeWithAttrib) then\r\n                            overload_argList = overload_argList..\"&wxluatype_TINTEGER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getuintegertype(L, \"..argNum..\")\"\r\n                        elseif not numeric then\r\n                            overload_argList = overload_argList..\"&wxluatype_\"..MakeClassVar(argType)..\", \"\r\n                            argItem = \"*(\"..argTypeWithAttrib..\"*)wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"\r\n                        else\r\n                            overload_argList = overload_argList..\"&wxluatype_TNUMBER, \"\r\n                            argItem = \"(\"..argTypeWithAttrib..\")wxlua_getnumbertype(L, \"..argNum..\")\"\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1567,
    "text": "argItem = \"wxlua_getbooleantype(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1568,
    "text": "argItem = \"(\"..argTypeWithAttrib..\")wxlua_getenumtype(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1569,
    "text": "argItem = \"(\"..argTypeWithAttrib..\")wxlua_getuintegertype(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1570,
    "text": "argItem = \"*(\"..argTypeWithAttrib..\"*)wxluaT_getuserdatatype(L, \"..argNum..\", wxluatype_\"..MakeClassVar(argType)..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1571,
    "text": "argItem = \"(\"..argTypeWithAttrib..\")wxlua_getnumbertype(L, \"..argNum..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1572,
    "text": "local point = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1573,
    "text": "for z = 1, #param.TypedDataTypePointer do\r\n                            point = point..param.TypedDataTypePointer[z]\r\n                        end",
    "type": "statement:numericfor"
  }, {
    "id": 1574,
    "text": "point = point..param.TypedDataTypePointer[z]",
    "type": "statement:assign"
  }, {
    "id": 1575,
    "text": "print(\"ERROR: Unsupported pointer indirection '\"..point..\"' \"..LineTableErrString(member))",
    "type": "statement:functioncall"
  }, {
    "id": 1576,
    "text": "if argCast then\r\n                        argList = argList..\"(\"..argCast..\")\"\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1577,
    "text": "argList = argList..\"(\"..argCast..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1578,
    "text": "argList = argList..(argListOverride or argName)",
    "type": "statement:assign"
  }, {
    "id": 1579,
    "text": "if not declare then\r\n                        declare = argTypeWithAttrib\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1580,
    "text": "declare = argTypeWithAttrib",
    "type": "statement:assign"
  }, {
    "id": 1581,
    "text": "if not param.Name then\r\n                        print(\"ERROR: No Param Name: \"..member.LineText..\" \"..LineTableErrString(member))\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1582,
    "text": "print(\"ERROR: No Param Name: \"..member.LineText..\" \"..LineTableErrString(member))",
    "type": "statement:functioncall"
  }, {
    "id": 1583,
    "text": "if opt then\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\" = \"..param.DefaultValue..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = (argCount >= \"..argNum..\" ? \"..argItem..\" : \"..opt..\");\\n\")\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\"\\n\")\r\n                        table.insert(codeList, \"    \"..declare..\" \"..argName..\" = \"..argItem..\";\\n\")\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1584,
    "text": "CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\" = \"..param.DefaultValue..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1585,
    "text": "table.insert(codeList, \"    \"..declare..\" \"..argName..\" = (argCount >= \"..argNum..\" ? \"..argItem..\" : \"..opt..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1586,
    "text": "CommentBindingTable(codeList, \"    // \"..param.DataTypeWithAttrib..\" \"..param.Name..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1587,
    "text": "table.insert(codeList, \"    \"..declare..\" \"..argName..\" = \"..argItem..\";\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1588,
    "text": "local paramBinding =\r\n                    {\r\n                        ParamName = argName,\r\n                        ParamType = argType,\r\n                        ParamCast = argCast,\r\n                        ParamCode = codeList,\r\n                    }",
    "type": "statement:localassign"
  }, {
    "id": 1589,
    "text": "interface.objectData[o].Members[m].Params[arg].Binding = paramBinding",
    "type": "statement:assign"
  }, {
    "id": 1590,
    "text": "local funcType = nil",
    "type": "statement:localassign"
  }, {
    "id": 1591,
    "text": "local funcName = nil",
    "type": "statement:localassign"
  }, {
    "id": 1592,
    "text": "local funcNameBase = nil",
    "type": "statement:localassign"
  }, {
    "id": 1593,
    "text": "local funcLuaCall = nil",
    "type": "statement:localassign"
  }, {
    "id": 1594,
    "text": "if member.IsConstructor or (member.Name == parseObject.Name) then\r\n                    member.IsConstructor = true\r\n                    funcName = \"wxLua_\"..MakeVar(member[\"%rename\"] or member.Name)..\"_constructor\"\r\n                    funcNameBase = funcName\r\n\r\n                    funcType = \"WXLUAMETHOD_CONSTRUCTOR\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif member.Name == \"~\"..parseObject.Name then\r\n                    print(\"WARNING: Unhandled ~ destructor \", member.Name, parseObject.Name);\r\n                elseif member.IsStaticFunction then\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_METHOD|WXLUAMETHOD_STATIC\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                elseif (parseObject.Name == \"globals\") or member[\"%function\"] then\r\n                    funcName = \"wxLua_function_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n                    funcType = \"WXLUAMETHOD_CFUNCTION\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                else\r\n                    if not parseObject.Name then\r\n                        print(\"ERROR: parseObject.Name = nil \"..LineTableErrString(member))\r\n                    end\r\n\r\n                    -- special case for unary -, convert from op_sub to op_neg if necessary\r\n                    if member[\"%operator\"] and (#member.Params == 0) and (member.Name == \"op_sub\") then\r\n                        member.Name = \"op_neg\"\r\n                        if member[\"%rename\"] == \"op_sub\" then -- maybe they renamed it?\r\n                            member[\"%rename\"] = \"op_neg\"\r\n                        end\r\n                    end\r\n\r\n                    funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)\r\n\r\n                    funcType = \"WXLUAMETHOD_METHOD\"\r\n                    funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1595,
    "text": "member.IsConstructor = true",
    "type": "statement:assign"
  }, {
    "id": 1596,
    "text": "funcName = \"wxLua_\"..MakeVar(member[\"%rename\"] or member.Name)..\"_constructor\"",
    "type": "statement:assign"
  }, {
    "id": 1597,
    "text": "funcNameBase = funcName",
    "type": "statement:assign"
  }, {
    "id": 1598,
    "text": "funcType = \"WXLUAMETHOD_CONSTRUCTOR\"",
    "type": "statement:assign"
  }, {
    "id": 1599,
    "text": "funcLuaCall = MakeVar(member[\"%rename\"] or member.Name)",
    "type": "statement:assign"
  }, {
    "id": 1600,
    "text": "print(\"WARNING: Unhandled ~ destructor \", member.Name, parseObject.Name)",
    "type": "statement:functioncall"
  }, {
    "id": 1601,
    "text": "funcName = \"wxLua_\"..MakeVar(parseObject.Name)..\"_\"..MakeVar(member[\"%rename\"] or member.Name)",
    "type": "statement:assign"
  }, {
    "id": 1602,
    "text": "funcName = \"wxLua_function_\"..MakeVar(member[\"%rename\"] or member.Name)",
    "type": "statement:assign"
  }, {
    "id": 1603,
    "text": "funcType = \"WXLUAMETHOD_CFUNCTION\"",
    "type": "statement:assign"
  }, {
    "id": 1604,
    "text": "if not parseObject.Name then\r\n                        print(\"ERROR: parseObject.Name = nil \"..LineTableErrString(member))\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1605,
    "text": "print(\"ERROR: parseObject.Name = nil \"..LineTableErrString(member))",
    "type": "statement:functioncall"
  }, {
    "id": 1606,
    "text": "if member[\"%operator\"] and (#member.Params == 0) and (member.Name == \"op_sub\") then\r\n                        member.Name = \"op_neg\"\r\n                        if member[\"%rename\"] == \"op_sub\" then -- maybe they renamed it?\r\n                            member[\"%rename\"] = \"op_neg\"\r\n                        end\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1607,
    "text": "member.Name = \"op_neg\"",
    "type": "statement:assign"
  }, {
    "id": 1608,
    "text": "if member[\"%rename\"] == \"op_sub\" then -- maybe they renamed it?\r\n                            member[\"%rename\"] = \"op_neg\"\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1609,
    "text": "member[\"%rename\"] = \"op_neg\"",
    "type": "statement:assign"
  }, {
    "id": 1610,
    "text": "funcType = \"WXLUAMETHOD_METHOD\"",
    "type": "statement:assign"
  }, {
    "id": 1611,
    "text": "if not funcNameBase then funcNameBase = funcName end",
    "type": "statement:if"
  }, {
    "id": 1612,
    "text": "if (member.NotOverload ~= true) then\r\n                    if overloadCount[funcName] then\r\n                        overloadCount[funcName] = overloadCount[funcName] + 1\r\n                        funcName = funcName..tostring(overloadCount[funcName]-1)\r\n                    else\r\n                        overloadCount[funcName] = 1\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1613,
    "text": "if overloadCount[funcName] then\r\n                        overloadCount[funcName] = overloadCount[funcName] + 1\r\n                        funcName = funcName..tostring(overloadCount[funcName]-1)\r\n                    else\r\n                        overloadCount[funcName] = 1\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1614,
    "text": "overloadCount[funcName] = overloadCount[funcName] + 1",
    "type": "statement:assign"
  }, {
    "id": 1615,
    "text": "funcName = funcName..tostring(overloadCount[funcName]-1)",
    "type": "statement:assign"
  }, {
    "id": 1616,
    "text": "overloadCount[funcName] = 1",
    "type": "statement:assign"
  }, {
    "id": 1617,
    "text": "local a = string.find(member.DataTypeWithAttrib, \"%gc\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 1618,
    "text": "if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+4)\r\n                    member.GC = true\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1619,
    "text": "member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+4)",
    "type": "statement:assign"
  }, {
    "id": 1620,
    "text": "member.GC = true",
    "type": "statement:assign"
  }, {
    "id": 1621,
    "text": "local a = string.find(member.DataTypeWithAttrib, \"%ungc\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 1622,
    "text": "if a then\r\n                    member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+6)\r\n                    member.UnGC = true\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1623,
    "text": "member.DataTypeWithAttrib = string.sub(member.DataTypeWithAttrib, 1, a-1)..string.sub(member.DataTypeWithAttrib, a+6)",
    "type": "statement:assign"
  }, {
    "id": 1624,
    "text": "member.UnGC = true",
    "type": "statement:assign"
  }, {
    "id": 1625,
    "text": "local memberType = member.DataType",
    "type": "statement:localassign"
  }, {
    "id": 1626,
    "text": "local memberTypeWithAttrib = member.DataTypeWithAttrib",
    "type": "statement:localassign"
  }, {
    "id": 1627,
    "text": "local origMemberType =  memberType",
    "type": "statement:localassign"
  }, {
    "id": 1628,
    "text": "local origMemberTypeWithAttrib = memberTypeWithAttrib",
    "type": "statement:localassign"
  }, {
    "id": 1629,
    "text": "local origMemberPtr = memberPtr",
    "type": "statement:localassign"
  }, {
    "id": 1630,
    "text": "local memberCast = nil",
    "type": "statement:localassign"
  }, {
    "id": 1631,
    "text": "TranslateDataType(member)",
    "type": "statement:functioncall"
  }, {
    "id": 1632,
    "text": "if #member.TypedDataTypePointer ~= indirectionCount then\r\n                    indirectionCount = #member.TypedDataTypePointer\r\n\r\n                    -- translated datatype\r\n                    memberType = member.TypedDataType\r\n                    memberTypeWithAttrib = member.TypedDataTypeWithAttrib\r\n                    memberPtr = member.TypedDataTypePointer[1]\r\n\r\n                    isTranslated = true\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1633,
    "text": "indirectionCount = #member.TypedDataTypePointer",
    "type": "statement:assign"
  }, {
    "id": 1634,
    "text": "memberType = member.TypedDataType",
    "type": "statement:assign"
  }, {
    "id": 1635,
    "text": "memberTypeWithAttrib = member.TypedDataTypeWithAttrib",
    "type": "statement:assign"
  }, {
    "id": 1636,
    "text": "memberPtr = member.TypedDataTypePointer[1]",
    "type": "statement:assign"
  }, {
    "id": 1637,
    "text": "local returnPtr = \"*\"",
    "type": "statement:localassign"
  }, {
    "id": 1638,
    "text": "if (memberType ~= \"void\") or (indirectionCount > 0) then\r\n                    if numeric and ((indirectionCount == 0) or (memberPtr == \"&\"))  then\r\n                        returnPtr = \"\"\r\n                    end\r\n\r\n                    if isTranslated and (indirectionCount == 1) and (origIndirectionCount == 0) then\r\n                        memberTypeWithAttrib = origMemberTypeWithAttrib..\" \"\r\n                        memberCast = origMemberTypeWithAttrib\r\n                    else\r\n                        memberTypeWithAttrib = memberTypeWithAttrib..returnPtr\r\n                    end\r\n\r\n                    -- Un 'const' strings and non-pointer datatypes\r\n                    if (string.sub(memberTypeWithAttrib, 1, 6) == \"const \") and ((memberType == \"wxString\") or (returnPtr == \"\") or member.IsConstructor) then\r\n                        memberTypeWithAttrib = string.sub(memberTypeWithAttrib, 7)\r\n                    end\r\n\r\n                    if string.find(\"voidptr_long\", memberTypeWithAttrib, 1, 1) then\r\n                        memberTypeWithAttrib = \"long \"\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1639,
    "text": "if numeric and ((indirectionCount == 0) or (memberPtr == \"&\"))  then\r\n                        returnPtr = \"\"\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1640,
    "text": "returnPtr = \"\"",
    "type": "statement:assign"
  }, {
    "id": 1641,
    "text": "if isTranslated and (indirectionCount == 1) and (origIndirectionCount == 0) then\r\n                        memberTypeWithAttrib = origMemberTypeWithAttrib..\" \"\r\n                        memberCast = origMemberTypeWithAttrib\r\n                    else\r\n                        memberTypeWithAttrib = memberTypeWithAttrib..returnPtr\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1642,
    "text": "memberTypeWithAttrib = origMemberTypeWithAttrib..\" \"",
    "type": "statement:assign"
  }, {
    "id": 1643,
    "text": "memberCast = origMemberTypeWithAttrib",
    "type": "statement:assign"
  }, {
    "id": 1644,
    "text": "memberTypeWithAttrib = memberTypeWithAttrib..returnPtr",
    "type": "statement:assign"
  }, {
    "id": 1645,
    "text": "if (string.sub(memberTypeWithAttrib, 1, 6) == \"const \") and ((memberType == \"wxString\") or (returnPtr == \"\") or member.IsConstructor) then\r\n                        memberTypeWithAttrib = string.sub(memberTypeWithAttrib, 7)\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1646,
    "text": "memberTypeWithAttrib = string.sub(memberTypeWithAttrib, 7)",
    "type": "statement:assign"
  }, {
    "id": 1647,
    "text": "if string.find(\"voidptr_long\", memberTypeWithAttrib, 1, 1) then\r\n                        memberTypeWithAttrib = \"long \"\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1648,
    "text": "memberTypeWithAttrib = \"long \"",
    "type": "statement:assign"
  }, {
    "id": 1649,
    "text": "local returnCondition = GetDataTypeCondition(memberType)",
    "type": "statement:localassign"
  }, {
    "id": 1650,
    "text": "local requiredParamCount = 0",
    "type": "statement:localassign"
  }, {
    "id": 1651,
    "text": "local paramCount = #member.Params",
    "type": "statement:localassign"
  }, {
    "id": 1652,
    "text": "if  paramCount > 0 then\r\n                    for arg=1, paramCount do\r\n                        if not member.Params[arg].DefaultValue then\r\n                            requiredParamCount = requiredParamCount + 1\r\n                        elseif member.Params[arg+1] and (not member.Params[arg+1].DefaultValue) then\r\n                            print(\"ERROR: Missing default arg #\"..tostring(arg+1)..\" in function. \"..LineTableErrString(member))\r\n                        end\r\n                    end\r\n\r\n                    if requiredParamCount ~= paramCount then\r\n                        CommentBindingTable(codeList, \"    // get number of arguments\\n\")\r\n                        table.insert(codeList, \"    int argCount = lua_gettop(L);\\n\")\r\n                    end\r\n\r\n                    for arg = 1, paramCount do\r\n                        -- add function code to get args (in reverse order)\r\n                        local paramLineCount = #(member.Params[paramCount + 1 - arg].Binding.ParamCode)\r\n                        for paramLine=1, paramLineCount do\r\n                            table.insert(codeList, member.Params[paramCount + 1 - arg].Binding.ParamCode[paramLine])\r\n                        end\r\n\r\n                        -- param conditions\r\n                        local paramCondition = GetDataTypeCondition(member.Params[arg].DataType)\r\n                        if paramCondition then\r\n                            dependConditions[paramCondition] = paramCondition\r\n                        end\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1653,
    "text": "for arg=1, paramCount do\r\n                        if not member.Params[arg].DefaultValue then\r\n                            requiredParamCount = requiredParamCount + 1\r\n                        elseif member.Params[arg+1] and (not member.Params[arg+1].DefaultValue) then\r\n                            print(\"ERROR: Missing default arg #\"..tostring(arg+1)..\" in function. \"..LineTableErrString(member))\r\n                        end\r\n                    end",
    "type": "statement:numericfor"
  }, {
    "id": 1654,
    "text": "if not member.Params[arg].DefaultValue then\r\n                            requiredParamCount = requiredParamCount + 1\r\n                        elseif member.Params[arg+1] and (not member.Params[arg+1].DefaultValue) then\r\n                            print(\"ERROR: Missing default arg #\"..tostring(arg+1)..\" in function. \"..LineTableErrString(member))\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1655,
    "text": "requiredParamCount = requiredParamCount + 1",
    "type": "statement:assign"
  }, {
    "id": 1656,
    "text": "print(\"ERROR: Missing default arg #\"..tostring(arg+1)..\" in function. \"..LineTableErrString(member))",
    "type": "statement:functioncall"
  }, {
    "id": 1657,
    "text": "if requiredParamCount ~= paramCount then\r\n                        CommentBindingTable(codeList, \"    // get number of arguments\\n\")\r\n                        table.insert(codeList, \"    int argCount = lua_gettop(L);\\n\")\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1658,
    "text": "CommentBindingTable(codeList, \"    // get number of arguments\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1659,
    "text": "table.insert(codeList, \"    int argCount = lua_gettop(L);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1660,
    "text": "for arg = 1, paramCount do\r\n                        -- add function code to get args (in reverse order)\r\n                        local paramLineCount = #(member.Params[paramCount + 1 - arg].Binding.ParamCode)\r\n                        for paramLine=1, paramLineCount do\r\n                            table.insert(codeList, member.Params[paramCount + 1 - arg].Binding.ParamCode[paramLine])\r\n                        end\r\n\r\n                        -- param conditions\r\n                        local paramCondition = GetDataTypeCondition(member.Params[arg].DataType)\r\n                        if paramCondition then\r\n                            dependConditions[paramCondition] = paramCondition\r\n                        end\r\n                    end",
    "type": "statement:numericfor"
  }, {
    "id": 1661,
    "text": "local paramLineCount = #(member.Params[paramCount + 1 - arg].Binding.ParamCode)",
    "type": "statement:localassign"
  }, {
    "id": 1662,
    "text": "for paramLine=1, paramLineCount do\r\n                            table.insert(codeList, member.Params[paramCount + 1 - arg].Binding.ParamCode[paramLine])\r\n                        end",
    "type": "statement:numericfor"
  }, {
    "id": 1663,
    "text": "table.insert(codeList, member.Params[paramCount + 1 - arg].Binding.ParamCode[paramLine])",
    "type": "statement:functioncall"
  }, {
    "id": 1664,
    "text": "local paramCondition = GetDataTypeCondition(member.Params[arg].DataType)",
    "type": "statement:localassign"
  }, {
    "id": 1665,
    "text": "if paramCondition then\r\n                            dependConditions[paramCondition] = paramCondition\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1666,
    "text": "dependConditions[paramCondition] = paramCondition",
    "type": "statement:assign"
  }, {
    "id": 1667,
    "text": "for i = 1, #gcList do\r\n                    table.insert(codeList, gcList[i])\r\n                end",
    "type": "statement:numericfor"
  }, {
    "id": 1668,
    "text": "table.insert(codeList, gcList[i])",
    "type": "statement:functioncall"
  }, {
    "id": 1669,
    "text": "if member.IsConstructor then\r\n                    CommentBindingTable(codeList, \"    // call constructor\\n\")\r\n                    table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..parseObject.Name..\"(\"..argList..\");\\n\")\r\n\r\n                    if parseObject[\"%gc_this\"] or (parseObject[\"%delete\"] and (not parseObject[\"%ungc_this\"])) then\r\n                        CommentBindingTable(codeList, \"    // add to tracked memory list\\n\")\r\n\r\n                        -- Un 'const' AddTrackedObject\r\n                        local returnCast = memberTypeWithAttrib\r\n                        if string.sub(returnCast, 1, 6) == \"const \" then\r\n                            returnCast = string.sub(returnCast, 7)\r\n                        end\r\n\r\n                        if parseObject[\"%encapsulate\"] then\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(parseObject.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                        else\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, returns);\\n\")\r\n                        end\r\n                    elseif not parseObject[\"%noclassinfo\"] then\r\n                        CommentBindingTable(codeList, \"    // add to tracked window list, it will check validity\\n\")\r\n                        table.insert(codeList, \"    wxluaW_addtrackedwindow(L, returns);\\n\")\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // push the constructed class pointer\\n\")\r\n                    table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n\r\n                    table.insert(codeList, \"\\n    return 1;\\n\")\r\n                    table.insert(codeList, \"}\\n\")\r\n                else\r\n                    -- how we call c-function\r\n                    if parseObject.Name == \"globals\" then\r\n                        functor = member.Name   -- global\r\n                    elseif member.IsStaticFunction then\r\n                        functor = parseObject.Name..\"::\"..member.Name -- static member function\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // get this\\n\")\r\n\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\" * self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                        overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                        if parseObject[\"%ungc_this\"] then\r\n                            table.insert(codeList, \"    wxluaO_undeletegcobject(L, self);\\n\")\r\n                        elseif parseObject[\"%gc_this\"] then\r\n                            if parseObject[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    if (!wxluaO_isgcobject(L, self)) wxluaO_addgcobject(L, (void*)self, new wxLua_wxObject_\"..MakeClassVar(parseObject.Name)..\"(self));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, self);\\n\")\r\n                            end\r\n                        end\r\n\r\n                        requiredParamCount = requiredParamCount + 1\r\n                        paramCount = paramCount + 1\r\n\r\n                        if member[\"%operator\"] then\r\n                            if (member.Name == \"op_preinc\") or (member.Name == \"op_predec\") then\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            elseif (member.Name == \"op_inc\") or (member.Name == \"op_dec\") then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            elseif member[\"%operator\"] == \"[]\" then     -- op_index\r\n                                functor = \"(*self)[\"\r\n                            elseif member[\"%operator\"] == \"()\" then -- op_func\r\n                                functor = \"(*self)\"\r\n                            elseif paramCount > 1 then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            else\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            end\r\n                        -- static member function?\r\n                        elseif string.find(member.Name, \"::\") then\r\n                            functor = member.Name\r\n                        else\r\n                            functor = \"self->\"..member.Name\r\n                        end\r\n                    end\r\n\r\n                    -- need cast?\r\n                    if memberCast then\r\n                        functor  = \"(\"..memberCast..\")\"..functor\r\n                    end\r\n\r\n                    local is_func = iff(not member[\"%operator\"] and member.IsFunction, true, false)\r\n\r\n                    -- Add Function Argument List\r\n                    if (argList ~= \"\") or is_func then\r\n                        functor = functor..\"(\"..argList..\")\"\r\n                    end\r\n\r\n                    if member[\"%operator\"] == \"[]\" then -- op_index\r\n                        functor = functor..\"]\"\r\n                    end\r\n\r\n                    CommentBindingTable(codeList, \"    // call \"..member.Name..\"\\n\")\r\n\r\n                    if not memberType or (memberTypeWithAttrib == \"void\") then\r\n                        -- call (void) function\r\n                        table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                        table.insert(codeList, \"\\n    return 0;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    else\r\n                        -- call function, get return value\r\n                        if member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and string.find(member[\"%operator\"], \"=\", 1, 1) then\r\n                            table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = self;\\n\")\r\n                        elseif member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and (string.find(member[\"%operator\"], \"=\", 1, 1) == nil) then\r\n                            if string.find(memberTypeWithAttrib or \"\", \"*\", 1, 1) then\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &(\"..functor..\");\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = \"..functor..\";\\n\")\r\n                            end\r\n                        elseif (not numeric) and (not memberPtr) then\r\n                            CommentBindingTable(codeList, \"    // allocate a new object using the copy constructor\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..memberType..\"(\"..functor..\");\\n\")\r\n                            CommentBindingTable(codeList, \"    // add the new object to the tracked memory list\\n\")\r\n\r\n                            -- Un 'const' AddTrackedObject\r\n                            local returnCast = memberTypeWithAttrib\r\n                            if string.sub(returnCast, 1, 6) == \"const \" then\r\n                                returnCast = string.sub(returnCast, 7)\r\n                            end\r\n\r\n                            local member_DataType = GetDataTypedefBase(memberType)\r\n\r\n                            if member_DataType[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(member_DataType.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (\"..returnCast..\")returns);\\n\")\r\n                            end\r\n\r\n                        elseif (not member[\"%operator\"]) and (memberPtr == \"&\") and string.find(memberTypeWithAttrib, \"*\") and (memberType ~= \"wxString\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &\"..functor..\";\\n\")\r\n                        elseif (memberPtr == \"*\") or (memberType == \"voidptr_long\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..memberTypeWithAttrib..\")\"..functor..\";\\n\")\r\n\r\n                            if member.GC then\r\n                                if dataTypeTable[memberType][\"%encapsulate\"] then\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")\r\n                                else\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")\r\n                                end\r\n                            elseif member.UnGC then\r\n                                table.insert(codeList, \"    if (wxluaO_isgcobject(L, returns)) wxluaO_undeletegcobject(L, returns);\\n\")\r\n                            end\r\n\r\n                        else\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..functor..\");\\n\")\r\n                        end\r\n\r\n                        -- bind return value\r\n                        if memberType == \"wxString\" then\r\n                            CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                            table.insert(codeList, \"    wxlua_pushwxString(L, \"..returnPtr..\"returns);\\n\")\r\n                        elseif not numeric then\r\n                            CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                            table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                        elseif IsDataTypeBool(member.DataType) then\r\n                            CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                            table.insert(codeList, \"    lua_pushboolean(L, returns);\\n\")\r\n                        elseif returnPtr == \"*\" then\r\n                            CommentBindingTable(codeList, \"    // push the result pointer\\n\")\r\n                            table.insert(codeList, \"    lua_pushlightuserdata(L, (void *)returns);\\n\")\r\n                        else -- Number\r\n                            CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                            table.insert(codeList, \"    lua_pushnumber(L, returns);\\n\")\r\n                        end\r\n\r\n                        table.insert(codeList, \"\\n    return 1;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1670,
    "text": "CommentBindingTable(codeList, \"    // call constructor\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1671,
    "text": "table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..parseObject.Name..\"(\"..argList..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1672,
    "text": "if parseObject[\"%gc_this\"] or (parseObject[\"%delete\"] and (not parseObject[\"%ungc_this\"])) then\r\n                        CommentBindingTable(codeList, \"    // add to tracked memory list\\n\")\r\n\r\n                        -- Un 'const' AddTrackedObject\r\n                        local returnCast = memberTypeWithAttrib\r\n                        if string.sub(returnCast, 1, 6) == \"const \" then\r\n                            returnCast = string.sub(returnCast, 7)\r\n                        end\r\n\r\n                        if parseObject[\"%encapsulate\"] then\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(parseObject.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                        else\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, returns);\\n\")\r\n                        end\r\n                    elseif not parseObject[\"%noclassinfo\"] then\r\n                        CommentBindingTable(codeList, \"    // add to tracked window list, it will check validity\\n\")\r\n                        table.insert(codeList, \"    wxluaW_addtrackedwindow(L, returns);\\n\")\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1673,
    "text": "CommentBindingTable(codeList, \"    // add to tracked memory list\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1674,
    "text": "local returnCast = memberTypeWithAttrib",
    "type": "statement:localassign"
  }, {
    "id": 1675,
    "text": "if string.sub(returnCast, 1, 6) == \"const \" then\r\n                            returnCast = string.sub(returnCast, 7)\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1676,
    "text": "returnCast = string.sub(returnCast, 7)",
    "type": "statement:assign"
  }, {
    "id": 1677,
    "text": "if parseObject[\"%encapsulate\"] then\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(parseObject.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                        else\r\n                            table.insert(codeList, \"    wxluaO_addgcobject(L, returns);\\n\")\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1678,
    "text": "table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(parseObject.Name)..\"((\"..returnCast..\")returns));\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1679,
    "text": "table.insert(codeList, \"    wxluaO_addgcobject(L, returns);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1680,
    "text": "CommentBindingTable(codeList, \"    // add to tracked window list, it will check validity\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1681,
    "text": "table.insert(codeList, \"    wxluaW_addtrackedwindow(L, returns);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1682,
    "text": "CommentBindingTable(codeList, \"    // push the constructed class pointer\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1683,
    "text": "table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1684,
    "text": "table.insert(codeList, \"\\n    return 1;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1685,
    "text": "if parseObject.Name == \"globals\" then\r\n                        functor = member.Name   -- global\r\n                    elseif member.IsStaticFunction then\r\n                        functor = parseObject.Name..\"::\"..member.Name -- static member function\r\n                    else\r\n                        CommentBindingTable(codeList, \"    // get this\\n\")\r\n\r\n                        table.insert(codeList, \"    \"..parseObject.Name..\" * self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")\r\n                        overload_argList = \"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"..overload_argList\r\n\r\n                        if parseObject[\"%ungc_this\"] then\r\n                            table.insert(codeList, \"    wxluaO_undeletegcobject(L, self);\\n\")\r\n                        elseif parseObject[\"%gc_this\"] then\r\n                            if parseObject[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    if (!wxluaO_isgcobject(L, self)) wxluaO_addgcobject(L, (void*)self, new wxLua_wxObject_\"..MakeClassVar(parseObject.Name)..\"(self));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, self);\\n\")\r\n                            end\r\n                        end\r\n\r\n                        requiredParamCount = requiredParamCount + 1\r\n                        paramCount = paramCount + 1\r\n\r\n                        if member[\"%operator\"] then\r\n                            if (member.Name == \"op_preinc\") or (member.Name == \"op_predec\") then\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            elseif (member.Name == \"op_inc\") or (member.Name == \"op_dec\") then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            elseif member[\"%operator\"] == \"[]\" then     -- op_index\r\n                                functor = \"(*self)[\"\r\n                            elseif member[\"%operator\"] == \"()\" then -- op_func\r\n                                functor = \"(*self)\"\r\n                            elseif paramCount > 1 then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            else\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            end\r\n                        -- static member function?\r\n                        elseif string.find(member.Name, \"::\") then\r\n                            functor = member.Name\r\n                        else\r\n                            functor = \"self->\"..member.Name\r\n                        end\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1686,
    "text": "functor = member.Name",
    "type": "statement:assign"
  }, {
    "id": 1687,
    "text": "functor = parseObject.Name..\"::\"..member.Name",
    "type": "statement:assign"
  }, {
    "id": 1688,
    "text": "table.insert(codeList, \"    \"..parseObject.Name..\" * self = (\"..parseObject.Name..\" *)wxluaT_getuserdatatype(L, 1, wxluatype_\"..MakeClassVar(parseObject.Name)..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1689,
    "text": "if parseObject[\"%ungc_this\"] then\r\n                            table.insert(codeList, \"    wxluaO_undeletegcobject(L, self);\\n\")\r\n                        elseif parseObject[\"%gc_this\"] then\r\n                            if parseObject[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    if (!wxluaO_isgcobject(L, self)) wxluaO_addgcobject(L, (void*)self, new wxLua_wxObject_\"..MakeClassVar(parseObject.Name)..\"(self));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, self);\\n\")\r\n                            end\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1690,
    "text": "table.insert(codeList, \"    wxluaO_undeletegcobject(L, self);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1691,
    "text": "if parseObject[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    if (!wxluaO_isgcobject(L, self)) wxluaO_addgcobject(L, (void*)self, new wxLua_wxObject_\"..MakeClassVar(parseObject.Name)..\"(self));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, self);\\n\")\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1692,
    "text": "table.insert(codeList, \"    if (!wxluaO_isgcobject(L, self)) wxluaO_addgcobject(L, (void*)self, new wxLua_wxObject_\"..MakeClassVar(parseObject.Name)..\"(self));\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1693,
    "text": "table.insert(codeList, \"    wxluaO_addgcobject(L, self);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1694,
    "text": "paramCount = paramCount + 1",
    "type": "statement:assign"
  }, {
    "id": 1695,
    "text": "if member[\"%operator\"] then\r\n                            if (member.Name == \"op_preinc\") or (member.Name == \"op_predec\") then\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            elseif (member.Name == \"op_inc\") or (member.Name == \"op_dec\") then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            elseif member[\"%operator\"] == \"[]\" then     -- op_index\r\n                                functor = \"(*self)[\"\r\n                            elseif member[\"%operator\"] == \"()\" then -- op_func\r\n                                functor = \"(*self)\"\r\n                            elseif paramCount > 1 then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            else\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            end\r\n                        -- static member function?\r\n                        elseif string.find(member.Name, \"::\") then\r\n                            functor = member.Name\r\n                        else\r\n                            functor = \"self->\"..member.Name\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1696,
    "text": "if (member.Name == \"op_preinc\") or (member.Name == \"op_predec\") then\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            elseif (member.Name == \"op_inc\") or (member.Name == \"op_dec\") then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            elseif member[\"%operator\"] == \"[]\" then     -- op_index\r\n                                functor = \"(*self)[\"\r\n                            elseif member[\"%operator\"] == \"()\" then -- op_func\r\n                                functor = \"(*self)\"\r\n                            elseif paramCount > 1 then\r\n                                functor = \"(*self)\"..member[\"%operator\"]\r\n                            else\r\n                                functor = member[\"%operator\"]..\"(*self)\"\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1697,
    "text": "functor = member[\"%operator\"]..\"(*self)\"",
    "type": "statement:assign"
  }, {
    "id": 1698,
    "text": "functor = \"(*self)\"..member[\"%operator\"]",
    "type": "statement:assign"
  }, {
    "id": 1699,
    "text": "functor = \"(*self)[\"",
    "type": "statement:assign"
  }, {
    "id": 1700,
    "text": "functor = \"(*self)\"",
    "type": "statement:assign"
  }, {
    "id": 1701,
    "text": "functor = \"self->\"..member.Name",
    "type": "statement:assign"
  }, {
    "id": 1702,
    "text": "if memberCast then\r\n                        functor  = \"(\"..memberCast..\")\"..functor\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1703,
    "text": "functor  = \"(\"..memberCast..\")\"..functor",
    "type": "statement:assign"
  }, {
    "id": 1704,
    "text": "local is_func = iff(not member[\"%operator\"] and member.IsFunction, true, false)",
    "type": "statement:localassign"
  }, {
    "id": 1705,
    "text": "if (argList ~= \"\") or is_func then\r\n                        functor = functor..\"(\"..argList..\")\"\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1706,
    "text": "functor = functor..\"(\"..argList..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1707,
    "text": "if member[\"%operator\"] == \"[]\" then -- op_index\r\n                        functor = functor..\"]\"\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1708,
    "text": "functor = functor..\"]\"",
    "type": "statement:assign"
  }, {
    "id": 1709,
    "text": "CommentBindingTable(codeList, \"    // call \"..member.Name..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1710,
    "text": "if not memberType or (memberTypeWithAttrib == \"void\") then\r\n                        -- call (void) function\r\n                        table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                        table.insert(codeList, \"\\n    return 0;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    else\r\n                        -- call function, get return value\r\n                        if member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and string.find(member[\"%operator\"], \"=\", 1, 1) then\r\n                            table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = self;\\n\")\r\n                        elseif member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and (string.find(member[\"%operator\"], \"=\", 1, 1) == nil) then\r\n                            if string.find(memberTypeWithAttrib or \"\", \"*\", 1, 1) then\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &(\"..functor..\");\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = \"..functor..\";\\n\")\r\n                            end\r\n                        elseif (not numeric) and (not memberPtr) then\r\n                            CommentBindingTable(codeList, \"    // allocate a new object using the copy constructor\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..memberType..\"(\"..functor..\");\\n\")\r\n                            CommentBindingTable(codeList, \"    // add the new object to the tracked memory list\\n\")\r\n\r\n                            -- Un 'const' AddTrackedObject\r\n                            local returnCast = memberTypeWithAttrib\r\n                            if string.sub(returnCast, 1, 6) == \"const \" then\r\n                                returnCast = string.sub(returnCast, 7)\r\n                            end\r\n\r\n                            local member_DataType = GetDataTypedefBase(memberType)\r\n\r\n                            if member_DataType[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(member_DataType.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (\"..returnCast..\")returns);\\n\")\r\n                            end\r\n\r\n                        elseif (not member[\"%operator\"]) and (memberPtr == \"&\") and string.find(memberTypeWithAttrib, \"*\") and (memberType ~= \"wxString\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &\"..functor..\";\\n\")\r\n                        elseif (memberPtr == \"*\") or (memberType == \"voidptr_long\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..memberTypeWithAttrib..\")\"..functor..\";\\n\")\r\n\r\n                            if member.GC then\r\n                                if dataTypeTable[memberType][\"%encapsulate\"] then\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")\r\n                                else\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")\r\n                                end\r\n                            elseif member.UnGC then\r\n                                table.insert(codeList, \"    if (wxluaO_isgcobject(L, returns)) wxluaO_undeletegcobject(L, returns);\\n\")\r\n                            end\r\n\r\n                        else\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..functor..\");\\n\")\r\n                        end\r\n\r\n                        -- bind return value\r\n                        if memberType == \"wxString\" then\r\n                            CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                            table.insert(codeList, \"    wxlua_pushwxString(L, \"..returnPtr..\"returns);\\n\")\r\n                        elseif not numeric then\r\n                            CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                            table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                        elseif IsDataTypeBool(member.DataType) then\r\n                            CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                            table.insert(codeList, \"    lua_pushboolean(L, returns);\\n\")\r\n                        elseif returnPtr == \"*\" then\r\n                            CommentBindingTable(codeList, \"    // push the result pointer\\n\")\r\n                            table.insert(codeList, \"    lua_pushlightuserdata(L, (void *)returns);\\n\")\r\n                        else -- Number\r\n                            CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                            table.insert(codeList, \"    lua_pushnumber(L, returns);\\n\")\r\n                        end\r\n\r\n                        table.insert(codeList, \"\\n    return 1;\\n\")\r\n                        table.insert(codeList, \"}\\n\")\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 1711,
    "text": "table.insert(codeList, \"    \"..functor..\";\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1712,
    "text": "table.insert(codeList, \"\\n    return 0;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1713,
    "text": "if member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and string.find(member[\"%operator\"], \"=\", 1, 1) then\r\n                            table.insert(codeList, \"    \"..functor..\";\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = self;\\n\")\r\n                        elseif member[\"%operator\"] and string.find(origMemberPtr or \"\", \"&\", 1, 1) and (string.find(member[\"%operator\"], \"=\", 1, 1) == nil) then\r\n                            if string.find(memberTypeWithAttrib or \"\", \"*\", 1, 1) then\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &(\"..functor..\");\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = \"..functor..\";\\n\")\r\n                            end\r\n                        elseif (not numeric) and (not memberPtr) then\r\n                            CommentBindingTable(codeList, \"    // allocate a new object using the copy constructor\\n\")\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..memberType..\"(\"..functor..\");\\n\")\r\n                            CommentBindingTable(codeList, \"    // add the new object to the tracked memory list\\n\")\r\n\r\n                            -- Un 'const' AddTrackedObject\r\n                            local returnCast = memberTypeWithAttrib\r\n                            if string.sub(returnCast, 1, 6) == \"const \" then\r\n                                returnCast = string.sub(returnCast, 7)\r\n                            end\r\n\r\n                            local member_DataType = GetDataTypedefBase(memberType)\r\n\r\n                            if member_DataType[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(member_DataType.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (\"..returnCast..\")returns);\\n\")\r\n                            end\r\n\r\n                        elseif (not member[\"%operator\"]) and (memberPtr == \"&\") and string.find(memberTypeWithAttrib, \"*\") and (memberType ~= \"wxString\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &\"..functor..\";\\n\")\r\n                        elseif (memberPtr == \"*\") or (memberType == \"voidptr_long\") then\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..memberTypeWithAttrib..\")\"..functor..\";\\n\")\r\n\r\n                            if member.GC then\r\n                                if dataTypeTable[memberType][\"%encapsulate\"] then\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")\r\n                                else\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")\r\n                                end\r\n                            elseif member.UnGC then\r\n                                table.insert(codeList, \"    if (wxluaO_isgcobject(L, returns)) wxluaO_undeletegcobject(L, returns);\\n\")\r\n                            end\r\n\r\n                        else\r\n                            table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..functor..\");\\n\")\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1714,
    "text": "table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = self;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1715,
    "text": "if string.find(memberTypeWithAttrib or \"\", \"*\", 1, 1) then\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &(\"..functor..\");\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = \"..functor..\";\\n\")\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1716,
    "text": "table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &(\"..functor..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1717,
    "text": "table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = \"..functor..\";\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1718,
    "text": "CommentBindingTable(codeList, \"    // allocate a new object using the copy constructor\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1719,
    "text": "table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = new \"..memberType..\"(\"..functor..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1720,
    "text": "CommentBindingTable(codeList, \"    // add the new object to the tracked memory list\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1721,
    "text": "if string.sub(returnCast, 1, 6) == \"const \" then\r\n                                returnCast = string.sub(returnCast, 7)\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1722,
    "text": "local member_DataType = GetDataTypedefBase(memberType)",
    "type": "statement:localassign"
  }, {
    "id": 1723,
    "text": "if member_DataType[\"%encapsulate\"] then\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(member_DataType.Name)..\"((\"..returnCast..\")returns));\\n\")\r\n                            else\r\n                                table.insert(codeList, \"    wxluaO_addgcobject(L, (\"..returnCast..\")returns);\\n\")\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1724,
    "text": "table.insert(codeList, \"    wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(member_DataType.Name)..\"((\"..returnCast..\")returns));\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1725,
    "text": "table.insert(codeList, \"    wxluaO_addgcobject(L, (\"..returnCast..\")returns);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1726,
    "text": "table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = &\"..functor..\";\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1727,
    "text": "table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..memberTypeWithAttrib..\")\"..functor..\";\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1728,
    "text": "if member.GC then\r\n                                if dataTypeTable[memberType][\"%encapsulate\"] then\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")\r\n                                else\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")\r\n                                end\r\n                            elseif member.UnGC then\r\n                                table.insert(codeList, \"    if (wxluaO_isgcobject(L, returns)) wxluaO_undeletegcobject(L, returns);\\n\")\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 1729,
    "text": "if dataTypeTable[memberType][\"%encapsulate\"] then\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")\r\n                                else\r\n                                    table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")\r\n                                end",
    "type": "statement:if"
  }, {
    "id": 1730,
    "text": "table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, (void*)returns, new wxLua_wxObject_\"..MakeVar(memberType)..\"(returns));\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1731,
    "text": "table.insert(codeList, \"    if (!wxluaO_isgcobject(L, returns)) wxluaO_addgcobject(L, returns);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1732,
    "text": "table.insert(codeList, \"    if (wxluaO_isgcobject(L, returns)) wxluaO_undeletegcobject(L, returns);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1733,
    "text": "table.insert(codeList, \"    \"..memberTypeWithAttrib..\" returns = (\"..functor..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1734,
    "text": "if memberType == \"wxString\" then\r\n                            CommentBindingTable(codeList, \"    // push the result string\\n\")\r\n                            table.insert(codeList, \"    wxlua_pushwxString(L, \"..returnPtr..\"returns);\\n\")\r\n                        elseif not numeric then\r\n                            CommentBindingTable(codeList, \"    // push the result datatype\\n\")\r\n                            table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(memberType)..\");\\n\")\r\n                        elseif IsDataTypeBool(member.DataType) then\r\n                            CommentBindingTable(codeList, \"    // push the result flag\\n\")\r\n                            table.insert(codeList, \"    lua_pushboolean(L, returns);\\n\")\r\n                        elseif returnPtr == \"*\" then\r\n                            CommentBindingTable(codeList, \"    // push the result pointer\\n\")\r\n                            table.insert(codeList, \"    lua_pushlightuserdata(L, (void *)returns);\\n\")\r\n                        else -- Number\r\n                            CommentBindingTable(codeList, \"    // push the result number\\n\")\r\n                            table.insert(codeList, \"    lua_pushnumber(L, returns);\\n\")\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 1735,
    "text": "table.insert(codeList, \"    wxlua_pushwxString(L, \"..returnPtr..\"returns);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1736,
    "text": "table.insert(codeList, \"    wxluaT_pushuserdatatype(L, returns, wxluatype_\"..MakeClassVar(memberType)..\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1737,
    "text": "table.insert(codeList, \"    lua_pushboolean(L, returns);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1738,
    "text": "CommentBindingTable(codeList, \"    // push the result pointer\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1739,
    "text": "table.insert(codeList, \"    lua_pushlightuserdata(L, (void *)returns);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1740,
    "text": "table.insert(codeList, \"    lua_pushnumber(L, returns);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1741,
    "text": "local funcMap   = \"{ \"..funcName..\", \"..funcType..\", \"..tostring(requiredParamCount)..\", \"..tostring(paramCount)..\", \"..overload_argListName..\" }\"",
    "type": "statement:localassign"
  }, {
    "id": 1742,
    "text": "local methodMap = \"    { \\\"\"..funcLuaCall..\"\\\", \"..funcType..\", \"..funcMapName..\", 1, NULL },\\n\"",
    "type": "statement:localassign"
  }, {
    "id": 1743,
    "text": "local methodcondition = nil",
    "type": "statement:localassign"
  }, {
    "id": 1744,
    "text": "for idx, condition in pairs(dependConditions) do\r\n                    methodcondition = AddCondition(methodcondition, condition)\r\n                end",
    "type": "statement:genericfor"
  }, {
    "id": 1745,
    "text": "methodcondition = AddCondition(methodcondition, condition)",
    "type": "statement:assign"
  }, {
    "id": 1746,
    "text": "methodcondition = FixCondition(methodcondition)",
    "type": "statement:assign"
  }, {
    "id": 1747,
    "text": "methodBinding =\r\n                {\r\n                    ClassName          = parseObject.Name,\r\n                    FuncType           = funcType,\r\n                    LuaName            = funcLuaCall,\r\n                    CFunctionName      = funcName,\r\n                    CFunctionNameBase  = funcNameBase,\r\n                    Method             = codeList,\r\n                    ArgArray           = overload_argList,\r\n                    ArgArrayName       = overload_argListName,\r\n                    ParamCount         = paramCount,\r\n                    RequiredParamCount = requiredParamCount,\r\n                    FuncMap            = funcMap,\r\n                    FuncMapName        = funcMapName,\r\n                    Map                = methodMap,\r\n                    NotOverload        = member.NotOverload,\r\n                    Condition          = methodcondition,\r\n                    PreDefineCode      = nil, -- set later if necessary\r\n                }",
    "type": "statement:assign"
  }, {
    "id": 1748,
    "text": "if (member.override_name and overrideTable[member.override_name]) then\r\n                    methodBinding.Method = overrideTable[member.override_name]\r\n                    methodBinding.PreDefineCode = \"#define \"..funcName..\" \"..member.override_name..\"\\n\"\r\n                    overrideTableUsed[member.override_name] = true\r\n                elseif ((member.override_name == nil) and overrideTable[methodBinding.CFunctionName]) then\r\n                    methodBinding.Method = overrideTable[methodBinding.CFunctionName]\r\n                    overrideTableUsed[methodBinding.CFunctionName] = true\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1749,
    "text": "methodBinding.Method = overrideTable[member.override_name]",
    "type": "statement:assign"
  }, {
    "id": 1750,
    "text": "methodBinding.PreDefineCode = \"#define \"..funcName..\" \"..member.override_name..\"\\n\"",
    "type": "statement:assign"
  }, {
    "id": 1751,
    "text": "overrideTableUsed[member.override_name] = true",
    "type": "statement:assign"
  }, {
    "id": 1752,
    "text": "if member[\"%function\"] then\r\n                    table.insert(functionBindingTable, methodBinding)\r\n                elseif not (member.IsConstructor and parseObject[\"%abstract\"]) then\r\n                    table.insert(interface.objectData[o].BindTable, methodBinding)\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1753,
    "text": "table.insert(functionBindingTable, methodBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1754,
    "text": "if (parseObject.ObjType == \"objtype_%class\") or (parseObject.ObjType == \"objtype_%struct\") then\r\n            -- Class Includes\r\n            for condition, includeBindingList in pairs(interface.includeBindingTable) do\r\n                if not classIncludeBindingTable[condition] then classIncludeBindingTable[condition] = {} end\r\n\r\n                for idx, includeBinding in pairs(includeBindingList) do\r\n                    classIncludeBindingTable[condition][idx] = includeBinding\r\n                end\r\n            end\r\n\r\n            -- Figure out if we really need to have member enums for the class\r\n                local enumArrayName = \"g_wxluanumberArray_None\"\r\n                local enumArrayCountName = 0\r\n                local ExternEnumDeclaration = \"\"\r\n                local ExternEnumCountDeclaration = \"\"\r\n\r\n            if enumClassBindingTable[MakeVar(parseObject.Name)] ~= nil then\r\n                enumArrayName = MakeVar(parseObject.Name)..\"_enums\"\r\n                enumArrayCountName = MakeVar(parseObject.Name)..\"_enumCount\"\r\n                --ExternEnumDeclaration = \"extern \"..output_cpp_impexpsymbol..\" wxLuaBindNumber \"..enumArrayName..\"[];\\n\"\r\n                --ExternEnumCountDeclaration = \"extern \"..MakeImpExpData(\"int\")..\" \"..enumArrayCountName..\";\\n\"\r\n                ExternEnumDeclaration = \"extern wxLuaBindNumber \"..enumArrayName..\"[];\\n\"\r\n                ExternEnumCountDeclaration = \"extern int \"..enumArrayCountName..\";\\n\"\r\n            end\r\n\r\n\r\n            -- Extern Class Tag Declaration\r\n            local tagcondition = FixCondition(parseObject.Condition)\r\n            local classTypeBinding =\r\n            {\r\n                ExternDeclaration            = \"extern \"..MakeImpExpData(\"int\")..\" wxluatype_\"..MakeClassVar(parseObject.Name)..\";\\n\",\r\n                --ExternMethodDeclaration      = \"extern \"..output_cpp_impexpsymbol..\" wxLuaBindMethod \"..MakeVar(parseObject.Name)..\"_methods[];\\n\",\r\n                --ExternMethodCountDeclaration = \"extern \"..MakeImpExpData(\"int\")..\" \"..MakeVar(parseObject.Name)..\"_methodCount;\\n\",\r\n                ExternMethodDeclaration      = \"extern wxLuaBindMethod \"..MakeVar(parseObject.Name)..\"_methods[];\\n\",\r\n                ExternMethodCountDeclaration = \"extern int \"..MakeVar(parseObject.Name)..\"_methodCount;\\n\",\r\n                ExternEnumDeclaration        = ExternEnumDeclaration,\r\n                ExternEnumCountDeclaration   = ExternEnumCountDeclaration,\r\n                Condition                    = tagcondition\r\n            }\r\n\r\n            if not classTypeBindingTable[tagcondition] then classTypeBindingTable[tagcondition] = {} end\r\n            classTypeBindingTable[tagcondition][parseObject.Name] = classTypeBinding\r\n\r\n            -- Class Tag Declaration\r\n            local decl = \"\";\r\n            if comment_cpp_binding_code then\r\n                decl = decl..\"// Lua MetaTable Tag for Class '\"..parseObject.Name..\"'\\n\"\r\n            end\r\n            decl = decl..\"int wxluatype_\"..MakeClassVar(parseObject.Name)..\" = WXLUA_TUNKNOWN;\\n\"\r\n\r\n            interface.objectData[o].TagDeclaration = decl\r\n\r\n            -- Class Binding\r\n            local baseclassNames = \"NULL\"\r\n            local baseclassBinds = \"NULL\"\r\n            if dataTypeTable[parseObject.Name].BaseClasses then\r\n                baseclassNames = \"wxluabaseclassnames_\"..MakeVar(parseObject.Name)\r\n                baseclassBinds = \"wxluabaseclassbinds_\"..MakeVar(parseObject.Name)\r\n            end\r\n\r\n            local classinfo = \"NULL\"\r\n            if not parseObject[\"%noclassinfo\"] then\r\n                classinfo = \"CLASSINFO(\"..parseObject.Name..\")\"\r\n            end\r\n\r\n            -- Class Functions\r\n            if parseObject[\"%delete\"] then\r\n                -- delete routine\r\n                codeList = {}\r\n                local funcName  = \"wxLua_\"..MakeVar(parseObject.Name)..\"_delete\"\r\n                local funcName_ = funcName\r\n\r\n                if not overrideTable[funcName] then\r\n                    funcName_ = \"wxlua_userdata_delete\"\r\n                end\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                local overload_argList = \"{ &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL }\"\r\n\r\n                local condition = FixCondition(parseObject.Condition)\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcType = \"WXLUAMETHOD_METHOD\"\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                local delMethodBinding =\r\n                {\r\n                    LuaName         = \"delete\",\r\n                    CFunctionName   = funcName_,\r\n                    Method          = codeList,\r\n                    FuncType        = funcType,\r\n                    FuncMap         = \"{ \"..funcName_..\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName     = funcMapName,\r\n                    ArgArray        = overload_argList,\r\n                    ArgArrayName    = overload_argListName,\r\n                    ParamCount      = 1,\r\n                    RequiredParamCount = 1,\r\n                    Map             = \"    { \\\"delete\\\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition       = condition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[funcName] then\r\n                    delMethodBinding.Method = overrideTable[funcName]\r\n                    overrideTableUsed[funcName] = true\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, delMethodBinding)\r\n            end\r\n\r\n            local classcondition = FixCondition(parseObject.Condition)\r\n            local classBinding =\r\n            {\r\n                LuaName = MakeVar(parseObject.Name),\r\n                Map = \"    { wxluaclassname_\"..MakeVar(parseObject.Name)..\", \"\r\n                                ..MakeVar(parseObject.Name)..\"_methods, \"\r\n                                ..MakeVar(parseObject.Name)..\"_methodCount, \"\r\n                                ..classinfo..\", \"\r\n                                ..\"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"\r\n                                ..baseclassNames..\", \"\r\n                                ..baseclassBinds..\", \"\r\n                                ..enumArrayName..\", \"\r\n                                ..enumArrayCountName..\", \"\r\n                                ..\"}, \\n\",\r\n                BaseClasses = dataTypeTable[parseObject.Name].BaseClasses,\r\n                Condition = classcondition\r\n            }\r\n\r\n            table.insert(classBindingTable, classBinding)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1755,
    "text": "for condition, includeBindingList in pairs(interface.includeBindingTable) do\r\n                if not classIncludeBindingTable[condition] then classIncludeBindingTable[condition] = {} end\r\n\r\n                for idx, includeBinding in pairs(includeBindingList) do\r\n                    classIncludeBindingTable[condition][idx] = includeBinding\r\n                end\r\n            end",
    "type": "statement:genericfor"
  }, {
    "id": 1756,
    "text": "if not classIncludeBindingTable[condition] then classIncludeBindingTable[condition] = {} end",
    "type": "statement:if"
  }, {
    "id": 1757,
    "text": "classIncludeBindingTable[condition] = {}",
    "type": "statement:assign"
  }, {
    "id": 1758,
    "text": "for idx, includeBinding in pairs(includeBindingList) do\r\n                    classIncludeBindingTable[condition][idx] = includeBinding\r\n                end",
    "type": "statement:genericfor"
  }, {
    "id": 1759,
    "text": "classIncludeBindingTable[condition][idx] = includeBinding",
    "type": "statement:assign"
  }, {
    "id": 1760,
    "text": "local enumArrayName = \"g_wxluanumberArray_None\"",
    "type": "statement:localassign"
  }, {
    "id": 1761,
    "text": "local enumArrayCountName = 0",
    "type": "statement:localassign"
  }, {
    "id": 1762,
    "text": "local ExternEnumDeclaration = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1763,
    "text": "local ExternEnumCountDeclaration = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1764,
    "text": "if enumClassBindingTable[MakeVar(parseObject.Name)] ~= nil then\r\n                enumArrayName = MakeVar(parseObject.Name)..\"_enums\"\r\n                enumArrayCountName = MakeVar(parseObject.Name)..\"_enumCount\"\r\n                --ExternEnumDeclaration = \"extern \"..output_cpp_impexpsymbol..\" wxLuaBindNumber \"..enumArrayName..\"[];\\n\"\r\n                --ExternEnumCountDeclaration = \"extern \"..MakeImpExpData(\"int\")..\" \"..enumArrayCountName..\";\\n\"\r\n                ExternEnumDeclaration = \"extern wxLuaBindNumber \"..enumArrayName..\"[];\\n\"\r\n                ExternEnumCountDeclaration = \"extern int \"..enumArrayCountName..\";\\n\"\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1765,
    "text": "enumArrayName = MakeVar(parseObject.Name)..\"_enums\"",
    "type": "statement:assign"
  }, {
    "id": 1766,
    "text": "enumArrayCountName = MakeVar(parseObject.Name)..\"_enumCount\"",
    "type": "statement:assign"
  }, {
    "id": 1767,
    "text": "ExternEnumDeclaration = \"extern wxLuaBindNumber \"..enumArrayName..\"[];\\n\"",
    "type": "statement:assign"
  }, {
    "id": 1768,
    "text": "ExternEnumCountDeclaration = \"extern int \"..enumArrayCountName..\";\\n\"",
    "type": "statement:assign"
  }, {
    "id": 1769,
    "text": "local tagcondition = FixCondition(parseObject.Condition)",
    "type": "statement:localassign"
  }, {
    "id": 1770,
    "text": "local classTypeBinding =\r\n            {\r\n                ExternDeclaration            = \"extern \"..MakeImpExpData(\"int\")..\" wxluatype_\"..MakeClassVar(parseObject.Name)..\";\\n\",\r\n                --ExternMethodDeclaration      = \"extern \"..output_cpp_impexpsymbol..\" wxLuaBindMethod \"..MakeVar(parseObject.Name)..\"_methods[];\\n\",\r\n                --ExternMethodCountDeclaration = \"extern \"..MakeImpExpData(\"int\")..\" \"..MakeVar(parseObject.Name)..\"_methodCount;\\n\",\r\n                ExternMethodDeclaration      = \"extern wxLuaBindMethod \"..MakeVar(parseObject.Name)..\"_methods[];\\n\",\r\n                ExternMethodCountDeclaration = \"extern int \"..MakeVar(parseObject.Name)..\"_methodCount;\\n\",\r\n                ExternEnumDeclaration        = ExternEnumDeclaration,\r\n                ExternEnumCountDeclaration   = ExternEnumCountDeclaration,\r\n                Condition                    = tagcondition\r\n            }",
    "type": "statement:localassign"
  }, {
    "id": 1771,
    "text": "if not classTypeBindingTable[tagcondition] then classTypeBindingTable[tagcondition] = {} end",
    "type": "statement:if"
  }, {
    "id": 1772,
    "text": "classTypeBindingTable[tagcondition] = {}",
    "type": "statement:assign"
  }, {
    "id": 1773,
    "text": "classTypeBindingTable[tagcondition][parseObject.Name] = classTypeBinding",
    "type": "statement:assign"
  }, {
    "id": 1774,
    "text": "local decl = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1775,
    "text": "if comment_cpp_binding_code then\r\n                decl = decl..\"// Lua MetaTable Tag for Class '\"..parseObject.Name..\"'\\n\"\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1776,
    "text": "decl = decl..\"// Lua MetaTable Tag for Class '\"..parseObject.Name..\"'\\n\"",
    "type": "statement:assign"
  }, {
    "id": 1777,
    "text": "decl = decl..\"int wxluatype_\"..MakeClassVar(parseObject.Name)..\" = WXLUA_TUNKNOWN;\\n\"",
    "type": "statement:assign"
  }, {
    "id": 1778,
    "text": "interface.objectData[o].TagDeclaration = decl",
    "type": "statement:assign"
  }, {
    "id": 1779,
    "text": "local baseclassNames = \"NULL\"",
    "type": "statement:localassign"
  }, {
    "id": 1780,
    "text": "local baseclassBinds = \"NULL\"",
    "type": "statement:localassign"
  }, {
    "id": 1781,
    "text": "if dataTypeTable[parseObject.Name].BaseClasses then\r\n                baseclassNames = \"wxluabaseclassnames_\"..MakeVar(parseObject.Name)\r\n                baseclassBinds = \"wxluabaseclassbinds_\"..MakeVar(parseObject.Name)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1782,
    "text": "baseclassNames = \"wxluabaseclassnames_\"..MakeVar(parseObject.Name)",
    "type": "statement:assign"
  }, {
    "id": 1783,
    "text": "baseclassBinds = \"wxluabaseclassbinds_\"..MakeVar(parseObject.Name)",
    "type": "statement:assign"
  }, {
    "id": 1784,
    "text": "local classinfo = \"NULL\"",
    "type": "statement:localassign"
  }, {
    "id": 1785,
    "text": "if not parseObject[\"%noclassinfo\"] then\r\n                classinfo = \"CLASSINFO(\"..parseObject.Name..\")\"\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1786,
    "text": "classinfo = \"CLASSINFO(\"..parseObject.Name..\")\"",
    "type": "statement:assign"
  }, {
    "id": 1787,
    "text": "if parseObject[\"%delete\"] then\r\n                -- delete routine\r\n                codeList = {}\r\n                local funcName  = \"wxLua_\"..MakeVar(parseObject.Name)..\"_delete\"\r\n                local funcName_ = funcName\r\n\r\n                if not overrideTable[funcName] then\r\n                    funcName_ = \"wxlua_userdata_delete\"\r\n                end\r\n\r\n                local funcMapName = \"s_wxluafunc_\"..funcName\r\n\r\n                local overload_argListName = \"s_wxluatypeArray_\".. funcName\r\n                local overload_argList = \"{ &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL }\"\r\n\r\n                local condition = FixCondition(parseObject.Condition)\r\n\r\n                RemovewxLuaStateIfNotUsed(codeList)\r\n\r\n                local funcType = \"WXLUAMETHOD_METHOD\"\r\n\r\n                if parseObject[\"%encapsulate\"] then\r\n                    --funcType = AddOredValue(funcType, \"WXLUAMETHOD_ENCAPSULATE\") FIXME\r\n                end\r\n\r\n                local delMethodBinding =\r\n                {\r\n                    LuaName         = \"delete\",\r\n                    CFunctionName   = funcName_,\r\n                    Method          = codeList,\r\n                    FuncType        = funcType,\r\n                    FuncMap         = \"{ \"..funcName_..\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName     = funcMapName,\r\n                    ArgArray        = overload_argList,\r\n                    ArgArrayName    = overload_argListName,\r\n                    ParamCount      = 1,\r\n                    RequiredParamCount = 1,\r\n                    Map             = \"    { \\\"delete\\\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition       = condition\r\n                }\r\n\r\n                -- Override Generated Method Code\r\n                if overrideTable[funcName] then\r\n                    delMethodBinding.Method = overrideTable[funcName]\r\n                    overrideTableUsed[funcName] = true\r\n                end\r\n\r\n                table.insert(interface.objectData[o].BindTable, delMethodBinding)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1788,
    "text": "local funcName  = \"wxLua_\"..MakeVar(parseObject.Name)..\"_delete\"",
    "type": "statement:localassign"
  }, {
    "id": 1789,
    "text": "local funcName_ = funcName",
    "type": "statement:localassign"
  }, {
    "id": 1790,
    "text": "if not overrideTable[funcName] then\r\n                    funcName_ = \"wxlua_userdata_delete\"\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1791,
    "text": "funcName_ = \"wxlua_userdata_delete\"",
    "type": "statement:assign"
  }, {
    "id": 1792,
    "text": "local overload_argList = \"{ &wxluatype_\"..MakeClassVar(parseObject.Name)..\", NULL }\"",
    "type": "statement:localassign"
  }, {
    "id": 1793,
    "text": "local condition = FixCondition(parseObject.Condition)",
    "type": "statement:localassign"
  }, {
    "id": 1794,
    "text": "local delMethodBinding =\r\n                {\r\n                    LuaName         = \"delete\",\r\n                    CFunctionName   = funcName_,\r\n                    Method          = codeList,\r\n                    FuncType        = funcType,\r\n                    FuncMap         = \"{ \"..funcName_..\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, 1, 1, \"..overload_argListName..\" }\",\r\n                    FuncMapName     = funcMapName,\r\n                    ArgArray        = overload_argList,\r\n                    ArgArrayName    = overload_argListName,\r\n                    ParamCount      = 1,\r\n                    RequiredParamCount = 1,\r\n                    Map             = \"    { \\\"delete\\\", WXLUAMETHOD_METHOD|WXLUAMETHOD_DELETE, \"..funcMapName..\", 1, NULL },\\n\",\r\n                    Condition       = condition\r\n                }",
    "type": "statement:localassign"
  }, {
    "id": 1795,
    "text": "if overrideTable[funcName] then\r\n                    delMethodBinding.Method = overrideTable[funcName]\r\n                    overrideTableUsed[funcName] = true\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1796,
    "text": "delMethodBinding.Method = overrideTable[funcName]",
    "type": "statement:assign"
  }, {
    "id": 1797,
    "text": "overrideTableUsed[funcName] = true",
    "type": "statement:assign"
  }, {
    "id": 1798,
    "text": "table.insert(interface.objectData[o].BindTable, delMethodBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1799,
    "text": "local classcondition = FixCondition(parseObject.Condition)",
    "type": "statement:localassign"
  }, {
    "id": 1800,
    "text": "local classBinding =\r\n            {\r\n                LuaName = MakeVar(parseObject.Name),\r\n                Map = \"    { wxluaclassname_\"..MakeVar(parseObject.Name)..\", \"\r\n                                ..MakeVar(parseObject.Name)..\"_methods, \"\r\n                                ..MakeVar(parseObject.Name)..\"_methodCount, \"\r\n                                ..classinfo..\", \"\r\n                                ..\"&wxluatype_\"..MakeClassVar(parseObject.Name)..\", \"\r\n                                ..baseclassNames..\", \"\r\n                                ..baseclassBinds..\", \"\r\n                                ..enumArrayName..\", \"\r\n                                ..enumArrayCountName..\", \"\r\n                                ..\"}, \\n\",\r\n                BaseClasses = dataTypeTable[parseObject.Name].BaseClasses,\r\n                Condition = classcondition\r\n            }",
    "type": "statement:localassign"
  }, {
    "id": 1801,
    "text": "table.insert(classBindingTable, classBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 1802,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1803,
    "text": "function GenerateLuaNameFromIndexedTable(MapTable, OutTable)\r\n    for n = 1, #MapTable do\r\n        local luaname = MapTable[n].LuaName\r\n        if not OutTable[luaname] then OutTable[luaname] = {} end\r\n        if HasCondition(MapTable[n].Condition) then\r\n            table.insert(OutTable[luaname], 1, MapTable[n])\r\n        else\r\n            table.insert(OutTable[luaname], MapTable[n])\r\n        end\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 1804,
    "text": "for n = 1, #MapTable do\r\n        local luaname = MapTable[n].LuaName\r\n        if not OutTable[luaname] then OutTable[luaname] = {} end\r\n        if HasCondition(MapTable[n].Condition) then\r\n            table.insert(OutTable[luaname], 1, MapTable[n])\r\n        else\r\n            table.insert(OutTable[luaname], MapTable[n])\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 1805,
    "text": "local luaname = MapTable[n].LuaName",
    "type": "statement:localassign"
  }, {
    "id": 1806,
    "text": "if not OutTable[luaname] then OutTable[luaname] = {} end",
    "type": "statement:if"
  }, {
    "id": 1807,
    "text": "OutTable[luaname] = {}",
    "type": "statement:assign"
  }, {
    "id": 1808,
    "text": "if HasCondition(MapTable[n].Condition) then\r\n            table.insert(OutTable[luaname], 1, MapTable[n])\r\n        else\r\n            table.insert(OutTable[luaname], MapTable[n])\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1809,
    "text": "table.insert(OutTable[luaname], 1, MapTable[n])",
    "type": "statement:functioncall"
  }, {
    "id": 1810,
    "text": "table.insert(OutTable[luaname], MapTable[n])",
    "type": "statement:functioncall"
  }, {
    "id": 1811,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1812,
    "text": "function GenerateMap(fileData, sortedBindings, indent, writeFunc, no_elseif, ignore_condition)\r\n    indent = indent or \"\"\r\n    no_elseif = no_elseif or false\r\n    local last_condition = \"1\"\r\n\r\n    for n = 1, #sortedBindings do\r\n        local wrote_elseif = false\r\n\r\n        local duplicatesTable = {}\r\n\r\n        for i = 1, #sortedBindings[n] do\r\n            local condition = sortedBindings[n][i].Condition\r\n\r\n--[[\r\n            -- FIXME implement duplicate entries check\r\n            if duplicatesTable[condition] then\r\n                print(\"WARNING: Duplicate entries with the same #if condition! Check bindings\")\r\n                TableDump(duplicatesTable[condition], \"Entry #1: \")\r\n                TableDump(sortedBindings[n][i], \"Entry #2: \")\r\n            else\r\n                duplicatesTable[condition] = sortedBindings[n][i]\r\n            end\r\n]]\r\n\r\n            local next_condition = \"1\"\r\n            if i < #sortedBindings[n] then\r\n                next_condition = sortedBindings[n][i+1].Condition\r\n            elseif n < #sortedBindings then\r\n                next_condition = sortedBindings[n+1][1].Condition\r\n            end\r\n\r\n            -- try to combine the #if statements if possible\r\n            if HasCondition(condition) and (condition ~= ignore_condition) and (condition ~= last_condition) and ((i == 1) or no_elseif) then\r\n                table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n            end\r\n\r\n            if writeFunc then\r\n                writeFunc(sortedBindings[n][i], fileData)\r\n            else\r\n                table.insert(fileData, indent..sortedBindings[n][i].Map)\r\n            end\r\n\r\n            last_condition = condition\r\n\r\n            if wrote_elseif or (HasCondition(condition) and (condition ~= ignore_condition) and (condition ~= next_condition)) then\r\n                if (i == #sortedBindings[n]) or no_elseif then\r\n                    table.insert(fileData, \"#endif // \"..condition..\"\\n\")\r\n                    last_condition = \"1\"\r\n                else\r\n                    table.insert(fileData, \"#elif \"..next_condition..\"\\n\")\r\n                    wrote_elseif = true\r\n                end\r\n            end\r\n\r\n            if not wrote_elseif and (condition ~= next_condition) then\r\n                table.insert(fileData, \"\\n\")\r\n            end\r\n        end\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 1813,
    "text": "indent = indent or \"\"",
    "type": "statement:assign"
  }, {
    "id": 1814,
    "text": "no_elseif = no_elseif or false",
    "type": "statement:assign"
  }, {
    "id": 1815,
    "text": "local last_condition = \"1\"",
    "type": "statement:localassign"
  }, {
    "id": 1816,
    "text": "for n = 1, #sortedBindings do\r\n        local wrote_elseif = false\r\n\r\n        local duplicatesTable = {}\r\n\r\n        for i = 1, #sortedBindings[n] do\r\n            local condition = sortedBindings[n][i].Condition\r\n\r\n--[[\r\n            -- FIXME implement duplicate entries check\r\n            if duplicatesTable[condition] then\r\n                print(\"WARNING: Duplicate entries with the same #if condition! Check bindings\")\r\n                TableDump(duplicatesTable[condition], \"Entry #1: \")\r\n                TableDump(sortedBindings[n][i], \"Entry #2: \")\r\n            else\r\n                duplicatesTable[condition] = sortedBindings[n][i]\r\n            end\r\n]]\r\n\r\n            local next_condition = \"1\"\r\n            if i < #sortedBindings[n] then\r\n                next_condition = sortedBindings[n][i+1].Condition\r\n            elseif n < #sortedBindings then\r\n                next_condition = sortedBindings[n+1][1].Condition\r\n            end\r\n\r\n            -- try to combine the #if statements if possible\r\n            if HasCondition(condition) and (condition ~= ignore_condition) and (condition ~= last_condition) and ((i == 1) or no_elseif) then\r\n                table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n            end\r\n\r\n            if writeFunc then\r\n                writeFunc(sortedBindings[n][i], fileData)\r\n            else\r\n                table.insert(fileData, indent..sortedBindings[n][i].Map)\r\n            end\r\n\r\n            last_condition = condition\r\n\r\n            if wrote_elseif or (HasCondition(condition) and (condition ~= ignore_condition) and (condition ~= next_condition)) then\r\n                if (i == #sortedBindings[n]) or no_elseif then\r\n                    table.insert(fileData, \"#endif // \"..condition..\"\\n\")\r\n                    last_condition = \"1\"\r\n                else\r\n                    table.insert(fileData, \"#elif \"..next_condition..\"\\n\")\r\n                    wrote_elseif = true\r\n                end\r\n            end\r\n\r\n            if not wrote_elseif and (condition ~= next_condition) then\r\n                table.insert(fileData, \"\\n\")\r\n            end\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 1817,
    "text": "local wrote_elseif = false",
    "type": "statement:localassign"
  }, {
    "id": 1818,
    "text": "local duplicatesTable = {}",
    "type": "statement:localassign"
  }, {
    "id": 1819,
    "text": "for i = 1, #sortedBindings[n] do\r\n            local condition = sortedBindings[n][i].Condition\r\n\r\n--[[\r\n            -- FIXME implement duplicate entries check\r\n            if duplicatesTable[condition] then\r\n                print(\"WARNING: Duplicate entries with the same #if condition! Check bindings\")\r\n                TableDump(duplicatesTable[condition], \"Entry #1: \")\r\n                TableDump(sortedBindings[n][i], \"Entry #2: \")\r\n            else\r\n                duplicatesTable[condition] = sortedBindings[n][i]\r\n            end\r\n]]\r\n\r\n            local next_condition = \"1\"\r\n            if i < #sortedBindings[n] then\r\n                next_condition = sortedBindings[n][i+1].Condition\r\n            elseif n < #sortedBindings then\r\n                next_condition = sortedBindings[n+1][1].Condition\r\n            end\r\n\r\n            -- try to combine the #if statements if possible\r\n            if HasCondition(condition) and (condition ~= ignore_condition) and (condition ~= last_condition) and ((i == 1) or no_elseif) then\r\n                table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n            end\r\n\r\n            if writeFunc then\r\n                writeFunc(sortedBindings[n][i], fileData)\r\n            else\r\n                table.insert(fileData, indent..sortedBindings[n][i].Map)\r\n            end\r\n\r\n            last_condition = condition\r\n\r\n            if wrote_elseif or (HasCondition(condition) and (condition ~= ignore_condition) and (condition ~= next_condition)) then\r\n                if (i == #sortedBindings[n]) or no_elseif then\r\n                    table.insert(fileData, \"#endif // \"..condition..\"\\n\")\r\n                    last_condition = \"1\"\r\n                else\r\n                    table.insert(fileData, \"#elif \"..next_condition..\"\\n\")\r\n                    wrote_elseif = true\r\n                end\r\n            end\r\n\r\n            if not wrote_elseif and (condition ~= next_condition) then\r\n                table.insert(fileData, \"\\n\")\r\n            end\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 1820,
    "text": "local condition = sortedBindings[n][i].Condition",
    "type": "statement:localassign"
  }, {
    "id": 1821,
    "text": "local next_condition = \"1\"",
    "type": "statement:localassign"
  }, {
    "id": 1822,
    "text": "if i < #sortedBindings[n] then\r\n                next_condition = sortedBindings[n][i+1].Condition\r\n            elseif n < #sortedBindings then\r\n                next_condition = sortedBindings[n+1][1].Condition\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1823,
    "text": "next_condition = sortedBindings[n][i+1].Condition",
    "type": "statement:assign"
  }, {
    "id": 1824,
    "text": "next_condition = sortedBindings[n+1][1].Condition",
    "type": "statement:assign"
  }, {
    "id": 1825,
    "text": "if HasCondition(condition) and (condition ~= ignore_condition) and (condition ~= last_condition) and ((i == 1) or no_elseif) then\r\n                table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1826,
    "text": "table.insert(fileData, \"#if \"..condition..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1827,
    "text": "if writeFunc then\r\n                writeFunc(sortedBindings[n][i], fileData)\r\n            else\r\n                table.insert(fileData, indent..sortedBindings[n][i].Map)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1828,
    "text": "writeFunc(sortedBindings[n][i], fileData)",
    "type": "statement:functioncall"
  }, {
    "id": 1829,
    "text": "table.insert(fileData, indent..sortedBindings[n][i].Map)",
    "type": "statement:functioncall"
  }, {
    "id": 1830,
    "text": "last_condition = condition",
    "type": "statement:assign"
  }, {
    "id": 1831,
    "text": "if wrote_elseif or (HasCondition(condition) and (condition ~= ignore_condition) and (condition ~= next_condition)) then\r\n                if (i == #sortedBindings[n]) or no_elseif then\r\n                    table.insert(fileData, \"#endif // \"..condition..\"\\n\")\r\n                    last_condition = \"1\"\r\n                else\r\n                    table.insert(fileData, \"#elif \"..next_condition..\"\\n\")\r\n                    wrote_elseif = true\r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1832,
    "text": "if (i == #sortedBindings[n]) or no_elseif then\r\n                    table.insert(fileData, \"#endif // \"..condition..\"\\n\")\r\n                    last_condition = \"1\"\r\n                else\r\n                    table.insert(fileData, \"#elif \"..next_condition..\"\\n\")\r\n                    wrote_elseif = true\r\n                end",
    "type": "statement:if"
  }, {
    "id": 1833,
    "text": "table.insert(fileData, \"#endif // \"..condition..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1834,
    "text": "last_condition = \"1\"",
    "type": "statement:assign"
  }, {
    "id": 1835,
    "text": "table.insert(fileData, \"#elif \"..next_condition..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1836,
    "text": "wrote_elseif = true",
    "type": "statement:assign"
  }, {
    "id": 1837,
    "text": "if not wrote_elseif and (condition ~= next_condition) then\r\n                table.insert(fileData, \"\\n\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1838,
    "text": "table.insert(fileData, \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1839,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1840,
    "text": "function GenerateHookHeaderFileTable()\r\n    local fileData = {}\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// \"..hook_cpp_namespace..\".h - headers and wxLua types for wxLua binding\\n\")\r\n    table.insert(fileData, \"//\\n\")\r\n    table.insert(fileData, \"// This file was generated by genwxbind.lua \\n\")\r\n    table.insert(fileData, \"// Any changes made to this file will be lost when the file is regenerated\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"\\n\")\r\n    table.insert(fileData, \"#ifndef __HOOK_WXLUA_\"..hook_cpp_namespace..\"_H__\\n\")\r\n    table.insert(fileData, \"#define __HOOK_WXLUA_\"..hook_cpp_namespace..\"_H__\\n\\n\")\r\n\r\n    table.insert(fileData, (hook_cpp_binding_header_includes or \"\")..\"\\n\")\r\n\r\n    table.insert(fileData, \"#include \\\"wxlua/include/wxlstate.h\\\"\\n\")\r\n    table.insert(fileData, \"#include \\\"wxlua/include/wxlbind.h\\\"\\n\\n\")\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// Check if the version of binding generator used to create this is older than\\n\")\r\n    table.insert(fileData, \"//   the current version of the bindings.\\n\")\r\n    table.insert(fileData, \"//   See 'bindings/genwxbind.lua' and 'modules/wxlua/include/wxldefs.h'\\n\")\r\n    table.insert(fileData, \"#if WXLUA_BINDING_VERSION > \"..WXLUA_BINDING_VERSION..\"\\n\")\r\n    table.insert(fileData, \"#   error \\\"The WXLUA_BINDING_VERSION in the bindings is too old, regenerate bindings.\\\"\\n\")\r\n    table.insert(fileData, \"#endif //WXLUA_BINDING_VERSION > \"..WXLUA_BINDING_VERSION..\"\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    if hook_bind_condition then\r\n        table.insert(fileData, \"#if \"..hook_bind_condition..\"\\n\\n\")\r\n    end\r\n\r\n    table.insert(fileData, \"// binding class\\n\")\r\n    table.insert(fileData, \"class \"..output_cpp_impexpsymbol..\" \"..hook_cpp_binding_classname..\" : public wxLuaBinding\\n\")\r\n    table.insert(fileData, \"{\\n\")\r\n    table.insert(fileData, \"public:\\n\")\r\n    table.insert(fileData, \"    \"..hook_cpp_binding_classname..\"();\\n\")\r\n    table.insert(fileData, \"\\n\")\r\n    table.insert(fileData, wxLuaBinding_class_declaration or \"\")\r\n    table.insert(fileData, \"\\nprivate:\\n\")\r\n    table.insert(fileData, \"    DECLARE_DYNAMIC_CLASS(\"..hook_cpp_binding_classname..\")\\n\")\r\n    table.insert(fileData, \"};\\n\")\r\n    table.insert(fileData, \"\\n\\n\")\r\n\r\n    table.insert(fileData, \"// initialize \"..hook_cpp_binding_classname..\" for all wxLuaStates\\n\")\r\n    table.insert(fileData, \"extern \"..output_cpp_impexpsymbol..\" bool \"..hook_cpp_binding_classname..\"_init();\\n\\n\")\r\n\r\n    if hook_bind_condition then\r\n        table.insert(fileData, \"#else\\n\\n\")\r\n        table.insert(fileData, \"#define bind_\"..hook_cpp_namespace..\"(L)\\n\\n\")\r\n        table.insert(fileData, \"#endif // \"..hook_bind_condition..\"\\n\\n\")\r\n    end\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- Object Include List - sorted by condition for the C++ compiler\r\n    -- ------------------------------------------------------------------------\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// Includes\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    for condition, classIncludeBindingList in pairs_sort(classIncludeBindingTable) do\r\n        local indent = \"\"\r\n\r\n        if HasCondition(condition) then\r\n            indent = \"    \"\r\n            table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, classIncludeBinding in pairs_sort(classIncludeBindingList) do\r\n            table.insert(fileData, indent..classIncludeBinding.Include)\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        else\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- Class Tag Declaration - sorted by condition for the C++ compiler\r\n    -- ------------------------------------------------------------------------\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// Lua Tag Method Values and Tables for each Class\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    for condition, classTypeBindingList in pairs_sort(classTypeBindingTable) do\r\n        local indent = \"\"\r\n\r\n        if HasCondition(condition) then\r\n            indent = \"    \"\r\n            table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, classTypeBinding in pairs_sort(classTypeBindingList) do\r\n            table.insert(fileData, indent..classTypeBinding.ExternDeclaration)\r\n            --table.insert(fileData, indent..classTypeBinding.ExternMethodDeclaration)\r\n            --table.insert(fileData, indent..classTypeBinding.ExternMethodCountDeclaration)\r\n            --if string.len(classTypeBinding.ExternEnumCountDeclaration) > 0 then\r\n            --    table.insert(fileData, indent..classTypeBinding.ExternEnumDeclaration)\r\n            --    table.insert(fileData, indent..classTypeBinding.ExternEnumCountDeclaration)\r\n            --end\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        else\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end\r\n\r\n    table.insert(fileData, \"\\n\")\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- Encapsulation Declarations - sorted by condition for the C++ compiler\r\n    -- ------------------------------------------------------------------------\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// Encapsulation Declarations - need to be public for other bindings.\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    for condition, encapsulationBindingList in pairs_sort(encapsulationBindingTable) do\r\n        local indent = \"\"\r\n\r\n        if HasCondition(condition) then\r\n            indent = \"    \"\r\n            table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, encapsulationBinding in pairs_sort(encapsulationBindingList) do\r\n            if encapsulationBinding and encapsulationBinding.Declaration then\r\n                table.insert(fileData, indent..encapsulationBinding.Declaration)\r\n            end\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        else\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end\r\n\r\n    table.insert(fileData, \"\\n\")\r\n    table.insert(fileData, \"#endif // __HOOK_WXLUA_\"..hook_cpp_namespace..\"_H__\\n\\n\")\r\n\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 1841,
    "text": "table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1842,
    "text": "table.insert(fileData, \"// \"..hook_cpp_namespace..\".h - headers and wxLua types for wxLua binding\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1843,
    "text": "table.insert(fileData, \"//\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1844,
    "text": "table.insert(fileData, \"// This file was generated by genwxbind.lua \\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1845,
    "text": "table.insert(fileData, \"// Any changes made to this file will be lost when the file is regenerated\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1846,
    "text": "table.insert(fileData, \"#ifndef __HOOK_WXLUA_\"..hook_cpp_namespace..\"_H__\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1847,
    "text": "table.insert(fileData, \"#define __HOOK_WXLUA_\"..hook_cpp_namespace..\"_H__\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1848,
    "text": "table.insert(fileData, (hook_cpp_binding_header_includes or \"\")..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1849,
    "text": "table.insert(fileData, \"#include \\\"wxlua/include/wxlstate.h\\\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1850,
    "text": "table.insert(fileData, \"#include \\\"wxlua/include/wxlbind.h\\\"\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1851,
    "text": "table.insert(fileData, \"// Check if the version of binding generator used to create this is older than\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1852,
    "text": "table.insert(fileData, \"//   the current version of the bindings.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1853,
    "text": "table.insert(fileData, \"//   See 'bindings/genwxbind.lua' and 'modules/wxlua/include/wxldefs.h'\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1854,
    "text": "table.insert(fileData, \"#if WXLUA_BINDING_VERSION > \"..WXLUA_BINDING_VERSION..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1855,
    "text": "table.insert(fileData, \"#   error \\\"The WXLUA_BINDING_VERSION in the bindings is too old, regenerate bindings.\\\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1856,
    "text": "table.insert(fileData, \"#endif //WXLUA_BINDING_VERSION > \"..WXLUA_BINDING_VERSION..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1857,
    "text": "table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1858,
    "text": "if hook_bind_condition then\r\n        table.insert(fileData, \"#if \"..hook_bind_condition..\"\\n\\n\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 1859,
    "text": "table.insert(fileData, \"#if \"..hook_bind_condition..\"\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1860,
    "text": "table.insert(fileData, \"// binding class\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1861,
    "text": "table.insert(fileData, \"class \"..output_cpp_impexpsymbol..\" \"..hook_cpp_binding_classname..\" : public wxLuaBinding\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1862,
    "text": "table.insert(fileData, \"{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1863,
    "text": "table.insert(fileData, \"public:\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1864,
    "text": "table.insert(fileData, \"    \"..hook_cpp_binding_classname..\"();\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1865,
    "text": "table.insert(fileData, wxLuaBinding_class_declaration or \"\")",
    "type": "statement:functioncall"
  }, {
    "id": 1866,
    "text": "table.insert(fileData, \"\\nprivate:\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1867,
    "text": "table.insert(fileData, \"    DECLARE_DYNAMIC_CLASS(\"..hook_cpp_binding_classname..\")\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1868,
    "text": "table.insert(fileData, \"};\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1869,
    "text": "table.insert(fileData, \"\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1870,
    "text": "table.insert(fileData, \"// initialize \"..hook_cpp_binding_classname..\" for all wxLuaStates\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1871,
    "text": "table.insert(fileData, \"extern \"..output_cpp_impexpsymbol..\" bool \"..hook_cpp_binding_classname..\"_init();\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1872,
    "text": "if hook_bind_condition then\r\n        table.insert(fileData, \"#else\\n\\n\")\r\n        table.insert(fileData, \"#define bind_\"..hook_cpp_namespace..\"(L)\\n\\n\")\r\n        table.insert(fileData, \"#endif // \"..hook_bind_condition..\"\\n\\n\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 1873,
    "text": "table.insert(fileData, \"#else\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1874,
    "text": "table.insert(fileData, \"#define bind_\"..hook_cpp_namespace..\"(L)\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1875,
    "text": "table.insert(fileData, \"#endif // \"..hook_bind_condition..\"\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1876,
    "text": "table.insert(fileData, \"// Includes\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1877,
    "text": "for condition, classIncludeBindingList in pairs_sort(classIncludeBindingTable) do\r\n        local indent = \"\"\r\n\r\n        if HasCondition(condition) then\r\n            indent = \"    \"\r\n            table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, classIncludeBinding in pairs_sort(classIncludeBindingList) do\r\n            table.insert(fileData, indent..classIncludeBinding.Include)\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        else\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 1878,
    "text": "local indent = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 1879,
    "text": "if HasCondition(condition) then\r\n            indent = \"    \"\r\n            table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1880,
    "text": "indent = \"    \"",
    "type": "statement:assign"
  }, {
    "id": 1881,
    "text": "for idx, classIncludeBinding in pairs_sort(classIncludeBindingList) do\r\n            table.insert(fileData, indent..classIncludeBinding.Include)\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 1882,
    "text": "table.insert(fileData, indent..classIncludeBinding.Include)",
    "type": "statement:functioncall"
  }, {
    "id": 1883,
    "text": "if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        else\r\n            table.insert(fileData, \"\\n\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1884,
    "text": "table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1885,
    "text": "table.insert(fileData, \"// Lua Tag Method Values and Tables for each Class\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1886,
    "text": "for condition, classTypeBindingList in pairs_sort(classTypeBindingTable) do\r\n        local indent = \"\"\r\n\r\n        if HasCondition(condition) then\r\n            indent = \"    \"\r\n            table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, classTypeBinding in pairs_sort(classTypeBindingList) do\r\n            table.insert(fileData, indent..classTypeBinding.ExternDeclaration)\r\n            --table.insert(fileData, indent..classTypeBinding.ExternMethodDeclaration)\r\n            --table.insert(fileData, indent..classTypeBinding.ExternMethodCountDeclaration)\r\n            --if string.len(classTypeBinding.ExternEnumCountDeclaration) > 0 then\r\n            --    table.insert(fileData, indent..classTypeBinding.ExternEnumDeclaration)\r\n            --    table.insert(fileData, indent..classTypeBinding.ExternEnumCountDeclaration)\r\n            --end\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        else\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 1887,
    "text": "for idx, classTypeBinding in pairs_sort(classTypeBindingList) do\r\n            table.insert(fileData, indent..classTypeBinding.ExternDeclaration)\r\n            --table.insert(fileData, indent..classTypeBinding.ExternMethodDeclaration)\r\n            --table.insert(fileData, indent..classTypeBinding.ExternMethodCountDeclaration)\r\n            --if string.len(classTypeBinding.ExternEnumCountDeclaration) > 0 then\r\n            --    table.insert(fileData, indent..classTypeBinding.ExternEnumDeclaration)\r\n            --    table.insert(fileData, indent..classTypeBinding.ExternEnumCountDeclaration)\r\n            --end\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 1888,
    "text": "table.insert(fileData, indent..classTypeBinding.ExternDeclaration)",
    "type": "statement:functioncall"
  }, {
    "id": 1889,
    "text": "table.insert(fileData, \"// Encapsulation Declarations - need to be public for other bindings.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1890,
    "text": "for condition, encapsulationBindingList in pairs_sort(encapsulationBindingTable) do\r\n        local indent = \"\"\r\n\r\n        if HasCondition(condition) then\r\n            indent = \"    \"\r\n            table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, encapsulationBinding in pairs_sort(encapsulationBindingList) do\r\n            if encapsulationBinding and encapsulationBinding.Declaration then\r\n                table.insert(fileData, indent..encapsulationBinding.Declaration)\r\n            end\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        else\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 1891,
    "text": "for idx, encapsulationBinding in pairs_sort(encapsulationBindingList) do\r\n            if encapsulationBinding and encapsulationBinding.Declaration then\r\n                table.insert(fileData, indent..encapsulationBinding.Declaration)\r\n            end\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 1892,
    "text": "if encapsulationBinding and encapsulationBinding.Declaration then\r\n                table.insert(fileData, indent..encapsulationBinding.Declaration)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1893,
    "text": "table.insert(fileData, indent..encapsulationBinding.Declaration)",
    "type": "statement:functioncall"
  }, {
    "id": 1894,
    "text": "table.insert(fileData, \"#endif // __HOOK_WXLUA_\"..hook_cpp_namespace..\"_H__\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1895,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1896,
    "text": "function GenerateHookCppFileHeader(fileData, fileName, add_includes)\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// \"..fileName..\" was generated by genwxbind.lua \\n\")\r\n    table.insert(fileData, \"//\\n\")\r\n    table.insert(fileData, \"// Any changes made to this file will be lost when the file is regenerated.\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    if add_includes then\r\n        table.insert(fileData, \"#ifdef __BORLANDC__\\n\")\r\n        table.insert(fileData, \"    #pragma hdrstop\\n\")\r\n        table.insert(fileData, \"#endif\\n\")\r\n        table.insert(fileData, \"\\n\")\r\n        table.insert(fileData, \"#include \\\"wx/wxprec.h\\\"\\n\")\r\n        table.insert(fileData, \"\\n\")\r\n        table.insert(fileData, \"#ifndef WX_PRECOMP\\n\")\r\n        table.insert(fileData, \"     #include \\\"wx/wx.h\\\"\\n\")\r\n        table.insert(fileData, \"#endif\\n\")\r\n        table.insert(fileData, \"\\n\")\r\n        table.insert(fileData, hook_cpp_binding_includes or \"\")\r\n        table.insert(fileData, \"\\n\")\r\n        table.insert(fileData, \"#include \\\"wxlua/include/wxlstate.h\\\"\\n\")\r\n        table.insert(fileData, \"#include \\\"\"..hook_cpp_header_filename..\"\\\"\\n\")\r\n        table.insert(fileData, hook_cpp_binding_post_includes or \"\")\r\n        table.insert(fileData, \"\\n\")\r\n    end\r\n\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 1897,
    "text": "table.insert(fileData, \"// \"..fileName..\" was generated by genwxbind.lua \\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1898,
    "text": "table.insert(fileData, \"// Any changes made to this file will be lost when the file is regenerated.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1899,
    "text": "if add_includes then\r\n        table.insert(fileData, \"#ifdef __BORLANDC__\\n\")\r\n        table.insert(fileData, \"    #pragma hdrstop\\n\")\r\n        table.insert(fileData, \"#endif\\n\")\r\n        table.insert(fileData, \"\\n\")\r\n        table.insert(fileData, \"#include \\\"wx/wxprec.h\\\"\\n\")\r\n        table.insert(fileData, \"\\n\")\r\n        table.insert(fileData, \"#ifndef WX_PRECOMP\\n\")\r\n        table.insert(fileData, \"     #include \\\"wx/wx.h\\\"\\n\")\r\n        table.insert(fileData, \"#endif\\n\")\r\n        table.insert(fileData, \"\\n\")\r\n        table.insert(fileData, hook_cpp_binding_includes or \"\")\r\n        table.insert(fileData, \"\\n\")\r\n        table.insert(fileData, \"#include \\\"wxlua/include/wxlstate.h\\\"\\n\")\r\n        table.insert(fileData, \"#include \\\"\"..hook_cpp_header_filename..\"\\\"\\n\")\r\n        table.insert(fileData, hook_cpp_binding_post_includes or \"\")\r\n        table.insert(fileData, \"\\n\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 1900,
    "text": "table.insert(fileData, \"#ifdef __BORLANDC__\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1901,
    "text": "table.insert(fileData, \"    #pragma hdrstop\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1902,
    "text": "table.insert(fileData, \"#endif\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1903,
    "text": "table.insert(fileData, \"#include \\\"wx/wxprec.h\\\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1904,
    "text": "table.insert(fileData, \"#ifndef WX_PRECOMP\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1905,
    "text": "table.insert(fileData, \"     #include \\\"wx/wx.h\\\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1906,
    "text": "table.insert(fileData, hook_cpp_binding_includes or \"\")",
    "type": "statement:functioncall"
  }, {
    "id": 1907,
    "text": "table.insert(fileData, \"#include \\\"\"..hook_cpp_header_filename..\"\\\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1908,
    "text": "table.insert(fileData, hook_cpp_binding_post_includes or \"\")",
    "type": "statement:functioncall"
  }, {
    "id": 1909,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1910,
    "text": "function GenerateHookClassFileTable(fileData)\r\n    fileData = fileData or {}\r\n\r\n    table.insert(fileData, \"\\n\\n\")\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- GetClassList\r\n    -- ------------------------------------------------------------------------\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// \"..hook_cpp_class_funcname..\"() is called to register classes\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    local namedBindingTable = {}\r\n    GenerateLuaNameFromIndexedTable(classBindingTable, namedBindingTable)\r\n    local sortedBindings = TableSort(namedBindingTable)\r\n\r\n    -- Gather up all of the classnames\r\n    local classNames = {}\r\n\r\n    for n = 1, #sortedBindings do\r\n        for i = 1, #sortedBindings[n] do\r\n            classNames[sortedBindings[n][i].LuaName] = sortedBindings[n][i].LuaName\r\n            for _, bc in ipairs(sortedBindings[n][i].BaseClasses or {}) do\r\n                classNames[bc] = bc\r\n            end\r\n        end\r\n    end\r\n\r\n    classNames = TableSort(classNames)\r\n\r\n    for _, c in pairs(classNames) do\r\n        table.insert(fileData, \"static const char* wxluaclassname_\"..c..\" = \\\"\"..c..\"\\\";\\n\")\r\n    end\r\n\r\n    table.insert(fileData, \"\\n\")\r\n\r\n    for n = 1, #sortedBindings do\r\n        for i = 1, #sortedBindings[n] do\r\n            if sortedBindings[n][i].BaseClasses then\r\n                local bc_n = 0\r\n                local s = \"static const char* wxluabaseclassnames_\"..sortedBindings[n][i].LuaName..\"[] = {\"\r\n                for _, bc in ipairs(sortedBindings[n][i].BaseClasses) do\r\n                    s = s..\" wxluaclassname_\"..bc..\",\"\r\n                    bc_n = bc_n + 1\r\n                end\r\n\r\n                table.insert(fileData, s..\" NULL };\\n\")\r\n                table.insert(fileData, \"static wxLuaBindClass* wxluabaseclassbinds_\"..sortedBindings[n][i].LuaName..\"[] = { \"..string.sub(string.rep(\"NULL, \", bc_n), 1, -3)..\" };\\n\")\r\n            end\r\n        end\r\n    end\r\n\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- Class Tag Declaration - sorted by condition for the C++ compiler\r\n    -- ------------------------------------------------------------------------\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// Lua Tag Method Values and Tables for each Class\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    for condition, classTypeBindingList in pairs_sort(classTypeBindingTable) do\r\n        local indent = \"\"\r\n\r\n        if HasCondition(condition) then\r\n            indent = \"    \"\r\n            table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, classTypeBinding in pairs_sort(classTypeBindingList) do\r\n            --table.insert(fileData, indent..classTypeBinding.ExternDeclaration)\r\n            table.insert(fileData, indent..classTypeBinding.ExternMethodDeclaration)\r\n            table.insert(fileData, indent..classTypeBinding.ExternMethodCountDeclaration)\r\n            if string.len(classTypeBinding.ExternEnumCountDeclaration) > 0 then\r\n                table.insert(fileData, indent..classTypeBinding.ExternEnumDeclaration)\r\n                table.insert(fileData, indent..classTypeBinding.ExternEnumCountDeclaration)\r\n            end\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        else\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end\r\n\r\n    table.insert(fileData, \"\\n\")\r\n\r\n\r\n    table.insert(fileData, \"\\n\\n\")\r\n\r\n    table.insert(fileData, \"wxLuaBindClass* \"..hook_cpp_class_funcname..\"(size_t &count)\\n{\\n\")\r\n    table.insert(fileData, \"    static wxLuaBindClass classList[] =\\n    {\\n\")\r\n\r\n    -- sort the bindings by class name and write them out alphabetically\r\n    GenerateMap(fileData, sortedBindings, \"    \")\r\n\r\n    table.insert(fileData, \"\\n\")\r\n    table.insert(fileData, \"        { 0, 0, 0, 0, 0, 0, 0 }, \\n\")\r\n    table.insert(fileData, \"    };\\n\")\r\n    table.insert(fileData, \"    count = sizeof(classList)/sizeof(wxLuaBindClass) - 1;\\n\\n\")\r\n    table.insert(fileData, \"    return classList;\\n\")\r\n    table.insert(fileData, \"}\\n\\n\")\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// \"..hook_cpp_binding_classname..\"() - the binding class\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    if hook_bind_condition then\r\n        table.insert(fileData, \"#if \"..hook_bind_condition..\"\\n\\n\")\r\n    end\r\n\r\n    table.insert(fileData, \"IMPLEMENT_DYNAMIC_CLASS(\"..hook_cpp_binding_classname..\", wxLuaBinding)\\n\\n\")\r\n    table.insert(fileData, \"\"..hook_cpp_binding_classname..\"::\"..hook_cpp_binding_classname..\"() : wxLuaBinding()\\n\")\r\n    table.insert(fileData, \"{\\n\")\r\n    table.insert(fileData, \"    m_bindingName   = wxT(\\\"\"..hook_cpp_namespace..\"\\\");\\n\")\r\n    table.insert(fileData, \"    m_nameSpace     = wxT(\\\"\"..hook_lua_namespace..\"\\\");\\n\")\r\n    table.insert(fileData, \"    m_classArray    = \"..hook_cpp_class_funcname..\"(m_classCount);\\n\")\r\n    table.insert(fileData, \"    m_numberArray   = \"..hook_cpp_define_funcname..\"(m_numberCount);\\n\")\r\n    table.insert(fileData, \"    m_stringArray   = \"..hook_cpp_string_funcname..\"(m_stringCount);\\n\")\r\n    table.insert(fileData, \"    m_eventArray    = \"..hook_cpp_event_funcname..\"(m_eventCount);\\n\")\r\n    table.insert(fileData, \"    m_objectArray   = \"..hook_cpp_object_funcname..\"(m_objectCount);\\n\")\r\n    table.insert(fileData, \"    m_functionArray = \"..hook_cpp_function_funcname..\"(m_functionCount);\\n\")\r\n    table.insert(fileData, \"}\\n\\n\")\r\n\r\n    table.insert(fileData, (wxLuaBinding_class_implementation or \"\")..\"\\n\\n\")\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    table.insert(fileData, \"bool \"..hook_cpp_binding_classname..\"_init()\\n\")\r\n    table.insert(fileData, \"{\\n\")\r\n    table.insert(fileData, \"    static \"..hook_cpp_binding_classname..\" m_binding;\\n\")\r\n    --table.insert(fileData, \"    wxLuaBindingList::Node *node = wxLuaBinding::GetBindingList()->Find(&m_binding);\\n\")\r\n    table.insert(fileData, \"    if (wxLuaBinding::GetBindingList()->Find(&m_binding)) return false;\\n\\n\")\r\n    table.insert(fileData, \"    wxLuaBinding::GetBindingList()->Append(&m_binding);\\n\")\r\n    table.insert(fileData, \"    return true;\\n\")\r\n    table.insert(fileData, \"}\\n\\n\")\r\n\r\n    if hook_bind_condition then\r\n        table.insert(fileData, \"#endif // \"..hook_bind_condition..\"\\n\\n\")\r\n    end\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- Encapsulation Implementation\r\n    -- ------------------------------------------------------------------------\r\n    for condition, encapsulationBindingList in pairs_sort(encapsulationBindingTable) do\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"\\n#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, encapsulationBinding in pairs_sort(encapsulationBindingList) do\r\n            if encapsulationBinding and encapsulationBinding.Declaration then\r\n                table.insert(fileData, encapsulationBinding.Implementation)\r\n            end\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        end\r\n    end\r\n\r\n    table.insert(fileData, \"\\n\")\r\n\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 1911,
    "text": "fileData = fileData or {}",
    "type": "statement:assign"
  }, {
    "id": 1912,
    "text": "table.insert(fileData, \"// \"..hook_cpp_class_funcname..\"() is called to register classes\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1913,
    "text": "local namedBindingTable = {}",
    "type": "statement:localassign"
  }, {
    "id": 1914,
    "text": "GenerateLuaNameFromIndexedTable(classBindingTable, namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 1915,
    "text": "local sortedBindings = TableSort(namedBindingTable)",
    "type": "statement:localassign"
  }, {
    "id": 1916,
    "text": "local classNames = {}",
    "type": "statement:localassign"
  }, {
    "id": 1917,
    "text": "for n = 1, #sortedBindings do\r\n        for i = 1, #sortedBindings[n] do\r\n            classNames[sortedBindings[n][i].LuaName] = sortedBindings[n][i].LuaName\r\n            for _, bc in ipairs(sortedBindings[n][i].BaseClasses or {}) do\r\n                classNames[bc] = bc\r\n            end\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 1918,
    "text": "for i = 1, #sortedBindings[n] do\r\n            classNames[sortedBindings[n][i].LuaName] = sortedBindings[n][i].LuaName\r\n            for _, bc in ipairs(sortedBindings[n][i].BaseClasses or {}) do\r\n                classNames[bc] = bc\r\n            end\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 1919,
    "text": "classNames[sortedBindings[n][i].LuaName] = sortedBindings[n][i].LuaName",
    "type": "statement:assign"
  }, {
    "id": 1920,
    "text": "for _, bc in ipairs(sortedBindings[n][i].BaseClasses or {}) do\r\n                classNames[bc] = bc\r\n            end",
    "type": "statement:genericfor"
  }, {
    "id": 1921,
    "text": "classNames[bc] = bc",
    "type": "statement:assign"
  }, {
    "id": 1922,
    "text": "classNames = TableSort(classNames)",
    "type": "statement:assign"
  }, {
    "id": 1923,
    "text": "for _, c in pairs(classNames) do\r\n        table.insert(fileData, \"static const char* wxluaclassname_\"..c..\" = \\\"\"..c..\"\\\";\\n\")\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 1924,
    "text": "table.insert(fileData, \"static const char* wxluaclassname_\"..c..\" = \\\"\"..c..\"\\\";\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1925,
    "text": "for n = 1, #sortedBindings do\r\n        for i = 1, #sortedBindings[n] do\r\n            if sortedBindings[n][i].BaseClasses then\r\n                local bc_n = 0\r\n                local s = \"static const char* wxluabaseclassnames_\"..sortedBindings[n][i].LuaName..\"[] = {\"\r\n                for _, bc in ipairs(sortedBindings[n][i].BaseClasses) do\r\n                    s = s..\" wxluaclassname_\"..bc..\",\"\r\n                    bc_n = bc_n + 1\r\n                end\r\n\r\n                table.insert(fileData, s..\" NULL };\\n\")\r\n                table.insert(fileData, \"static wxLuaBindClass* wxluabaseclassbinds_\"..sortedBindings[n][i].LuaName..\"[] = { \"..string.sub(string.rep(\"NULL, \", bc_n), 1, -3)..\" };\\n\")\r\n            end\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 1926,
    "text": "for i = 1, #sortedBindings[n] do\r\n            if sortedBindings[n][i].BaseClasses then\r\n                local bc_n = 0\r\n                local s = \"static const char* wxluabaseclassnames_\"..sortedBindings[n][i].LuaName..\"[] = {\"\r\n                for _, bc in ipairs(sortedBindings[n][i].BaseClasses) do\r\n                    s = s..\" wxluaclassname_\"..bc..\",\"\r\n                    bc_n = bc_n + 1\r\n                end\r\n\r\n                table.insert(fileData, s..\" NULL };\\n\")\r\n                table.insert(fileData, \"static wxLuaBindClass* wxluabaseclassbinds_\"..sortedBindings[n][i].LuaName..\"[] = { \"..string.sub(string.rep(\"NULL, \", bc_n), 1, -3)..\" };\\n\")\r\n            end\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 1927,
    "text": "if sortedBindings[n][i].BaseClasses then\r\n                local bc_n = 0\r\n                local s = \"static const char* wxluabaseclassnames_\"..sortedBindings[n][i].LuaName..\"[] = {\"\r\n                for _, bc in ipairs(sortedBindings[n][i].BaseClasses) do\r\n                    s = s..\" wxluaclassname_\"..bc..\",\"\r\n                    bc_n = bc_n + 1\r\n                end\r\n\r\n                table.insert(fileData, s..\" NULL };\\n\")\r\n                table.insert(fileData, \"static wxLuaBindClass* wxluabaseclassbinds_\"..sortedBindings[n][i].LuaName..\"[] = { \"..string.sub(string.rep(\"NULL, \", bc_n), 1, -3)..\" };\\n\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1928,
    "text": "local bc_n = 0",
    "type": "statement:localassign"
  }, {
    "id": 1929,
    "text": "local s = \"static const char* wxluabaseclassnames_\"..sortedBindings[n][i].LuaName..\"[] = {\"",
    "type": "statement:localassign"
  }, {
    "id": 1930,
    "text": "for _, bc in ipairs(sortedBindings[n][i].BaseClasses) do\r\n                    s = s..\" wxluaclassname_\"..bc..\",\"\r\n                    bc_n = bc_n + 1\r\n                end",
    "type": "statement:genericfor"
  }, {
    "id": 1931,
    "text": "s = s..\" wxluaclassname_\"..bc..\",\"",
    "type": "statement:assign"
  }, {
    "id": 1932,
    "text": "bc_n = bc_n + 1",
    "type": "statement:assign"
  }, {
    "id": 1933,
    "text": "table.insert(fileData, s..\" NULL };\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1934,
    "text": "table.insert(fileData, \"static wxLuaBindClass* wxluabaseclassbinds_\"..sortedBindings[n][i].LuaName..\"[] = { \"..string.sub(string.rep(\"NULL, \", bc_n), 1, -3)..\" };\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1935,
    "text": "for condition, classTypeBindingList in pairs_sort(classTypeBindingTable) do\r\n        local indent = \"\"\r\n\r\n        if HasCondition(condition) then\r\n            indent = \"    \"\r\n            table.insert(fileData, \"#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, classTypeBinding in pairs_sort(classTypeBindingList) do\r\n            --table.insert(fileData, indent..classTypeBinding.ExternDeclaration)\r\n            table.insert(fileData, indent..classTypeBinding.ExternMethodDeclaration)\r\n            table.insert(fileData, indent..classTypeBinding.ExternMethodCountDeclaration)\r\n            if string.len(classTypeBinding.ExternEnumCountDeclaration) > 0 then\r\n                table.insert(fileData, indent..classTypeBinding.ExternEnumDeclaration)\r\n                table.insert(fileData, indent..classTypeBinding.ExternEnumCountDeclaration)\r\n            end\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        else\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 1936,
    "text": "for idx, classTypeBinding in pairs_sort(classTypeBindingList) do\r\n            --table.insert(fileData, indent..classTypeBinding.ExternDeclaration)\r\n            table.insert(fileData, indent..classTypeBinding.ExternMethodDeclaration)\r\n            table.insert(fileData, indent..classTypeBinding.ExternMethodCountDeclaration)\r\n            if string.len(classTypeBinding.ExternEnumCountDeclaration) > 0 then\r\n                table.insert(fileData, indent..classTypeBinding.ExternEnumDeclaration)\r\n                table.insert(fileData, indent..classTypeBinding.ExternEnumCountDeclaration)\r\n            end\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 1937,
    "text": "table.insert(fileData, indent..classTypeBinding.ExternMethodDeclaration)",
    "type": "statement:functioncall"
  }, {
    "id": 1938,
    "text": "table.insert(fileData, indent..classTypeBinding.ExternMethodCountDeclaration)",
    "type": "statement:functioncall"
  }, {
    "id": 1939,
    "text": "if string.len(classTypeBinding.ExternEnumCountDeclaration) > 0 then\r\n                table.insert(fileData, indent..classTypeBinding.ExternEnumDeclaration)\r\n                table.insert(fileData, indent..classTypeBinding.ExternEnumCountDeclaration)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1940,
    "text": "table.insert(fileData, indent..classTypeBinding.ExternEnumDeclaration)",
    "type": "statement:functioncall"
  }, {
    "id": 1941,
    "text": "table.insert(fileData, indent..classTypeBinding.ExternEnumCountDeclaration)",
    "type": "statement:functioncall"
  }, {
    "id": 1942,
    "text": "table.insert(fileData, \"wxLuaBindClass* \"..hook_cpp_class_funcname..\"(size_t &count)\\n{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1943,
    "text": "table.insert(fileData, \"    static wxLuaBindClass classList[] =\\n    {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1944,
    "text": "GenerateMap(fileData, sortedBindings, \"    \")",
    "type": "statement:functioncall"
  }, {
    "id": 1945,
    "text": "table.insert(fileData, \"        { 0, 0, 0, 0, 0, 0, 0 }, \\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1946,
    "text": "table.insert(fileData, \"    };\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1947,
    "text": "table.insert(fileData, \"    count = sizeof(classList)/sizeof(wxLuaBindClass) - 1;\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1948,
    "text": "table.insert(fileData, \"    return classList;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1949,
    "text": "table.insert(fileData, \"}\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1950,
    "text": "table.insert(fileData, \"// \"..hook_cpp_binding_classname..\"() - the binding class\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1951,
    "text": "table.insert(fileData, \"IMPLEMENT_DYNAMIC_CLASS(\"..hook_cpp_binding_classname..\", wxLuaBinding)\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1952,
    "text": "table.insert(fileData, \"\"..hook_cpp_binding_classname..\"::\"..hook_cpp_binding_classname..\"() : wxLuaBinding()\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1953,
    "text": "table.insert(fileData, \"    m_bindingName   = wxT(\\\"\"..hook_cpp_namespace..\"\\\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1954,
    "text": "table.insert(fileData, \"    m_nameSpace     = wxT(\\\"\"..hook_lua_namespace..\"\\\");\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1955,
    "text": "table.insert(fileData, \"    m_classArray    = \"..hook_cpp_class_funcname..\"(m_classCount);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1956,
    "text": "table.insert(fileData, \"    m_numberArray   = \"..hook_cpp_define_funcname..\"(m_numberCount);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1957,
    "text": "table.insert(fileData, \"    m_stringArray   = \"..hook_cpp_string_funcname..\"(m_stringCount);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1958,
    "text": "table.insert(fileData, \"    m_eventArray    = \"..hook_cpp_event_funcname..\"(m_eventCount);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1959,
    "text": "table.insert(fileData, \"    m_objectArray   = \"..hook_cpp_object_funcname..\"(m_objectCount);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1960,
    "text": "table.insert(fileData, \"    m_functionArray = \"..hook_cpp_function_funcname..\"(m_functionCount);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1961,
    "text": "table.insert(fileData, (wxLuaBinding_class_implementation or \"\")..\"\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1962,
    "text": "table.insert(fileData, \"bool \"..hook_cpp_binding_classname..\"_init()\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1963,
    "text": "table.insert(fileData, \"    static \"..hook_cpp_binding_classname..\" m_binding;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1964,
    "text": "table.insert(fileData, \"    if (wxLuaBinding::GetBindingList()->Find(&m_binding)) return false;\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1965,
    "text": "table.insert(fileData, \"    wxLuaBinding::GetBindingList()->Append(&m_binding);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1966,
    "text": "table.insert(fileData, \"    return true;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1967,
    "text": "if hook_bind_condition then\r\n        table.insert(fileData, \"#endif // \"..hook_bind_condition..\"\\n\\n\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 1968,
    "text": "for condition, encapsulationBindingList in pairs_sort(encapsulationBindingTable) do\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"\\n#if \"..condition..\"\\n\")\r\n        end\r\n\r\n        for idx, encapsulationBinding in pairs_sort(encapsulationBindingList) do\r\n            if encapsulationBinding and encapsulationBinding.Declaration then\r\n                table.insert(fileData, encapsulationBinding.Implementation)\r\n            end\r\n        end\r\n\r\n        if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 1969,
    "text": "if HasCondition(condition) then\r\n            table.insert(fileData, \"\\n#if \"..condition..\"\\n\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1970,
    "text": "table.insert(fileData, \"\\n#if \"..condition..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1971,
    "text": "for idx, encapsulationBinding in pairs_sort(encapsulationBindingList) do\r\n            if encapsulationBinding and encapsulationBinding.Declaration then\r\n                table.insert(fileData, encapsulationBinding.Implementation)\r\n            end\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 1972,
    "text": "if encapsulationBinding and encapsulationBinding.Declaration then\r\n                table.insert(fileData, encapsulationBinding.Implementation)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 1973,
    "text": "table.insert(fileData, encapsulationBinding.Implementation)",
    "type": "statement:functioncall"
  }, {
    "id": 1974,
    "text": "if HasCondition(condition) then\r\n            table.insert(fileData, \"#endif // \"..condition..\"\\n\\n\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 1975,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1976,
    "text": "function GenerateHookDefineFileTable(fileData)\r\n    fileData = fileData or {}\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- GetDefineList\r\n    -- ------------------------------------------------------------------------\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// \"..hook_cpp_define_funcname..\"() is called to register %define and %enum\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    table.insert(fileData, \"wxLuaBindNumber* \"..hook_cpp_define_funcname..\"(size_t &count)\\n{\\n\")\r\n    table.insert(fileData, \"    static wxLuaBindNumber numberList[] =\\n    {\\n\")\r\n\r\n    -- mix the %define and %enums together since they're both in the same wxLuaBindNumber struct\r\n    local namedBindingTable = {}\r\n    GenerateLuaNameFromIndexedTable(defineBindingTable, namedBindingTable)\r\n    GenerateLuaNameFromIndexedTable(enumBindingTable, namedBindingTable)\r\n\r\n    -- sort the bindings by class name and write them out alphabetically\r\n    local sortedBindings = TableSort(namedBindingTable)\r\n    GenerateMap(fileData, sortedBindings)\r\n\r\n    table.insert(fileData, \"\\n\")\r\n    table.insert(fileData, \"        { 0, 0 },\\n\")\r\n    table.insert(fileData, \"    };\\n\")\r\n    table.insert(fileData, \"    count = sizeof(numberList)/sizeof(wxLuaBindNumber) - 1;\\n\")\r\n    table.insert(fileData, \"    return numberList;\\n\")\r\n    table.insert(fileData, \"}\\n\\n\")\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- GetStringList\r\n    -- ------------------------------------------------------------------------\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n    table.insert(fileData, \"// \"..hook_cpp_string_funcname..\"() is called to register %define %string\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    table.insert(fileData, \"wxLuaBindString* \"..hook_cpp_string_funcname..\"(size_t &count)\\n{\\n\")\r\n    table.insert(fileData, \"    static wxLuaBindString stringList[] =\\n    {\\n\")\r\n\r\n    local namedBindingTable = {}\r\n    GenerateLuaNameFromIndexedTable(stringBindingTable, namedBindingTable)\r\n\r\n    -- sort the bindings by class name and write them out alphabetically\r\n    local sortedBindings = TableSort(namedBindingTable)\r\n    GenerateMap(fileData, sortedBindings)\r\n\r\n    table.insert(fileData, \"\\n\")\r\n    table.insert(fileData, \"        { 0, 0 },\\n\")\r\n    table.insert(fileData, \"    };\\n\")\r\n    table.insert(fileData, \"    count = sizeof(stringList)/sizeof(wxLuaBindString) - 1;\\n\")\r\n    table.insert(fileData, \"    return stringList;\\n\")\r\n    table.insert(fileData, \"}\\n\\n\")\r\n\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 1977,
    "text": "table.insert(fileData, \"// \"..hook_cpp_define_funcname..\"() is called to register %define and %enum\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1978,
    "text": "table.insert(fileData, \"wxLuaBindNumber* \"..hook_cpp_define_funcname..\"(size_t &count)\\n{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1979,
    "text": "table.insert(fileData, \"    static wxLuaBindNumber numberList[] =\\n    {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1980,
    "text": "GenerateLuaNameFromIndexedTable(defineBindingTable, namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 1981,
    "text": "GenerateLuaNameFromIndexedTable(enumBindingTable, namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 1982,
    "text": "GenerateMap(fileData, sortedBindings)",
    "type": "statement:functioncall"
  }, {
    "id": 1983,
    "text": "table.insert(fileData, \"        { 0, 0 },\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1984,
    "text": "table.insert(fileData, \"    count = sizeof(numberList)/sizeof(wxLuaBindNumber) - 1;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1985,
    "text": "table.insert(fileData, \"    return numberList;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1986,
    "text": "table.insert(fileData, \"// \"..hook_cpp_string_funcname..\"() is called to register %define %string\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1987,
    "text": "table.insert(fileData, \"wxLuaBindString* \"..hook_cpp_string_funcname..\"(size_t &count)\\n{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1988,
    "text": "table.insert(fileData, \"    static wxLuaBindString stringList[] =\\n    {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1989,
    "text": "GenerateLuaNameFromIndexedTable(stringBindingTable, namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 1990,
    "text": "table.insert(fileData, \"    count = sizeof(stringList)/sizeof(wxLuaBindString) - 1;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1991,
    "text": "table.insert(fileData, \"    return stringList;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1992,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 1993,
    "text": "function GenerateHookObjectFileTable(fileData)\r\n    fileData = fileData or {}\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// \"..hook_cpp_object_funcname..\"() is called to register object and pointer bindings\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- GetObjectList\r\n    -- ------------------------------------------------------------------------\r\n    table.insert(fileData, \"wxLuaBindObject* \"..hook_cpp_object_funcname..\"(size_t &count)\\n{\\n\")\r\n    table.insert(fileData, \"    static wxLuaBindObject objectList[] =\\n    {\\n\")\r\n\r\n    -- mix %object and %pointer together since they're both in the same wxLuaBindObject struct\r\n    local namedBindingTable = {}\r\n    GenerateLuaNameFromIndexedTable(objectBindingTable, namedBindingTable)\r\n    GenerateLuaNameFromIndexedTable(pointerBindingTable, namedBindingTable)\r\n\r\n    -- sort the bindings by class name and write them out alphabetically\r\n    local sortedBindings = TableSort(namedBindingTable)\r\n    GenerateMap(fileData, sortedBindings)\r\n\r\n    table.insert(fileData, \"\\n\")\r\n    table.insert(fileData, \"        { 0, 0, 0, 0 },\\n\")\r\n    table.insert(fileData, \"    };\\n\")\r\n    table.insert(fileData, \"    count = sizeof(objectList)/sizeof(wxLuaBindObject) - 1;\\n\")\r\n    table.insert(fileData, \"    return objectList;\\n\")\r\n    table.insert(fileData, \"}\\n\\n\")\r\n\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 1994,
    "text": "table.insert(fileData, \"// \"..hook_cpp_object_funcname..\"() is called to register object and pointer bindings\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1995,
    "text": "table.insert(fileData, \"wxLuaBindObject* \"..hook_cpp_object_funcname..\"(size_t &count)\\n{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1996,
    "text": "table.insert(fileData, \"    static wxLuaBindObject objectList[] =\\n    {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 1997,
    "text": "GenerateLuaNameFromIndexedTable(objectBindingTable, namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 1998,
    "text": "GenerateLuaNameFromIndexedTable(pointerBindingTable, namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 1999,
    "text": "table.insert(fileData, \"        { 0, 0, 0, 0 },\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2000,
    "text": "table.insert(fileData, \"    count = sizeof(objectList)/sizeof(wxLuaBindObject) - 1;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2001,
    "text": "table.insert(fileData, \"    return objectList;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2002,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2003,
    "text": "function GenerateHookEventFileTable(fileData)\r\n    fileData = fileData or {}\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// \"..hook_cpp_event_funcname..\"() is called to register events\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- GetEventList\r\n    -- ------------------------------------------------------------------------\r\n    table.insert(fileData, \"wxLuaBindEvent* \"..hook_cpp_event_funcname..\"(size_t &count)\\n{\\n\")\r\n    table.insert(fileData, \"    static wxLuaBindEvent eventList[] =\\n    {\\n\")\r\n\r\n    local namedBindingTable = {}\r\n    GenerateLuaNameFromIndexedTable(eventBindingTable, namedBindingTable)\r\n    -- sort the bindings by class name and write them out alphabetically\r\n    local sortedBindings = TableSort(namedBindingTable)\r\n    GenerateMap(fileData, sortedBindings)\r\n\r\n    table.insert(fileData, \"\\n\")\r\n    table.insert(fileData, \"        { 0, 0, 0 },\\n\")\r\n    table.insert(fileData, \"    };\\n\")\r\n    table.insert(fileData, \"    count = sizeof(eventList)/sizeof(wxLuaBindEvent) - 1;\\n\")\r\n    table.insert(fileData, \"    return eventList;\\n\")\r\n    table.insert(fileData, \"}\\n\\n\")\r\n\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 2004,
    "text": "table.insert(fileData, \"// \"..hook_cpp_event_funcname..\"() is called to register events\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2005,
    "text": "table.insert(fileData, \"wxLuaBindEvent* \"..hook_cpp_event_funcname..\"(size_t &count)\\n{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2006,
    "text": "table.insert(fileData, \"    static wxLuaBindEvent eventList[] =\\n    {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2007,
    "text": "GenerateLuaNameFromIndexedTable(eventBindingTable, namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 2008,
    "text": "table.insert(fileData, \"        { 0, 0, 0 },\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2009,
    "text": "table.insert(fileData, \"    count = sizeof(eventList)/sizeof(wxLuaBindEvent) - 1;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2010,
    "text": "table.insert(fileData, \"    return eventList;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2011,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2012,
    "text": "function GenerateHookCFunctionFileTable(fileData)\r\n    fileData = fileData or {}\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// \"..hook_cpp_function_funcname..\"() is called to register global functions\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    -- Don't use #elif to let compiler fail on multiple definitions per condition\r\n    -- since there's a problem with the bindings if that happens\r\n\r\n    local namedBindingTable = {}\r\n    GenerateLuaNameFromIndexedTable(functionBindingTable, namedBindingTable)\r\n    -- sort the bindings by class name and write them out alphabetically\r\n    local sortedBindings = TableSort(namedBindingTable)\r\n\r\n    local function writeFunc(functionBinding)\r\n        if functionBinding.Method then\r\n            if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n            end\r\n\r\n            table.insert(fileData, table.concat(functionBinding.Method))\r\n\r\n            if functionBinding.FuncMapName then\r\n                table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\\n\")\r\n            end\r\n        end\r\n    end\r\n    GenerateMap(fileData, sortedBindings, \"    \", writeFunc, true)\r\n\r\n    -- ------------------------------------------------------------------------\r\n    -- GetCFunctionList\r\n    -- ------------------------------------------------------------------------\r\n\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"// \"..hook_cpp_function_funcname..\"() is called to register global functions\\n\")\r\n    table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n    table.insert(fileData, \"wxLuaBindMethod* \"..hook_cpp_function_funcname..\"(size_t &count)\\n{\\n\")\r\n    table.insert(fileData, \"    static wxLuaBindMethod functionList[] =\\n    {\\n\")\r\n\r\n    GenerateMap(fileData, sortedBindings, \"    \")\r\n\r\n    table.insert(fileData, \"\\n\")\r\n    table.insert(fileData, \"        { 0, 0, 0, 0 }, \\n\")\r\n    table.insert(fileData, \"    };\\n\")\r\n    table.insert(fileData, \"    count = sizeof(functionList)/sizeof(wxLuaBindMethod) - 1;\\n\")\r\n    table.insert(fileData, \"    return functionList;\\n\")\r\n    table.insert(fileData, \"}\\n\\n\")\r\n\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 2013,
    "text": "table.insert(fileData, \"// \"..hook_cpp_function_funcname..\"() is called to register global functions\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2014,
    "text": "GenerateLuaNameFromIndexedTable(functionBindingTable, namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 2015,
    "text": "local function writeFunc(functionBinding)\r\n        if functionBinding.Method then\r\n            if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n            end\r\n\r\n            table.insert(fileData, table.concat(functionBinding.Method))\r\n\r\n            if functionBinding.FuncMapName then\r\n                table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\\n\")\r\n            end\r\n        end\r\n    end",
    "type": "statement:localfunction"
  }, {
    "id": 2016,
    "text": "if functionBinding.Method then\r\n            if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n            end\r\n\r\n            table.insert(fileData, table.concat(functionBinding.Method))\r\n\r\n            if functionBinding.FuncMapName then\r\n                table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\\n\")\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 2017,
    "text": "if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 2018,
    "text": "table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2019,
    "text": "table.insert(fileData, table.concat(functionBinding.Method))",
    "type": "statement:functioncall"
  }, {
    "id": 2020,
    "text": "if functionBinding.FuncMapName then\r\n                table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\\n\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 2021,
    "text": "table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2022,
    "text": "GenerateMap(fileData, sortedBindings, \"    \", writeFunc, true)",
    "type": "statement:functioncall"
  }, {
    "id": 2023,
    "text": "table.insert(fileData, \"wxLuaBindMethod* \"..hook_cpp_function_funcname..\"(size_t &count)\\n{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2024,
    "text": "table.insert(fileData, \"    static wxLuaBindMethod functionList[] =\\n    {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2025,
    "text": "table.insert(fileData, \"        { 0, 0, 0, 0 }, \\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2026,
    "text": "table.insert(fileData, \"    count = sizeof(functionList)/sizeof(wxLuaBindMethod) - 1;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2027,
    "text": "table.insert(fileData, \"    return functionList;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2028,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2029,
    "text": "local function writeFunc(functionBinding)\r\n        if functionBinding.Method then\r\n            if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n            end\r\n\r\n            table.insert(fileData, table.concat(functionBinding.Method))\r\n\r\n            if functionBinding.FuncMapName then\r\n                table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\\n\")\r\n            end\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 2030,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2031,
    "text": "function GenerateOverloadBinding(sortedBindings, object)\r\n    local overloadBindings = {}\r\n\r\n    for n = 1, #sortedBindings do\r\n        local overload_count = 0\r\n        local methodBindings = sortedBindings[n]\r\n\r\n        local paramCount = 0\r\n        local requiredParamCount = 1E6\r\n        local funcType = methodBindings[1].FuncType\r\n\r\n        local not_overload = 0\r\n\r\n        for i = 1, #methodBindings do\r\n            if methodBindings[i].Method then -- ignore properties\r\n                overload_count = overload_count + 1\r\n\r\n                if methodBindings[i].NotOverload == true then\r\n                    not_overload = not_overload + 1\r\n                end\r\n\r\n                if methodBindings[i].ParamCount and (paramCount < methodBindings[i].ParamCount) then\r\n                    paramCount = methodBindings[i].ParamCount\r\n                end\r\n                if methodBindings[i].RequiredParamCount and (requiredParamCount > methodBindings[i].RequiredParamCount) then\r\n                    requiredParamCount = methodBindings[i].RequiredParamCount\r\n                end\r\n\r\n                for s in string.gmatch(methodBindings[i].FuncType, \"[%a_]+\") do\r\n                    if (string.find(funcType, s, 1, 1) == nil) then\r\n                        funcType = funcType..\"|\"..s\r\n                    end\r\n                end\r\n            end\r\n        end\r\n\r\n        if (overload_count > 1) and (not_overload < overload_count) then\r\n            --print(n, #methodBindings, methodBindings[1].Map)\r\n\r\n            local overload_condition = \"\"\r\n            local overload_conditions_used = {}\r\n            --if HasCondition(object.Condition) then\r\n            --    overload_conditions_used[object.Condition] = 1\r\n            --end\r\n            local cfuncNameBase = methodBindings[1].CFunctionNameBase\r\n\r\n            for i = 1, #methodBindings do\r\n                if HasCondition(methodBindings[i].Condition) and (overload_conditions_used[methodBindings[i].Condition] == nil) then\r\n                    if overload_condition ~= \"\" then overload_condition = overload_condition..\"||\" end\r\n                    overload_condition = overload_condition..\"(\"..methodBindings[i].Condition..\")\"\r\n                    overload_conditions_used[methodBindings[i].Condition] = 1\r\n                end\r\n            end\r\n\r\n            local funcName = cfuncNameBase..\"_overload\"\r\n            local funcMap = {}\r\n            local funcMapName = \"s_wxluafunc_\"..cfuncNameBase..\"_overload\"\r\n\r\n            CommentBindingTable(funcMap, \"// function overload table\\n\")\r\n            table.insert(funcMap, \"static wxLuaBindCFunc \"..funcMapName..\"[] =\\n{\\n\")\r\n--            table.insert(funcMap, \"    { \"..funcName..\", WXLUAMETHOD_METHOD|WXLUAMETHOD_OVERLOAD, \"..tostring(requiredParamCount)..\", \"..tostring(paramCount)..\", g_wxluaargtypeArray_None },\\n\")\r\n            for i = 1, #methodBindings do\r\n                if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"\\n#if \"..methodBindings[i].Condition..\"\\n\")\r\n                end\r\n\r\n                table.insert(funcMap, \"    \"..methodBindings[i].FuncMap..\",\\n\")\r\n\r\n                if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"#endif // \"..methodBindings[i].Condition..\"\\n\")\r\n                end\r\n            end\r\n            table.insert(funcMap, \"};\\n\")\r\n\r\n            table.insert(funcMap, \"static int \"..funcMapName..\"_count = sizeof(\"..funcMapName..\")/sizeof(wxLuaBindCFunc);\\n\\n\")\r\n\r\n            local methodMap = \"    { \\\"\"..methodBindings[1].LuaName..\"\\\", \"..funcType..\", \"..funcMapName..\", \"..funcMapName..\"_count, 0 }\"\r\n\r\n            local codeList = {}\r\n\r\n--            CommentBindingTable(codeList, \"// Overloaded function for \"..methodBindings[1].ClassName..\"::\"..methodBindings[1].LuaName..\"\\n\")\r\n--            table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n--            table.insert(codeList, \"    static wxLuaBindMethod overload_method = \\n\")\r\n--            table.insert(codeList, \"    \"..methodMap..\";\\n\")\r\n--            table.insert(codeList, \"    return wxlua_CallOverloadedFunction(L, &overload_method);\\n\")\r\n--            table.insert(codeList, \"}\\n\")\r\n\r\n            local methodBinding =\r\n            {\r\n                Condition = overload_condition,\r\n                CFunctionName = funcName,\r\n                FuncMap = funcMap,\r\n                funcMapName = funcMapName,\r\n                ParamCount = paramCount,\r\n                RequiredParamCount = requiredParamCount,\r\n                Method = codeList,\r\n                Map = methodMap..\",\\n\",\r\n                IsOverload = true\r\n            }\r\n\r\n            -- clear and replace the other bindings\r\n            sortedBindings[n] = {}\r\n            table.insert(sortedBindings[n], methodBinding)\r\n\r\n            table.insert(overloadBindings, {})\r\n            table.insert(overloadBindings[#overloadBindings], methodBinding)\r\n        end\r\n    end\r\n\r\n    return overloadBindings\r\nend",
    "type": "function"
  }, {
    "id": 2032,
    "text": "local overloadBindings = {}",
    "type": "statement:localassign"
  }, {
    "id": 2033,
    "text": "for n = 1, #sortedBindings do\r\n        local overload_count = 0\r\n        local methodBindings = sortedBindings[n]\r\n\r\n        local paramCount = 0\r\n        local requiredParamCount = 1E6\r\n        local funcType = methodBindings[1].FuncType\r\n\r\n        local not_overload = 0\r\n\r\n        for i = 1, #methodBindings do\r\n            if methodBindings[i].Method then -- ignore properties\r\n                overload_count = overload_count + 1\r\n\r\n                if methodBindings[i].NotOverload == true then\r\n                    not_overload = not_overload + 1\r\n                end\r\n\r\n                if methodBindings[i].ParamCount and (paramCount < methodBindings[i].ParamCount) then\r\n                    paramCount = methodBindings[i].ParamCount\r\n                end\r\n                if methodBindings[i].RequiredParamCount and (requiredParamCount > methodBindings[i].RequiredParamCount) then\r\n                    requiredParamCount = methodBindings[i].RequiredParamCount\r\n                end\r\n\r\n                for s in string.gmatch(methodBindings[i].FuncType, \"[%a_]+\") do\r\n                    if (string.find(funcType, s, 1, 1) == nil) then\r\n                        funcType = funcType..\"|\"..s\r\n                    end\r\n                end\r\n            end\r\n        end\r\n\r\n        if (overload_count > 1) and (not_overload < overload_count) then\r\n            --print(n, #methodBindings, methodBindings[1].Map)\r\n\r\n            local overload_condition = \"\"\r\n            local overload_conditions_used = {}\r\n            --if HasCondition(object.Condition) then\r\n            --    overload_conditions_used[object.Condition] = 1\r\n            --end\r\n            local cfuncNameBase = methodBindings[1].CFunctionNameBase\r\n\r\n            for i = 1, #methodBindings do\r\n                if HasCondition(methodBindings[i].Condition) and (overload_conditions_used[methodBindings[i].Condition] == nil) then\r\n                    if overload_condition ~= \"\" then overload_condition = overload_condition..\"||\" end\r\n                    overload_condition = overload_condition..\"(\"..methodBindings[i].Condition..\")\"\r\n                    overload_conditions_used[methodBindings[i].Condition] = 1\r\n                end\r\n            end\r\n\r\n            local funcName = cfuncNameBase..\"_overload\"\r\n            local funcMap = {}\r\n            local funcMapName = \"s_wxluafunc_\"..cfuncNameBase..\"_overload\"\r\n\r\n            CommentBindingTable(funcMap, \"// function overload table\\n\")\r\n            table.insert(funcMap, \"static wxLuaBindCFunc \"..funcMapName..\"[] =\\n{\\n\")\r\n--            table.insert(funcMap, \"    { \"..funcName..\", WXLUAMETHOD_METHOD|WXLUAMETHOD_OVERLOAD, \"..tostring(requiredParamCount)..\", \"..tostring(paramCount)..\", g_wxluaargtypeArray_None },\\n\")\r\n            for i = 1, #methodBindings do\r\n                if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"\\n#if \"..methodBindings[i].Condition..\"\\n\")\r\n                end\r\n\r\n                table.insert(funcMap, \"    \"..methodBindings[i].FuncMap..\",\\n\")\r\n\r\n                if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"#endif // \"..methodBindings[i].Condition..\"\\n\")\r\n                end\r\n            end\r\n            table.insert(funcMap, \"};\\n\")\r\n\r\n            table.insert(funcMap, \"static int \"..funcMapName..\"_count = sizeof(\"..funcMapName..\")/sizeof(wxLuaBindCFunc);\\n\\n\")\r\n\r\n            local methodMap = \"    { \\\"\"..methodBindings[1].LuaName..\"\\\", \"..funcType..\", \"..funcMapName..\", \"..funcMapName..\"_count, 0 }\"\r\n\r\n            local codeList = {}\r\n\r\n--            CommentBindingTable(codeList, \"// Overloaded function for \"..methodBindings[1].ClassName..\"::\"..methodBindings[1].LuaName..\"\\n\")\r\n--            table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n--            table.insert(codeList, \"    static wxLuaBindMethod overload_method = \\n\")\r\n--            table.insert(codeList, \"    \"..methodMap..\";\\n\")\r\n--            table.insert(codeList, \"    return wxlua_CallOverloadedFunction(L, &overload_method);\\n\")\r\n--            table.insert(codeList, \"}\\n\")\r\n\r\n            local methodBinding =\r\n            {\r\n                Condition = overload_condition,\r\n                CFunctionName = funcName,\r\n                FuncMap = funcMap,\r\n                funcMapName = funcMapName,\r\n                ParamCount = paramCount,\r\n                RequiredParamCount = requiredParamCount,\r\n                Method = codeList,\r\n                Map = methodMap..\",\\n\",\r\n                IsOverload = true\r\n            }\r\n\r\n            -- clear and replace the other bindings\r\n            sortedBindings[n] = {}\r\n            table.insert(sortedBindings[n], methodBinding)\r\n\r\n            table.insert(overloadBindings, {})\r\n            table.insert(overloadBindings[#overloadBindings], methodBinding)\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 2034,
    "text": "local overload_count = 0",
    "type": "statement:localassign"
  }, {
    "id": 2035,
    "text": "local methodBindings = sortedBindings[n]",
    "type": "statement:localassign"
  }, {
    "id": 2036,
    "text": "local paramCount = 0",
    "type": "statement:localassign"
  }, {
    "id": 2037,
    "text": "local requiredParamCount = 1E6",
    "type": "statement:localassign"
  }, {
    "id": 2038,
    "text": "local funcType = methodBindings[1].FuncType",
    "type": "statement:localassign"
  }, {
    "id": 2039,
    "text": "local not_overload = 0",
    "type": "statement:localassign"
  }, {
    "id": 2040,
    "text": "for i = 1, #methodBindings do\r\n            if methodBindings[i].Method then -- ignore properties\r\n                overload_count = overload_count + 1\r\n\r\n                if methodBindings[i].NotOverload == true then\r\n                    not_overload = not_overload + 1\r\n                end\r\n\r\n                if methodBindings[i].ParamCount and (paramCount < methodBindings[i].ParamCount) then\r\n                    paramCount = methodBindings[i].ParamCount\r\n                end\r\n                if methodBindings[i].RequiredParamCount and (requiredParamCount > methodBindings[i].RequiredParamCount) then\r\n                    requiredParamCount = methodBindings[i].RequiredParamCount\r\n                end\r\n\r\n                for s in string.gmatch(methodBindings[i].FuncType, \"[%a_]+\") do\r\n                    if (string.find(funcType, s, 1, 1) == nil) then\r\n                        funcType = funcType..\"|\"..s\r\n                    end\r\n                end\r\n            end\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 2041,
    "text": "if methodBindings[i].Method then -- ignore properties\r\n                overload_count = overload_count + 1\r\n\r\n                if methodBindings[i].NotOverload == true then\r\n                    not_overload = not_overload + 1\r\n                end\r\n\r\n                if methodBindings[i].ParamCount and (paramCount < methodBindings[i].ParamCount) then\r\n                    paramCount = methodBindings[i].ParamCount\r\n                end\r\n                if methodBindings[i].RequiredParamCount and (requiredParamCount > methodBindings[i].RequiredParamCount) then\r\n                    requiredParamCount = methodBindings[i].RequiredParamCount\r\n                end\r\n\r\n                for s in string.gmatch(methodBindings[i].FuncType, \"[%a_]+\") do\r\n                    if (string.find(funcType, s, 1, 1) == nil) then\r\n                        funcType = funcType..\"|\"..s\r\n                    end\r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 2042,
    "text": "overload_count = overload_count + 1",
    "type": "statement:assign"
  }, {
    "id": 2043,
    "text": "if methodBindings[i].NotOverload == true then\r\n                    not_overload = not_overload + 1\r\n                end",
    "type": "statement:if"
  }, {
    "id": 2044,
    "text": "not_overload = not_overload + 1",
    "type": "statement:assign"
  }, {
    "id": 2045,
    "text": "if methodBindings[i].ParamCount and (paramCount < methodBindings[i].ParamCount) then\r\n                    paramCount = methodBindings[i].ParamCount\r\n                end",
    "type": "statement:if"
  }, {
    "id": 2046,
    "text": "paramCount = methodBindings[i].ParamCount",
    "type": "statement:assign"
  }, {
    "id": 2047,
    "text": "if methodBindings[i].RequiredParamCount and (requiredParamCount > methodBindings[i].RequiredParamCount) then\r\n                    requiredParamCount = methodBindings[i].RequiredParamCount\r\n                end",
    "type": "statement:if"
  }, {
    "id": 2048,
    "text": "requiredParamCount = methodBindings[i].RequiredParamCount",
    "type": "statement:assign"
  }, {
    "id": 2049,
    "text": "for s in string.gmatch(methodBindings[i].FuncType, \"[%a_]+\") do\r\n                    if (string.find(funcType, s, 1, 1) == nil) then\r\n                        funcType = funcType..\"|\"..s\r\n                    end\r\n                end",
    "type": "statement:genericfor"
  }, {
    "id": 2050,
    "text": "if (string.find(funcType, s, 1, 1) == nil) then\r\n                        funcType = funcType..\"|\"..s\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 2051,
    "text": "funcType = funcType..\"|\"..s",
    "type": "statement:assign"
  }, {
    "id": 2052,
    "text": "if (overload_count > 1) and (not_overload < overload_count) then\r\n            --print(n, #methodBindings, methodBindings[1].Map)\r\n\r\n            local overload_condition = \"\"\r\n            local overload_conditions_used = {}\r\n            --if HasCondition(object.Condition) then\r\n            --    overload_conditions_used[object.Condition] = 1\r\n            --end\r\n            local cfuncNameBase = methodBindings[1].CFunctionNameBase\r\n\r\n            for i = 1, #methodBindings do\r\n                if HasCondition(methodBindings[i].Condition) and (overload_conditions_used[methodBindings[i].Condition] == nil) then\r\n                    if overload_condition ~= \"\" then overload_condition = overload_condition..\"||\" end\r\n                    overload_condition = overload_condition..\"(\"..methodBindings[i].Condition..\")\"\r\n                    overload_conditions_used[methodBindings[i].Condition] = 1\r\n                end\r\n            end\r\n\r\n            local funcName = cfuncNameBase..\"_overload\"\r\n            local funcMap = {}\r\n            local funcMapName = \"s_wxluafunc_\"..cfuncNameBase..\"_overload\"\r\n\r\n            CommentBindingTable(funcMap, \"// function overload table\\n\")\r\n            table.insert(funcMap, \"static wxLuaBindCFunc \"..funcMapName..\"[] =\\n{\\n\")\r\n--            table.insert(funcMap, \"    { \"..funcName..\", WXLUAMETHOD_METHOD|WXLUAMETHOD_OVERLOAD, \"..tostring(requiredParamCount)..\", \"..tostring(paramCount)..\", g_wxluaargtypeArray_None },\\n\")\r\n            for i = 1, #methodBindings do\r\n                if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"\\n#if \"..methodBindings[i].Condition..\"\\n\")\r\n                end\r\n\r\n                table.insert(funcMap, \"    \"..methodBindings[i].FuncMap..\",\\n\")\r\n\r\n                if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"#endif // \"..methodBindings[i].Condition..\"\\n\")\r\n                end\r\n            end\r\n            table.insert(funcMap, \"};\\n\")\r\n\r\n            table.insert(funcMap, \"static int \"..funcMapName..\"_count = sizeof(\"..funcMapName..\")/sizeof(wxLuaBindCFunc);\\n\\n\")\r\n\r\n            local methodMap = \"    { \\\"\"..methodBindings[1].LuaName..\"\\\", \"..funcType..\", \"..funcMapName..\", \"..funcMapName..\"_count, 0 }\"\r\n\r\n            local codeList = {}\r\n\r\n--            CommentBindingTable(codeList, \"// Overloaded function for \"..methodBindings[1].ClassName..\"::\"..methodBindings[1].LuaName..\"\\n\")\r\n--            table.insert(codeList, \"static int LUACALL \"..funcName..\"(lua_State *L)\\n{\\n\")\r\n--            table.insert(codeList, \"    static wxLuaBindMethod overload_method = \\n\")\r\n--            table.insert(codeList, \"    \"..methodMap..\";\\n\")\r\n--            table.insert(codeList, \"    return wxlua_CallOverloadedFunction(L, &overload_method);\\n\")\r\n--            table.insert(codeList, \"}\\n\")\r\n\r\n            local methodBinding =\r\n            {\r\n                Condition = overload_condition,\r\n                CFunctionName = funcName,\r\n                FuncMap = funcMap,\r\n                funcMapName = funcMapName,\r\n                ParamCount = paramCount,\r\n                RequiredParamCount = requiredParamCount,\r\n                Method = codeList,\r\n                Map = methodMap..\",\\n\",\r\n                IsOverload = true\r\n            }\r\n\r\n            -- clear and replace the other bindings\r\n            sortedBindings[n] = {}\r\n            table.insert(sortedBindings[n], methodBinding)\r\n\r\n            table.insert(overloadBindings, {})\r\n            table.insert(overloadBindings[#overloadBindings], methodBinding)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 2053,
    "text": "local overload_condition = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 2054,
    "text": "local overload_conditions_used = {}",
    "type": "statement:localassign"
  }, {
    "id": 2055,
    "text": "local cfuncNameBase = methodBindings[1].CFunctionNameBase",
    "type": "statement:localassign"
  }, {
    "id": 2056,
    "text": "for i = 1, #methodBindings do\r\n                if HasCondition(methodBindings[i].Condition) and (overload_conditions_used[methodBindings[i].Condition] == nil) then\r\n                    if overload_condition ~= \"\" then overload_condition = overload_condition..\"||\" end\r\n                    overload_condition = overload_condition..\"(\"..methodBindings[i].Condition..\")\"\r\n                    overload_conditions_used[methodBindings[i].Condition] = 1\r\n                end\r\n            end",
    "type": "statement:numericfor"
  }, {
    "id": 2057,
    "text": "if HasCondition(methodBindings[i].Condition) and (overload_conditions_used[methodBindings[i].Condition] == nil) then\r\n                    if overload_condition ~= \"\" then overload_condition = overload_condition..\"||\" end\r\n                    overload_condition = overload_condition..\"(\"..methodBindings[i].Condition..\")\"\r\n                    overload_conditions_used[methodBindings[i].Condition] = 1\r\n                end",
    "type": "statement:if"
  }, {
    "id": 2058,
    "text": "if overload_condition ~= \"\" then overload_condition = overload_condition..\"||\" end",
    "type": "statement:if"
  }, {
    "id": 2059,
    "text": "overload_condition = overload_condition..\"||\"",
    "type": "statement:assign"
  }, {
    "id": 2060,
    "text": "overload_condition = overload_condition..\"(\"..methodBindings[i].Condition..\")\"",
    "type": "statement:assign"
  }, {
    "id": 2061,
    "text": "overload_conditions_used[methodBindings[i].Condition] = 1",
    "type": "statement:assign"
  }, {
    "id": 2062,
    "text": "local funcName = cfuncNameBase..\"_overload\"",
    "type": "statement:localassign"
  }, {
    "id": 2063,
    "text": "local funcMap = {}",
    "type": "statement:localassign"
  }, {
    "id": 2064,
    "text": "local funcMapName = \"s_wxluafunc_\"..cfuncNameBase..\"_overload\"",
    "type": "statement:localassign"
  }, {
    "id": 2065,
    "text": "CommentBindingTable(funcMap, \"// function overload table\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2066,
    "text": "table.insert(funcMap, \"static wxLuaBindCFunc \"..funcMapName..\"[] =\\n{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2067,
    "text": "for i = 1, #methodBindings do\r\n                if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"\\n#if \"..methodBindings[i].Condition..\"\\n\")\r\n                end\r\n\r\n                table.insert(funcMap, \"    \"..methodBindings[i].FuncMap..\",\\n\")\r\n\r\n                if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"#endif // \"..methodBindings[i].Condition..\"\\n\")\r\n                end\r\n            end",
    "type": "statement:numericfor"
  }, {
    "id": 2068,
    "text": "if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"\\n#if \"..methodBindings[i].Condition..\"\\n\")\r\n                end",
    "type": "statement:if"
  }, {
    "id": 2069,
    "text": "table.insert(funcMap, \"\\n#if \"..methodBindings[i].Condition..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2070,
    "text": "table.insert(funcMap, \"    \"..methodBindings[i].FuncMap..\",\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2071,
    "text": "if HasCondition(methodBindings[i].Condition) and (methodBindings[i].Condition ~= object.Condition) then\r\n                    table.insert(funcMap, \"#endif // \"..methodBindings[i].Condition..\"\\n\")\r\n                end",
    "type": "statement:if"
  }, {
    "id": 2072,
    "text": "table.insert(funcMap, \"#endif // \"..methodBindings[i].Condition..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2073,
    "text": "table.insert(funcMap, \"};\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2074,
    "text": "table.insert(funcMap, \"static int \"..funcMapName..\"_count = sizeof(\"..funcMapName..\")/sizeof(wxLuaBindCFunc);\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2075,
    "text": "local methodMap = \"    { \\\"\"..methodBindings[1].LuaName..\"\\\", \"..funcType..\", \"..funcMapName..\", \"..funcMapName..\"_count, 0 }\"",
    "type": "statement:localassign"
  }, {
    "id": 2076,
    "text": "local methodBinding =\r\n            {\r\n                Condition = overload_condition,\r\n                CFunctionName = funcName,\r\n                FuncMap = funcMap,\r\n                funcMapName = funcMapName,\r\n                ParamCount = paramCount,\r\n                RequiredParamCount = requiredParamCount,\r\n                Method = codeList,\r\n                Map = methodMap..\",\\n\",\r\n                IsOverload = true\r\n            }",
    "type": "statement:localassign"
  }, {
    "id": 2077,
    "text": "sortedBindings[n] = {}",
    "type": "statement:assign"
  }, {
    "id": 2078,
    "text": "table.insert(sortedBindings[n], methodBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 2079,
    "text": "table.insert(overloadBindings, {})",
    "type": "statement:functioncall"
  }, {
    "id": 2080,
    "text": "table.insert(overloadBindings[#overloadBindings], methodBinding)",
    "type": "statement:functioncall"
  }, {
    "id": 2081,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2082,
    "text": "function GenerateBindingFileTable(interface, fileData, add_includes)\r\n\r\n    fileData = GenerateHookCppFileHeader(fileData, interface.CPPFileName, add_includes)\r\n\r\n    for k, v in pairs_sort(interface.includeFiles) do\r\n        table.insert(fileData, \"#include \"..v..\"\\n\")\r\n    end\r\n    table.insert(fileData, \"\\n\")\r\n\r\n    for o = 1, #interface.objectData do\r\n        local object = interface.objectData[o]\r\n\r\n        --print(\"Output \", object.ObjType, object.Name)\r\n\r\n        if (object.ObjType == \"objtype_%class\") or (object.ObjType == \"objtype_%struct\") then\r\n            local ObjectName = object.Name\r\n            local BindTable = object.BindTable\r\n            local OverloadTable = object.OverloadTable\r\n\r\n            if object.Condition then\r\n                table.insert(fileData, \"\\n#if \"..object.Condition..\"\\n\")\r\n            end\r\n\r\n            -- Output Parsed Object\r\n            table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n            table.insert(fileData, \"// Bind \"..string.sub(object.ObjType, 10)..\" \"..object.Name..\"\\n\")\r\n            table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n            -- Class Tag Declaration\r\n            table.insert(fileData, object.TagDeclaration)\r\n            table.insert(fileData, \"\\n\")\r\n\r\n            local namedBindingTable = {}\r\n            GenerateLuaNameFromIndexedTable(BindTable, namedBindingTable)\r\n            -- sort the bindings by class name and write them out alphabetically\r\n            local sortedBindings = TableSort(namedBindingTable)\r\n\r\n            -- Output Bind Methods\r\n            local function writeFunc(functionBinding)\r\n                if functionBinding.Method then\r\n                    if functionBinding.PreDefineCode then\r\n                        table.insert(fileData, functionBinding.PreDefineCode)\r\n                    end\r\n                    if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                        table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n                    end\r\n                    if functionBinding.FuncMapName then\r\n                        if functionBinding.CFunctionName ~= \"wxlua_userdata_delete\" then\r\n                            table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                        end\r\n                        table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\")\r\n                    end\r\n\r\n                    table.insert(fileData, table.concat(functionBinding.Method)..\"\\n\")\r\n                end\r\n            end\r\n            GenerateMap(fileData, sortedBindings, \"    \", writeFunc, true, object.Condition)\r\n\r\n            table.insert(fileData, \"\\n\\n\")\r\n\r\n            -- Output overloaded functions\r\n            local overloadBindings = GenerateOverloadBinding(sortedBindings, object)\r\n\r\n            local function writeFunc(functionBinding)\r\n                if functionBinding.IsOverload then\r\n--                    table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                    table.insert(fileData, table.concat(functionBinding.FuncMap))\r\n                    table.insert(fileData, table.concat(functionBinding.Method))\r\n                end\r\n            end\r\n            GenerateMap(fileData, overloadBindings, \"    \", writeFunc, true, object.Condition)\r\n\r\n            -- Output Method Map Table\r\n\r\n            CommentBindingTable(fileData, \"// Map Lua Class Methods to C Binding Functions\\n\")\r\n\r\n            table.insert(fileData, \"wxLuaBindMethod \"..MakeClassVar(ObjectName)..\"_methods[] = {\\n\")\r\n            GenerateMap(fileData, sortedBindings, \"\", nil, false, object.Condition)\r\n            table.insert(fileData, \"    { 0, 0, 0, 0 },\\n\")\r\n            table.insert(fileData, \"};\\n\\n\")\r\n\r\n            -- since there may be conditions count them up afterwards\r\n            table.insert(fileData, \"int \"..MakeVar(ObjectName)..\"_methodCount = sizeof(\"..MakeClassVar(ObjectName)..\"_methods)/sizeof(wxLuaBindMethod) - 1;\\n\\n\")\r\n\r\n            if enumClassBindingTable[MakeClassVar(ObjectName)] then\r\n                table.insert(fileData, \"wxLuaBindNumber \"..MakeClassVar(ObjectName)..\"_enums[] = {\\n\")\r\n                local namedBindingTable = {}\r\n                GenerateLuaNameFromIndexedTable(enumClassBindingTable[MakeClassVar(ObjectName)], namedBindingTable)\r\n                -- sort the bindings by class name and write them out alphabetically\r\n                local sortedBindings = TableSort(namedBindingTable)\r\n                GenerateMap(fileData, sortedBindings)\r\n                table.insert(fileData, \"    { NULL, 0, },\\n\")\r\n                table.insert(fileData, \"};\\n\")\r\n\r\n                -- since there may be conditions count them up afterwards\r\n                table.insert(fileData, \"int \"..MakeVar(ObjectName)..\"_enumCount = sizeof(\"..MakeClassVar(ObjectName)..\"_enums)/sizeof(wxLuaBindNumber) - 1;\\n\")\r\n            end\r\n\r\n            if object.Condition then\r\n                table.insert(fileData, \"#endif  // \"..object.Condition..\"\\n\")\r\n            end\r\n\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end\r\n\r\n    RemoveExtra_wxLuaBindCFunc(fileData)\r\n\r\n    return fileData\r\nend",
    "type": "function"
  }, {
    "id": 2083,
    "text": "fileData = GenerateHookCppFileHeader(fileData, interface.CPPFileName, add_includes)",
    "type": "statement:assign"
  }, {
    "id": 2084,
    "text": "for k, v in pairs_sort(interface.includeFiles) do\r\n        table.insert(fileData, \"#include \"..v..\"\\n\")\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 2085,
    "text": "table.insert(fileData, \"#include \"..v..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2086,
    "text": "for o = 1, #interface.objectData do\r\n        local object = interface.objectData[o]\r\n\r\n        --print(\"Output \", object.ObjType, object.Name)\r\n\r\n        if (object.ObjType == \"objtype_%class\") or (object.ObjType == \"objtype_%struct\") then\r\n            local ObjectName = object.Name\r\n            local BindTable = object.BindTable\r\n            local OverloadTable = object.OverloadTable\r\n\r\n            if object.Condition then\r\n                table.insert(fileData, \"\\n#if \"..object.Condition..\"\\n\")\r\n            end\r\n\r\n            -- Output Parsed Object\r\n            table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n            table.insert(fileData, \"// Bind \"..string.sub(object.ObjType, 10)..\" \"..object.Name..\"\\n\")\r\n            table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n            -- Class Tag Declaration\r\n            table.insert(fileData, object.TagDeclaration)\r\n            table.insert(fileData, \"\\n\")\r\n\r\n            local namedBindingTable = {}\r\n            GenerateLuaNameFromIndexedTable(BindTable, namedBindingTable)\r\n            -- sort the bindings by class name and write them out alphabetically\r\n            local sortedBindings = TableSort(namedBindingTable)\r\n\r\n            -- Output Bind Methods\r\n            local function writeFunc(functionBinding)\r\n                if functionBinding.Method then\r\n                    if functionBinding.PreDefineCode then\r\n                        table.insert(fileData, functionBinding.PreDefineCode)\r\n                    end\r\n                    if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                        table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n                    end\r\n                    if functionBinding.FuncMapName then\r\n                        if functionBinding.CFunctionName ~= \"wxlua_userdata_delete\" then\r\n                            table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                        end\r\n                        table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\")\r\n                    end\r\n\r\n                    table.insert(fileData, table.concat(functionBinding.Method)..\"\\n\")\r\n                end\r\n            end\r\n            GenerateMap(fileData, sortedBindings, \"    \", writeFunc, true, object.Condition)\r\n\r\n            table.insert(fileData, \"\\n\\n\")\r\n\r\n            -- Output overloaded functions\r\n            local overloadBindings = GenerateOverloadBinding(sortedBindings, object)\r\n\r\n            local function writeFunc(functionBinding)\r\n                if functionBinding.IsOverload then\r\n--                    table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                    table.insert(fileData, table.concat(functionBinding.FuncMap))\r\n                    table.insert(fileData, table.concat(functionBinding.Method))\r\n                end\r\n            end\r\n            GenerateMap(fileData, overloadBindings, \"    \", writeFunc, true, object.Condition)\r\n\r\n            -- Output Method Map Table\r\n\r\n            CommentBindingTable(fileData, \"// Map Lua Class Methods to C Binding Functions\\n\")\r\n\r\n            table.insert(fileData, \"wxLuaBindMethod \"..MakeClassVar(ObjectName)..\"_methods[] = {\\n\")\r\n            GenerateMap(fileData, sortedBindings, \"\", nil, false, object.Condition)\r\n            table.insert(fileData, \"    { 0, 0, 0, 0 },\\n\")\r\n            table.insert(fileData, \"};\\n\\n\")\r\n\r\n            -- since there may be conditions count them up afterwards\r\n            table.insert(fileData, \"int \"..MakeVar(ObjectName)..\"_methodCount = sizeof(\"..MakeClassVar(ObjectName)..\"_methods)/sizeof(wxLuaBindMethod) - 1;\\n\\n\")\r\n\r\n            if enumClassBindingTable[MakeClassVar(ObjectName)] then\r\n                table.insert(fileData, \"wxLuaBindNumber \"..MakeClassVar(ObjectName)..\"_enums[] = {\\n\")\r\n                local namedBindingTable = {}\r\n                GenerateLuaNameFromIndexedTable(enumClassBindingTable[MakeClassVar(ObjectName)], namedBindingTable)\r\n                -- sort the bindings by class name and write them out alphabetically\r\n                local sortedBindings = TableSort(namedBindingTable)\r\n                GenerateMap(fileData, sortedBindings)\r\n                table.insert(fileData, \"    { NULL, 0, },\\n\")\r\n                table.insert(fileData, \"};\\n\")\r\n\r\n                -- since there may be conditions count them up afterwards\r\n                table.insert(fileData, \"int \"..MakeVar(ObjectName)..\"_enumCount = sizeof(\"..MakeClassVar(ObjectName)..\"_enums)/sizeof(wxLuaBindNumber) - 1;\\n\")\r\n            end\r\n\r\n            if object.Condition then\r\n                table.insert(fileData, \"#endif  // \"..object.Condition..\"\\n\")\r\n            end\r\n\r\n            table.insert(fileData, \"\\n\")\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 2087,
    "text": "local object = interface.objectData[o]",
    "type": "statement:localassign"
  }, {
    "id": 2088,
    "text": "if (object.ObjType == \"objtype_%class\") or (object.ObjType == \"objtype_%struct\") then\r\n            local ObjectName = object.Name\r\n            local BindTable = object.BindTable\r\n            local OverloadTable = object.OverloadTable\r\n\r\n            if object.Condition then\r\n                table.insert(fileData, \"\\n#if \"..object.Condition..\"\\n\")\r\n            end\r\n\r\n            -- Output Parsed Object\r\n            table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\")\r\n            table.insert(fileData, \"// Bind \"..string.sub(object.ObjType, 10)..\" \"..object.Name..\"\\n\")\r\n            table.insert(fileData, \"// ---------------------------------------------------------------------------\\n\\n\")\r\n\r\n            -- Class Tag Declaration\r\n            table.insert(fileData, object.TagDeclaration)\r\n            table.insert(fileData, \"\\n\")\r\n\r\n            local namedBindingTable = {}\r\n            GenerateLuaNameFromIndexedTable(BindTable, namedBindingTable)\r\n            -- sort the bindings by class name and write them out alphabetically\r\n            local sortedBindings = TableSort(namedBindingTable)\r\n\r\n            -- Output Bind Methods\r\n            local function writeFunc(functionBinding)\r\n                if functionBinding.Method then\r\n                    if functionBinding.PreDefineCode then\r\n                        table.insert(fileData, functionBinding.PreDefineCode)\r\n                    end\r\n                    if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                        table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n                    end\r\n                    if functionBinding.FuncMapName then\r\n                        if functionBinding.CFunctionName ~= \"wxlua_userdata_delete\" then\r\n                            table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                        end\r\n                        table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\")\r\n                    end\r\n\r\n                    table.insert(fileData, table.concat(functionBinding.Method)..\"\\n\")\r\n                end\r\n            end\r\n            GenerateMap(fileData, sortedBindings, \"    \", writeFunc, true, object.Condition)\r\n\r\n            table.insert(fileData, \"\\n\\n\")\r\n\r\n            -- Output overloaded functions\r\n            local overloadBindings = GenerateOverloadBinding(sortedBindings, object)\r\n\r\n            local function writeFunc(functionBinding)\r\n                if functionBinding.IsOverload then\r\n--                    table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                    table.insert(fileData, table.concat(functionBinding.FuncMap))\r\n                    table.insert(fileData, table.concat(functionBinding.Method))\r\n                end\r\n            end\r\n            GenerateMap(fileData, overloadBindings, \"    \", writeFunc, true, object.Condition)\r\n\r\n            -- Output Method Map Table\r\n\r\n            CommentBindingTable(fileData, \"// Map Lua Class Methods to C Binding Functions\\n\")\r\n\r\n            table.insert(fileData, \"wxLuaBindMethod \"..MakeClassVar(ObjectName)..\"_methods[] = {\\n\")\r\n            GenerateMap(fileData, sortedBindings, \"\", nil, false, object.Condition)\r\n            table.insert(fileData, \"    { 0, 0, 0, 0 },\\n\")\r\n            table.insert(fileData, \"};\\n\\n\")\r\n\r\n            -- since there may be conditions count them up afterwards\r\n            table.insert(fileData, \"int \"..MakeVar(ObjectName)..\"_methodCount = sizeof(\"..MakeClassVar(ObjectName)..\"_methods)/sizeof(wxLuaBindMethod) - 1;\\n\\n\")\r\n\r\n            if enumClassBindingTable[MakeClassVar(ObjectName)] then\r\n                table.insert(fileData, \"wxLuaBindNumber \"..MakeClassVar(ObjectName)..\"_enums[] = {\\n\")\r\n                local namedBindingTable = {}\r\n                GenerateLuaNameFromIndexedTable(enumClassBindingTable[MakeClassVar(ObjectName)], namedBindingTable)\r\n                -- sort the bindings by class name and write them out alphabetically\r\n                local sortedBindings = TableSort(namedBindingTable)\r\n                GenerateMap(fileData, sortedBindings)\r\n                table.insert(fileData, \"    { NULL, 0, },\\n\")\r\n                table.insert(fileData, \"};\\n\")\r\n\r\n                -- since there may be conditions count them up afterwards\r\n                table.insert(fileData, \"int \"..MakeVar(ObjectName)..\"_enumCount = sizeof(\"..MakeClassVar(ObjectName)..\"_enums)/sizeof(wxLuaBindNumber) - 1;\\n\")\r\n            end\r\n\r\n            if object.Condition then\r\n                table.insert(fileData, \"#endif  // \"..object.Condition..\"\\n\")\r\n            end\r\n\r\n            table.insert(fileData, \"\\n\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 2089,
    "text": "local ObjectName = object.Name",
    "type": "statement:localassign"
  }, {
    "id": 2090,
    "text": "local BindTable = object.BindTable",
    "type": "statement:localassign"
  }, {
    "id": 2091,
    "text": "local OverloadTable = object.OverloadTable",
    "type": "statement:localassign"
  }, {
    "id": 2092,
    "text": "if object.Condition then\r\n                table.insert(fileData, \"\\n#if \"..object.Condition..\"\\n\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 2093,
    "text": "table.insert(fileData, \"\\n#if \"..object.Condition..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2094,
    "text": "table.insert(fileData, \"// Bind \"..string.sub(object.ObjType, 10)..\" \"..object.Name..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2095,
    "text": "table.insert(fileData, object.TagDeclaration)",
    "type": "statement:functioncall"
  }, {
    "id": 2096,
    "text": "GenerateLuaNameFromIndexedTable(BindTable, namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 2097,
    "text": "local function writeFunc(functionBinding)\r\n                if functionBinding.Method then\r\n                    if functionBinding.PreDefineCode then\r\n                        table.insert(fileData, functionBinding.PreDefineCode)\r\n                    end\r\n                    if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                        table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n                    end\r\n                    if functionBinding.FuncMapName then\r\n                        if functionBinding.CFunctionName ~= \"wxlua_userdata_delete\" then\r\n                            table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                        end\r\n                        table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\")\r\n                    end\r\n\r\n                    table.insert(fileData, table.concat(functionBinding.Method)..\"\\n\")\r\n                end\r\n            end",
    "type": "statement:localfunction"
  }, {
    "id": 2098,
    "text": "if functionBinding.Method then\r\n                    if functionBinding.PreDefineCode then\r\n                        table.insert(fileData, functionBinding.PreDefineCode)\r\n                    end\r\n                    if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                        table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n                    end\r\n                    if functionBinding.FuncMapName then\r\n                        if functionBinding.CFunctionName ~= \"wxlua_userdata_delete\" then\r\n                            table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                        end\r\n                        table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\")\r\n                    end\r\n\r\n                    table.insert(fileData, table.concat(functionBinding.Method)..\"\\n\")\r\n                end",
    "type": "statement:if"
  }, {
    "id": 2099,
    "text": "if functionBinding.PreDefineCode then\r\n                        table.insert(fileData, functionBinding.PreDefineCode)\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 2100,
    "text": "table.insert(fileData, functionBinding.PreDefineCode)",
    "type": "statement:functioncall"
  }, {
    "id": 2101,
    "text": "if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                        table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 2102,
    "text": "if functionBinding.FuncMapName then\r\n                        if functionBinding.CFunctionName ~= \"wxlua_userdata_delete\" then\r\n                            table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                        end\r\n                        table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\")\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 2103,
    "text": "if functionBinding.CFunctionName ~= \"wxlua_userdata_delete\" then\r\n                            table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 2104,
    "text": "table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2105,
    "text": "table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2106,
    "text": "table.insert(fileData, table.concat(functionBinding.Method)..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2107,
    "text": "GenerateMap(fileData, sortedBindings, \"    \", writeFunc, true, object.Condition)",
    "type": "statement:functioncall"
  }, {
    "id": 2108,
    "text": "local overloadBindings = GenerateOverloadBinding(sortedBindings, object)",
    "type": "statement:localassign"
  }, {
    "id": 2109,
    "text": "local function writeFunc(functionBinding)\r\n                if functionBinding.IsOverload then\r\n--                    table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                    table.insert(fileData, table.concat(functionBinding.FuncMap))\r\n                    table.insert(fileData, table.concat(functionBinding.Method))\r\n                end\r\n            end",
    "type": "statement:localfunction"
  }, {
    "id": 2110,
    "text": "if functionBinding.IsOverload then\r\n--                    table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                    table.insert(fileData, table.concat(functionBinding.FuncMap))\r\n                    table.insert(fileData, table.concat(functionBinding.Method))\r\n                end",
    "type": "statement:if"
  }, {
    "id": 2111,
    "text": "table.insert(fileData, table.concat(functionBinding.FuncMap))",
    "type": "statement:functioncall"
  }, {
    "id": 2112,
    "text": "GenerateMap(fileData, overloadBindings, \"    \", writeFunc, true, object.Condition)",
    "type": "statement:functioncall"
  }, {
    "id": 2113,
    "text": "CommentBindingTable(fileData, \"// Map Lua Class Methods to C Binding Functions\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2114,
    "text": "table.insert(fileData, \"wxLuaBindMethod \"..MakeClassVar(ObjectName)..\"_methods[] = {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2115,
    "text": "GenerateMap(fileData, sortedBindings, \"\", nil, false, object.Condition)",
    "type": "statement:functioncall"
  }, {
    "id": 2116,
    "text": "table.insert(fileData, \"    { 0, 0, 0, 0 },\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2117,
    "text": "table.insert(fileData, \"};\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2118,
    "text": "table.insert(fileData, \"int \"..MakeVar(ObjectName)..\"_methodCount = sizeof(\"..MakeClassVar(ObjectName)..\"_methods)/sizeof(wxLuaBindMethod) - 1;\\n\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2119,
    "text": "if enumClassBindingTable[MakeClassVar(ObjectName)] then\r\n                table.insert(fileData, \"wxLuaBindNumber \"..MakeClassVar(ObjectName)..\"_enums[] = {\\n\")\r\n                local namedBindingTable = {}\r\n                GenerateLuaNameFromIndexedTable(enumClassBindingTable[MakeClassVar(ObjectName)], namedBindingTable)\r\n                -- sort the bindings by class name and write them out alphabetically\r\n                local sortedBindings = TableSort(namedBindingTable)\r\n                GenerateMap(fileData, sortedBindings)\r\n                table.insert(fileData, \"    { NULL, 0, },\\n\")\r\n                table.insert(fileData, \"};\\n\")\r\n\r\n                -- since there may be conditions count them up afterwards\r\n                table.insert(fileData, \"int \"..MakeVar(ObjectName)..\"_enumCount = sizeof(\"..MakeClassVar(ObjectName)..\"_enums)/sizeof(wxLuaBindNumber) - 1;\\n\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 2120,
    "text": "table.insert(fileData, \"wxLuaBindNumber \"..MakeClassVar(ObjectName)..\"_enums[] = {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2121,
    "text": "GenerateLuaNameFromIndexedTable(enumClassBindingTable[MakeClassVar(ObjectName)], namedBindingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 2122,
    "text": "table.insert(fileData, \"    { NULL, 0, },\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2123,
    "text": "table.insert(fileData, \"int \"..MakeVar(ObjectName)..\"_enumCount = sizeof(\"..MakeClassVar(ObjectName)..\"_enums)/sizeof(wxLuaBindNumber) - 1;\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2124,
    "text": "if object.Condition then\r\n                table.insert(fileData, \"#endif  // \"..object.Condition..\"\\n\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 2125,
    "text": "table.insert(fileData, \"#endif  // \"..object.Condition..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2126,
    "text": "RemoveExtra_wxLuaBindCFunc(fileData)",
    "type": "statement:functioncall"
  }, {
    "id": 2127,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2128,
    "text": "local function writeFunc(functionBinding)\r\n                if functionBinding.Method then\r\n                    if functionBinding.PreDefineCode then\r\n                        table.insert(fileData, functionBinding.PreDefineCode)\r\n                    end\r\n                    if functionBinding.ArgArrayName and (functionBinding.ArgArrayName ~= \"g_wxluaargtypeArray_None\") then\r\n                        table.insert(fileData, \"static wxLuaArgType \"..functionBinding.ArgArrayName..\"[] = \"..functionBinding.ArgArray..\";\\n\")\r\n                    end\r\n                    if functionBinding.FuncMapName then\r\n                        if functionBinding.CFunctionName ~= \"wxlua_userdata_delete\" then\r\n                            table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                        end\r\n                        table.insert(fileData, \"static wxLuaBindCFunc \"..functionBinding.FuncMapName..\"[1] = {\"..functionBinding.FuncMap..\"};\\n\")\r\n                    end\r\n\r\n                    table.insert(fileData, table.concat(functionBinding.Method)..\"\\n\")\r\n                end\r\n            end",
    "type": "function"
  }, {
    "id": 2129,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2130,
    "text": "local function writeFunc(functionBinding)\r\n                if functionBinding.IsOverload then\r\n--                    table.insert(fileData, \"static int LUACALL \"..functionBinding.CFunctionName..\"(lua_State *L);\\n\")\r\n                    table.insert(fileData, table.concat(functionBinding.FuncMap))\r\n                    table.insert(fileData, table.concat(functionBinding.Method))\r\n                end\r\n            end",
    "type": "function"
  }, {
    "id": 2131,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2132,
    "text": "function RemoveExtra_wxLuaBindCFunc(fileData)\r\n    local cfuncTable = {}\r\n\r\n    for n = 1, #fileData do\r\n        if string.find(fileData[n], \"static wxLuaBindCFunc s_wxluafunc\", 1, 1) then\r\n            local a, b = string.find(fileData[n], \"s_wxluafunc\", 1, 1)\r\n            local s = string.sub(fileData[n], a)\r\n            a, b = string.find(s, \"[\", 1, 1)\r\n            s = string.sub(s, 1, a-1)\r\n\r\n            cfuncTable[s] = n\r\n        elseif string.find(fileData[n], \"s_wxluafunc\", 1, 1) then\r\n            for k, v in pairs(cfuncTable) do\r\n                if string.find(fileData[n], k..\",\", 1, 1) or string.find(fileData[n], k..\" \", 1, 1) then\r\n                    cfuncTable[k] = -1 -- found\r\n                end\r\n            end\r\n        end\r\n    end\r\n\r\n    for k, v in pairs(cfuncTable) do\r\n        if v > 0 then\r\n            fileData[v] = \"// \"..fileData[v]\r\n        end\r\n    end\r\nend",
    "type": "function"
  }, {
    "id": 2133,
    "text": "local cfuncTable = {}",
    "type": "statement:localassign"
  }, {
    "id": 2134,
    "text": "for n = 1, #fileData do\r\n        if string.find(fileData[n], \"static wxLuaBindCFunc s_wxluafunc\", 1, 1) then\r\n            local a, b = string.find(fileData[n], \"s_wxluafunc\", 1, 1)\r\n            local s = string.sub(fileData[n], a)\r\n            a, b = string.find(s, \"[\", 1, 1)\r\n            s = string.sub(s, 1, a-1)\r\n\r\n            cfuncTable[s] = n\r\n        elseif string.find(fileData[n], \"s_wxluafunc\", 1, 1) then\r\n            for k, v in pairs(cfuncTable) do\r\n                if string.find(fileData[n], k..\",\", 1, 1) or string.find(fileData[n], k..\" \", 1, 1) then\r\n                    cfuncTable[k] = -1 -- found\r\n                end\r\n            end\r\n        end\r\n    end",
    "type": "statement:numericfor"
  }, {
    "id": 2135,
    "text": "if string.find(fileData[n], \"static wxLuaBindCFunc s_wxluafunc\", 1, 1) then\r\n            local a, b = string.find(fileData[n], \"s_wxluafunc\", 1, 1)\r\n            local s = string.sub(fileData[n], a)\r\n            a, b = string.find(s, \"[\", 1, 1)\r\n            s = string.sub(s, 1, a-1)\r\n\r\n            cfuncTable[s] = n\r\n        elseif string.find(fileData[n], \"s_wxluafunc\", 1, 1) then\r\n            for k, v in pairs(cfuncTable) do\r\n                if string.find(fileData[n], k..\",\", 1, 1) or string.find(fileData[n], k..\" \", 1, 1) then\r\n                    cfuncTable[k] = -1 -- found\r\n                end\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 2136,
    "text": "local a, b = string.find(fileData[n], \"s_wxluafunc\", 1, 1)",
    "type": "statement:localassign"
  }, {
    "id": 2137,
    "text": "local s = string.sub(fileData[n], a)",
    "type": "statement:localassign"
  }, {
    "id": 2138,
    "text": "a, b = string.find(s, \"[\", 1, 1)",
    "type": "statement:assign"
  }, {
    "id": 2139,
    "text": "s = string.sub(s, 1, a-1)",
    "type": "statement:assign"
  }, {
    "id": 2140,
    "text": "cfuncTable[s] = n",
    "type": "statement:assign"
  }, {
    "id": 2141,
    "text": "for k, v in pairs(cfuncTable) do\r\n                if string.find(fileData[n], k..\",\", 1, 1) or string.find(fileData[n], k..\" \", 1, 1) then\r\n                    cfuncTable[k] = -1 -- found\r\n                end\r\n            end",
    "type": "statement:genericfor"
  }, {
    "id": 2142,
    "text": "if string.find(fileData[n], k..\",\", 1, 1) or string.find(fileData[n], k..\" \", 1, 1) then\r\n                    cfuncTable[k] = -1 -- found\r\n                end",
    "type": "statement:if"
  }, {
    "id": 2143,
    "text": "cfuncTable[k] = -1",
    "type": "statement:assign"
  }, {
    "id": 2144,
    "text": "for k, v in pairs(cfuncTable) do\r\n        if v > 0 then\r\n            fileData[v] = \"// \"..fileData[v]\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 2145,
    "text": "if v > 0 then\r\n            fileData[v] = \"// \"..fileData[v]\r\n        end",
    "type": "statement:if"
  }, {
    "id": 2146,
    "text": "fileData[v] = \"// \"..fileData[v]",
    "type": "statement:assign"
  }, {
    "id": 2147,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2148,
    "text": "function SerializeDataTypes(filename)\r\n    local fileData = {}\r\n\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"-- \"..filename..\" was generated by genwxbind.lua \\n\")\r\n    table.insert(fileData, \"-- \\n\")\r\n    table.insert(fileData, \"-- Any changes made to this file will be lost when the file is regenerated  \\n\")\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"\\n\\n\")\r\n\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"-- typedefTable\\n\")\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, hook_cpp_namespace..\"_typedefTable =\\n\")\r\n    table.insert(fileData, Serialize(typedefTable))\r\n\r\n    table.insert(fileData, \"\\n\\n\")\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"-- dataTypes\\n\")\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, hook_cpp_namespace..\"_dataTypeTable =\\n\")\r\n    table.insert(fileData, Serialize(dataTypeTable))\r\n\r\n    table.insert(fileData, \"\\n\\n\")\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"-- preprocConditionTable\\n\")\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, hook_cpp_namespace..\"_preprocConditionTable =\\n\")\r\n    table.insert(fileData, Serialize(preprocConditionTable))\r\n\r\n    table.insert(fileData, \"\\n\\n\")\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"-- Cache the dataTypes\\n\")\r\n    table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")\r\n    table.insert(fileData, \"    for k, v in pairs(\"..hook_cpp_namespace..\"_typedefTable) do\\n\")\r\n    table.insert(fileData, \"        typedefTable[k] = v\\n\")\r\n    table.insert(fileData, \"    end\\n\")\r\n    table.insert(fileData, \"    for k, v in pairs(\"..hook_cpp_namespace..\"_dataTypeTable) do\\n\")\r\n    table.insert(fileData, \"        dataTypeTable[k] = v\\n\")\r\n    table.insert(fileData, \"    end\\n\")\r\n    table.insert(fileData, \"    for k, v in pairs(\"..hook_cpp_namespace..\"_preprocConditionTable) do\\n\")\r\n    table.insert(fileData, \"        preprocConditionTable[k] = v\\n\")\r\n    table.insert(fileData, \"    end\\n\")\r\n\r\n    WriteTableToFile(filename, fileData, false)\r\nend",
    "type": "function"
  }, {
    "id": 2149,
    "text": "table.insert(fileData, \"-- ---------------------------------------------------------------------------\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2150,
    "text": "table.insert(fileData, \"-- \"..filename..\" was generated by genwxbind.lua \\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2151,
    "text": "table.insert(fileData, \"-- \\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2152,
    "text": "table.insert(fileData, \"-- Any changes made to this file will be lost when the file is regenerated  \\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2153,
    "text": "table.insert(fileData, \"-- typedefTable\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2154,
    "text": "table.insert(fileData, hook_cpp_namespace..\"_typedefTable =\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2155,
    "text": "table.insert(fileData, Serialize(typedefTable))",
    "type": "statement:functioncall"
  }, {
    "id": 2156,
    "text": "table.insert(fileData, \"-- dataTypes\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2157,
    "text": "table.insert(fileData, hook_cpp_namespace..\"_dataTypeTable =\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2158,
    "text": "table.insert(fileData, Serialize(dataTypeTable))",
    "type": "statement:functioncall"
  }, {
    "id": 2159,
    "text": "table.insert(fileData, \"-- preprocConditionTable\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2160,
    "text": "table.insert(fileData, hook_cpp_namespace..\"_preprocConditionTable =\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2161,
    "text": "table.insert(fileData, Serialize(preprocConditionTable))",
    "type": "statement:functioncall"
  }, {
    "id": 2162,
    "text": "table.insert(fileData, \"-- Cache the dataTypes\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2163,
    "text": "table.insert(fileData, \"    for k, v in pairs(\"..hook_cpp_namespace..\"_typedefTable) do\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2164,
    "text": "table.insert(fileData, \"        typedefTable[k] = v\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2165,
    "text": "table.insert(fileData, \"    end\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2166,
    "text": "table.insert(fileData, \"    for k, v in pairs(\"..hook_cpp_namespace..\"_dataTypeTable) do\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2167,
    "text": "table.insert(fileData, \"        dataTypeTable[k] = v\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2168,
    "text": "table.insert(fileData, \"    for k, v in pairs(\"..hook_cpp_namespace..\"_preprocConditionTable) do\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2169,
    "text": "table.insert(fileData, \"        preprocConditionTable[k] = v\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2170,
    "text": "WriteTableToFile(filename, fileData, false)",
    "type": "statement:functioncall"
  }, {
    "id": 2171,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2172,
    "text": "function Serialize(o, d)\r\n    if not d then d = 0 end\r\n    local s = \"\"\r\n\r\n    if type(o) == \"number\" then\r\n        s = s..o\r\n    elseif type(o) == \"string\" then\r\n        s = s..string.format(\"%q\", o)\r\n    elseif type(o) == \"boolean\" then\r\n        if(o) then s = s..\"true\" else s = s..\"false\" end\r\n    elseif type(o) == \"table\" then\r\n        s = s..\"{\\n\"\r\n        for k,v in pairs_sort(o) do\r\n\r\n            for f = 1,d do\r\n                s = s..\"  \"\r\n            end\r\n\r\n            if type(k) == \"string\" and not string.find(k, \"[^%w_]\") then\r\n                s = s..\"  \"..k..\" = \"\r\n            else\r\n                s = s..\"  [\"\r\n                s = s..Serialize(k)\r\n                s = s..\"] = \"\r\n            end\r\n\r\n            s = s..Serialize(v, d + 1)\r\n            if type(v) ~= \"table\" then s = s..\",\\n\" end\r\n        end\r\n\r\n        for f = 1,d do\r\n            s = s..\"  \"\r\n        end\r\n\r\n        s = s..\"}\"\r\n        if d ~= 0 then\r\n            s = s..\",\"\r\n        end\r\n        s = s..\"\\n\"\r\n    elseif type(o) == \"function\" then\r\n        s = s..tostring(o)\r\n    else\r\n        error(\"cannot serialize a \"..type(o))\r\n    end\r\n\r\n    return s\r\nend",
    "type": "function"
  }, {
    "id": 2173,
    "text": "if not d then d = 0 end",
    "type": "statement:if"
  }, {
    "id": 2174,
    "text": "d = 0",
    "type": "statement:assign"
  }, {
    "id": 2175,
    "text": "local s = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 2176,
    "text": "if type(o) == \"number\" then\r\n        s = s..o\r\n    elseif type(o) == \"string\" then\r\n        s = s..string.format(\"%q\", o)\r\n    elseif type(o) == \"boolean\" then\r\n        if(o) then s = s..\"true\" else s = s..\"false\" end\r\n    elseif type(o) == \"table\" then\r\n        s = s..\"{\\n\"\r\n        for k,v in pairs_sort(o) do\r\n\r\n            for f = 1,d do\r\n                s = s..\"  \"\r\n            end\r\n\r\n            if type(k) == \"string\" and not string.find(k, \"[^%w_]\") then\r\n                s = s..\"  \"..k..\" = \"\r\n            else\r\n                s = s..\"  [\"\r\n                s = s..Serialize(k)\r\n                s = s..\"] = \"\r\n            end\r\n\r\n            s = s..Serialize(v, d + 1)\r\n            if type(v) ~= \"table\" then s = s..\",\\n\" end\r\n        end\r\n\r\n        for f = 1,d do\r\n            s = s..\"  \"\r\n        end\r\n\r\n        s = s..\"}\"\r\n        if d ~= 0 then\r\n            s = s..\",\"\r\n        end\r\n        s = s..\"\\n\"\r\n    elseif type(o) == \"function\" then\r\n        s = s..tostring(o)\r\n    else\r\n        error(\"cannot serialize a \"..type(o))\r\n    end",
    "type": "statement:if"
  }, {
    "id": 2177,
    "text": "s = s..o",
    "type": "statement:assign"
  }, {
    "id": 2178,
    "text": "s = s..string.format(\"%q\", o)",
    "type": "statement:assign"
  }, {
    "id": 2179,
    "text": "if(o) then s = s..\"true\" else s = s..\"false\" end",
    "type": "statement:if"
  }, {
    "id": 2180,
    "text": "s = s..\"true\"",
    "type": "statement:assign"
  }, {
    "id": 2181,
    "text": "s = s..\"false\"",
    "type": "statement:assign"
  }, {
    "id": 2182,
    "text": "s = s..\"{\\n\"",
    "type": "statement:assign"
  }, {
    "id": 2183,
    "text": "for k,v in pairs_sort(o) do\r\n\r\n            for f = 1,d do\r\n                s = s..\"  \"\r\n            end\r\n\r\n            if type(k) == \"string\" and not string.find(k, \"[^%w_]\") then\r\n                s = s..\"  \"..k..\" = \"\r\n            else\r\n                s = s..\"  [\"\r\n                s = s..Serialize(k)\r\n                s = s..\"] = \"\r\n            end\r\n\r\n            s = s..Serialize(v, d + 1)\r\n            if type(v) ~= \"table\" then s = s..\",\\n\" end\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 2184,
    "text": "for f = 1,d do\r\n                s = s..\"  \"\r\n            end",
    "type": "statement:numericfor"
  }, {
    "id": 2185,
    "text": "s = s..\"  \"",
    "type": "statement:assign"
  }, {
    "id": 2186,
    "text": "if type(k) == \"string\" and not string.find(k, \"[^%w_]\") then\r\n                s = s..\"  \"..k..\" = \"\r\n            else\r\n                s = s..\"  [\"\r\n                s = s..Serialize(k)\r\n                s = s..\"] = \"\r\n            end",
    "type": "statement:if"
  }, {
    "id": 2187,
    "text": "s = s..\"  \"..k..\" = \"",
    "type": "statement:assign"
  }, {
    "id": 2188,
    "text": "s = s..\"  [\"",
    "type": "statement:assign"
  }, {
    "id": 2189,
    "text": "s = s..Serialize(k)",
    "type": "statement:assign"
  }, {
    "id": 2190,
    "text": "s = s..\"] = \"",
    "type": "statement:assign"
  }, {
    "id": 2191,
    "text": "s = s..Serialize(v, d + 1)",
    "type": "statement:assign"
  }, {
    "id": 2192,
    "text": "if type(v) ~= \"table\" then s = s..\",\\n\" end",
    "type": "statement:if"
  }, {
    "id": 2193,
    "text": "s = s..\",\\n\"",
    "type": "statement:assign"
  }, {
    "id": 2194,
    "text": "for f = 1,d do\r\n            s = s..\"  \"\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 2195,
    "text": "s = s..\"}\"",
    "type": "statement:assign"
  }, {
    "id": 2196,
    "text": "if d ~= 0 then\r\n            s = s..\",\"\r\n        end",
    "type": "statement:if"
  }, {
    "id": 2197,
    "text": "s = s..\",\"",
    "type": "statement:assign"
  }, {
    "id": 2198,
    "text": "s = s..\"\\n\"",
    "type": "statement:assign"
  }, {
    "id": 2199,
    "text": "s = s..tostring(o)",
    "type": "statement:assign"
  }, {
    "id": 2200,
    "text": "error(\"cannot serialize a \"..type(o))",
    "type": "statement:functioncall"
  }, {
    "id": 2201,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2202,
    "text": "function main()\r\n    local time1 = os.time()\r\n\r\n    -- load rules file\r\n    if not rulesFilename then\r\n        print(\"ERROR: No rules filename set!\")\r\n        do return end\r\n    end\r\n\r\n    local rules = loadfile(rulesFilename)\r\n    if rules then\r\n        rules()\r\n        print(\"Loaded rules file: \"..rulesFilename)\r\n        CheckRules()\r\n    else\r\n        dofile(rulesFilename) -- get the error message\r\n        print(\"ERROR: Unable to load rules file: '\"..tostring(rulesFilename)..\"'\")\r\n        do return end\r\n    end\r\n\r\n    -- load any cached settings from other wrappers\r\n    if datatype_cache_input_fileTable then\r\n        for key, filename in pairs(datatype_cache_input_fileTable) do\r\n            if FileExists(filename) then\r\n                local cache = loadfile(filename)\r\n                cache() -- run loaded file\r\n                print(\"Loaded datatypes cache file: \"..filename)\r\n            else\r\n                print(\"ERROR: Unable to load datatypes cache file: '\"..filename..\"'\")\r\n            end\r\n        end\r\n    end\r\n\r\n    InitKeywords()\r\n    InitDataTypes()\r\n\r\n    if override_fileTable then\r\n        for i = 1, #override_fileTable do\r\n            ReadOverrideFile(override_fileTable[i])\r\n        end\r\n    end\r\n\r\n    local updated_files = 0\r\n\r\n    if #interface_fileTable > 0 then\r\n        local interfaceList = GenerateInterfaceData()\r\n        updated_files = WriteWrapperFiles(interfaceList)\r\n    end\r\n\r\n    -- Write out the data types for these interface files\r\n    if datatypes_cache_output_filename and string.len(datatypes_cache_output_filename) then\r\n        SerializeDataTypes(interface_filepath..\"/\"..datatypes_cache_output_filename)\r\n    end\r\n\r\n    -- Check for any unused overrides and print a warning\r\n    for overrideName, value in pairs_sort(overrideTableUsed) do\r\n        if not value then\r\n            print(\"WARNING: Overridden function '\"..overrideName..\"' was not used.\")\r\n        end\r\n    end\r\n\r\n    print(\"Done. \"..updated_files..\" Files were updated in \"..os.difftime(os.time(), time1)..\" seconds.\\n\")\r\nend",
    "type": "function"
  }, {
    "id": 2203,
    "text": "if not rulesFilename then\r\n        print(\"ERROR: No rules filename set!\")\r\n        do return end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 2204,
    "text": "print(\"ERROR: No rules filename set!\")",
    "type": "statement:functioncall"
  }, {
    "id": 2205,
    "text": "do return end",
    "type": "statement:do"
  }, {
    "id": 2206,
    "text": "local rules = loadfile(rulesFilename)",
    "type": "statement:localassign"
  }, {
    "id": 2207,
    "text": "if rules then\r\n        rules()\r\n        print(\"Loaded rules file: \"..rulesFilename)\r\n        CheckRules()\r\n    else\r\n        dofile(rulesFilename) -- get the error message\r\n        print(\"ERROR: Unable to load rules file: '\"..tostring(rulesFilename)..\"'\")\r\n        do return end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 2208,
    "text": "rules()",
    "type": "statement:functioncall"
  }, {
    "id": 2209,
    "text": "print(\"Loaded rules file: \"..rulesFilename)",
    "type": "statement:functioncall"
  }, {
    "id": 2210,
    "text": "CheckRules()",
    "type": "statement:functioncall"
  }, {
    "id": 2211,
    "text": "dofile(rulesFilename)",
    "type": "statement:functioncall"
  }, {
    "id": 2212,
    "text": "print(\"ERROR: Unable to load rules file: '\"..tostring(rulesFilename)..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 2213,
    "text": "if datatype_cache_input_fileTable then\r\n        for key, filename in pairs(datatype_cache_input_fileTable) do\r\n            if FileExists(filename) then\r\n                local cache = loadfile(filename)\r\n                cache() -- run loaded file\r\n                print(\"Loaded datatypes cache file: \"..filename)\r\n            else\r\n                print(\"ERROR: Unable to load datatypes cache file: '\"..filename..\"'\")\r\n            end\r\n        end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 2214,
    "text": "for key, filename in pairs(datatype_cache_input_fileTable) do\r\n            if FileExists(filename) then\r\n                local cache = loadfile(filename)\r\n                cache() -- run loaded file\r\n                print(\"Loaded datatypes cache file: \"..filename)\r\n            else\r\n                print(\"ERROR: Unable to load datatypes cache file: '\"..filename..\"'\")\r\n            end\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 2215,
    "text": "if FileExists(filename) then\r\n                local cache = loadfile(filename)\r\n                cache() -- run loaded file\r\n                print(\"Loaded datatypes cache file: \"..filename)\r\n            else\r\n                print(\"ERROR: Unable to load datatypes cache file: '\"..filename..\"'\")\r\n            end",
    "type": "statement:if"
  }, {
    "id": 2216,
    "text": "local cache = loadfile(filename)",
    "type": "statement:localassign"
  }, {
    "id": 2217,
    "text": "cache()",
    "type": "statement:functioncall"
  }, {
    "id": 2218,
    "text": "print(\"Loaded datatypes cache file: \"..filename)",
    "type": "statement:functioncall"
  }, {
    "id": 2219,
    "text": "print(\"ERROR: Unable to load datatypes cache file: '\"..filename..\"'\")",
    "type": "statement:functioncall"
  }, {
    "id": 2220,
    "text": "InitKeywords()",
    "type": "statement:functioncall"
  }, {
    "id": 2221,
    "text": "InitDataTypes()",
    "type": "statement:functioncall"
  }, {
    "id": 2222,
    "text": "if override_fileTable then\r\n        for i = 1, #override_fileTable do\r\n            ReadOverrideFile(override_fileTable[i])\r\n        end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 2223,
    "text": "for i = 1, #override_fileTable do\r\n            ReadOverrideFile(override_fileTable[i])\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 2224,
    "text": "ReadOverrideFile(override_fileTable[i])",
    "type": "statement:functioncall"
  }, {
    "id": 2225,
    "text": "if #interface_fileTable > 0 then\r\n        local interfaceList = GenerateInterfaceData()\r\n        updated_files = WriteWrapperFiles(interfaceList)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 2226,
    "text": "local interfaceList = GenerateInterfaceData()",
    "type": "statement:localassign"
  }, {
    "id": 2227,
    "text": "updated_files = WriteWrapperFiles(interfaceList)",
    "type": "statement:assign"
  }, {
    "id": 2228,
    "text": "if datatypes_cache_output_filename and string.len(datatypes_cache_output_filename) then\r\n        SerializeDataTypes(interface_filepath..\"/\"..datatypes_cache_output_filename)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 2229,
    "text": "SerializeDataTypes(interface_filepath..\"/\"..datatypes_cache_output_filename)",
    "type": "statement:functioncall"
  }, {
    "id": 2230,
    "text": "for overrideName, value in pairs_sort(overrideTableUsed) do\r\n        if not value then\r\n            print(\"WARNING: Overridden function '\"..overrideName..\"' was not used.\")\r\n        end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 2231,
    "text": "if not value then\r\n            print(\"WARNING: Overridden function '\"..overrideName..\"' was not used.\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 2232,
    "text": "print(\"WARNING: Overridden function '\"..overrideName..\"' was not used.\")",
    "type": "statement:functioncall"
  }, {
    "id": 2233,
    "text": "print(\"Done. \"..updated_files..\" Files were updated in \"..os.difftime(os.time(), time1)..\" seconds.\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 2234,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 2235,
    "text": "",
    "type": "function container"
  }, {
    "id": 2236,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 2237,
    "text": "ipairs",
    "type": "global function"
  }, {
    "id": 2238,
    "text": "print",
    "type": "global function"
  }, {
    "id": 2239,
    "text": "sub",
    "type": "global function"
  }, {
    "id": 2240,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 2241,
    "text": "remove",
    "type": "global function"
  }, {
    "id": 2242,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 2243,
    "text": "lines",
    "type": "global function"
  }, {
    "id": 2244,
    "text": "string_sub",
    "type": "global function"
  }, {
    "id": 2245,
    "text": "gmatch",
    "type": "global function"
  }, {
    "id": 2246,
    "text": "sort",
    "type": "global function"
  }, {
    "id": 2247,
    "text": "len",
    "type": "global function"
  }, {
    "id": 2248,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 2249,
    "text": "close",
    "type": "global function"
  }, {
    "id": 2250,
    "text": "tonumber",
    "type": "global function"
  }, {
    "id": 2251,
    "text": "cache",
    "type": "global function"
  }, {
    "id": 2252,
    "text": "format",
    "type": "global function"
  }, {
    "id": 2253,
    "text": "time",
    "type": "global function"
  }, {
    "id": 2254,
    "text": "type",
    "type": "global function"
  }, {
    "id": 2255,
    "text": "string_byte",
    "type": "global function"
  }, {
    "id": 2256,
    "text": "gsub",
    "type": "global function"
  }, {
    "id": 2257,
    "text": "find",
    "type": "global function"
  }, {
    "id": 2258,
    "text": "loadfile",
    "type": "global function"
  }, {
    "id": 2259,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 2260,
    "text": "open",
    "type": "global function"
  }, {
    "id": 2261,
    "text": "error",
    "type": "global function"
  }, {
    "id": 2262,
    "text": "dofile",
    "type": "global function"
  }, {
    "id": 2263,
    "text": "byte",
    "type": "global function"
  }, {
    "id": 2264,
    "text": "rules",
    "type": "global function"
  }, {
    "id": 2265,
    "text": "difftime",
    "type": "global function"
  }, {
    "id": 2266,
    "text": "string_len",
    "type": "global function"
  }, {
    "id": 2267,
    "text": "rep",
    "type": "global function"
  }, {
    "id": 2268,
    "text": "",
    "type": "variable container"
  }, {
    "id": 2269,
    "text": "",
    "type": "require container"
  }, {
    "id": 2270,
    "text": "",
    "type": "local variable"
  }, {
    "id": 2271,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2272,
    "text": "",
    "type": "local variable"
  }, {
    "id": 2273,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2274,
    "text": "",
    "type": "local variable"
  }, {
    "id": 2275,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2276,
    "text": "",
    "type": "local variable"
  }, {
    "id": 2277,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2278,
    "text": "",
    "type": "local variable"
  }, {
    "id": 2279,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2280,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2281,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2282,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2283,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2284,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2285,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2286,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2287,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2288,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2289,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2290,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2291,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2292,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2293,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2294,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2295,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2296,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2297,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2298,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2299,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2300,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2301,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2302,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2303,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2304,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2305,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2306,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2307,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2308,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2309,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2310,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2311,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2312,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2313,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2314,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2315,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2316,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2317,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2318,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2319,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2320,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2321,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2322,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2323,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2324,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2325,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2326,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2327,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2328,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2329,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2330,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2331,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2332,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2333,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2334,
    "text": "",
    "type": "n/a"
  }, {
    "id": 2335,
    "text": "",
    "type": "global variable"
  }, {
    "id": 2336,
    "text": "",
    "type": "n/a"
  } ]
}