{
  "_filename": "gg.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/metalua/src/compiler/gg.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "has",
    "to": 3
  }, {
    "from": 3,
    "label": "has",
    "to": 4
  }, {
    "from": 3,
    "label": "has",
    "to": 5
  }, {
    "from": 3,
    "label": "has",
    "to": 6
  }, {
    "from": 6,
    "label": "has",
    "to": 7
  }, {
    "from": 2,
    "label": "has",
    "to": 8
  }, {
    "from": 2,
    "label": "has",
    "to": 8
  }, {
    "from": 2,
    "label": "has",
    "to": 9
  }, {
    "from": 10,
    "label": "has",
    "to": 11
  }, {
    "from": 10,
    "label": "has",
    "to": 12
  }, {
    "from": 12,
    "label": "has",
    "to": 13
  }, {
    "from": 10,
    "label": "has",
    "to": 14
  }, {
    "from": 14,
    "label": "has",
    "to": 15
  }, {
    "from": 10,
    "label": "has",
    "to": 16
  }, {
    "from": 10,
    "label": "has",
    "to": 8
  }, {
    "from": 10,
    "label": "has",
    "to": 17
  }, {
    "from": 18,
    "label": "has",
    "to": 15
  }, {
    "from": 18,
    "label": "has",
    "to": 19
  }, {
    "from": 20,
    "label": "has",
    "to": 8
  }, {
    "from": 20,
    "label": "has",
    "to": 21
  }, {
    "from": 22,
    "label": "has",
    "to": 23
  }, {
    "from": 22,
    "label": "has",
    "to": 24
  }, {
    "from": 24,
    "label": "has",
    "to": 25
  }, {
    "from": 24,
    "label": "has",
    "to": 26
  }, {
    "from": 26,
    "label": "has",
    "to": 27
  }, {
    "from": 27,
    "label": "has",
    "to": 28
  }, {
    "from": 26,
    "label": "has",
    "to": 29
  }, {
    "from": 26,
    "label": "has",
    "to": 30
  }, {
    "from": 22,
    "label": "has",
    "to": 8
  }, {
    "from": 22,
    "label": "has",
    "to": 31
  }, {
    "from": 32,
    "label": "has",
    "to": 33
  }, {
    "from": 32,
    "label": "has",
    "to": 34
  }, {
    "from": 32,
    "label": "has",
    "to": 8
  }, {
    "from": 32,
    "label": "has",
    "to": 8
  }, {
    "from": 32,
    "label": "has",
    "to": 8
  }, {
    "from": 32,
    "label": "has",
    "to": 35
  }, {
    "from": 36,
    "label": "has",
    "to": 37
  }, {
    "from": 37,
    "label": "has",
    "to": 38
  }, {
    "from": 38,
    "label": "has",
    "to": 39
  }, {
    "from": 36,
    "label": "has",
    "to": 40
  }, {
    "from": 40,
    "label": "has",
    "to": 41
  }, {
    "from": 40,
    "label": "has",
    "to": 42
  }, {
    "from": 42,
    "label": "has",
    "to": 43
  }, {
    "from": 36,
    "label": "has",
    "to": 8
  }, {
    "from": 36,
    "label": "has",
    "to": 44
  }, {
    "from": 45,
    "label": "has",
    "to": 46
  }, {
    "from": 45,
    "label": "has",
    "to": 47
  }, {
    "from": 45,
    "label": "has",
    "to": 48
  }, {
    "from": 45,
    "label": "has",
    "to": 49
  }, {
    "from": 49,
    "label": "has",
    "to": 50
  }, {
    "from": 49,
    "label": "has",
    "to": 51
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 49,
    "label": "has",
    "to": 53
  }, {
    "from": 53,
    "label": "has",
    "to": 54
  }, {
    "from": 49,
    "label": "has",
    "to": 55
  }, {
    "from": 49,
    "label": "has",
    "to": 56
  }, {
    "from": 49,
    "label": "has",
    "to": 57
  }, {
    "from": 45,
    "label": "has",
    "to": 58
  }, {
    "from": 45,
    "label": "has",
    "to": 59
  }, {
    "from": 60,
    "label": "has",
    "to": 61
  }, {
    "from": 60,
    "label": "has",
    "to": 62
  }, {
    "from": 62,
    "label": "has",
    "to": 63
  }, {
    "from": 62,
    "label": "has",
    "to": 64
  }, {
    "from": 62,
    "label": "has",
    "to": 65
  }, {
    "from": 62,
    "label": "has",
    "to": 66
  }, {
    "from": 62,
    "label": "has",
    "to": 67
  }, {
    "from": 67,
    "label": "has",
    "to": 68
  }, {
    "from": 67,
    "label": "has",
    "to": 69
  }, {
    "from": 67,
    "label": "has",
    "to": 70
  }, {
    "from": 62,
    "label": "has",
    "to": 71
  }, {
    "from": 62,
    "label": "has",
    "to": 72
  }, {
    "from": 62,
    "label": "has",
    "to": 8
  }, {
    "from": 60,
    "label": "has",
    "to": 73
  }, {
    "from": 73,
    "label": "has",
    "to": 74
  }, {
    "from": 74,
    "label": "has",
    "to": 75
  }, {
    "from": 74,
    "label": "has",
    "to": 76
  }, {
    "from": 74,
    "label": "has",
    "to": 77
  }, {
    "from": 73,
    "label": "has",
    "to": 78
  }, {
    "from": 60,
    "label": "has",
    "to": 8
  }, {
    "from": 60,
    "label": "has",
    "to": 79
  }, {
    "from": 80,
    "label": "has",
    "to": 63
  }, {
    "from": 80,
    "label": "has",
    "to": 64
  }, {
    "from": 80,
    "label": "has",
    "to": 65
  }, {
    "from": 80,
    "label": "has",
    "to": 66
  }, {
    "from": 80,
    "label": "has",
    "to": 67
  }, {
    "from": 67,
    "label": "has",
    "to": 68
  }, {
    "from": 67,
    "label": "has",
    "to": 69
  }, {
    "from": 67,
    "label": "has",
    "to": 70
  }, {
    "from": 80,
    "label": "has",
    "to": 71
  }, {
    "from": 80,
    "label": "has",
    "to": 72
  }, {
    "from": 80,
    "label": "has",
    "to": 8
  }, {
    "from": 80,
    "label": "has",
    "to": 81
  }, {
    "from": 82,
    "label": "has",
    "to": 83
  }, {
    "from": 82,
    "label": "has",
    "to": 84
  }, {
    "from": 84,
    "label": "has",
    "to": 85
  }, {
    "from": 84,
    "label": "has",
    "to": 86
  }, {
    "from": 86,
    "label": "has",
    "to": 87
  }, {
    "from": 84,
    "label": "has",
    "to": 88
  }, {
    "from": 88,
    "label": "has",
    "to": 89
  }, {
    "from": 89,
    "label": "has",
    "to": 90
  }, {
    "from": 89,
    "label": "has",
    "to": 91
  }, {
    "from": 88,
    "label": "has",
    "to": 92
  }, {
    "from": 88,
    "label": "has",
    "to": 93
  }, {
    "from": 88,
    "label": "has",
    "to": 93
  }, {
    "from": 82,
    "label": "has",
    "to": 94
  }, {
    "from": 94,
    "label": "has",
    "to": 8
  }, {
    "from": 82,
    "label": "has",
    "to": 95
  }, {
    "from": 95,
    "label": "has",
    "to": 96
  }, {
    "from": 96,
    "label": "has",
    "to": 97
  }, {
    "from": 95,
    "label": "has",
    "to": 98
  }, {
    "from": 95,
    "label": "has",
    "to": 99
  }, {
    "from": 95,
    "label": "has",
    "to": 8
  }, {
    "from": 82,
    "label": "has",
    "to": 100
  }, {
    "from": 100,
    "label": "has",
    "to": 63
  }, {
    "from": 100,
    "label": "has",
    "to": 101
  }, {
    "from": 100,
    "label": "has",
    "to": 65
  }, {
    "from": 100,
    "label": "has",
    "to": 8
  }, {
    "from": 82,
    "label": "has",
    "to": 102
  }, {
    "from": 82,
    "label": "has",
    "to": 103
  }, {
    "from": 103,
    "label": "has",
    "to": 104
  }, {
    "from": 103,
    "label": "has",
    "to": 105
  }, {
    "from": 82,
    "label": "has",
    "to": 8
  }, {
    "from": 82,
    "label": "has",
    "to": 106
  }, {
    "from": 107,
    "label": "has",
    "to": 85
  }, {
    "from": 107,
    "label": "has",
    "to": 86
  }, {
    "from": 86,
    "label": "has",
    "to": 87
  }, {
    "from": 107,
    "label": "has",
    "to": 88
  }, {
    "from": 88,
    "label": "has",
    "to": 89
  }, {
    "from": 89,
    "label": "has",
    "to": 90
  }, {
    "from": 89,
    "label": "has",
    "to": 91
  }, {
    "from": 88,
    "label": "has",
    "to": 92
  }, {
    "from": 88,
    "label": "has",
    "to": 93
  }, {
    "from": 88,
    "label": "has",
    "to": 93
  }, {
    "from": 107,
    "label": "has",
    "to": 108
  }, {
    "from": 109,
    "label": "has",
    "to": 8
  }, {
    "from": 110,
    "label": "has",
    "to": 96
  }, {
    "from": 96,
    "label": "has",
    "to": 97
  }, {
    "from": 110,
    "label": "has",
    "to": 98
  }, {
    "from": 110,
    "label": "has",
    "to": 99
  }, {
    "from": 110,
    "label": "has",
    "to": 8
  }, {
    "from": 110,
    "label": "has",
    "to": 111
  }, {
    "from": 112,
    "label": "has",
    "to": 63
  }, {
    "from": 112,
    "label": "has",
    "to": 101
  }, {
    "from": 112,
    "label": "has",
    "to": 65
  }, {
    "from": 112,
    "label": "has",
    "to": 8
  }, {
    "from": 112,
    "label": "has",
    "to": 113
  }, {
    "from": 114,
    "label": "has",
    "to": 115
  }, {
    "from": 114,
    "label": "has",
    "to": 116
  }, {
    "from": 116,
    "label": "has",
    "to": 117
  }, {
    "from": 116,
    "label": "has",
    "to": 118
  }, {
    "from": 118,
    "label": "has",
    "to": 119
  }, {
    "from": 118,
    "label": "has",
    "to": 120
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 121,
    "label": "has",
    "to": 8
  }, {
    "from": 120,
    "label": "has",
    "to": 122
  }, {
    "from": 120,
    "label": "has",
    "to": 123
  }, {
    "from": 118,
    "label": "has",
    "to": 8
  }, {
    "from": 118,
    "label": "has",
    "to": 8
  }, {
    "from": 118,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 124
  }, {
    "from": 124,
    "label": "has",
    "to": 63
  }, {
    "from": 124,
    "label": "has",
    "to": 125
  }, {
    "from": 124,
    "label": "has",
    "to": 126
  }, {
    "from": 124,
    "label": "has",
    "to": 127
  }, {
    "from": 127,
    "label": "has",
    "to": 128
  }, {
    "from": 127,
    "label": "has",
    "to": 129
  }, {
    "from": 127,
    "label": "has",
    "to": 65
  }, {
    "from": 127,
    "label": "has",
    "to": 130
  }, {
    "from": 127,
    "label": "has",
    "to": 65
  }, {
    "from": 124,
    "label": "has",
    "to": 8
  }, {
    "from": 124,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 131,
    "label": "has",
    "to": 133
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 131,
    "label": "has",
    "to": 134
  }, {
    "from": 134,
    "label": "has",
    "to": 63
  }, {
    "from": 134,
    "label": "has",
    "to": 135
  }, {
    "from": 134,
    "label": "has",
    "to": 136
  }, {
    "from": 136,
    "label": "has",
    "to": 137
  }, {
    "from": 136,
    "label": "has",
    "to": 138
  }, {
    "from": 136,
    "label": "has",
    "to": 139
  }, {
    "from": 136,
    "label": "has",
    "to": 140
  }, {
    "from": 136,
    "label": "has",
    "to": 141
  }, {
    "from": 134,
    "label": "has",
    "to": 142
  }, {
    "from": 134,
    "label": "has",
    "to": 65
  }, {
    "from": 134,
    "label": "has",
    "to": 143
  }, {
    "from": 134,
    "label": "has",
    "to": 137
  }, {
    "from": 134,
    "label": "has",
    "to": 144
  }, {
    "from": 134,
    "label": "has",
    "to": 145
  }, {
    "from": 134,
    "label": "has",
    "to": 146
  }, {
    "from": 134,
    "label": "has",
    "to": 65
  }, {
    "from": 134,
    "label": "has",
    "to": 147
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 148
  }, {
    "from": 148,
    "label": "has",
    "to": 149
  }, {
    "from": 148,
    "label": "has",
    "to": 133
  }, {
    "from": 148,
    "label": "has",
    "to": 8
  }, {
    "from": 148,
    "label": "has",
    "to": 150
  }, {
    "from": 150,
    "label": "has",
    "to": 143
  }, {
    "from": 150,
    "label": "has",
    "to": 137
  }, {
    "from": 150,
    "label": "has",
    "to": 144
  }, {
    "from": 150,
    "label": "has",
    "to": 65
  }, {
    "from": 150,
    "label": "has",
    "to": 151
  }, {
    "from": 150,
    "label": "has",
    "to": 152
  }, {
    "from": 148,
    "label": "has",
    "to": 8
  }, {
    "from": 148,
    "label": "has",
    "to": 8
  }, {
    "from": 148,
    "label": "has",
    "to": 8
  }, {
    "from": 116,
    "label": "has",
    "to": 153
  }, {
    "from": 116,
    "label": "has",
    "to": 154
  }, {
    "from": 154,
    "label": "has",
    "to": 155
  }, {
    "from": 154,
    "label": "has",
    "to": 156
  }, {
    "from": 154,
    "label": "has",
    "to": 157
  }, {
    "from": 154,
    "label": "has",
    "to": 158
  }, {
    "from": 116,
    "label": "has",
    "to": 8
  }, {
    "from": 114,
    "label": "has",
    "to": 159
  }, {
    "from": 159,
    "label": "has",
    "to": 160
  }, {
    "from": 159,
    "label": "has",
    "to": 161
  }, {
    "from": 114,
    "label": "has",
    "to": 162
  }, {
    "from": 162,
    "label": "has",
    "to": 163
  }, {
    "from": 163,
    "label": "has",
    "to": 164
  }, {
    "from": 162,
    "label": "has",
    "to": 165
  }, {
    "from": 165,
    "label": "has",
    "to": 166
  }, {
    "from": 114,
    "label": "has",
    "to": 167
  }, {
    "from": 167,
    "label": "has",
    "to": 8
  }, {
    "from": 114,
    "label": "has",
    "to": 8
  }, {
    "from": 114,
    "label": "has",
    "to": 168
  }, {
    "from": 169,
    "label": "has",
    "to": 117
  }, {
    "from": 169,
    "label": "has",
    "to": 118
  }, {
    "from": 118,
    "label": "has",
    "to": 119
  }, {
    "from": 118,
    "label": "has",
    "to": 120
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 121,
    "label": "has",
    "to": 8
  }, {
    "from": 120,
    "label": "has",
    "to": 122
  }, {
    "from": 120,
    "label": "has",
    "to": 123
  }, {
    "from": 118,
    "label": "has",
    "to": 8
  }, {
    "from": 118,
    "label": "has",
    "to": 8
  }, {
    "from": 118,
    "label": "has",
    "to": 8
  }, {
    "from": 169,
    "label": "has",
    "to": 124
  }, {
    "from": 124,
    "label": "has",
    "to": 63
  }, {
    "from": 124,
    "label": "has",
    "to": 125
  }, {
    "from": 124,
    "label": "has",
    "to": 126
  }, {
    "from": 124,
    "label": "has",
    "to": 127
  }, {
    "from": 127,
    "label": "has",
    "to": 128
  }, {
    "from": 127,
    "label": "has",
    "to": 129
  }, {
    "from": 127,
    "label": "has",
    "to": 65
  }, {
    "from": 127,
    "label": "has",
    "to": 130
  }, {
    "from": 127,
    "label": "has",
    "to": 65
  }, {
    "from": 124,
    "label": "has",
    "to": 8
  }, {
    "from": 124,
    "label": "has",
    "to": 8
  }, {
    "from": 169,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 131,
    "label": "has",
    "to": 133
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 131,
    "label": "has",
    "to": 134
  }, {
    "from": 134,
    "label": "has",
    "to": 63
  }, {
    "from": 134,
    "label": "has",
    "to": 135
  }, {
    "from": 134,
    "label": "has",
    "to": 136
  }, {
    "from": 136,
    "label": "has",
    "to": 137
  }, {
    "from": 136,
    "label": "has",
    "to": 138
  }, {
    "from": 136,
    "label": "has",
    "to": 139
  }, {
    "from": 136,
    "label": "has",
    "to": 140
  }, {
    "from": 136,
    "label": "has",
    "to": 141
  }, {
    "from": 134,
    "label": "has",
    "to": 142
  }, {
    "from": 134,
    "label": "has",
    "to": 65
  }, {
    "from": 134,
    "label": "has",
    "to": 143
  }, {
    "from": 134,
    "label": "has",
    "to": 137
  }, {
    "from": 134,
    "label": "has",
    "to": 144
  }, {
    "from": 134,
    "label": "has",
    "to": 145
  }, {
    "from": 134,
    "label": "has",
    "to": 146
  }, {
    "from": 134,
    "label": "has",
    "to": 65
  }, {
    "from": 134,
    "label": "has",
    "to": 147
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 131,
    "label": "has",
    "to": 8
  }, {
    "from": 169,
    "label": "has",
    "to": 148
  }, {
    "from": 148,
    "label": "has",
    "to": 149
  }, {
    "from": 148,
    "label": "has",
    "to": 133
  }, {
    "from": 148,
    "label": "has",
    "to": 8
  }, {
    "from": 148,
    "label": "has",
    "to": 150
  }, {
    "from": 150,
    "label": "has",
    "to": 143
  }, {
    "from": 150,
    "label": "has",
    "to": 137
  }, {
    "from": 150,
    "label": "has",
    "to": 144
  }, {
    "from": 150,
    "label": "has",
    "to": 65
  }, {
    "from": 150,
    "label": "has",
    "to": 151
  }, {
    "from": 150,
    "label": "has",
    "to": 152
  }, {
    "from": 148,
    "label": "has",
    "to": 8
  }, {
    "from": 148,
    "label": "has",
    "to": 8
  }, {
    "from": 148,
    "label": "has",
    "to": 8
  }, {
    "from": 169,
    "label": "has",
    "to": 153
  }, {
    "from": 169,
    "label": "has",
    "to": 154
  }, {
    "from": 154,
    "label": "has",
    "to": 155
  }, {
    "from": 154,
    "label": "has",
    "to": 156
  }, {
    "from": 154,
    "label": "has",
    "to": 157
  }, {
    "from": 154,
    "label": "has",
    "to": 158
  }, {
    "from": 169,
    "label": "has",
    "to": 8
  }, {
    "from": 169,
    "label": "has",
    "to": 170
  }, {
    "from": 171,
    "label": "has",
    "to": 119
  }, {
    "from": 171,
    "label": "has",
    "to": 120
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 121,
    "label": "has",
    "to": 8
  }, {
    "from": 120,
    "label": "has",
    "to": 122
  }, {
    "from": 120,
    "label": "has",
    "to": 123
  }, {
    "from": 171,
    "label": "has",
    "to": 8
  }, {
    "from": 171,
    "label": "has",
    "to": 8
  }, {
    "from": 171,
    "label": "has",
    "to": 8
  }, {
    "from": 171,
    "label": "has",
    "to": 172
  }, {
    "from": 173,
    "label": "has",
    "to": 8
  }, {
    "from": 174,
    "label": "has",
    "to": 63
  }, {
    "from": 174,
    "label": "has",
    "to": 125
  }, {
    "from": 174,
    "label": "has",
    "to": 126
  }, {
    "from": 174,
    "label": "has",
    "to": 127
  }, {
    "from": 127,
    "label": "has",
    "to": 128
  }, {
    "from": 127,
    "label": "has",
    "to": 129
  }, {
    "from": 127,
    "label": "has",
    "to": 65
  }, {
    "from": 127,
    "label": "has",
    "to": 130
  }, {
    "from": 127,
    "label": "has",
    "to": 65
  }, {
    "from": 174,
    "label": "has",
    "to": 8
  }, {
    "from": 174,
    "label": "has",
    "to": 8
  }, {
    "from": 174,
    "label": "has",
    "to": 175
  }, {
    "from": 176,
    "label": "has",
    "to": 132
  }, {
    "from": 176,
    "label": "has",
    "to": 133
  }, {
    "from": 176,
    "label": "has",
    "to": 8
  }, {
    "from": 176,
    "label": "has",
    "to": 134
  }, {
    "from": 134,
    "label": "has",
    "to": 63
  }, {
    "from": 134,
    "label": "has",
    "to": 135
  }, {
    "from": 134,
    "label": "has",
    "to": 136
  }, {
    "from": 136,
    "label": "has",
    "to": 137
  }, {
    "from": 136,
    "label": "has",
    "to": 138
  }, {
    "from": 136,
    "label": "has",
    "to": 139
  }, {
    "from": 136,
    "label": "has",
    "to": 140
  }, {
    "from": 136,
    "label": "has",
    "to": 141
  }, {
    "from": 134,
    "label": "has",
    "to": 142
  }, {
    "from": 134,
    "label": "has",
    "to": 65
  }, {
    "from": 134,
    "label": "has",
    "to": 143
  }, {
    "from": 134,
    "label": "has",
    "to": 137
  }, {
    "from": 134,
    "label": "has",
    "to": 144
  }, {
    "from": 134,
    "label": "has",
    "to": 145
  }, {
    "from": 134,
    "label": "has",
    "to": 146
  }, {
    "from": 134,
    "label": "has",
    "to": 65
  }, {
    "from": 134,
    "label": "has",
    "to": 147
  }, {
    "from": 176,
    "label": "has",
    "to": 8
  }, {
    "from": 176,
    "label": "has",
    "to": 8
  }, {
    "from": 176,
    "label": "has",
    "to": 8
  }, {
    "from": 176,
    "label": "has",
    "to": 8
  }, {
    "from": 176,
    "label": "has",
    "to": 177
  }, {
    "from": 178,
    "label": "has",
    "to": 149
  }, {
    "from": 178,
    "label": "has",
    "to": 133
  }, {
    "from": 178,
    "label": "has",
    "to": 8
  }, {
    "from": 178,
    "label": "has",
    "to": 150
  }, {
    "from": 150,
    "label": "has",
    "to": 143
  }, {
    "from": 150,
    "label": "has",
    "to": 137
  }, {
    "from": 150,
    "label": "has",
    "to": 144
  }, {
    "from": 150,
    "label": "has",
    "to": 65
  }, {
    "from": 150,
    "label": "has",
    "to": 151
  }, {
    "from": 150,
    "label": "has",
    "to": 152
  }, {
    "from": 178,
    "label": "has",
    "to": 8
  }, {
    "from": 178,
    "label": "has",
    "to": 8
  }, {
    "from": 178,
    "label": "has",
    "to": 8
  }, {
    "from": 178,
    "label": "has",
    "to": 179
  }, {
    "from": 180,
    "label": "has",
    "to": 8
  }, {
    "from": 181,
    "label": "has",
    "to": 182
  }, {
    "from": 181,
    "label": "has",
    "to": 183
  }, {
    "from": 183,
    "label": "has",
    "to": 184
  }, {
    "from": 184,
    "label": "has",
    "to": 8
  }, {
    "from": 183,
    "label": "has",
    "to": 185
  }, {
    "from": 183,
    "label": "has",
    "to": 63
  }, {
    "from": 183,
    "label": "has",
    "to": 186
  }, {
    "from": 186,
    "label": "has",
    "to": 187
  }, {
    "from": 187,
    "label": "has",
    "to": 188
  }, {
    "from": 183,
    "label": "has",
    "to": 65
  }, {
    "from": 183,
    "label": "has",
    "to": 189
  }, {
    "from": 183,
    "label": "has",
    "to": 190
  }, {
    "from": 190,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 191,
    "label": "has",
    "to": 193
  }, {
    "from": 191,
    "label": "has",
    "to": 194
  }, {
    "from": 191,
    "label": "has",
    "to": 195
  }, {
    "from": 195,
    "label": "has",
    "to": 193
  }, {
    "from": 183,
    "label": "has",
    "to": 8
  }, {
    "from": 181,
    "label": "has",
    "to": 196
  }, {
    "from": 196,
    "label": "has",
    "to": 197
  }, {
    "from": 196,
    "label": "has",
    "to": 198
  }, {
    "from": 181,
    "label": "has",
    "to": 199
  }, {
    "from": 199,
    "label": "has",
    "to": 200
  }, {
    "from": 199,
    "label": "has",
    "to": 201
  }, {
    "from": 181,
    "label": "has",
    "to": 202
  }, {
    "from": 202,
    "label": "has",
    "to": 203
  }, {
    "from": 202,
    "label": "has",
    "to": 204
  }, {
    "from": 181,
    "label": "has",
    "to": 8
  }, {
    "from": 181,
    "label": "has",
    "to": 205
  }, {
    "from": 206,
    "label": "has",
    "to": 184
  }, {
    "from": 184,
    "label": "has",
    "to": 8
  }, {
    "from": 206,
    "label": "has",
    "to": 185
  }, {
    "from": 206,
    "label": "has",
    "to": 63
  }, {
    "from": 206,
    "label": "has",
    "to": 186
  }, {
    "from": 186,
    "label": "has",
    "to": 187
  }, {
    "from": 187,
    "label": "has",
    "to": 188
  }, {
    "from": 206,
    "label": "has",
    "to": 65
  }, {
    "from": 206,
    "label": "has",
    "to": 189
  }, {
    "from": 206,
    "label": "has",
    "to": 190
  }, {
    "from": 190,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 191,
    "label": "has",
    "to": 193
  }, {
    "from": 191,
    "label": "has",
    "to": 194
  }, {
    "from": 191,
    "label": "has",
    "to": 195
  }, {
    "from": 195,
    "label": "has",
    "to": 193
  }, {
    "from": 206,
    "label": "has",
    "to": 8
  }, {
    "from": 206,
    "label": "has",
    "to": 207
  }, {
    "from": 208,
    "label": "has",
    "to": 8
  }, {
    "from": 208,
    "label": "has",
    "to": 209
  }, {
    "from": 210,
    "label": "has",
    "to": 211
  }, {
    "from": 210,
    "label": "has",
    "to": 212
  }, {
    "from": 212,
    "label": "has",
    "to": 213
  }, {
    "from": 213,
    "label": "has",
    "to": 214
  }, {
    "from": 214,
    "label": "has",
    "to": 215
  }, {
    "from": 213,
    "label": "has",
    "to": 216
  }, {
    "from": 213,
    "label": "has",
    "to": 217
  }, {
    "from": 212,
    "label": "has",
    "to": 8
  }, {
    "from": 212,
    "label": "has",
    "to": 8
  }, {
    "from": 210,
    "label": "has",
    "to": 218
  }, {
    "from": 218,
    "label": "has",
    "to": 219
  }, {
    "from": 210,
    "label": "has",
    "to": 220
  }, {
    "from": 220,
    "label": "has",
    "to": 221
  }, {
    "from": 221,
    "label": "has",
    "to": 222
  }, {
    "from": 221,
    "label": "has",
    "to": 223
  }, {
    "from": 221,
    "label": "has",
    "to": 224
  }, {
    "from": 210,
    "label": "has",
    "to": 225
  }, {
    "from": 225,
    "label": "has",
    "to": 226
  }, {
    "from": 210,
    "label": "has",
    "to": 227
  }, {
    "from": 210,
    "label": "has",
    "to": 8
  }, {
    "from": 210,
    "label": "has",
    "to": 228
  }, {
    "from": 229,
    "label": "has",
    "to": 213
  }, {
    "from": 213,
    "label": "has",
    "to": 214
  }, {
    "from": 214,
    "label": "has",
    "to": 215
  }, {
    "from": 213,
    "label": "has",
    "to": 216
  }, {
    "from": 213,
    "label": "has",
    "to": 217
  }, {
    "from": 229,
    "label": "has",
    "to": 8
  }, {
    "from": 229,
    "label": "has",
    "to": 8
  }, {
    "from": 229,
    "label": "has",
    "to": 230
  }, {
    "from": 231,
    "label": "has",
    "to": 232
  }, {
    "from": 231,
    "label": "has",
    "to": 233
  }, {
    "from": 233,
    "label": "has",
    "to": 234
  }, {
    "from": 233,
    "label": "has",
    "to": 235
  }, {
    "from": 231,
    "label": "has",
    "to": 236
  }, {
    "from": 236,
    "label": "has",
    "to": 237
  }, {
    "from": 231,
    "label": "has",
    "to": 8
  }, {
    "from": 231,
    "label": "has",
    "to": 238
  }, {
    "from": 231,
    "label": "has",
    "to": 239
  }, {
    "from": 239,
    "label": "has",
    "to": 215
  }, {
    "from": 231,
    "label": "has",
    "to": 8
  }, {
    "from": 231,
    "label": "has",
    "to": 8
  }, {
    "from": 231,
    "label": "has",
    "to": 240
  }, {
    "from": 241,
    "label": "has",
    "to": 242
  }, {
    "from": 241,
    "label": "has",
    "to": 8
  }, {
    "from": 241,
    "label": "has",
    "to": 8
  }, {
    "from": 241,
    "label": "has",
    "to": 243
  }, {
    "from": 241,
    "label": "has",
    "to": 244
  }, {
    "from": 241,
    "label": "has",
    "to": 245
  }, {
    "from": 241,
    "label": "has",
    "to": 246
  }, {
    "from": 241,
    "label": "has",
    "to": 244
  }, {
    "from": 241,
    "label": "has",
    "to": 247
  }, {
    "from": 241,
    "label": "has",
    "to": 248
  }, {
    "from": 248,
    "label": "has",
    "to": 249
  }, {
    "from": 241,
    "label": "has",
    "to": 8
  }, {
    "from": 241,
    "label": "has",
    "to": 250
  }, {
    "from": 251,
    "label": "has",
    "to": 238
  }, {
    "from": 251,
    "label": "has",
    "to": 239
  }, {
    "from": 239,
    "label": "has",
    "to": 215
  }, {
    "from": 251,
    "label": "has",
    "to": 8
  }, {
    "from": 251,
    "label": "has",
    "to": 8
  }, {
    "from": 251,
    "label": "has",
    "to": 252
  }, {
    "from": 253,
    "label": "has",
    "to": 243
  }, {
    "from": 253,
    "label": "has",
    "to": 244
  }, {
    "from": 253,
    "label": "has",
    "to": 245
  }, {
    "from": 253,
    "label": "has",
    "to": 246
  }, {
    "from": 253,
    "label": "has",
    "to": 244
  }, {
    "from": 253,
    "label": "has",
    "to": 247
  }, {
    "from": 253,
    "label": "has",
    "to": 248
  }, {
    "from": 248,
    "label": "has",
    "to": 249
  }, {
    "from": 253,
    "label": "has",
    "to": 8
  }, {
    "from": 253,
    "label": "has",
    "to": 254
  }, {
    "from": 114,
    "label": "calls",
    "to": 176
  }, {
    "from": 2,
    "label": "calls",
    "to": 274
  }, {
    "from": 45,
    "label": "calls",
    "to": 274
  }, {
    "from": 45,
    "label": "calls",
    "to": 274
  }, {
    "from": 60,
    "label": "calls",
    "to": 268
  }, {
    "from": 210,
    "label": "calls",
    "to": 268
  }, {
    "from": 210,
    "label": "calls",
    "to": 268
  }, {
    "from": 231,
    "label": "calls",
    "to": 268
  }, {
    "from": 231,
    "label": "calls",
    "to": 268
  }, {
    "from": 181,
    "label": "calls",
    "to": 275
  }, {
    "from": 181,
    "label": "calls",
    "to": 275
  }, {
    "from": 114,
    "label": "calls",
    "to": 82
  }, {
    "from": 60,
    "label": "calls",
    "to": 269
  }, {
    "from": 36,
    "label": "calls",
    "to": 258
  }, {
    "from": 114,
    "label": "calls",
    "to": 258
  }, {
    "from": 210,
    "label": "calls",
    "to": 258
  }, {
    "from": 231,
    "label": "calls",
    "to": 258
  }, {
    "from": 22,
    "label": "calls",
    "to": 259
  }, {
    "from": 22,
    "label": "calls",
    "to": 45
  }, {
    "from": 176,
    "label": "calls",
    "to": 45
  }, {
    "from": 255,
    "label": "calls",
    "to": 286
  }, {
    "from": 241,
    "label": "calls",
    "to": 241
  }, {
    "from": 174,
    "label": "calls",
    "to": 282
  }, {
    "from": 176,
    "label": "calls",
    "to": 282
  }, {
    "from": 178,
    "label": "calls",
    "to": 282
  }, {
    "from": 174,
    "label": "calls",
    "to": 261
  }, {
    "from": 181,
    "label": "calls",
    "to": 261
  }, {
    "from": 210,
    "label": "calls",
    "to": 261
  }, {
    "from": 114,
    "label": "calls",
    "to": 174
  }, {
    "from": 82,
    "label": "calls",
    "to": 267
  }, {
    "from": 82,
    "label": "calls",
    "to": 267
  }, {
    "from": 210,
    "label": "calls",
    "to": 267
  }, {
    "from": 32,
    "label": "calls",
    "to": 270
  }, {
    "from": 2,
    "label": "calls",
    "to": 279
  }, {
    "from": 45,
    "label": "calls",
    "to": 279
  }, {
    "from": 60,
    "label": "calls",
    "to": 279
  }, {
    "from": 82,
    "label": "calls",
    "to": 279
  }, {
    "from": 241,
    "label": "calls",
    "to": 279
  }, {
    "from": 82,
    "label": "calls",
    "to": 60
  }, {
    "from": 114,
    "label": "calls",
    "to": 178
  }, {
    "from": 60,
    "label": "calls",
    "to": 22
  }, {
    "from": 171,
    "label": "calls",
    "to": 22
  }, {
    "from": 60,
    "label": "calls",
    "to": 36
  }, {
    "from": 82,
    "label": "calls",
    "to": 36
  }, {
    "from": 174,
    "label": "calls",
    "to": 36
  }, {
    "from": 174,
    "label": "calls",
    "to": 36
  }, {
    "from": 174,
    "label": "calls",
    "to": 36
  }, {
    "from": 176,
    "label": "calls",
    "to": 36
  }, {
    "from": 176,
    "label": "calls",
    "to": 36
  }, {
    "from": 176,
    "label": "calls",
    "to": 36
  }, {
    "from": 176,
    "label": "calls",
    "to": 36
  }, {
    "from": 178,
    "label": "calls",
    "to": 36
  }, {
    "from": 178,
    "label": "calls",
    "to": 36
  }, {
    "from": 181,
    "label": "calls",
    "to": 36
  }, {
    "from": 210,
    "label": "calls",
    "to": 36
  }, {
    "from": 176,
    "label": "calls",
    "to": 256
  }, {
    "from": 20,
    "label": "calls",
    "to": 263
  }, {
    "from": 22,
    "label": "calls",
    "to": 263
  }, {
    "from": 36,
    "label": "calls",
    "to": 263
  }, {
    "from": 60,
    "label": "calls",
    "to": 263
  }, {
    "from": 60,
    "label": "calls",
    "to": 263
  }, {
    "from": 60,
    "label": "calls",
    "to": 263
  }, {
    "from": 82,
    "label": "calls",
    "to": 263
  }, {
    "from": 82,
    "label": "calls",
    "to": 263
  }, {
    "from": 82,
    "label": "calls",
    "to": 263
  }, {
    "from": 181,
    "label": "calls",
    "to": 263
  }, {
    "from": 181,
    "label": "calls",
    "to": 263
  }, {
    "from": 181,
    "label": "calls",
    "to": 263
  }, {
    "from": 181,
    "label": "calls",
    "to": 263
  }, {
    "from": 210,
    "label": "calls",
    "to": 263
  }, {
    "from": 231,
    "label": "calls",
    "to": 263
  }, {
    "from": 231,
    "label": "calls",
    "to": 263
  }, {
    "from": 241,
    "label": "calls",
    "to": 263
  }, {
    "from": 60,
    "label": "calls",
    "to": 10
  }, {
    "from": 82,
    "label": "calls",
    "to": 10
  }, {
    "from": 114,
    "label": "calls",
    "to": 10
  }, {
    "from": 181,
    "label": "calls",
    "to": 10
  }, {
    "from": 210,
    "label": "calls",
    "to": 10
  }, {
    "from": 45,
    "label": "calls",
    "to": 284
  }, {
    "from": 22,
    "label": "calls",
    "to": 265
  }, {
    "from": 2,
    "label": "calls",
    "to": 260
  }, {
    "from": 241,
    "label": "calls",
    "to": 260
  }, {
    "from": 210,
    "label": "calls",
    "to": 272
  }, {
    "from": 10,
    "label": "calls",
    "to": 262
  }, {
    "from": 22,
    "label": "calls",
    "to": 262
  }, {
    "from": 176,
    "label": "calls",
    "to": 262
  }, {
    "from": 181,
    "label": "calls",
    "to": 262
  }, {
    "from": 210,
    "label": "calls",
    "to": 262
  }, {
    "from": 22,
    "label": "calls",
    "to": 20
  }, {
    "from": 82,
    "label": "calls",
    "to": 20
  }, {
    "from": 82,
    "label": "calls",
    "to": 20
  }, {
    "from": 114,
    "label": "calls",
    "to": 20
  }, {
    "from": 210,
    "label": "calls",
    "to": 20
  }, {
    "from": 22,
    "label": "calls",
    "to": 264
  }, {
    "from": 174,
    "label": "calls",
    "to": 278
  }, {
    "from": 176,
    "label": "calls",
    "to": 278
  }, {
    "from": 176,
    "label": "calls",
    "to": 278
  }, {
    "from": 178,
    "label": "calls",
    "to": 278
  }, {
    "from": 82,
    "label": "calls",
    "to": 32
  }, {
    "from": 10,
    "label": "calls",
    "to": 285
  }, {
    "from": 241,
    "label": "calls",
    "to": 285
  }, {
    "from": 241,
    "label": "calls",
    "to": 285
  }, {
    "from": 181,
    "label": "calls",
    "to": 208
  }, {
    "from": 181,
    "label": "calls",
    "to": 208
  }, {
    "from": 181,
    "label": "calls",
    "to": 208
  }, {
    "from": 174,
    "label": "calls",
    "to": 171
  }, {
    "from": 176,
    "label": "calls",
    "to": 171
  }, {
    "from": 176,
    "label": "calls",
    "to": 171
  }, {
    "from": 178,
    "label": "calls",
    "to": 171
  }, {
    "from": 208,
    "label": "calls",
    "to": 266
  }, {
    "from": 210,
    "label": "calls",
    "to": 266
  }, {
    "from": 231,
    "label": "calls",
    "to": 266
  }, {
    "from": 241,
    "label": "calls",
    "to": 266
  }, {
    "from": 20,
    "label": "calls",
    "to": 277
  }, {
    "from": 181,
    "label": "calls",
    "to": 277
  }, {
    "from": 241,
    "label": "calls",
    "to": 277
  }, {
    "from": 36,
    "label": "calls",
    "to": 273
  }, {
    "from": 32,
    "label": "calls",
    "to": 276
  }, {
    "from": 1,
    "label": "contains",
    "to": 255
  }, {
    "from": 255,
    "label": "declares",
    "to": 2
  }, {
    "from": 255,
    "label": "declares",
    "to": 10
  }, {
    "from": 255,
    "label": "declares",
    "to": 18
  }, {
    "from": 255,
    "label": "declares",
    "to": 20
  }, {
    "from": 255,
    "label": "declares",
    "to": 22
  }, {
    "from": 255,
    "label": "declares",
    "to": 32
  }, {
    "from": 255,
    "label": "declares",
    "to": 36
  }, {
    "from": 255,
    "label": "declares",
    "to": 45
  }, {
    "from": 255,
    "label": "declares",
    "to": 60
  }, {
    "from": 255,
    "label": "declares",
    "to": 80
  }, {
    "from": 255,
    "label": "declares",
    "to": 82
  }, {
    "from": 255,
    "label": "declares",
    "to": 107
  }, {
    "from": 255,
    "label": "declares",
    "to": 109
  }, {
    "from": 255,
    "label": "declares",
    "to": 110
  }, {
    "from": 255,
    "label": "declares",
    "to": 112
  }, {
    "from": 255,
    "label": "declares",
    "to": 114
  }, {
    "from": 255,
    "label": "declares",
    "to": 169
  }, {
    "from": 255,
    "label": "declares",
    "to": 171
  }, {
    "from": 255,
    "label": "declares",
    "to": 173
  }, {
    "from": 255,
    "label": "declares",
    "to": 174
  }, {
    "from": 255,
    "label": "declares",
    "to": 176
  }, {
    "from": 255,
    "label": "declares",
    "to": 178
  }, {
    "from": 255,
    "label": "declares",
    "to": 180
  }, {
    "from": 255,
    "label": "declares",
    "to": 181
  }, {
    "from": 255,
    "label": "declares",
    "to": 206
  }, {
    "from": 255,
    "label": "declares",
    "to": 208
  }, {
    "from": 255,
    "label": "declares",
    "to": 210
  }, {
    "from": 255,
    "label": "declares",
    "to": 229
  }, {
    "from": 255,
    "label": "declares",
    "to": 231
  }, {
    "from": 255,
    "label": "declares",
    "to": 241
  }, {
    "from": 255,
    "label": "declares",
    "to": 251
  }, {
    "from": 255,
    "label": "declares",
    "to": 253
  }, {
    "from": 1,
    "label": "declares",
    "to": 257
  }, {
    "from": 1,
    "label": "declares",
    "to": 265
  }, {
    "from": 1,
    "label": "declares",
    "to": 271
  }, {
    "from": 1,
    "label": "declares",
    "to": 280
  }, {
    "from": 1,
    "label": "declares",
    "to": 281
  }, {
    "from": 1,
    "label": "declares",
    "to": 283
  }, {
    "from": 1,
    "label": "contains",
    "to": 287
  }, {
    "from": 1,
    "label": "contains",
    "to": 288
  }, {
    "from": 287,
    "label": "initializes",
    "to": 289
  }, {
    "from": 289,
    "label": "assigns",
    "to": 290
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "gg",
    "type": "module"
  }, {
    "id": 2,
    "text": "function parser_metatable.__call (parser, lx, ...)\r\n   --printf (\"Call parser %q of type %q\", parser.name or \"?\", parser.kind)\r\n   if mlc.metabugs then \r\n      return parser:parse (lx, ...) \r\n      --local x = parser:parse (lx, ...) \r\n      --printf (\"Result of parser %q: %s\", \r\n      --        parser.name or \"?\",\r\n      --        _G.table.tostring(x, \"nohash\", 80))\r\n      --return x\r\n   else\r\n      local li = lx:lineinfo_right() or { \"?\", \"?\", \"?\", \"?\" }\r\n      local status, ast = pcall (parser.parse, parser, lx, ...)      \r\n      if status then return ast else\r\n         -- Try to replace the gg.lua location, in the error msg, with\r\n         -- the place where the current parser started handling the\r\n         -- lexstream.\r\n         -- Since the error is rethrown, these places are stacked. \r\n         error (string.format (\"%s\\n - (l.%s, c.%s, k.%s) in parser %s\", \r\n                               ast :strmatch \"gg.lua:%d+: (.*)\" or ast,\r\n                               li[1], li[2], li[3], parser.name or parser.kind))\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "if mlc.metabugs then \r\n      return parser:parse (lx, ...) \r\n      --local x = parser:parse (lx, ...) \r\n      --printf (\"Result of parser %q: %s\", \r\n      --        parser.name or \"?\",\r\n      --        _G.table.tostring(x, \"nohash\", 80))\r\n      --return x\r\n   else\r\n      local li = lx:lineinfo_right() or { \"?\", \"?\", \"?\", \"?\" }\r\n      local status, ast = pcall (parser.parse, parser, lx, ...)      \r\n      if status then return ast else\r\n         -- Try to replace the gg.lua location, in the error msg, with\r\n         -- the place where the current parser started handling the\r\n         -- lexstream.\r\n         -- Since the error is rethrown, these places are stacked. \r\n         error (string.format (\"%s\\n - (l.%s, c.%s, k.%s) in parser %s\", \r\n                               ast :strmatch \"gg.lua:%d+: (.*)\" or ast,\r\n                               li[1], li[2], li[3], parser.name or parser.kind))\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 4,
    "text": "local li = lx:lineinfo_right() or { \"?\", \"?\", \"?\", \"?\" }",
    "type": "statement:localassign"
  }, {
    "id": 5,
    "text": "local status, ast = pcall (parser.parse, parser, lx, ...)",
    "type": "statement:localassign"
  }, {
    "id": 6,
    "text": "if status then return ast else\r\n         -- Try to replace the gg.lua location, in the error msg, with\r\n         -- the place where the current parser started handling the\r\n         -- lexstream.\r\n         -- Since the error is rethrown, these places are stacked. \r\n         error (string.format (\"%s\\n - (l.%s, c.%s, k.%s) in parser %s\", \r\n                               ast :strmatch \"gg.lua:%d+: (.*)\" or ast,\r\n                               li[1], li[2], li[3], parser.name or parser.kind))\r\n      end",
    "type": "statement:if"
  }, {
    "id": 7,
    "text": "error (string.format (\"%s\\n - (l.%s, c.%s, k.%s) in parser %s\", \r\n                               ast :strmatch \"gg.lua:%d+: (.*)\" or ast,\r\n                               li[1], li[2], li[3], parser.name or parser.kind))",
    "type": "statement:functioncall"
  }, {
    "id": 8,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 9,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 10,
    "text": "function make_parser(kind, p)\r\n   p.kind = kind\r\n   if not p.transformers then p.transformers = { } end\r\n   function p.transformers:add (x)\r\n      table.insert (self, x)\r\n   end\r\n   setmetatable (p, parser_metatable)\r\n   return p\r\nend",
    "type": "function"
  }, {
    "id": 11,
    "text": "p.kind = kind",
    "type": "statement:assign"
  }, {
    "id": 12,
    "text": "if not p.transformers then p.transformers = { } end",
    "type": "statement:if"
  }, {
    "id": 13,
    "text": "p.transformers = { }",
    "type": "statement:assign"
  }, {
    "id": 14,
    "text": "function p.transformers:add (x)\r\n      table.insert (self, x)\r\n   end",
    "type": "statement:globalfunction"
  }, {
    "id": 15,
    "text": "table.insert (self, x)",
    "type": "statement:functioncall"
  }, {
    "id": 16,
    "text": "setmetatable (p, parser_metatable)",
    "type": "statement:functioncall"
  }, {
    "id": 17,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 18,
    "text": "function p.transformers:add (x)\r\n      table.insert (self, x)\r\n   end",
    "type": "function"
  }, {
    "id": 19,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 20,
    "text": "function is_parser (x)\r\n   return type(x)==\"function\" or getmetatable(x)==parser_metatable and x.kind\r\nend",
    "type": "function"
  }, {
    "id": 21,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 22,
    "text": "local function raw_parse_sequence (lx, p)\r\n   local r = { }\r\n   for i=1, #p do\r\n      e=p[i]\r\n      if type(e) == \"string\" then \r\n         if not lx:is_keyword (lx:next(), e) then\r\n            parse_error (lx, \"A keyword was expected, probably `%s'.\", e) end\r\n      elseif is_parser (e) then\r\n         table.insert (r, e (lx)) \r\n      else \r\n         gg.parse_error (lx,\"Sequence `%s': element #%i is neither a string \"..\r\n                         \"nor a parser: %s\", \r\n                         p.name, i, table.tostring(e))\r\n      end\r\n   end\r\n   return r\r\nend",
    "type": "function"
  }, {
    "id": 23,
    "text": "local r = { }",
    "type": "statement:localassign"
  }, {
    "id": 24,
    "text": "for i=1, #p do\r\n      e=p[i]\r\n      if type(e) == \"string\" then \r\n         if not lx:is_keyword (lx:next(), e) then\r\n            parse_error (lx, \"A keyword was expected, probably `%s'.\", e) end\r\n      elseif is_parser (e) then\r\n         table.insert (r, e (lx)) \r\n      else \r\n         gg.parse_error (lx,\"Sequence `%s': element #%i is neither a string \"..\r\n                         \"nor a parser: %s\", \r\n                         p.name, i, table.tostring(e))\r\n      end\r\n   end",
    "type": "statement:numericfor"
  }, {
    "id": 25,
    "text": "e=p[i]",
    "type": "statement:assign"
  }, {
    "id": 26,
    "text": "if type(e) == \"string\" then \r\n         if not lx:is_keyword (lx:next(), e) then\r\n            parse_error (lx, \"A keyword was expected, probably `%s'.\", e) end\r\n      elseif is_parser (e) then\r\n         table.insert (r, e (lx)) \r\n      else \r\n         gg.parse_error (lx,\"Sequence `%s': element #%i is neither a string \"..\r\n                         \"nor a parser: %s\", \r\n                         p.name, i, table.tostring(e))\r\n      end",
    "type": "statement:if"
  }, {
    "id": 27,
    "text": "if not lx:is_keyword (lx:next(), e) then\r\n            parse_error (lx, \"A keyword was expected, probably `%s'.\", e) end",
    "type": "statement:if"
  }, {
    "id": 28,
    "text": "parse_error (lx, \"A keyword was expected, probably `%s'.\", e)",
    "type": "statement:functioncall"
  }, {
    "id": 29,
    "text": "table.insert (r, e (lx))",
    "type": "statement:functioncall"
  }, {
    "id": 30,
    "text": "gg.parse_error (lx,\"Sequence `%s': element #%i is neither a string \"..\r\n                         \"nor a parser: %s\", \r\n                         p.name, i, table.tostring(e))",
    "type": "statement:functioncall"
  }, {
    "id": 31,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 32,
    "text": "local function raw_parse_multisequence (lx, sequence_table, default)\r\n   local seq_parser = sequence_table[lx:is_keyword(lx:peek())]\r\n   if seq_parser  then return seq_parser (lx)\r\n   elseif default then return default (lx)\r\n   else return false end\r\nend",
    "type": "function"
  }, {
    "id": 33,
    "text": "local seq_parser = sequence_table[lx:is_keyword(lx:peek())]",
    "type": "statement:localassign"
  }, {
    "id": 34,
    "text": "if seq_parser  then return seq_parser (lx)\r\n   elseif default then return default (lx)\r\n   else return false end",
    "type": "statement:if"
  }, {
    "id": 35,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 36,
    "text": "local function transform (ast, parser, fli, lli)\r\n   if parser.transformers then\r\n      for _, t in ipairs (parser.transformers) do ast = t(ast) or ast end\r\n   end\r\n   if type(ast) == 'table'then\r\n      local ali = ast.lineinfo\r\n      if not ali or ali.first~=fli or ali.last~=lli then\r\n         ast.lineinfo = { first = fli, last = lli }\r\n      end\r\n   end\r\n   return ast\r\nend",
    "type": "function"
  }, {
    "id": 37,
    "text": "if parser.transformers then\r\n      for _, t in ipairs (parser.transformers) do ast = t(ast) or ast end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 38,
    "text": "for _, t in ipairs (parser.transformers) do ast = t(ast) or ast end",
    "type": "statement:genericfor"
  }, {
    "id": 39,
    "text": "ast = t(ast) or ast",
    "type": "statement:assign"
  }, {
    "id": 40,
    "text": "if type(ast) == 'table'then\r\n      local ali = ast.lineinfo\r\n      if not ali or ali.first~=fli or ali.last~=lli then\r\n         ast.lineinfo = { first = fli, last = lli }\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 41,
    "text": "local ali = ast.lineinfo",
    "type": "statement:localassign"
  }, {
    "id": 42,
    "text": "if not ali or ali.first~=fli or ali.last~=lli then\r\n         ast.lineinfo = { first = fli, last = lli }\r\n      end",
    "type": "statement:if"
  }, {
    "id": 43,
    "text": "ast.lineinfo = { first = fli, last = lli }",
    "type": "statement:assign"
  }, {
    "id": 44,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 45,
    "text": "function parse_error(lx, fmt, ...)\r\n   local li = lx:lineinfo_left() or {-1,-1,-1, \"<unknown file>\"}\r\n   local msg  = string.format(\"line %i, char %i: \"..fmt, li[1], li[2], ...)   \r\n   local src = lx.src\r\n   if li[3]>0 and src then\r\n      local i, j = li[3], li[3]\r\n      while src:sub(i,i) ~= '\\n' and i>=0    do i=i-1 end\r\n      while src:sub(j,j) ~= '\\n' and j<=#src do j=j+1 end      \r\n      local srcline = src:sub (i+1, j-1)\r\n      local idx  = string.rep (\" \", li[2])..\"^\"\r\n      msg = string.format(\"%s\\n>>> %s\\n>>> %s\", msg, srcline, idx)\r\n   end\r\n   error(msg)\r\nend",
    "type": "function"
  }, {
    "id": 46,
    "text": "local li = lx:lineinfo_left() or {-1,-1,-1, \"<unknown file>\"}",
    "type": "statement:localassign"
  }, {
    "id": 47,
    "text": "local msg  = string.format(\"line %i, char %i: \"..fmt, li[1], li[2], ...)",
    "type": "statement:localassign"
  }, {
    "id": 48,
    "text": "local src = lx.src",
    "type": "statement:localassign"
  }, {
    "id": 49,
    "text": "if li[3]>0 and src then\r\n      local i, j = li[3], li[3]\r\n      while src:sub(i,i) ~= '\\n' and i>=0    do i=i-1 end\r\n      while src:sub(j,j) ~= '\\n' and j<=#src do j=j+1 end      \r\n      local srcline = src:sub (i+1, j-1)\r\n      local idx  = string.rep (\" \", li[2])..\"^\"\r\n      msg = string.format(\"%s\\n>>> %s\\n>>> %s\", msg, srcline, idx)\r\n   end",
    "type": "statement:if"
  }, {
    "id": 50,
    "text": "local i, j = li[3], li[3]",
    "type": "statement:localassign"
  }, {
    "id": 51,
    "text": "while src:sub(i,i) ~= '\\n' and i>=0    do i=i-1 end",
    "type": "statement:while"
  }, {
    "id": 52,
    "text": "i=i-1",
    "type": "statement:assign"
  }, {
    "id": 53,
    "text": "while src:sub(j,j) ~= '\\n' and j<=#src do j=j+1 end",
    "type": "statement:while"
  }, {
    "id": 54,
    "text": "j=j+1",
    "type": "statement:assign"
  }, {
    "id": 55,
    "text": "local srcline = src:sub (i+1, j-1)",
    "type": "statement:localassign"
  }, {
    "id": 56,
    "text": "local idx  = string.rep (\" \", li[2])..\"^\"",
    "type": "statement:localassign"
  }, {
    "id": 57,
    "text": "msg = string.format(\"%s\\n>>> %s\\n>>> %s\", msg, srcline, idx)",
    "type": "statement:assign"
  }, {
    "id": 58,
    "text": "error(msg)",
    "type": "statement:functioncall"
  }, {
    "id": 59,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 60,
    "text": "function sequence (p)\r\n   make_parser (\"sequence\", p)\r\n\r\n   -------------------------------------------------------------------\r\n   -- Parsing method\r\n   -------------------------------------------------------------------\r\n   function p:parse (lx)\r\n      -- Raw parsing:\r\n      local fli = lx:lineinfo_right()\r\n      local seq = raw_parse_sequence (lx, self)\r\n      local lli = lx:lineinfo_left()\r\n\r\n      -- Builder application:\r\n      local builder, tb = self.builder, type (self.builder)\r\n      if tb == \"string\" then seq.tag = builder\r\n      elseif tb == \"function\" or builder and builder.__call then seq = builder(seq)\r\n      elseif builder == nil then -- nothing\r\n      else error (\"Invalid builder of type \"..tb..\" in sequence\") end\r\n      seq = transform (seq, self, fli, lli)\r\n      assert (not seq or seq.lineinfo)\r\n      return seq\r\n   end\r\n\r\n   -------------------------------------------------------------------\r\n   -- Construction\r\n   -------------------------------------------------------------------\r\n   -- Try to build a proper name\r\n   if p.name then\r\n      -- don't touch existing name\r\n   elseif type(p[1])==\"string\" then -- find name based on 1st keyword\r\n      if #p==1 then p.name=p[1]\r\n      elseif type(p[#p])==\"string\" then\r\n         p.name = p[1] .. \" ... \" .. p[#p]\r\n      else p.name = p[1] .. \" ...\" end\r\n   else -- can't find a decent name\r\n      p.name = \"<anonymous>\"\r\n   end\r\n\r\n   return p\r\nend",
    "type": "function"
  }, {
    "id": 61,
    "text": "make_parser (\"sequence\", p)",
    "type": "statement:functioncall"
  }, {
    "id": 62,
    "text": "function p:parse (lx)\r\n      -- Raw parsing:\r\n      local fli = lx:lineinfo_right()\r\n      local seq = raw_parse_sequence (lx, self)\r\n      local lli = lx:lineinfo_left()\r\n\r\n      -- Builder application:\r\n      local builder, tb = self.builder, type (self.builder)\r\n      if tb == \"string\" then seq.tag = builder\r\n      elseif tb == \"function\" or builder and builder.__call then seq = builder(seq)\r\n      elseif builder == nil then -- nothing\r\n      else error (\"Invalid builder of type \"..tb..\" in sequence\") end\r\n      seq = transform (seq, self, fli, lli)\r\n      assert (not seq or seq.lineinfo)\r\n      return seq\r\n   end",
    "type": "statement:globalfunction"
  }, {
    "id": 63,
    "text": "local fli = lx:lineinfo_right()",
    "type": "statement:localassign"
  }, {
    "id": 64,
    "text": "local seq = raw_parse_sequence (lx, self)",
    "type": "statement:localassign"
  }, {
    "id": 65,
    "text": "local lli = lx:lineinfo_left()",
    "type": "statement:localassign"
  }, {
    "id": 66,
    "text": "local builder, tb = self.builder, type (self.builder)",
    "type": "statement:localassign"
  }, {
    "id": 67,
    "text": "if tb == \"string\" then seq.tag = builder\r\n      elseif tb == \"function\" or builder and builder.__call then seq = builder(seq)\r\n      elseif builder == nil then -- nothing\r\n      else error (\"Invalid builder of type \"..tb..\" in sequence\") end",
    "type": "statement:if"
  }, {
    "id": 68,
    "text": "seq.tag = builder",
    "type": "statement:assign"
  }, {
    "id": 69,
    "text": "seq = builder(seq)",
    "type": "statement:assign"
  }, {
    "id": 70,
    "text": "error (\"Invalid builder of type \"..tb..\" in sequence\")",
    "type": "statement:functioncall"
  }, {
    "id": 71,
    "text": "seq = transform (seq, self, fli, lli)",
    "type": "statement:assign"
  }, {
    "id": 72,
    "text": "assert (not seq or seq.lineinfo)",
    "type": "statement:functioncall"
  }, {
    "id": 73,
    "text": "if p.name then\r\n      -- don't touch existing name\r\n   elseif type(p[1])==\"string\" then -- find name based on 1st keyword\r\n      if #p==1 then p.name=p[1]\r\n      elseif type(p[#p])==\"string\" then\r\n         p.name = p[1] .. \" ... \" .. p[#p]\r\n      else p.name = p[1] .. \" ...\" end\r\n   else -- can't find a decent name\r\n      p.name = \"<anonymous>\"\r\n   end",
    "type": "statement:if"
  }, {
    "id": 74,
    "text": "if #p==1 then p.name=p[1]\r\n      elseif type(p[#p])==\"string\" then\r\n         p.name = p[1] .. \" ... \" .. p[#p]\r\n      else p.name = p[1] .. \" ...\" end",
    "type": "statement:if"
  }, {
    "id": 75,
    "text": "p.name=p[1]",
    "type": "statement:assign"
  }, {
    "id": 76,
    "text": "p.name = p[1] .. \" ... \" .. p[#p]",
    "type": "statement:assign"
  }, {
    "id": 77,
    "text": "p.name = p[1] .. \" ...\"",
    "type": "statement:assign"
  }, {
    "id": 78,
    "text": "p.name = \"<anonymous>\"",
    "type": "statement:assign"
  }, {
    "id": 79,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 80,
    "text": "function p:parse (lx)\r\n      -- Raw parsing:\r\n      local fli = lx:lineinfo_right()\r\n      local seq = raw_parse_sequence (lx, self)\r\n      local lli = lx:lineinfo_left()\r\n\r\n      -- Builder application:\r\n      local builder, tb = self.builder, type (self.builder)\r\n      if tb == \"string\" then seq.tag = builder\r\n      elseif tb == \"function\" or builder and builder.__call then seq = builder(seq)\r\n      elseif builder == nil then -- nothing\r\n      else error (\"Invalid builder of type \"..tb..\" in sequence\") end\r\n      seq = transform (seq, self, fli, lli)\r\n      assert (not seq or seq.lineinfo)\r\n      return seq\r\n   end",
    "type": "function"
  }, {
    "id": 81,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 82,
    "text": "function multisequence (p)   \r\n   make_parser (\"multisequence\", p)\r\n\r\n   -------------------------------------------------------------------\r\n   -- Add a sequence (might be just a config table for [gg.sequence])\r\n   -------------------------------------------------------------------\r\n   function p:add (s)\r\n      -- compile if necessary:\r\n      local keyword = type(s)=='table' and s[1]\r\n      if type(s)=='table' and not is_parser(s) then sequence(s) end\r\n      if is_parser(s)~='sequence' or type(keyword)~='string' then \r\n         if self.default then -- two defaults\r\n            error (\"In a multisequence parser, all but one sequences \"..\r\n                   \"must start with a keyword\")\r\n         else self.default = s end -- first default\r\n      elseif self.sequences[keyword] then -- duplicate keyword\r\n         eprintf (\" *** Warning: keyword %q overloaded in multisequence ***\",\r\n                  keyword)\r\n         self.sequences[keyword] = s\r\n      else -- newly caught keyword\r\n         self.sequences[keyword] = s\r\n      end\r\n   end -- </multisequence.add>\r\n\r\n   -------------------------------------------------------------------\r\n   -- Get the sequence starting with this keyword. [kw :: string]\r\n   -------------------------------------------------------------------\r\n   function p:get (kw) return self.sequences [kw] end\r\n\r\n   -------------------------------------------------------------------\r\n   -- Remove the sequence starting with keyword [kw :: string]\r\n   -------------------------------------------------------------------\r\n   function p:del (kw) \r\n      if not self.sequences[kw] then \r\n         eprintf(\"*** Warning: trying to delete sequence starting \"..\r\n                 \"with %q from a multisequence having no such \"..\r\n                 \"entry ***\", kw) end\r\n      local removed = self.sequences[kw]\r\n      self.sequences[kw] = nil \r\n      return removed\r\n   end\r\n\r\n   -------------------------------------------------------------------\r\n   -- Parsing method\r\n   -------------------------------------------------------------------\r\n   function p:parse (lx)\r\n      local fli = lx:lineinfo_right()\r\n      local x = raw_parse_multisequence (lx, self.sequences, self.default)\r\n      local lli = lx:lineinfo_left()\r\n      return transform (x, self, fli, lli)\r\n   end\r\n\r\n   -------------------------------------------------------------------\r\n   -- Construction\r\n   -------------------------------------------------------------------\r\n   -- Register the sequences passed to the constructor. They're going\r\n   -- from the array part of the parser to the hash part of field\r\n   -- [sequences]\r\n   p.sequences = { }\r\n   for i=1, #p do p:add (p[i]); p[i] = nil end\r\n\r\n   -- FIXME: why is this commented out?\r\n   --if p.default and not is_parser(p.default) then sequence(p.default) end\r\n   return p\r\nend",
    "type": "function"
  }, {
    "id": 83,
    "text": "make_parser (\"multisequence\", p)",
    "type": "statement:functioncall"
  }, {
    "id": 84,
    "text": "function p:add (s)\r\n      -- compile if necessary:\r\n      local keyword = type(s)=='table' and s[1]\r\n      if type(s)=='table' and not is_parser(s) then sequence(s) end\r\n      if is_parser(s)~='sequence' or type(keyword)~='string' then \r\n         if self.default then -- two defaults\r\n            error (\"In a multisequence parser, all but one sequences \"..\r\n                   \"must start with a keyword\")\r\n         else self.default = s end -- first default\r\n      elseif self.sequences[keyword] then -- duplicate keyword\r\n         eprintf (\" *** Warning: keyword %q overloaded in multisequence ***\",\r\n                  keyword)\r\n         self.sequences[keyword] = s\r\n      else -- newly caught keyword\r\n         self.sequences[keyword] = s\r\n      end\r\n   end",
    "type": "statement:globalfunction"
  }, {
    "id": 85,
    "text": "local keyword = type(s)=='table' and s[1]",
    "type": "statement:localassign"
  }, {
    "id": 86,
    "text": "if type(s)=='table' and not is_parser(s) then sequence(s) end",
    "type": "statement:if"
  }, {
    "id": 87,
    "text": "sequence(s)",
    "type": "statement:functioncall"
  }, {
    "id": 88,
    "text": "if is_parser(s)~='sequence' or type(keyword)~='string' then \r\n         if self.default then -- two defaults\r\n            error (\"In a multisequence parser, all but one sequences \"..\r\n                   \"must start with a keyword\")\r\n         else self.default = s end -- first default\r\n      elseif self.sequences[keyword] then -- duplicate keyword\r\n         eprintf (\" *** Warning: keyword %q overloaded in multisequence ***\",\r\n                  keyword)\r\n         self.sequences[keyword] = s\r\n      else -- newly caught keyword\r\n         self.sequences[keyword] = s\r\n      end",
    "type": "statement:if"
  }, {
    "id": 89,
    "text": "if self.default then -- two defaults\r\n            error (\"In a multisequence parser, all but one sequences \"..\r\n                   \"must start with a keyword\")\r\n         else self.default = s end",
    "type": "statement:if"
  }, {
    "id": 90,
    "text": "error (\"In a multisequence parser, all but one sequences \"..\r\n                   \"must start with a keyword\")",
    "type": "statement:functioncall"
  }, {
    "id": 91,
    "text": "self.default = s",
    "type": "statement:assign"
  }, {
    "id": 92,
    "text": "eprintf (\" *** Warning: keyword %q overloaded in multisequence ***\",\r\n                  keyword)",
    "type": "statement:functioncall"
  }, {
    "id": 93,
    "text": "self.sequences[keyword] = s",
    "type": "statement:assign"
  }, {
    "id": 94,
    "text": "function p:get (kw) return self.sequences [kw] end",
    "type": "statement:globalfunction"
  }, {
    "id": 95,
    "text": "function p:del (kw) \r\n      if not self.sequences[kw] then \r\n         eprintf(\"*** Warning: trying to delete sequence starting \"..\r\n                 \"with %q from a multisequence having no such \"..\r\n                 \"entry ***\", kw) end\r\n      local removed = self.sequences[kw]\r\n      self.sequences[kw] = nil \r\n      return removed\r\n   end",
    "type": "statement:globalfunction"
  }, {
    "id": 96,
    "text": "if not self.sequences[kw] then \r\n         eprintf(\"*** Warning: trying to delete sequence starting \"..\r\n                 \"with %q from a multisequence having no such \"..\r\n                 \"entry ***\", kw) end",
    "type": "statement:if"
  }, {
    "id": 97,
    "text": "eprintf(\"*** Warning: trying to delete sequence starting \"..\r\n                 \"with %q from a multisequence having no such \"..\r\n                 \"entry ***\", kw)",
    "type": "statement:functioncall"
  }, {
    "id": 98,
    "text": "local removed = self.sequences[kw]",
    "type": "statement:localassign"
  }, {
    "id": 99,
    "text": "self.sequences[kw] = nil",
    "type": "statement:assign"
  }, {
    "id": 100,
    "text": "function p:parse (lx)\r\n      local fli = lx:lineinfo_right()\r\n      local x = raw_parse_multisequence (lx, self.sequences, self.default)\r\n      local lli = lx:lineinfo_left()\r\n      return transform (x, self, fli, lli)\r\n   end",
    "type": "statement:globalfunction"
  }, {
    "id": 101,
    "text": "local x = raw_parse_multisequence (lx, self.sequences, self.default)",
    "type": "statement:localassign"
  }, {
    "id": 102,
    "text": "p.sequences = { }",
    "type": "statement:assign"
  }, {
    "id": 103,
    "text": "for i=1, #p do p:add (p[i]); p[i] = nil end",
    "type": "statement:numericfor"
  }, {
    "id": 104,
    "text": "p:add (p[i])",
    "type": "statement:functioncall"
  }, {
    "id": 105,
    "text": "p[i] = nil",
    "type": "statement:assign"
  }, {
    "id": 106,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 107,
    "text": "function p:add (s)\r\n      -- compile if necessary:\r\n      local keyword = type(s)=='table' and s[1]\r\n      if type(s)=='table' and not is_parser(s) then sequence(s) end\r\n      if is_parser(s)~='sequence' or type(keyword)~='string' then \r\n         if self.default then -- two defaults\r\n            error (\"In a multisequence parser, all but one sequences \"..\r\n                   \"must start with a keyword\")\r\n         else self.default = s end -- first default\r\n      elseif self.sequences[keyword] then -- duplicate keyword\r\n         eprintf (\" *** Warning: keyword %q overloaded in multisequence ***\",\r\n                  keyword)\r\n         self.sequences[keyword] = s\r\n      else -- newly caught keyword\r\n         self.sequences[keyword] = s\r\n      end\r\n   end",
    "type": "function"
  }, {
    "id": 108,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 109,
    "text": "function p:get (kw) return self.sequences [kw] end",
    "type": "function"
  }, {
    "id": 110,
    "text": "function p:del (kw) \r\n      if not self.sequences[kw] then \r\n         eprintf(\"*** Warning: trying to delete sequence starting \"..\r\n                 \"with %q from a multisequence having no such \"..\r\n                 \"entry ***\", kw) end\r\n      local removed = self.sequences[kw]\r\n      self.sequences[kw] = nil \r\n      return removed\r\n   end",
    "type": "function"
  }, {
    "id": 111,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 112,
    "text": "function p:parse (lx)\r\n      local fli = lx:lineinfo_right()\r\n      local x = raw_parse_multisequence (lx, self.sequences, self.default)\r\n      local lli = lx:lineinfo_left()\r\n      return transform (x, self, fli, lli)\r\n   end",
    "type": "function"
  }, {
    "id": 113,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 114,
    "text": "function expr (p)\r\n   make_parser (\"expr\", p)\r\n\r\n   -------------------------------------------------------------------\r\n   -- parser method.\r\n   -- In addition to the lexer, it takes an optional precedence:\r\n   -- it won't read expressions whose precedence is lower or equal\r\n   -- to [prec].\r\n   -------------------------------------------------------------------\r\n   function p:parse (lx, prec)\r\n      prec = prec or 0\r\n\r\n      ------------------------------------------------------\r\n      -- Extract the right parser and the corresponding\r\n      -- options table, for (pre|in|suff)fix operators.\r\n      -- Options include prec, assoc, transformers.\r\n      ------------------------------------------------------\r\n      local function get_parser_info (tab)\r\n         local p2 = tab:get (lx:is_keyword (lx:peek()))\r\n         if p2 then -- keyword-based sequence found\r\n            local function parser(lx) return raw_parse_sequence(lx, p2) end\r\n            return parser, p2\r\n         else -- Got to use the default parser\r\n            local d = tab.default\r\n            if d then return d.parse or d.parser, d\r\n            else return false, false end\r\n         end\r\n      end\r\n\r\n      ------------------------------------------------------\r\n      -- Look for a prefix sequence. Multiple prefixes are\r\n      -- handled through the recursive [p.parse] call.\r\n      -- Notice the double-transform: one for the primary\r\n      -- expr, and one for the one with the prefix op.\r\n      ------------------------------------------------------\r\n      local function handle_prefix ()\r\n         local fli = lx:lineinfo_right()\r\n         local p2_func, p2 = get_parser_info (self.prefix)\r\n         local op = p2_func and p2_func (lx)\r\n         if op then -- Keyword-based sequence found\r\n            local ili = lx:lineinfo_right() -- Intermediate LineInfo\r\n            local e = p2.builder (op, self:parse (lx, p2.prec))\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e, p2, ili, lli), self, fli, lli)\r\n         else -- No prefix found, get a primary expression         \r\n            local e = self.primary(lx)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (e, self, fli, lli)\r\n         end\r\n      end --</expr.parse.handle_prefix>\r\n\r\n      ------------------------------------------------------\r\n      -- Look for an infix sequence+right-hand-side operand.\r\n      -- Return the whole binary expression result,\r\n      -- or false if no operator was found.\r\n      ------------------------------------------------------\r\n      local function handle_infix (e)\r\n         local p2_func, p2 = get_parser_info (self.infix)\r\n         if not p2 then return false end\r\n\r\n         -----------------------------------------\r\n         -- Handle flattening operators: gather all operands\r\n         -- of the series in [list]; when a different operator \r\n         -- is found, stop, build from [list], [transform] and\r\n         -- return.\r\n         -----------------------------------------\r\n         if (not p2.prec or p2.prec>prec) and p2.assoc==\"flat\" then\r\n            local fli = lx:lineinfo_right()\r\n            local pflat, list = p2, { e }\r\n            repeat\r\n               local op = p2_func(lx)\r\n               if not op then break end\r\n               table.insert (list, self:parse (lx, p2.prec))\r\n               local _ -- We only care about checking that p2==pflat\r\n               _, p2 = get_parser_info (self.infix)\r\n            until p2 ~= pflat\r\n            local e2 = pflat.builder (list)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e2, pflat, fli, lli), self, fli, lli)\r\n \r\n         -----------------------------------------\r\n         -- Handle regular infix operators: [e] the LHS is known,\r\n         -- just gather the operator and [e2] the RHS.\r\n         -- Result goes in [e3].\r\n         -----------------------------------------\r\n         elseif p2.prec and p2.prec>prec or \r\n                p2.prec==prec and p2.assoc==\"right\" then\r\n            local fli = e.lineinfo.first -- lx:lineinfo_right()\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local e2 = self:parse (lx, p2.prec)\r\n            local e3 = p2.builder (e, op, e2)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e3, p2, fli, lli), self, fli, lli)\r\n\r\n         -----------------------------------------\r\n         -- Check for non-associative operators, and complain if applicable. \r\n         -----------------------------------------\r\n         elseif p2.assoc==\"none\" and p2.prec==prec then\r\n            parse_error (lx, \"non-associative operator!\")\r\n\r\n         -----------------------------------------\r\n         -- No infix operator suitable at that precedence\r\n         -----------------------------------------\r\n         else return false end\r\n\r\n      end --</expr.parse.handle_infix>\r\n\r\n      ------------------------------------------------------\r\n      -- Look for a suffix sequence.\r\n      -- Return the result of suffix operator on [e],\r\n      -- or false if no operator was found.\r\n      ------------------------------------------------------\r\n      local function handle_suffix (e)\r\n         -- FIXME bad fli, must take e.lineinfo.first\r\n         local p2_func, p2 = get_parser_info (self.suffix)\r\n         if not p2 then return false end\r\n         if not p2.prec or p2.prec>=prec then\r\n            --local fli = lx:lineinfo_right()\r\n            local fli = e.lineinfo.first\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local lli = lx:lineinfo_left()\r\n            e = p2.builder (e, op)\r\n            e = transform (transform (e, p2, fli, lli), self, fli, lli)\r\n            return e\r\n         end\r\n         return false\r\n      end --</expr.parse.handle_suffix>\r\n\r\n      ------------------------------------------------------\r\n      -- Parser body: read suffix and (infix+operand) \r\n      -- extensions as long as we're able to fetch more at\r\n      -- this precedence level.\r\n      ------------------------------------------------------\r\n      local e = handle_prefix()\r\n      repeat\r\n         local x = handle_suffix (e); e = x or e\r\n         local y = handle_infix   (e); e = y or e\r\n      until not (x or y)\r\n\r\n      -- No transform: it already happened in operators handling\r\n      return e\r\n   end --</expr.parse>\r\n\r\n   -------------------------------------------------------------------\r\n   -- Construction\r\n   -------------------------------------------------------------------\r\n   if not p.primary then p.primary=p[1]; p[1]=nil end\r\n   for _, t in ipairs{ \"primary\", \"prefix\", \"infix\", \"suffix\" } do\r\n      if not p[t] then p[t] = { } end\r\n      if not is_parser(p[t]) then multisequence(p[t]) end\r\n   end\r\n   function p:add(...) return self.primary:add(...) end\r\n   return p\r\nend",
    "type": "function"
  }, {
    "id": 115,
    "text": "make_parser (\"expr\", p)",
    "type": "statement:functioncall"
  }, {
    "id": 116,
    "text": "function p:parse (lx, prec)\r\n      prec = prec or 0\r\n\r\n      ------------------------------------------------------\r\n      -- Extract the right parser and the corresponding\r\n      -- options table, for (pre|in|suff)fix operators.\r\n      -- Options include prec, assoc, transformers.\r\n      ------------------------------------------------------\r\n      local function get_parser_info (tab)\r\n         local p2 = tab:get (lx:is_keyword (lx:peek()))\r\n         if p2 then -- keyword-based sequence found\r\n            local function parser(lx) return raw_parse_sequence(lx, p2) end\r\n            return parser, p2\r\n         else -- Got to use the default parser\r\n            local d = tab.default\r\n            if d then return d.parse or d.parser, d\r\n            else return false, false end\r\n         end\r\n      end\r\n\r\n      ------------------------------------------------------\r\n      -- Look for a prefix sequence. Multiple prefixes are\r\n      -- handled through the recursive [p.parse] call.\r\n      -- Notice the double-transform: one for the primary\r\n      -- expr, and one for the one with the prefix op.\r\n      ------------------------------------------------------\r\n      local function handle_prefix ()\r\n         local fli = lx:lineinfo_right()\r\n         local p2_func, p2 = get_parser_info (self.prefix)\r\n         local op = p2_func and p2_func (lx)\r\n         if op then -- Keyword-based sequence found\r\n            local ili = lx:lineinfo_right() -- Intermediate LineInfo\r\n            local e = p2.builder (op, self:parse (lx, p2.prec))\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e, p2, ili, lli), self, fli, lli)\r\n         else -- No prefix found, get a primary expression         \r\n            local e = self.primary(lx)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (e, self, fli, lli)\r\n         end\r\n      end --</expr.parse.handle_prefix>\r\n\r\n      ------------------------------------------------------\r\n      -- Look for an infix sequence+right-hand-side operand.\r\n      -- Return the whole binary expression result,\r\n      -- or false if no operator was found.\r\n      ------------------------------------------------------\r\n      local function handle_infix (e)\r\n         local p2_func, p2 = get_parser_info (self.infix)\r\n         if not p2 then return false end\r\n\r\n         -----------------------------------------\r\n         -- Handle flattening operators: gather all operands\r\n         -- of the series in [list]; when a different operator \r\n         -- is found, stop, build from [list], [transform] and\r\n         -- return.\r\n         -----------------------------------------\r\n         if (not p2.prec or p2.prec>prec) and p2.assoc==\"flat\" then\r\n            local fli = lx:lineinfo_right()\r\n            local pflat, list = p2, { e }\r\n            repeat\r\n               local op = p2_func(lx)\r\n               if not op then break end\r\n               table.insert (list, self:parse (lx, p2.prec))\r\n               local _ -- We only care about checking that p2==pflat\r\n               _, p2 = get_parser_info (self.infix)\r\n            until p2 ~= pflat\r\n            local e2 = pflat.builder (list)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e2, pflat, fli, lli), self, fli, lli)\r\n \r\n         -----------------------------------------\r\n         -- Handle regular infix operators: [e] the LHS is known,\r\n         -- just gather the operator and [e2] the RHS.\r\n         -- Result goes in [e3].\r\n         -----------------------------------------\r\n         elseif p2.prec and p2.prec>prec or \r\n                p2.prec==prec and p2.assoc==\"right\" then\r\n            local fli = e.lineinfo.first -- lx:lineinfo_right()\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local e2 = self:parse (lx, p2.prec)\r\n            local e3 = p2.builder (e, op, e2)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e3, p2, fli, lli), self, fli, lli)\r\n\r\n         -----------------------------------------\r\n         -- Check for non-associative operators, and complain if applicable. \r\n         -----------------------------------------\r\n         elseif p2.assoc==\"none\" and p2.prec==prec then\r\n            parse_error (lx, \"non-associative operator!\")\r\n\r\n         -----------------------------------------\r\n         -- No infix operator suitable at that precedence\r\n         -----------------------------------------\r\n         else return false end\r\n\r\n      end --</expr.parse.handle_infix>\r\n\r\n      ------------------------------------------------------\r\n      -- Look for a suffix sequence.\r\n      -- Return the result of suffix operator on [e],\r\n      -- or false if no operator was found.\r\n      ------------------------------------------------------\r\n      local function handle_suffix (e)\r\n         -- FIXME bad fli, must take e.lineinfo.first\r\n         local p2_func, p2 = get_parser_info (self.suffix)\r\n         if not p2 then return false end\r\n         if not p2.prec or p2.prec>=prec then\r\n            --local fli = lx:lineinfo_right()\r\n            local fli = e.lineinfo.first\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local lli = lx:lineinfo_left()\r\n            e = p2.builder (e, op)\r\n            e = transform (transform (e, p2, fli, lli), self, fli, lli)\r\n            return e\r\n         end\r\n         return false\r\n      end --</expr.parse.handle_suffix>\r\n\r\n      ------------------------------------------------------\r\n      -- Parser body: read suffix and (infix+operand) \r\n      -- extensions as long as we're able to fetch more at\r\n      -- this precedence level.\r\n      ------------------------------------------------------\r\n      local e = handle_prefix()\r\n      repeat\r\n         local x = handle_suffix (e); e = x or e\r\n         local y = handle_infix   (e); e = y or e\r\n      until not (x or y)\r\n\r\n      -- No transform: it already happened in operators handling\r\n      return e\r\n   end",
    "type": "statement:globalfunction"
  }, {
    "id": 117,
    "text": "prec = prec or 0",
    "type": "statement:assign"
  }, {
    "id": 118,
    "text": "local function get_parser_info (tab)\r\n         local p2 = tab:get (lx:is_keyword (lx:peek()))\r\n         if p2 then -- keyword-based sequence found\r\n            local function parser(lx) return raw_parse_sequence(lx, p2) end\r\n            return parser, p2\r\n         else -- Got to use the default parser\r\n            local d = tab.default\r\n            if d then return d.parse or d.parser, d\r\n            else return false, false end\r\n         end\r\n      end",
    "type": "statement:localfunction"
  }, {
    "id": 119,
    "text": "local p2 = tab:get (lx:is_keyword (lx:peek()))",
    "type": "statement:localassign"
  }, {
    "id": 120,
    "text": "if p2 then -- keyword-based sequence found\r\n            local function parser(lx) return raw_parse_sequence(lx, p2) end\r\n            return parser, p2\r\n         else -- Got to use the default parser\r\n            local d = tab.default\r\n            if d then return d.parse or d.parser, d\r\n            else return false, false end\r\n         end",
    "type": "statement:if"
  }, {
    "id": 121,
    "text": "local function parser(lx) return raw_parse_sequence(lx, p2) end",
    "type": "statement:localfunction"
  }, {
    "id": 122,
    "text": "local d = tab.default",
    "type": "statement:localassign"
  }, {
    "id": 123,
    "text": "if d then return d.parse or d.parser, d\r\n            else return false, false end",
    "type": "statement:if"
  }, {
    "id": 124,
    "text": "local function handle_prefix ()\r\n         local fli = lx:lineinfo_right()\r\n         local p2_func, p2 = get_parser_info (self.prefix)\r\n         local op = p2_func and p2_func (lx)\r\n         if op then -- Keyword-based sequence found\r\n            local ili = lx:lineinfo_right() -- Intermediate LineInfo\r\n            local e = p2.builder (op, self:parse (lx, p2.prec))\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e, p2, ili, lli), self, fli, lli)\r\n         else -- No prefix found, get a primary expression         \r\n            local e = self.primary(lx)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (e, self, fli, lli)\r\n         end\r\n      end",
    "type": "statement:localfunction"
  }, {
    "id": 125,
    "text": "local p2_func, p2 = get_parser_info (self.prefix)",
    "type": "statement:localassign"
  }, {
    "id": 126,
    "text": "local op = p2_func and p2_func (lx)",
    "type": "statement:localassign"
  }, {
    "id": 127,
    "text": "if op then -- Keyword-based sequence found\r\n            local ili = lx:lineinfo_right() -- Intermediate LineInfo\r\n            local e = p2.builder (op, self:parse (lx, p2.prec))\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e, p2, ili, lli), self, fli, lli)\r\n         else -- No prefix found, get a primary expression         \r\n            local e = self.primary(lx)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (e, self, fli, lli)\r\n         end",
    "type": "statement:if"
  }, {
    "id": 128,
    "text": "local ili = lx:lineinfo_right()",
    "type": "statement:localassign"
  }, {
    "id": 129,
    "text": "local e = p2.builder (op, self:parse (lx, p2.prec))",
    "type": "statement:localassign"
  }, {
    "id": 130,
    "text": "local e = self.primary(lx)",
    "type": "statement:localassign"
  }, {
    "id": 131,
    "text": "local function handle_infix (e)\r\n         local p2_func, p2 = get_parser_info (self.infix)\r\n         if not p2 then return false end\r\n\r\n         -----------------------------------------\r\n         -- Handle flattening operators: gather all operands\r\n         -- of the series in [list]; when a different operator \r\n         -- is found, stop, build from [list], [transform] and\r\n         -- return.\r\n         -----------------------------------------\r\n         if (not p2.prec or p2.prec>prec) and p2.assoc==\"flat\" then\r\n            local fli = lx:lineinfo_right()\r\n            local pflat, list = p2, { e }\r\n            repeat\r\n               local op = p2_func(lx)\r\n               if not op then break end\r\n               table.insert (list, self:parse (lx, p2.prec))\r\n               local _ -- We only care about checking that p2==pflat\r\n               _, p2 = get_parser_info (self.infix)\r\n            until p2 ~= pflat\r\n            local e2 = pflat.builder (list)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e2, pflat, fli, lli), self, fli, lli)\r\n \r\n         -----------------------------------------\r\n         -- Handle regular infix operators: [e] the LHS is known,\r\n         -- just gather the operator and [e2] the RHS.\r\n         -- Result goes in [e3].\r\n         -----------------------------------------\r\n         elseif p2.prec and p2.prec>prec or \r\n                p2.prec==prec and p2.assoc==\"right\" then\r\n            local fli = e.lineinfo.first -- lx:lineinfo_right()\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local e2 = self:parse (lx, p2.prec)\r\n            local e3 = p2.builder (e, op, e2)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e3, p2, fli, lli), self, fli, lli)\r\n\r\n         -----------------------------------------\r\n         -- Check for non-associative operators, and complain if applicable. \r\n         -----------------------------------------\r\n         elseif p2.assoc==\"none\" and p2.prec==prec then\r\n            parse_error (lx, \"non-associative operator!\")\r\n\r\n         -----------------------------------------\r\n         -- No infix operator suitable at that precedence\r\n         -----------------------------------------\r\n         else return false end\r\n\r\n      end",
    "type": "statement:localfunction"
  }, {
    "id": 132,
    "text": "local p2_func, p2 = get_parser_info (self.infix)",
    "type": "statement:localassign"
  }, {
    "id": 133,
    "text": "if not p2 then return false end",
    "type": "statement:if"
  }, {
    "id": 134,
    "text": "if (not p2.prec or p2.prec>prec) and p2.assoc==\"flat\" then\r\n            local fli = lx:lineinfo_right()\r\n            local pflat, list = p2, { e }\r\n            repeat\r\n               local op = p2_func(lx)\r\n               if not op then break end\r\n               table.insert (list, self:parse (lx, p2.prec))\r\n               local _ -- We only care about checking that p2==pflat\r\n               _, p2 = get_parser_info (self.infix)\r\n            until p2 ~= pflat\r\n            local e2 = pflat.builder (list)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e2, pflat, fli, lli), self, fli, lli)\r\n \r\n         -----------------------------------------\r\n         -- Handle regular infix operators: [e] the LHS is known,\r\n         -- just gather the operator and [e2] the RHS.\r\n         -- Result goes in [e3].\r\n         -----------------------------------------\r\n         elseif p2.prec and p2.prec>prec or \r\n                p2.prec==prec and p2.assoc==\"right\" then\r\n            local fli = e.lineinfo.first -- lx:lineinfo_right()\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local e2 = self:parse (lx, p2.prec)\r\n            local e3 = p2.builder (e, op, e2)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e3, p2, fli, lli), self, fli, lli)\r\n\r\n         -----------------------------------------\r\n         -- Check for non-associative operators, and complain if applicable. \r\n         -----------------------------------------\r\n         elseif p2.assoc==\"none\" and p2.prec==prec then\r\n            parse_error (lx, \"non-associative operator!\")\r\n\r\n         -----------------------------------------\r\n         -- No infix operator suitable at that precedence\r\n         -----------------------------------------\r\n         else return false end",
    "type": "statement:if"
  }, {
    "id": 135,
    "text": "local pflat, list = p2, { e }",
    "type": "statement:localassign"
  }, {
    "id": 136,
    "text": "repeat\r\n               local op = p2_func(lx)\r\n               if not op then break end\r\n               table.insert (list, self:parse (lx, p2.prec))\r\n               local _ -- We only care about checking that p2==pflat\r\n               _, p2 = get_parser_info (self.infix)\r\n            until p2 ~= pflat",
    "type": "statement:repeat"
  }, {
    "id": 137,
    "text": "local op = p2_func(lx)",
    "type": "statement:localassign"
  }, {
    "id": 138,
    "text": "if not op then break end",
    "type": "statement:if"
  }, {
    "id": 139,
    "text": "table.insert (list, self:parse (lx, p2.prec))",
    "type": "statement:functioncall"
  }, {
    "id": 140,
    "text": "local _",
    "type": "statement:localassign"
  }, {
    "id": 141,
    "text": "_, p2 = get_parser_info (self.infix)",
    "type": "statement:assign"
  }, {
    "id": 142,
    "text": "local e2 = pflat.builder (list)",
    "type": "statement:localassign"
  }, {
    "id": 143,
    "text": "local fli = e.lineinfo.first",
    "type": "statement:localassign"
  }, {
    "id": 144,
    "text": "if not op then return false end",
    "type": "statement:if"
  }, {
    "id": 145,
    "text": "local e2 = self:parse (lx, p2.prec)",
    "type": "statement:localassign"
  }, {
    "id": 146,
    "text": "local e3 = p2.builder (e, op, e2)",
    "type": "statement:localassign"
  }, {
    "id": 147,
    "text": "parse_error (lx, \"non-associative operator!\")",
    "type": "statement:functioncall"
  }, {
    "id": 148,
    "text": "local function handle_suffix (e)\r\n         -- FIXME bad fli, must take e.lineinfo.first\r\n         local p2_func, p2 = get_parser_info (self.suffix)\r\n         if not p2 then return false end\r\n         if not p2.prec or p2.prec>=prec then\r\n            --local fli = lx:lineinfo_right()\r\n            local fli = e.lineinfo.first\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local lli = lx:lineinfo_left()\r\n            e = p2.builder (e, op)\r\n            e = transform (transform (e, p2, fli, lli), self, fli, lli)\r\n            return e\r\n         end\r\n         return false\r\n      end",
    "type": "statement:localfunction"
  }, {
    "id": 149,
    "text": "local p2_func, p2 = get_parser_info (self.suffix)",
    "type": "statement:localassign"
  }, {
    "id": 150,
    "text": "if not p2.prec or p2.prec>=prec then\r\n            --local fli = lx:lineinfo_right()\r\n            local fli = e.lineinfo.first\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local lli = lx:lineinfo_left()\r\n            e = p2.builder (e, op)\r\n            e = transform (transform (e, p2, fli, lli), self, fli, lli)\r\n            return e\r\n         end",
    "type": "statement:if"
  }, {
    "id": 151,
    "text": "e = p2.builder (e, op)",
    "type": "statement:assign"
  }, {
    "id": 152,
    "text": "e = transform (transform (e, p2, fli, lli), self, fli, lli)",
    "type": "statement:assign"
  }, {
    "id": 153,
    "text": "local e = handle_prefix()",
    "type": "statement:localassign"
  }, {
    "id": 154,
    "text": "repeat\r\n         local x = handle_suffix (e); e = x or e\r\n         local y = handle_infix   (e); e = y or e\r\n      until not (x or y)",
    "type": "statement:repeat"
  }, {
    "id": 155,
    "text": "local x = handle_suffix (e)",
    "type": "statement:localassign"
  }, {
    "id": 156,
    "text": "e = x or e",
    "type": "statement:assign"
  }, {
    "id": 157,
    "text": "local y = handle_infix   (e)",
    "type": "statement:localassign"
  }, {
    "id": 158,
    "text": "e = y or e",
    "type": "statement:assign"
  }, {
    "id": 159,
    "text": "if not p.primary then p.primary=p[1]; p[1]=nil end",
    "type": "statement:if"
  }, {
    "id": 160,
    "text": "p.primary=p[1]",
    "type": "statement:assign"
  }, {
    "id": 161,
    "text": "p[1]=nil",
    "type": "statement:assign"
  }, {
    "id": 162,
    "text": "for _, t in ipairs{ \"primary\", \"prefix\", \"infix\", \"suffix\" } do\r\n      if not p[t] then p[t] = { } end\r\n      if not is_parser(p[t]) then multisequence(p[t]) end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 163,
    "text": "if not p[t] then p[t] = { } end",
    "type": "statement:if"
  }, {
    "id": 164,
    "text": "p[t] = { }",
    "type": "statement:assign"
  }, {
    "id": 165,
    "text": "if not is_parser(p[t]) then multisequence(p[t]) end",
    "type": "statement:if"
  }, {
    "id": 166,
    "text": "multisequence(p[t])",
    "type": "statement:functioncall"
  }, {
    "id": 167,
    "text": "function p:add(...) return self.primary:add(...) end",
    "type": "statement:globalfunction"
  }, {
    "id": 168,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 169,
    "text": "function p:parse (lx, prec)\r\n      prec = prec or 0\r\n\r\n      ------------------------------------------------------\r\n      -- Extract the right parser and the corresponding\r\n      -- options table, for (pre|in|suff)fix operators.\r\n      -- Options include prec, assoc, transformers.\r\n      ------------------------------------------------------\r\n      local function get_parser_info (tab)\r\n         local p2 = tab:get (lx:is_keyword (lx:peek()))\r\n         if p2 then -- keyword-based sequence found\r\n            local function parser(lx) return raw_parse_sequence(lx, p2) end\r\n            return parser, p2\r\n         else -- Got to use the default parser\r\n            local d = tab.default\r\n            if d then return d.parse or d.parser, d\r\n            else return false, false end\r\n         end\r\n      end\r\n\r\n      ------------------------------------------------------\r\n      -- Look for a prefix sequence. Multiple prefixes are\r\n      -- handled through the recursive [p.parse] call.\r\n      -- Notice the double-transform: one for the primary\r\n      -- expr, and one for the one with the prefix op.\r\n      ------------------------------------------------------\r\n      local function handle_prefix ()\r\n         local fli = lx:lineinfo_right()\r\n         local p2_func, p2 = get_parser_info (self.prefix)\r\n         local op = p2_func and p2_func (lx)\r\n         if op then -- Keyword-based sequence found\r\n            local ili = lx:lineinfo_right() -- Intermediate LineInfo\r\n            local e = p2.builder (op, self:parse (lx, p2.prec))\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e, p2, ili, lli), self, fli, lli)\r\n         else -- No prefix found, get a primary expression         \r\n            local e = self.primary(lx)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (e, self, fli, lli)\r\n         end\r\n      end --</expr.parse.handle_prefix>\r\n\r\n      ------------------------------------------------------\r\n      -- Look for an infix sequence+right-hand-side operand.\r\n      -- Return the whole binary expression result,\r\n      -- or false if no operator was found.\r\n      ------------------------------------------------------\r\n      local function handle_infix (e)\r\n         local p2_func, p2 = get_parser_info (self.infix)\r\n         if not p2 then return false end\r\n\r\n         -----------------------------------------\r\n         -- Handle flattening operators: gather all operands\r\n         -- of the series in [list]; when a different operator \r\n         -- is found, stop, build from [list], [transform] and\r\n         -- return.\r\n         -----------------------------------------\r\n         if (not p2.prec or p2.prec>prec) and p2.assoc==\"flat\" then\r\n            local fli = lx:lineinfo_right()\r\n            local pflat, list = p2, { e }\r\n            repeat\r\n               local op = p2_func(lx)\r\n               if not op then break end\r\n               table.insert (list, self:parse (lx, p2.prec))\r\n               local _ -- We only care about checking that p2==pflat\r\n               _, p2 = get_parser_info (self.infix)\r\n            until p2 ~= pflat\r\n            local e2 = pflat.builder (list)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e2, pflat, fli, lli), self, fli, lli)\r\n \r\n         -----------------------------------------\r\n         -- Handle regular infix operators: [e] the LHS is known,\r\n         -- just gather the operator and [e2] the RHS.\r\n         -- Result goes in [e3].\r\n         -----------------------------------------\r\n         elseif p2.prec and p2.prec>prec or \r\n                p2.prec==prec and p2.assoc==\"right\" then\r\n            local fli = e.lineinfo.first -- lx:lineinfo_right()\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local e2 = self:parse (lx, p2.prec)\r\n            local e3 = p2.builder (e, op, e2)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e3, p2, fli, lli), self, fli, lli)\r\n\r\n         -----------------------------------------\r\n         -- Check for non-associative operators, and complain if applicable. \r\n         -----------------------------------------\r\n         elseif p2.assoc==\"none\" and p2.prec==prec then\r\n            parse_error (lx, \"non-associative operator!\")\r\n\r\n         -----------------------------------------\r\n         -- No infix operator suitable at that precedence\r\n         -----------------------------------------\r\n         else return false end\r\n\r\n      end --</expr.parse.handle_infix>\r\n\r\n      ------------------------------------------------------\r\n      -- Look for a suffix sequence.\r\n      -- Return the result of suffix operator on [e],\r\n      -- or false if no operator was found.\r\n      ------------------------------------------------------\r\n      local function handle_suffix (e)\r\n         -- FIXME bad fli, must take e.lineinfo.first\r\n         local p2_func, p2 = get_parser_info (self.suffix)\r\n         if not p2 then return false end\r\n         if not p2.prec or p2.prec>=prec then\r\n            --local fli = lx:lineinfo_right()\r\n            local fli = e.lineinfo.first\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local lli = lx:lineinfo_left()\r\n            e = p2.builder (e, op)\r\n            e = transform (transform (e, p2, fli, lli), self, fli, lli)\r\n            return e\r\n         end\r\n         return false\r\n      end --</expr.parse.handle_suffix>\r\n\r\n      ------------------------------------------------------\r\n      -- Parser body: read suffix and (infix+operand) \r\n      -- extensions as long as we're able to fetch more at\r\n      -- this precedence level.\r\n      ------------------------------------------------------\r\n      local e = handle_prefix()\r\n      repeat\r\n         local x = handle_suffix (e); e = x or e\r\n         local y = handle_infix   (e); e = y or e\r\n      until not (x or y)\r\n\r\n      -- No transform: it already happened in operators handling\r\n      return e\r\n   end",
    "type": "function"
  }, {
    "id": 170,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 171,
    "text": "local function get_parser_info (tab)\r\n         local p2 = tab:get (lx:is_keyword (lx:peek()))\r\n         if p2 then -- keyword-based sequence found\r\n            local function parser(lx) return raw_parse_sequence(lx, p2) end\r\n            return parser, p2\r\n         else -- Got to use the default parser\r\n            local d = tab.default\r\n            if d then return d.parse or d.parser, d\r\n            else return false, false end\r\n         end\r\n      end",
    "type": "function"
  }, {
    "id": 172,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 173,
    "text": "local function parser(lx) return raw_parse_sequence(lx, p2) end",
    "type": "function"
  }, {
    "id": 174,
    "text": "local function handle_prefix ()\r\n         local fli = lx:lineinfo_right()\r\n         local p2_func, p2 = get_parser_info (self.prefix)\r\n         local op = p2_func and p2_func (lx)\r\n         if op then -- Keyword-based sequence found\r\n            local ili = lx:lineinfo_right() -- Intermediate LineInfo\r\n            local e = p2.builder (op, self:parse (lx, p2.prec))\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e, p2, ili, lli), self, fli, lli)\r\n         else -- No prefix found, get a primary expression         \r\n            local e = self.primary(lx)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (e, self, fli, lli)\r\n         end\r\n      end",
    "type": "function"
  }, {
    "id": 175,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 176,
    "text": "local function handle_infix (e)\r\n         local p2_func, p2 = get_parser_info (self.infix)\r\n         if not p2 then return false end\r\n\r\n         -----------------------------------------\r\n         -- Handle flattening operators: gather all operands\r\n         -- of the series in [list]; when a different operator \r\n         -- is found, stop, build from [list], [transform] and\r\n         -- return.\r\n         -----------------------------------------\r\n         if (not p2.prec or p2.prec>prec) and p2.assoc==\"flat\" then\r\n            local fli = lx:lineinfo_right()\r\n            local pflat, list = p2, { e }\r\n            repeat\r\n               local op = p2_func(lx)\r\n               if not op then break end\r\n               table.insert (list, self:parse (lx, p2.prec))\r\n               local _ -- We only care about checking that p2==pflat\r\n               _, p2 = get_parser_info (self.infix)\r\n            until p2 ~= pflat\r\n            local e2 = pflat.builder (list)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e2, pflat, fli, lli), self, fli, lli)\r\n \r\n         -----------------------------------------\r\n         -- Handle regular infix operators: [e] the LHS is known,\r\n         -- just gather the operator and [e2] the RHS.\r\n         -- Result goes in [e3].\r\n         -----------------------------------------\r\n         elseif p2.prec and p2.prec>prec or \r\n                p2.prec==prec and p2.assoc==\"right\" then\r\n            local fli = e.lineinfo.first -- lx:lineinfo_right()\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local e2 = self:parse (lx, p2.prec)\r\n            local e3 = p2.builder (e, op, e2)\r\n            local lli = lx:lineinfo_left()\r\n            return transform (transform (e3, p2, fli, lli), self, fli, lli)\r\n\r\n         -----------------------------------------\r\n         -- Check for non-associative operators, and complain if applicable. \r\n         -----------------------------------------\r\n         elseif p2.assoc==\"none\" and p2.prec==prec then\r\n            parse_error (lx, \"non-associative operator!\")\r\n\r\n         -----------------------------------------\r\n         -- No infix operator suitable at that precedence\r\n         -----------------------------------------\r\n         else return false end\r\n\r\n      end",
    "type": "function"
  }, {
    "id": 177,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 178,
    "text": "local function handle_suffix (e)\r\n         -- FIXME bad fli, must take e.lineinfo.first\r\n         local p2_func, p2 = get_parser_info (self.suffix)\r\n         if not p2 then return false end\r\n         if not p2.prec or p2.prec>=prec then\r\n            --local fli = lx:lineinfo_right()\r\n            local fli = e.lineinfo.first\r\n            local op = p2_func(lx)\r\n            if not op then return false end\r\n            local lli = lx:lineinfo_left()\r\n            e = p2.builder (e, op)\r\n            e = transform (transform (e, p2, fli, lli), self, fli, lli)\r\n            return e\r\n         end\r\n         return false\r\n      end",
    "type": "function"
  }, {
    "id": 179,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 180,
    "text": "function p:add(...) return self.primary:add(...) end",
    "type": "function"
  }, {
    "id": 181,
    "text": "function list (p)\r\n   make_parser (\"list\", p)\r\n\r\n   -------------------------------------------------------------------\r\n   -- Parsing method\r\n   -------------------------------------------------------------------\r\n   function p:parse (lx)\r\n\r\n      ------------------------------------------------------\r\n      -- Used to quickly check whether there's a terminator \r\n      -- or a separator immediately ahead\r\n      ------------------------------------------------------\r\n      local function peek_is_in (keywords) \r\n         return keywords and lx:is_keyword(lx:peek(), unpack(keywords)) end\r\n\r\n      local x = { }\r\n      local fli = lx:lineinfo_right()\r\n\r\n      -- if there's a terminator to start with, don't bother trying\r\n      if not peek_is_in (self.terminators) then \r\n         repeat table.insert (x, self.primary (lx)) -- read one element\r\n         until\r\n            -- First reason to stop: There's a separator list specified,\r\n            -- and next token isn't one. Otherwise, consume it with [lx:next()]\r\n            self.separators and not(peek_is_in (self.separators) and lx:next()) or\r\n            -- Other reason to stop: terminator token ahead\r\n            peek_is_in (self.terminators) or\r\n            -- Last reason: end of file reached\r\n            lx:peek().tag==\"Eof\"\r\n      end\r\n\r\n      local lli = lx:lineinfo_left()\r\n      \r\n      -- Apply the builder. It can be a string, or a callable value, \r\n      -- or simply nothing.\r\n      local b = self.builder\r\n      if b then\r\n         if type(b)==\"string\" then x.tag = b -- b is a string, use it as a tag\r\n         elseif type(b)==\"function\" then x=b(x)\r\n         else\r\n            local bmt = getmetatable(b)\r\n            if bmt and bmt.__call then x=b(x) end\r\n         end\r\n      end\r\n      return transform (x, self, fli, lli)\r\n   end --</list.parse>\r\n\r\n   -------------------------------------------------------------------\r\n   -- Construction\r\n   -------------------------------------------------------------------\r\n   if not p.primary then p.primary = p[1]; p[1] = nil end\r\n   if type(p.terminators) == \"string\" then p.terminators = { p.terminators }\r\n   elseif p.terminators and #p.terminators == 0 then p.terminators = nil end\r\n   if type(p.separators) == \"string\" then p.separators = { p.separators }\r\n   elseif p.separators and #p.separators == 0 then p.separators = nil end\r\n\r\n   return p\r\nend",
    "type": "function"
  }, {
    "id": 182,
    "text": "make_parser (\"list\", p)",
    "type": "statement:functioncall"
  }, {
    "id": 183,
    "text": "function p:parse (lx)\r\n\r\n      ------------------------------------------------------\r\n      -- Used to quickly check whether there's a terminator \r\n      -- or a separator immediately ahead\r\n      ------------------------------------------------------\r\n      local function peek_is_in (keywords) \r\n         return keywords and lx:is_keyword(lx:peek(), unpack(keywords)) end\r\n\r\n      local x = { }\r\n      local fli = lx:lineinfo_right()\r\n\r\n      -- if there's a terminator to start with, don't bother trying\r\n      if not peek_is_in (self.terminators) then \r\n         repeat table.insert (x, self.primary (lx)) -- read one element\r\n         until\r\n            -- First reason to stop: There's a separator list specified,\r\n            -- and next token isn't one. Otherwise, consume it with [lx:next()]\r\n            self.separators and not(peek_is_in (self.separators) and lx:next()) or\r\n            -- Other reason to stop: terminator token ahead\r\n            peek_is_in (self.terminators) or\r\n            -- Last reason: end of file reached\r\n            lx:peek().tag==\"Eof\"\r\n      end\r\n\r\n      local lli = lx:lineinfo_left()\r\n      \r\n      -- Apply the builder. It can be a string, or a callable value, \r\n      -- or simply nothing.\r\n      local b = self.builder\r\n      if b then\r\n         if type(b)==\"string\" then x.tag = b -- b is a string, use it as a tag\r\n         elseif type(b)==\"function\" then x=b(x)\r\n         else\r\n            local bmt = getmetatable(b)\r\n            if bmt and bmt.__call then x=b(x) end\r\n         end\r\n      end\r\n      return transform (x, self, fli, lli)\r\n   end",
    "type": "statement:globalfunction"
  }, {
    "id": 184,
    "text": "local function peek_is_in (keywords) \r\n         return keywords and lx:is_keyword(lx:peek(), unpack(keywords)) end",
    "type": "statement:localfunction"
  }, {
    "id": 185,
    "text": "local x = { }",
    "type": "statement:localassign"
  }, {
    "id": 186,
    "text": "if not peek_is_in (self.terminators) then \r\n         repeat table.insert (x, self.primary (lx)) -- read one element\r\n         until\r\n            -- First reason to stop: There's a separator list specified,\r\n            -- and next token isn't one. Otherwise, consume it with [lx:next()]\r\n            self.separators and not(peek_is_in (self.separators) and lx:next()) or\r\n            -- Other reason to stop: terminator token ahead\r\n            peek_is_in (self.terminators) or\r\n            -- Last reason: end of file reached\r\n            lx:peek().tag==\"Eof\"\r\n      end",
    "type": "statement:if"
  }, {
    "id": 187,
    "text": "repeat table.insert (x, self.primary (lx)) -- read one element\r\n         until\r\n            -- First reason to stop: There's a separator list specified,\r\n            -- and next token isn't one. Otherwise, consume it with [lx:next()]\r\n            self.separators and not(peek_is_in (self.separators) and lx:next()) or\r\n            -- Other reason to stop: terminator token ahead\r\n            peek_is_in (self.terminators) or\r\n            -- Last reason: end of file reached\r\n            lx:peek().tag==\"Eof\"",
    "type": "statement:repeat"
  }, {
    "id": 188,
    "text": "table.insert (x, self.primary (lx))",
    "type": "statement:functioncall"
  }, {
    "id": 189,
    "text": "local b = self.builder",
    "type": "statement:localassign"
  }, {
    "id": 190,
    "text": "if b then\r\n         if type(b)==\"string\" then x.tag = b -- b is a string, use it as a tag\r\n         elseif type(b)==\"function\" then x=b(x)\r\n         else\r\n            local bmt = getmetatable(b)\r\n            if bmt and bmt.__call then x=b(x) end\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 191,
    "text": "if type(b)==\"string\" then x.tag = b -- b is a string, use it as a tag\r\n         elseif type(b)==\"function\" then x=b(x)\r\n         else\r\n            local bmt = getmetatable(b)\r\n            if bmt and bmt.__call then x=b(x) end\r\n         end",
    "type": "statement:if"
  }, {
    "id": 192,
    "text": "x.tag = b",
    "type": "statement:assign"
  }, {
    "id": 193,
    "text": "x=b(x)",
    "type": "statement:assign"
  }, {
    "id": 194,
    "text": "local bmt = getmetatable(b)",
    "type": "statement:localassign"
  }, {
    "id": 195,
    "text": "if bmt and bmt.__call then x=b(x) end",
    "type": "statement:if"
  }, {
    "id": 196,
    "text": "if not p.primary then p.primary = p[1]; p[1] = nil end",
    "type": "statement:if"
  }, {
    "id": 197,
    "text": "p.primary = p[1]",
    "type": "statement:assign"
  }, {
    "id": 198,
    "text": "p[1] = nil",
    "type": "statement:assign"
  }, {
    "id": 199,
    "text": "if type(p.terminators) == \"string\" then p.terminators = { p.terminators }\r\n   elseif p.terminators and #p.terminators == 0 then p.terminators = nil end",
    "type": "statement:if"
  }, {
    "id": 200,
    "text": "p.terminators = { p.terminators }",
    "type": "statement:assign"
  }, {
    "id": 201,
    "text": "p.terminators = nil",
    "type": "statement:assign"
  }, {
    "id": 202,
    "text": "if type(p.separators) == \"string\" then p.separators = { p.separators }\r\n   elseif p.separators and #p.separators == 0 then p.separators = nil end",
    "type": "statement:if"
  }, {
    "id": 203,
    "text": "p.separators = { p.separators }",
    "type": "statement:assign"
  }, {
    "id": 204,
    "text": "p.separators = nil",
    "type": "statement:assign"
  }, {
    "id": 205,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 206,
    "text": "function p:parse (lx)\r\n\r\n      ------------------------------------------------------\r\n      -- Used to quickly check whether there's a terminator \r\n      -- or a separator immediately ahead\r\n      ------------------------------------------------------\r\n      local function peek_is_in (keywords) \r\n         return keywords and lx:is_keyword(lx:peek(), unpack(keywords)) end\r\n\r\n      local x = { }\r\n      local fli = lx:lineinfo_right()\r\n\r\n      -- if there's a terminator to start with, don't bother trying\r\n      if not peek_is_in (self.terminators) then \r\n         repeat table.insert (x, self.primary (lx)) -- read one element\r\n         until\r\n            -- First reason to stop: There's a separator list specified,\r\n            -- and next token isn't one. Otherwise, consume it with [lx:next()]\r\n            self.separators and not(peek_is_in (self.separators) and lx:next()) or\r\n            -- Other reason to stop: terminator token ahead\r\n            peek_is_in (self.terminators) or\r\n            -- Last reason: end of file reached\r\n            lx:peek().tag==\"Eof\"\r\n      end\r\n\r\n      local lli = lx:lineinfo_left()\r\n      \r\n      -- Apply the builder. It can be a string, or a callable value, \r\n      -- or simply nothing.\r\n      local b = self.builder\r\n      if b then\r\n         if type(b)==\"string\" then x.tag = b -- b is a string, use it as a tag\r\n         elseif type(b)==\"function\" then x=b(x)\r\n         else\r\n            local bmt = getmetatable(b)\r\n            if bmt and bmt.__call then x=b(x) end\r\n         end\r\n      end\r\n      return transform (x, self, fli, lli)\r\n   end",
    "type": "function"
  }, {
    "id": 207,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 208,
    "text": "local function peek_is_in (keywords) \r\n         return keywords and lx:is_keyword(lx:peek(), unpack(keywords)) end",
    "type": "function"
  }, {
    "id": 209,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 210,
    "text": "function onkeyword (p)\r\n   make_parser (\"onkeyword\", p)\r\n\r\n   -------------------------------------------------------------------\r\n   -- Parsing method\r\n   -------------------------------------------------------------------\r\n   function p:parse(lx)\r\n      if lx:is_keyword (lx:peek(), unpack(self.keywords)) then\r\n         --local fli = lx:lineinfo_right()\r\n         if not self.peek then lx:next() end\r\n         local content = self.primary (lx)\r\n         --local lli = lx:lineinfo_left()\r\n         local fli, lli = content.lineinfo.first, content.lineinfo.last\r\n         return transform (content, p, fli, lli)\r\n      else return false end\r\n   end\r\n\r\n   -------------------------------------------------------------------\r\n   -- Construction\r\n   -------------------------------------------------------------------\r\n   if not p.keywords then p.keywords = { } end\r\n   for _, x in ipairs(p) do\r\n      if type(x)==\"string\" then table.insert (p.keywords, x)\r\n      else assert (not p.primary and is_parser (x)); p.primary = x end\r\n   end\r\n   if not next (p.keywords) then \r\n      eprintf(\"Warning, no keyword to trigger gg.onkeyword\") end\r\n   assert (p.primary, 'no primary parser in gg.onkeyword')\r\n   return p\r\nend",
    "type": "function"
  }, {
    "id": 211,
    "text": "make_parser (\"onkeyword\", p)",
    "type": "statement:functioncall"
  }, {
    "id": 212,
    "text": "function p:parse(lx)\r\n      if lx:is_keyword (lx:peek(), unpack(self.keywords)) then\r\n         --local fli = lx:lineinfo_right()\r\n         if not self.peek then lx:next() end\r\n         local content = self.primary (lx)\r\n         --local lli = lx:lineinfo_left()\r\n         local fli, lli = content.lineinfo.first, content.lineinfo.last\r\n         return transform (content, p, fli, lli)\r\n      else return false end\r\n   end",
    "type": "statement:globalfunction"
  }, {
    "id": 213,
    "text": "if lx:is_keyword (lx:peek(), unpack(self.keywords)) then\r\n         --local fli = lx:lineinfo_right()\r\n         if not self.peek then lx:next() end\r\n         local content = self.primary (lx)\r\n         --local lli = lx:lineinfo_left()\r\n         local fli, lli = content.lineinfo.first, content.lineinfo.last\r\n         return transform (content, p, fli, lli)\r\n      else return false end",
    "type": "statement:if"
  }, {
    "id": 214,
    "text": "if not self.peek then lx:next() end",
    "type": "statement:if"
  }, {
    "id": 215,
    "text": "lx:next()",
    "type": "statement:functioncall"
  }, {
    "id": 216,
    "text": "local content = self.primary (lx)",
    "type": "statement:localassign"
  }, {
    "id": 217,
    "text": "local fli, lli = content.lineinfo.first, content.lineinfo.last",
    "type": "statement:localassign"
  }, {
    "id": 218,
    "text": "if not p.keywords then p.keywords = { } end",
    "type": "statement:if"
  }, {
    "id": 219,
    "text": "p.keywords = { }",
    "type": "statement:assign"
  }, {
    "id": 220,
    "text": "for _, x in ipairs(p) do\r\n      if type(x)==\"string\" then table.insert (p.keywords, x)\r\n      else assert (not p.primary and is_parser (x)); p.primary = x end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 221,
    "text": "if type(x)==\"string\" then table.insert (p.keywords, x)\r\n      else assert (not p.primary and is_parser (x)); p.primary = x end",
    "type": "statement:if"
  }, {
    "id": 222,
    "text": "table.insert (p.keywords, x)",
    "type": "statement:functioncall"
  }, {
    "id": 223,
    "text": "assert (not p.primary and is_parser (x))",
    "type": "statement:functioncall"
  }, {
    "id": 224,
    "text": "p.primary = x",
    "type": "statement:assign"
  }, {
    "id": 225,
    "text": "if not next (p.keywords) then \r\n      eprintf(\"Warning, no keyword to trigger gg.onkeyword\") end",
    "type": "statement:if"
  }, {
    "id": 226,
    "text": "eprintf(\"Warning, no keyword to trigger gg.onkeyword\")",
    "type": "statement:functioncall"
  }, {
    "id": 227,
    "text": "assert (p.primary, 'no primary parser in gg.onkeyword')",
    "type": "statement:functioncall"
  }, {
    "id": 228,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 229,
    "text": "function p:parse(lx)\r\n      if lx:is_keyword (lx:peek(), unpack(self.keywords)) then\r\n         --local fli = lx:lineinfo_right()\r\n         if not self.peek then lx:next() end\r\n         local content = self.primary (lx)\r\n         --local lli = lx:lineinfo_left()\r\n         local fli, lli = content.lineinfo.first, content.lineinfo.last\r\n         return transform (content, p, fli, lli)\r\n      else return false end\r\n   end",
    "type": "function"
  }, {
    "id": 230,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 231,
    "text": "function optkeyword (...)\r\n   local args = {...}\r\n   if type (args[1]) == \"table\" then \r\n      assert (#args == 1)\r\n      args = args[1]\r\n   end\r\n   for _, v in ipairs(args) do assert (type(v)==\"string\") end\r\n   return function (lx)\r\n      local x = lx:is_keyword (lx:peek(), unpack (args))\r\n      if x then lx:next(); return x\r\n      else return false end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 232,
    "text": "local args = {...}",
    "type": "statement:localassign"
  }, {
    "id": 233,
    "text": "if type (args[1]) == \"table\" then \r\n      assert (#args == 1)\r\n      args = args[1]\r\n   end",
    "type": "statement:if"
  }, {
    "id": 234,
    "text": "assert (#args == 1)",
    "type": "statement:functioncall"
  }, {
    "id": 235,
    "text": "args = args[1]",
    "type": "statement:assign"
  }, {
    "id": 236,
    "text": "for _, v in ipairs(args) do assert (type(v)==\"string\") end",
    "type": "statement:genericfor"
  }, {
    "id": 237,
    "text": "assert (type(v)==\"string\")",
    "type": "statement:functioncall"
  }, {
    "id": 238,
    "text": "local x = lx:is_keyword (lx:peek(), unpack (args))",
    "type": "statement:localassign"
  }, {
    "id": 239,
    "text": "if x then lx:next(); return x\r\n      else return false end",
    "type": "statement:if"
  }, {
    "id": 240,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 241,
    "text": "function with_lexer(new_lexer, parser)\r\n\r\n   -------------------------------------------------------------------\r\n   -- Most gg functions take their parameters in a table, so it's \r\n   -- better to silently accept when with_lexer{ } is called with\r\n   -- its arguments in a list:\r\n   -------------------------------------------------------------------\r\n   if not parser and #new_lexer==2 and type(new_lexer[1])=='table' then\r\n      return with_lexer(unpack(new_lexer))\r\n   end\r\n\r\n   -------------------------------------------------------------------\r\n   -- Save the current lexer, switch it for the new one, run the parser,\r\n   -- restore the previous lexer, even if the parser caused an error.\r\n   -------------------------------------------------------------------\r\n   return function (lx)\r\n      local old_lexer = getmetatable(lx)\r\n      lx:sync()\r\n      setmetatable(lx, new_lexer)\r\n      local status, result = pcall(parser, lx)\r\n      lx:sync()\r\n      setmetatable(lx, old_lexer)\r\n      if status then return result else error(result) end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 242,
    "text": "if not parser and #new_lexer==2 and type(new_lexer[1])=='table' then\r\n      return with_lexer(unpack(new_lexer))\r\n   end",
    "type": "statement:if"
  }, {
    "id": 243,
    "text": "local old_lexer = getmetatable(lx)",
    "type": "statement:localassign"
  }, {
    "id": 244,
    "text": "lx:sync()",
    "type": "statement:functioncall"
  }, {
    "id": 245,
    "text": "setmetatable(lx, new_lexer)",
    "type": "statement:functioncall"
  }, {
    "id": 246,
    "text": "local status, result = pcall(parser, lx)",
    "type": "statement:localassign"
  }, {
    "id": 247,
    "text": "setmetatable(lx, old_lexer)",
    "type": "statement:functioncall"
  }, {
    "id": 248,
    "text": "if status then return result else error(result) end",
    "type": "statement:if"
  }, {
    "id": 249,
    "text": "error(result)",
    "type": "statement:functioncall"
  }, {
    "id": 250,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 251,
    "text": "function (lx)\r\n      local x = lx:is_keyword (lx:peek(), unpack (args))\r\n      if x then lx:next(); return x\r\n      else return false end\r\n   end",
    "type": "function"
  }, {
    "id": 252,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 253,
    "text": "function (lx)\r\n      local old_lexer = getmetatable(lx)\r\n      lx:sync()\r\n      setmetatable(lx, new_lexer)\r\n      local status, result = pcall(parser, lx)\r\n      lx:sync()\r\n      setmetatable(lx, old_lexer)\r\n      if status then return result else error(result) end\r\n   end",
    "type": "function"
  }, {
    "id": 254,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 255,
    "text": "",
    "type": "function container"
  }, {
    "id": 256,
    "text": "builder",
    "type": "global function"
  }, {
    "id": 257,
    "text": "onkeyword",
    "type": "global function"
  }, {
    "id": 258,
    "text": "ipairs",
    "type": "global function"
  }, {
    "id": 259,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 260,
    "text": "pcall",
    "type": "global function"
  }, {
    "id": 261,
    "text": "primary",
    "type": "global function"
  }, {
    "id": 262,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 263,
    "text": "type",
    "type": "global function"
  }, {
    "id": 264,
    "text": "e",
    "type": "global function"
  }, {
    "id": 265,
    "text": "parse_error",
    "type": "global function"
  }, {
    "id": 266,
    "text": "unpack",
    "type": "global function"
  }, {
    "id": 267,
    "text": "eprintf",
    "type": "global function"
  }, {
    "id": 268,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 269,
    "text": "builder",
    "type": "global function"
  }, {
    "id": 270,
    "text": "seq_parser",
    "type": "global function"
  }, {
    "id": 271,
    "text": "list",
    "type": "global function"
  }, {
    "id": 272,
    "text": "next",
    "type": "global function"
  }, {
    "id": 273,
    "text": "t",
    "type": "global function"
  }, {
    "id": 274,
    "text": "format",
    "type": "global function"
  }, {
    "id": 275,
    "text": "b",
    "type": "global function"
  }, {
    "id": 276,
    "text": "default",
    "type": "global function"
  }, {
    "id": 277,
    "text": "getmetatable",
    "type": "global function"
  }, {
    "id": 278,
    "text": "p2_func",
    "type": "global function"
  }, {
    "id": 279,
    "text": "error",
    "type": "global function"
  }, {
    "id": 280,
    "text": "expr",
    "type": "global function"
  }, {
    "id": 281,
    "text": "sequence",
    "type": "global function"
  }, {
    "id": 282,
    "text": "builder",
    "type": "global function"
  }, {
    "id": 283,
    "text": "multisequence",
    "type": "global function"
  }, {
    "id": 284,
    "text": "rep",
    "type": "global function"
  }, {
    "id": 285,
    "text": "setmetatable",
    "type": "global function"
  }, {
    "id": 286,
    "text": "module",
    "type": "global function"
  }, {
    "id": 287,
    "text": "",
    "type": "variable container"
  }, {
    "id": 288,
    "text": "",
    "type": "require container"
  }, {
    "id": 289,
    "text": "",
    "type": "local variable"
  }, {
    "id": 290,
    "text": "",
    "type": "tableconstructor"
  } ]
}