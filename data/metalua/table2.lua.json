{
  "_filename": "table2.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/metalua/src/lib/metalua/table2.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "has",
    "to": 3
  }, {
    "from": 2,
    "label": "has",
    "to": 4
  }, {
    "from": 4,
    "label": "has",
    "to": 5
  }, {
    "from": 2,
    "label": "has",
    "to": 6
  }, {
    "from": 2,
    "label": "has",
    "to": 7
  }, {
    "from": 8,
    "label": "has",
    "to": 9
  }, {
    "from": 8,
    "label": "has",
    "to": 10
  }, {
    "from": 10,
    "label": "has",
    "to": 11
  }, {
    "from": 10,
    "label": "has",
    "to": 12
  }, {
    "from": 10,
    "label": "has",
    "to": 13
  }, {
    "from": 13,
    "label": "has",
    "to": 14
  }, {
    "from": 13,
    "label": "has",
    "to": 15
  }, {
    "from": 10,
    "label": "has",
    "to": 16
  }, {
    "from": 10,
    "label": "has",
    "to": 17
  }, {
    "from": 17,
    "label": "has",
    "to": 18
  }, {
    "from": 17,
    "label": "has",
    "to": 19
  }, {
    "from": 17,
    "label": "has",
    "to": 20
  }, {
    "from": 10,
    "label": "has",
    "to": 21
  }, {
    "from": 10,
    "label": "has",
    "to": 22
  }, {
    "from": 22,
    "label": "has",
    "to": 23
  }, {
    "from": 23,
    "label": "has",
    "to": 24
  }, {
    "from": 23,
    "label": "has",
    "to": 25
  }, {
    "from": 10,
    "label": "has",
    "to": 26
  }, {
    "from": 26,
    "label": "has",
    "to": 27
  }, {
    "from": 27,
    "label": "has",
    "to": 28
  }, {
    "from": 26,
    "label": "has",
    "to": 29
  }, {
    "from": 26,
    "label": "has",
    "to": 15
  }, {
    "from": 8,
    "label": "has",
    "to": 6
  }, {
    "from": 8,
    "label": "has",
    "to": 6
  }, {
    "from": 8,
    "label": "has",
    "to": 30
  }, {
    "from": 31,
    "label": "has",
    "to": 32
  }, {
    "from": 31,
    "label": "has",
    "to": 33
  }, {
    "from": 33,
    "label": "has",
    "to": 34
  }, {
    "from": 33,
    "label": "has",
    "to": 35
  }, {
    "from": 31,
    "label": "has",
    "to": 36
  }, {
    "from": 31,
    "label": "has",
    "to": 6
  }, {
    "from": 31,
    "label": "has",
    "to": 37
  }, {
    "from": 38,
    "label": "has",
    "to": 34
  }, {
    "from": 38,
    "label": "has",
    "to": 35
  }, {
    "from": 39,
    "label": "has",
    "to": 40
  }, {
    "from": 40,
    "label": "has",
    "to": 41
  }, {
    "from": 39,
    "label": "has",
    "to": 42
  }, {
    "from": 39,
    "label": "has",
    "to": 6
  }, {
    "from": 39,
    "label": "has",
    "to": 43
  }, {
    "from": 44,
    "label": "has",
    "to": 41
  }, {
    "from": 45,
    "label": "has",
    "to": 46
  }, {
    "from": 46,
    "label": "has",
    "to": 6
  }, {
    "from": 45,
    "label": "has",
    "to": 6
  }, {
    "from": 45,
    "label": "has",
    "to": 47
  }, {
    "from": 48,
    "label": "has",
    "to": 6
  }, {
    "from": 49,
    "label": "has",
    "to": 50
  }, {
    "from": 49,
    "label": "has",
    "to": 51
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 49,
    "label": "has",
    "to": 6
  }, {
    "from": 49,
    "label": "has",
    "to": 53
  }, {
    "from": 54,
    "label": "has",
    "to": 55
  }, {
    "from": 54,
    "label": "has",
    "to": 56
  }, {
    "from": 56,
    "label": "has",
    "to": 57
  }, {
    "from": 57,
    "label": "has",
    "to": 58
  }, {
    "from": 54,
    "label": "has",
    "to": 6
  }, {
    "from": 54,
    "label": "has",
    "to": 59
  }, {
    "from": 60,
    "label": "has",
    "to": 6
  }, {
    "from": 61,
    "label": "has",
    "to": 62
  }, {
    "from": 61,
    "label": "has",
    "to": 63
  }, {
    "from": 63,
    "label": "has",
    "to": 64
  }, {
    "from": 61,
    "label": "has",
    "to": 6
  }, {
    "from": 61,
    "label": "has",
    "to": 65
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 66,
    "label": "has",
    "to": 68
  }, {
    "from": 66,
    "label": "has",
    "to": 69
  }, {
    "from": 69,
    "label": "has",
    "to": 70
  }, {
    "from": 69,
    "label": "has",
    "to": 71
  }, {
    "from": 71,
    "label": "has",
    "to": 72
  }, {
    "from": 66,
    "label": "has",
    "to": 6
  }, {
    "from": 66,
    "label": "has",
    "to": 73
  }, {
    "from": 74,
    "label": "has",
    "to": 75
  }, {
    "from": 74,
    "label": "has",
    "to": 76
  }, {
    "from": 76,
    "label": "has",
    "to": 6
  }, {
    "from": 74,
    "label": "has",
    "to": 6
  }, {
    "from": 74,
    "label": "has",
    "to": 77
  }, {
    "from": 78,
    "label": "has",
    "to": 6
  }, {
    "from": 79,
    "label": "has",
    "to": 76
  }, {
    "from": 76,
    "label": "has",
    "to": 6
  }, {
    "from": 79,
    "label": "has",
    "to": 6
  }, {
    "from": 79,
    "label": "has",
    "to": 80
  }, {
    "from": 81,
    "label": "has",
    "to": 6
  }, {
    "from": 82,
    "label": "has",
    "to": 83
  }, {
    "from": 82,
    "label": "has",
    "to": 84
  }, {
    "from": 84,
    "label": "has",
    "to": 85
  }, {
    "from": 82,
    "label": "has",
    "to": 6
  }, {
    "from": 82,
    "label": "has",
    "to": 86
  }, {
    "from": 87,
    "label": "has",
    "to": 83
  }, {
    "from": 87,
    "label": "has",
    "to": 88
  }, {
    "from": 88,
    "label": "has",
    "to": 89
  }, {
    "from": 89,
    "label": "has",
    "to": 90
  }, {
    "from": 88,
    "label": "has",
    "to": 91
  }, {
    "from": 88,
    "label": "has",
    "to": 92
  }, {
    "from": 92,
    "label": "has",
    "to": 93
  }, {
    "from": 92,
    "label": "has",
    "to": 94
  }, {
    "from": 88,
    "label": "has",
    "to": 95
  }, {
    "from": 95,
    "label": "has",
    "to": 96
  }, {
    "from": 95,
    "label": "has",
    "to": 97
  }, {
    "from": 87,
    "label": "has",
    "to": 6
  }, {
    "from": 87,
    "label": "has",
    "to": 98
  }, {
    "from": 99,
    "label": "has",
    "to": 100
  }, {
    "from": 99,
    "label": "has",
    "to": 101
  }, {
    "from": 101,
    "label": "has",
    "to": 102
  }, {
    "from": 102,
    "label": "has",
    "to": 103
  }, {
    "from": 102,
    "label": "has",
    "to": 104
  }, {
    "from": 102,
    "label": "has",
    "to": 105
  }, {
    "from": 102,
    "label": "has",
    "to": 106
  }, {
    "from": 102,
    "label": "has",
    "to": 107
  }, {
    "from": 102,
    "label": "has",
    "to": 108
  }, {
    "from": 108,
    "label": "has",
    "to": 109
  }, {
    "from": 101,
    "label": "has",
    "to": 6
  }, {
    "from": 101,
    "label": "has",
    "to": 6
  }, {
    "from": 101,
    "label": "has",
    "to": 6
  }, {
    "from": 99,
    "label": "has",
    "to": 6
  }, {
    "from": 99,
    "label": "has",
    "to": 110
  }, {
    "from": 111,
    "label": "has",
    "to": 102
  }, {
    "from": 102,
    "label": "has",
    "to": 103
  }, {
    "from": 102,
    "label": "has",
    "to": 104
  }, {
    "from": 102,
    "label": "has",
    "to": 105
  }, {
    "from": 102,
    "label": "has",
    "to": 106
  }, {
    "from": 102,
    "label": "has",
    "to": 107
  }, {
    "from": 102,
    "label": "has",
    "to": 108
  }, {
    "from": 108,
    "label": "has",
    "to": 109
  }, {
    "from": 111,
    "label": "has",
    "to": 6
  }, {
    "from": 111,
    "label": "has",
    "to": 6
  }, {
    "from": 111,
    "label": "has",
    "to": 6
  }, {
    "from": 111,
    "label": "has",
    "to": 112
  }, {
    "from": 113,
    "label": "has",
    "to": 114
  }, {
    "from": 114,
    "label": "has",
    "to": 115
  }, {
    "from": 113,
    "label": "has",
    "to": 116
  }, {
    "from": 116,
    "label": "has",
    "to": 117
  }, {
    "from": 113,
    "label": "has",
    "to": 6
  }, {
    "from": 113,
    "label": "has",
    "to": 118
  }, {
    "from": 119,
    "label": "has",
    "to": 120
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 120,
    "label": "has",
    "to": 122
  }, {
    "from": 120,
    "label": "has",
    "to": 123
  }, {
    "from": 120,
    "label": "has",
    "to": 124
  }, {
    "from": 119,
    "label": "has",
    "to": 55
  }, {
    "from": 119,
    "label": "has",
    "to": 125
  }, {
    "from": 125,
    "label": "has",
    "to": 126
  }, {
    "from": 119,
    "label": "has",
    "to": 6
  }, {
    "from": 119,
    "label": "has",
    "to": 127
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 128,
    "label": "has",
    "to": 130
  }, {
    "from": 130,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 132,
    "label": "has",
    "to": 133
  }, {
    "from": 132,
    "label": "has",
    "to": 134
  }, {
    "from": 131,
    "label": "has",
    "to": 135
  }, {
    "from": 131,
    "label": "has",
    "to": 136
  }, {
    "from": 131,
    "label": "has",
    "to": 137
  }, {
    "from": 131,
    "label": "has",
    "to": 138
  }, {
    "from": 138,
    "label": "has",
    "to": 139
  }, {
    "from": 128,
    "label": "has",
    "to": 140
  }, {
    "from": 128,
    "label": "has",
    "to": 141
  }, {
    "from": 128,
    "label": "has",
    "to": 142
  }, {
    "from": 128,
    "label": "has",
    "to": 143
  }, {
    "from": 128,
    "label": "has",
    "to": 144
  }, {
    "from": 128,
    "label": "has",
    "to": 145
  }, {
    "from": 145,
    "label": "has",
    "to": 146
  }, {
    "from": 145,
    "label": "has",
    "to": 147
  }, {
    "from": 145,
    "label": "has",
    "to": 148
  }, {
    "from": 128,
    "label": "has",
    "to": 149
  }, {
    "from": 149,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "has",
    "to": 150
  }, {
    "from": 128,
    "label": "has",
    "to": 151
  }, {
    "from": 151,
    "label": "has",
    "to": 152
  }, {
    "from": 151,
    "label": "has",
    "to": 153
  }, {
    "from": 151,
    "label": "has",
    "to": 6
  }, {
    "from": 151,
    "label": "has",
    "to": 154
  }, {
    "from": 151,
    "label": "has",
    "to": 155
  }, {
    "from": 151,
    "label": "has",
    "to": 6
  }, {
    "from": 151,
    "label": "has",
    "to": 156
  }, {
    "from": 151,
    "label": "has",
    "to": 157
  }, {
    "from": 151,
    "label": "has",
    "to": 6
  }, {
    "from": 151,
    "label": "has",
    "to": 158
  }, {
    "from": 151,
    "label": "has",
    "to": 159
  }, {
    "from": 151,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "has",
    "to": 160
  }, {
    "from": 160,
    "label": "has",
    "to": 161
  }, {
    "from": 161,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "has",
    "to": 162
  }, {
    "from": 162,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "has",
    "to": 163
  }, {
    "from": 163,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "has",
    "to": 164
  }, {
    "from": 164,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "has",
    "to": 165
  }, {
    "from": 165,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "has",
    "to": 166
  }, {
    "from": 166,
    "label": "has",
    "to": 167
  }, {
    "from": 166,
    "label": "has",
    "to": 6
  }, {
    "from": 166,
    "label": "has",
    "to": 168
  }, {
    "from": 166,
    "label": "has",
    "to": 169
  }, {
    "from": 166,
    "label": "has",
    "to": 170
  }, {
    "from": 166,
    "label": "has",
    "to": 171
  }, {
    "from": 166,
    "label": "has",
    "to": 172
  }, {
    "from": 166,
    "label": "has",
    "to": 173
  }, {
    "from": 166,
    "label": "has",
    "to": 174
  }, {
    "from": 174,
    "label": "has",
    "to": 175
  }, {
    "from": 175,
    "label": "has",
    "to": 176
  }, {
    "from": 176,
    "label": "has",
    "to": 177
  }, {
    "from": 176,
    "label": "has",
    "to": 178
  }, {
    "from": 178,
    "label": "has",
    "to": 179
  }, {
    "from": 178,
    "label": "has",
    "to": 180
  }, {
    "from": 176,
    "label": "has",
    "to": 181
  }, {
    "from": 166,
    "label": "has",
    "to": 182
  }, {
    "from": 182,
    "label": "has",
    "to": 183
  }, {
    "from": 166,
    "label": "has",
    "to": 184
  }, {
    "from": 166,
    "label": "has",
    "to": 185
  }, {
    "from": 166,
    "label": "has",
    "to": 6
  }, {
    "from": 166,
    "label": "has",
    "to": 186
  }, {
    "from": 186,
    "label": "has",
    "to": 187
  }, {
    "from": 166,
    "label": "has",
    "to": 188
  }, {
    "from": 166,
    "label": "has",
    "to": 6
  }, {
    "from": 166,
    "label": "has",
    "to": 189
  }, {
    "from": 166,
    "label": "has",
    "to": 6
  }, {
    "from": 166,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "has",
    "to": 190
  }, {
    "from": 190,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 190,
    "label": "has",
    "to": 193
  }, {
    "from": 193,
    "label": "has",
    "to": 194
  }, {
    "from": 193,
    "label": "has",
    "to": 195
  }, {
    "from": 193,
    "label": "has",
    "to": 196
  }, {
    "from": 190,
    "label": "has",
    "to": 197
  }, {
    "from": 190,
    "label": "has",
    "to": 198
  }, {
    "from": 198,
    "label": "has",
    "to": 199
  }, {
    "from": 190,
    "label": "has",
    "to": 200
  }, {
    "from": 200,
    "label": "has",
    "to": 201
  }, {
    "from": 190,
    "label": "has",
    "to": 202
  }, {
    "from": 202,
    "label": "has",
    "to": 203
  }, {
    "from": 190,
    "label": "has",
    "to": 204
  }, {
    "from": 204,
    "label": "has",
    "to": 205
  }, {
    "from": 190,
    "label": "has",
    "to": 206
  }, {
    "from": 206,
    "label": "has",
    "to": 207
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 206,
    "label": "has",
    "to": 6
  }, {
    "from": 206,
    "label": "has",
    "to": 209
  }, {
    "from": 206,
    "label": "has",
    "to": 169
  }, {
    "from": 206,
    "label": "has",
    "to": 170
  }, {
    "from": 206,
    "label": "has",
    "to": 171
  }, {
    "from": 206,
    "label": "has",
    "to": 172
  }, {
    "from": 206,
    "label": "has",
    "to": 210
  }, {
    "from": 210,
    "label": "has",
    "to": 211
  }, {
    "from": 210,
    "label": "has",
    "to": 212
  }, {
    "from": 206,
    "label": "has",
    "to": 213
  }, {
    "from": 213,
    "label": "has",
    "to": 214
  }, {
    "from": 214,
    "label": "has",
    "to": 215
  }, {
    "from": 215,
    "label": "has",
    "to": 216
  }, {
    "from": 216,
    "label": "has",
    "to": 217
  }, {
    "from": 216,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 216,
    "label": "has",
    "to": 218
  }, {
    "from": 215,
    "label": "has",
    "to": 219
  }, {
    "from": 215,
    "label": "has",
    "to": 220
  }, {
    "from": 220,
    "label": "has",
    "to": 221
  }, {
    "from": 220,
    "label": "has",
    "to": 222
  }, {
    "from": 215,
    "label": "has",
    "to": 223
  }, {
    "from": 223,
    "label": "has",
    "to": 224
  }, {
    "from": 215,
    "label": "has",
    "to": 225
  }, {
    "from": 225,
    "label": "has",
    "to": 226
  }, {
    "from": 225,
    "label": "has",
    "to": 227
  }, {
    "from": 225,
    "label": "has",
    "to": 228
  }, {
    "from": 225,
    "label": "has",
    "to": 229
  }, {
    "from": 225,
    "label": "has",
    "to": 230
  }, {
    "from": 215,
    "label": "has",
    "to": 231
  }, {
    "from": 215,
    "label": "has",
    "to": 177
  }, {
    "from": 206,
    "label": "has",
    "to": 232
  }, {
    "from": 232,
    "label": "has",
    "to": 233
  }, {
    "from": 232,
    "label": "has",
    "to": 234
  }, {
    "from": 232,
    "label": "has",
    "to": 235
  }, {
    "from": 232,
    "label": "has",
    "to": 236
  }, {
    "from": 236,
    "label": "has",
    "to": 218
  }, {
    "from": 236,
    "label": "has",
    "to": 237
  }, {
    "from": 236,
    "label": "has",
    "to": 238
  }, {
    "from": 236,
    "label": "has",
    "to": 239
  }, {
    "from": 236,
    "label": "has",
    "to": 217
  }, {
    "from": 236,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 232,
    "label": "has",
    "to": 240
  }, {
    "from": 240,
    "label": "has",
    "to": 238
  }, {
    "from": 240,
    "label": "has",
    "to": 241
  }, {
    "from": 241,
    "label": "has",
    "to": 218
  }, {
    "from": 241,
    "label": "has",
    "to": 242
  }, {
    "from": 242,
    "label": "has",
    "to": 224
  }, {
    "from": 241,
    "label": "has",
    "to": 243
  }, {
    "from": 232,
    "label": "has",
    "to": 244
  }, {
    "from": 244,
    "label": "has",
    "to": 245
  }, {
    "from": 206,
    "label": "has",
    "to": 184
  }, {
    "from": 190,
    "label": "has",
    "to": 246
  }, {
    "from": 190,
    "label": "has",
    "to": 247
  }, {
    "from": 247,
    "label": "has",
    "to": 248
  }, {
    "from": 247,
    "label": "has",
    "to": 208
  }, {
    "from": 128,
    "label": "has",
    "to": 249
  }, {
    "from": 128,
    "label": "has",
    "to": 250
  }, {
    "from": 128,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "has",
    "to": 251
  }, {
    "from": 252,
    "label": "has",
    "to": 146
  }, {
    "from": 252,
    "label": "has",
    "to": 147
  }, {
    "from": 252,
    "label": "has",
    "to": 148
  }, {
    "from": 252,
    "label": "has",
    "to": 253
  }, {
    "from": 254,
    "label": "has",
    "to": 6
  }, {
    "from": 254,
    "label": "has",
    "to": 255
  }, {
    "from": 256,
    "label": "has",
    "to": 152
  }, {
    "from": 256,
    "label": "has",
    "to": 153
  }, {
    "from": 256,
    "label": "has",
    "to": 6
  }, {
    "from": 256,
    "label": "has",
    "to": 154
  }, {
    "from": 256,
    "label": "has",
    "to": 155
  }, {
    "from": 256,
    "label": "has",
    "to": 6
  }, {
    "from": 256,
    "label": "has",
    "to": 156
  }, {
    "from": 256,
    "label": "has",
    "to": 157
  }, {
    "from": 256,
    "label": "has",
    "to": 6
  }, {
    "from": 256,
    "label": "has",
    "to": 158
  }, {
    "from": 256,
    "label": "has",
    "to": 159
  }, {
    "from": 256,
    "label": "has",
    "to": 6
  }, {
    "from": 256,
    "label": "has",
    "to": 257
  }, {
    "from": 258,
    "label": "has",
    "to": 6
  }, {
    "from": 259,
    "label": "has",
    "to": 6
  }, {
    "from": 260,
    "label": "has",
    "to": 6
  }, {
    "from": 261,
    "label": "has",
    "to": 6
  }, {
    "from": 262,
    "label": "has",
    "to": 6
  }, {
    "from": 263,
    "label": "has",
    "to": 167
  }, {
    "from": 263,
    "label": "has",
    "to": 6
  }, {
    "from": 263,
    "label": "has",
    "to": 168
  }, {
    "from": 263,
    "label": "has",
    "to": 169
  }, {
    "from": 263,
    "label": "has",
    "to": 170
  }, {
    "from": 263,
    "label": "has",
    "to": 171
  }, {
    "from": 263,
    "label": "has",
    "to": 172
  }, {
    "from": 263,
    "label": "has",
    "to": 173
  }, {
    "from": 263,
    "label": "has",
    "to": 174
  }, {
    "from": 174,
    "label": "has",
    "to": 175
  }, {
    "from": 175,
    "label": "has",
    "to": 176
  }, {
    "from": 176,
    "label": "has",
    "to": 177
  }, {
    "from": 176,
    "label": "has",
    "to": 178
  }, {
    "from": 178,
    "label": "has",
    "to": 179
  }, {
    "from": 178,
    "label": "has",
    "to": 180
  }, {
    "from": 176,
    "label": "has",
    "to": 181
  }, {
    "from": 263,
    "label": "has",
    "to": 182
  }, {
    "from": 182,
    "label": "has",
    "to": 183
  }, {
    "from": 263,
    "label": "has",
    "to": 184
  }, {
    "from": 263,
    "label": "has",
    "to": 185
  }, {
    "from": 263,
    "label": "has",
    "to": 6
  }, {
    "from": 263,
    "label": "has",
    "to": 186
  }, {
    "from": 186,
    "label": "has",
    "to": 187
  }, {
    "from": 263,
    "label": "has",
    "to": 188
  }, {
    "from": 263,
    "label": "has",
    "to": 6
  }, {
    "from": 263,
    "label": "has",
    "to": 189
  }, {
    "from": 263,
    "label": "has",
    "to": 6
  }, {
    "from": 263,
    "label": "has",
    "to": 6
  }, {
    "from": 263,
    "label": "has",
    "to": 264
  }, {
    "from": 265,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 265,
    "label": "has",
    "to": 193
  }, {
    "from": 193,
    "label": "has",
    "to": 194
  }, {
    "from": 193,
    "label": "has",
    "to": 195
  }, {
    "from": 193,
    "label": "has",
    "to": 196
  }, {
    "from": 265,
    "label": "has",
    "to": 197
  }, {
    "from": 265,
    "label": "has",
    "to": 198
  }, {
    "from": 198,
    "label": "has",
    "to": 199
  }, {
    "from": 265,
    "label": "has",
    "to": 200
  }, {
    "from": 200,
    "label": "has",
    "to": 201
  }, {
    "from": 265,
    "label": "has",
    "to": 202
  }, {
    "from": 202,
    "label": "has",
    "to": 203
  }, {
    "from": 265,
    "label": "has",
    "to": 204
  }, {
    "from": 204,
    "label": "has",
    "to": 205
  }, {
    "from": 265,
    "label": "has",
    "to": 206
  }, {
    "from": 206,
    "label": "has",
    "to": 207
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 206,
    "label": "has",
    "to": 6
  }, {
    "from": 206,
    "label": "has",
    "to": 209
  }, {
    "from": 206,
    "label": "has",
    "to": 169
  }, {
    "from": 206,
    "label": "has",
    "to": 170
  }, {
    "from": 206,
    "label": "has",
    "to": 171
  }, {
    "from": 206,
    "label": "has",
    "to": 172
  }, {
    "from": 206,
    "label": "has",
    "to": 210
  }, {
    "from": 210,
    "label": "has",
    "to": 211
  }, {
    "from": 210,
    "label": "has",
    "to": 212
  }, {
    "from": 206,
    "label": "has",
    "to": 213
  }, {
    "from": 213,
    "label": "has",
    "to": 214
  }, {
    "from": 214,
    "label": "has",
    "to": 215
  }, {
    "from": 215,
    "label": "has",
    "to": 216
  }, {
    "from": 216,
    "label": "has",
    "to": 217
  }, {
    "from": 216,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 216,
    "label": "has",
    "to": 218
  }, {
    "from": 215,
    "label": "has",
    "to": 219
  }, {
    "from": 215,
    "label": "has",
    "to": 220
  }, {
    "from": 220,
    "label": "has",
    "to": 221
  }, {
    "from": 220,
    "label": "has",
    "to": 222
  }, {
    "from": 215,
    "label": "has",
    "to": 223
  }, {
    "from": 223,
    "label": "has",
    "to": 224
  }, {
    "from": 215,
    "label": "has",
    "to": 225
  }, {
    "from": 225,
    "label": "has",
    "to": 226
  }, {
    "from": 225,
    "label": "has",
    "to": 227
  }, {
    "from": 225,
    "label": "has",
    "to": 228
  }, {
    "from": 225,
    "label": "has",
    "to": 229
  }, {
    "from": 225,
    "label": "has",
    "to": 230
  }, {
    "from": 215,
    "label": "has",
    "to": 231
  }, {
    "from": 215,
    "label": "has",
    "to": 177
  }, {
    "from": 206,
    "label": "has",
    "to": 232
  }, {
    "from": 232,
    "label": "has",
    "to": 233
  }, {
    "from": 232,
    "label": "has",
    "to": 234
  }, {
    "from": 232,
    "label": "has",
    "to": 235
  }, {
    "from": 232,
    "label": "has",
    "to": 236
  }, {
    "from": 236,
    "label": "has",
    "to": 218
  }, {
    "from": 236,
    "label": "has",
    "to": 237
  }, {
    "from": 236,
    "label": "has",
    "to": 238
  }, {
    "from": 236,
    "label": "has",
    "to": 239
  }, {
    "from": 236,
    "label": "has",
    "to": 217
  }, {
    "from": 236,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 232,
    "label": "has",
    "to": 240
  }, {
    "from": 240,
    "label": "has",
    "to": 238
  }, {
    "from": 240,
    "label": "has",
    "to": 241
  }, {
    "from": 241,
    "label": "has",
    "to": 218
  }, {
    "from": 241,
    "label": "has",
    "to": 242
  }, {
    "from": 242,
    "label": "has",
    "to": 224
  }, {
    "from": 241,
    "label": "has",
    "to": 243
  }, {
    "from": 232,
    "label": "has",
    "to": 244
  }, {
    "from": 244,
    "label": "has",
    "to": 245
  }, {
    "from": 206,
    "label": "has",
    "to": 184
  }, {
    "from": 265,
    "label": "has",
    "to": 246
  }, {
    "from": 265,
    "label": "has",
    "to": 247
  }, {
    "from": 247,
    "label": "has",
    "to": 248
  }, {
    "from": 247,
    "label": "has",
    "to": 208
  }, {
    "from": 265,
    "label": "has",
    "to": 266
  }, {
    "from": 267,
    "label": "has",
    "to": 194
  }, {
    "from": 267,
    "label": "has",
    "to": 195
  }, {
    "from": 267,
    "label": "has",
    "to": 196
  }, {
    "from": 267,
    "label": "has",
    "to": 268
  }, {
    "from": 269,
    "label": "has",
    "to": 199
  }, {
    "from": 270,
    "label": "has",
    "to": 201
  }, {
    "from": 271,
    "label": "has",
    "to": 203
  }, {
    "from": 272,
    "label": "has",
    "to": 205
  }, {
    "from": 273,
    "label": "has",
    "to": 207
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 273,
    "label": "has",
    "to": 6
  }, {
    "from": 273,
    "label": "has",
    "to": 209
  }, {
    "from": 273,
    "label": "has",
    "to": 169
  }, {
    "from": 273,
    "label": "has",
    "to": 170
  }, {
    "from": 273,
    "label": "has",
    "to": 171
  }, {
    "from": 273,
    "label": "has",
    "to": 172
  }, {
    "from": 273,
    "label": "has",
    "to": 210
  }, {
    "from": 210,
    "label": "has",
    "to": 211
  }, {
    "from": 210,
    "label": "has",
    "to": 212
  }, {
    "from": 273,
    "label": "has",
    "to": 213
  }, {
    "from": 213,
    "label": "has",
    "to": 214
  }, {
    "from": 214,
    "label": "has",
    "to": 215
  }, {
    "from": 215,
    "label": "has",
    "to": 216
  }, {
    "from": 216,
    "label": "has",
    "to": 217
  }, {
    "from": 216,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 216,
    "label": "has",
    "to": 218
  }, {
    "from": 215,
    "label": "has",
    "to": 219
  }, {
    "from": 215,
    "label": "has",
    "to": 220
  }, {
    "from": 220,
    "label": "has",
    "to": 221
  }, {
    "from": 220,
    "label": "has",
    "to": 222
  }, {
    "from": 215,
    "label": "has",
    "to": 223
  }, {
    "from": 223,
    "label": "has",
    "to": 224
  }, {
    "from": 215,
    "label": "has",
    "to": 225
  }, {
    "from": 225,
    "label": "has",
    "to": 226
  }, {
    "from": 225,
    "label": "has",
    "to": 227
  }, {
    "from": 225,
    "label": "has",
    "to": 228
  }, {
    "from": 225,
    "label": "has",
    "to": 229
  }, {
    "from": 225,
    "label": "has",
    "to": 230
  }, {
    "from": 215,
    "label": "has",
    "to": 231
  }, {
    "from": 215,
    "label": "has",
    "to": 177
  }, {
    "from": 273,
    "label": "has",
    "to": 232
  }, {
    "from": 232,
    "label": "has",
    "to": 233
  }, {
    "from": 232,
    "label": "has",
    "to": 234
  }, {
    "from": 232,
    "label": "has",
    "to": 235
  }, {
    "from": 232,
    "label": "has",
    "to": 236
  }, {
    "from": 236,
    "label": "has",
    "to": 218
  }, {
    "from": 236,
    "label": "has",
    "to": 237
  }, {
    "from": 236,
    "label": "has",
    "to": 238
  }, {
    "from": 236,
    "label": "has",
    "to": 239
  }, {
    "from": 236,
    "label": "has",
    "to": 217
  }, {
    "from": 236,
    "label": "has",
    "to": 191
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 232,
    "label": "has",
    "to": 240
  }, {
    "from": 240,
    "label": "has",
    "to": 238
  }, {
    "from": 240,
    "label": "has",
    "to": 241
  }, {
    "from": 241,
    "label": "has",
    "to": 218
  }, {
    "from": 241,
    "label": "has",
    "to": 242
  }, {
    "from": 242,
    "label": "has",
    "to": 224
  }, {
    "from": 241,
    "label": "has",
    "to": 243
  }, {
    "from": 232,
    "label": "has",
    "to": 244
  }, {
    "from": 244,
    "label": "has",
    "to": 245
  }, {
    "from": 273,
    "label": "has",
    "to": 184
  }, {
    "from": 273,
    "label": "has",
    "to": 274
  }, {
    "from": 275,
    "label": "has",
    "to": 6
  }, {
    "from": 128,
    "label": "calls",
    "to": 290
  }, {
    "from": 265,
    "label": "calls",
    "to": 290
  }, {
    "from": 60,
    "label": "calls",
    "to": 54
  }, {
    "from": 8,
    "label": "calls",
    "to": 286
  }, {
    "from": 8,
    "label": "calls",
    "to": 286
  }, {
    "from": 8,
    "label": "calls",
    "to": 286
  }, {
    "from": 119,
    "label": "calls",
    "to": 286
  }, {
    "from": 265,
    "label": "calls",
    "to": 286
  }, {
    "from": 256,
    "label": "calls",
    "to": 277
  }, {
    "from": 128,
    "label": "calls",
    "to": 277
  }, {
    "from": 128,
    "label": "calls",
    "to": 277
  }, {
    "from": 265,
    "label": "calls",
    "to": 277
  }, {
    "from": 265,
    "label": "calls",
    "to": 277
  }, {
    "from": 265,
    "label": "calls",
    "to": 277
  }, {
    "from": 128,
    "label": "calls",
    "to": 287
  }, {
    "from": 79,
    "label": "calls",
    "to": 74
  }, {
    "from": 66,
    "label": "calls",
    "to": 297
  }, {
    "from": 265,
    "label": "calls",
    "to": 267
  }, {
    "from": 265,
    "label": "calls",
    "to": 267
  }, {
    "from": 54,
    "label": "calls",
    "to": 293
  }, {
    "from": 54,
    "label": "calls",
    "to": 293
  }, {
    "from": 87,
    "label": "calls",
    "to": 293
  }, {
    "from": 87,
    "label": "calls",
    "to": 278
  }, {
    "from": 128,
    "label": "calls",
    "to": 278
  }, {
    "from": 275,
    "label": "calls",
    "to": 279
  }, {
    "from": 275,
    "label": "calls",
    "to": 128
  }, {
    "from": 45,
    "label": "calls",
    "to": 31
  }, {
    "from": 128,
    "label": "calls",
    "to": 280
  }, {
    "from": 265,
    "label": "calls",
    "to": 280
  }, {
    "from": 8,
    "label": "calls",
    "to": 294
  }, {
    "from": 8,
    "label": "calls",
    "to": 294
  }, {
    "from": 38,
    "label": "calls",
    "to": 294
  }, {
    "from": 38,
    "label": "calls",
    "to": 294
  }, {
    "from": 49,
    "label": "calls",
    "to": 294
  }, {
    "from": 38,
    "label": "calls",
    "to": 294
  }, {
    "from": 38,
    "label": "calls",
    "to": 294
  }, {
    "from": 256,
    "label": "calls",
    "to": 294
  }, {
    "from": 2,
    "label": "calls",
    "to": 295
  }, {
    "from": 82,
    "label": "calls",
    "to": 295
  }, {
    "from": 111,
    "label": "calls",
    "to": 295
  }, {
    "from": 113,
    "label": "calls",
    "to": 295
  }, {
    "from": 128,
    "label": "calls",
    "to": 295
  }, {
    "from": 265,
    "label": "calls",
    "to": 295
  }, {
    "from": 265,
    "label": "calls",
    "to": 265
  }, {
    "from": 265,
    "label": "calls",
    "to": 265
  }, {
    "from": 265,
    "label": "calls",
    "to": 265
  }, {
    "from": 265,
    "label": "calls",
    "to": 265
  }, {
    "from": 265,
    "label": "calls",
    "to": 265
  }, {
    "from": 128,
    "label": "calls",
    "to": 265
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 265,
    "label": "calls",
    "to": 252
  }, {
    "from": 31,
    "label": "calls",
    "to": 8
  }, {
    "from": 39,
    "label": "calls",
    "to": 8
  }, {
    "from": 74,
    "label": "calls",
    "to": 8
  }, {
    "from": 111,
    "label": "calls",
    "to": 111
  }, {
    "from": 111,
    "label": "calls",
    "to": 111
  }, {
    "from": 99,
    "label": "calls",
    "to": 111
  }, {
    "from": 8,
    "label": "calls",
    "to": 296
  }, {
    "from": 128,
    "label": "calls",
    "to": 254
  }, {
    "from": 128,
    "label": "calls",
    "to": 254
  }, {
    "from": 265,
    "label": "calls",
    "to": 254
  }, {
    "from": 265,
    "label": "calls",
    "to": 254
  }, {
    "from": 49,
    "label": "calls",
    "to": 281
  }, {
    "from": 54,
    "label": "calls",
    "to": 281
  }, {
    "from": 87,
    "label": "calls",
    "to": 281
  }, {
    "from": 119,
    "label": "calls",
    "to": 281
  }, {
    "from": 252,
    "label": "calls",
    "to": 281
  }, {
    "from": 265,
    "label": "calls",
    "to": 298
  }, {
    "from": 265,
    "label": "calls",
    "to": 288
  }, {
    "from": 128,
    "label": "calls",
    "to": 256
  }, {
    "from": 128,
    "label": "calls",
    "to": 256
  }, {
    "from": 128,
    "label": "calls",
    "to": 256
  }, {
    "from": 265,
    "label": "calls",
    "to": 256
  }, {
    "from": 265,
    "label": "calls",
    "to": 256
  }, {
    "from": 265,
    "label": "calls",
    "to": 256
  }, {
    "from": 265,
    "label": "calls",
    "to": 256
  }, {
    "from": 87,
    "label": "calls",
    "to": 289
  }, {
    "from": 87,
    "label": "calls",
    "to": 289
  }, {
    "from": 87,
    "label": "calls",
    "to": 289
  }, {
    "from": 111,
    "label": "calls",
    "to": 299
  }, {
    "from": 8,
    "label": "calls",
    "to": 284
  }, {
    "from": 66,
    "label": "calls",
    "to": 284
  }, {
    "from": 8,
    "label": "calls",
    "to": 285
  }, {
    "from": 60,
    "label": "calls",
    "to": 285
  }, {
    "from": 8,
    "label": "calls",
    "to": 282
  }, {
    "from": 8,
    "label": "calls",
    "to": 282
  }, {
    "from": 8,
    "label": "calls",
    "to": 282
  }, {
    "from": 8,
    "label": "calls",
    "to": 282
  }, {
    "from": 111,
    "label": "calls",
    "to": 282
  }, {
    "from": 128,
    "label": "calls",
    "to": 282
  }, {
    "from": 254,
    "label": "calls",
    "to": 282
  }, {
    "from": 256,
    "label": "calls",
    "to": 282
  }, {
    "from": 128,
    "label": "calls",
    "to": 282
  }, {
    "from": 128,
    "label": "calls",
    "to": 282
  }, {
    "from": 265,
    "label": "calls",
    "to": 282
  }, {
    "from": 265,
    "label": "calls",
    "to": 282
  }, {
    "from": 265,
    "label": "calls",
    "to": 282
  }, {
    "from": 111,
    "label": "calls",
    "to": 292
  }, {
    "from": 128,
    "label": "calls",
    "to": 291
  }, {
    "from": 254,
    "label": "calls",
    "to": 291
  }, {
    "from": 252,
    "label": "calls",
    "to": 283
  }, {
    "from": 128,
    "label": "calls",
    "to": 283
  }, {
    "from": 1,
    "label": "contains",
    "to": 276
  }, {
    "from": 276,
    "label": "declares",
    "to": 2
  }, {
    "from": 276,
    "label": "declares",
    "to": 8
  }, {
    "from": 276,
    "label": "declares",
    "to": 31
  }, {
    "from": 276,
    "label": "declares",
    "to": 38
  }, {
    "from": 276,
    "label": "declares",
    "to": 39
  }, {
    "from": 276,
    "label": "declares",
    "to": 44
  }, {
    "from": 276,
    "label": "declares",
    "to": 45
  }, {
    "from": 276,
    "label": "declares",
    "to": 48
  }, {
    "from": 276,
    "label": "declares",
    "to": 49
  }, {
    "from": 276,
    "label": "declares",
    "to": 54
  }, {
    "from": 276,
    "label": "declares",
    "to": 60
  }, {
    "from": 276,
    "label": "declares",
    "to": 61
  }, {
    "from": 276,
    "label": "declares",
    "to": 66
  }, {
    "from": 276,
    "label": "declares",
    "to": 74
  }, {
    "from": 276,
    "label": "declares",
    "to": 78
  }, {
    "from": 276,
    "label": "declares",
    "to": 79
  }, {
    "from": 276,
    "label": "declares",
    "to": 81
  }, {
    "from": 276,
    "label": "declares",
    "to": 82
  }, {
    "from": 276,
    "label": "declares",
    "to": 87
  }, {
    "from": 276,
    "label": "declares",
    "to": 99
  }, {
    "from": 276,
    "label": "declares",
    "to": 111
  }, {
    "from": 276,
    "label": "declares",
    "to": 113
  }, {
    "from": 276,
    "label": "declares",
    "to": 119
  }, {
    "from": 276,
    "label": "declares",
    "to": 128
  }, {
    "from": 276,
    "label": "declares",
    "to": 252
  }, {
    "from": 276,
    "label": "declares",
    "to": 254
  }, {
    "from": 276,
    "label": "declares",
    "to": 256
  }, {
    "from": 276,
    "label": "declares",
    "to": 258
  }, {
    "from": 276,
    "label": "declares",
    "to": 259
  }, {
    "from": 276,
    "label": "declares",
    "to": 260
  }, {
    "from": 276,
    "label": "declares",
    "to": 261
  }, {
    "from": 276,
    "label": "declares",
    "to": 262
  }, {
    "from": 276,
    "label": "declares",
    "to": 263
  }, {
    "from": 276,
    "label": "declares",
    "to": 265
  }, {
    "from": 276,
    "label": "declares",
    "to": 267
  }, {
    "from": 276,
    "label": "declares",
    "to": 269
  }, {
    "from": 276,
    "label": "declares",
    "to": 270
  }, {
    "from": 276,
    "label": "declares",
    "to": 271
  }, {
    "from": 276,
    "label": "declares",
    "to": 272
  }, {
    "from": 276,
    "label": "declares",
    "to": 273
  }, {
    "from": 276,
    "label": "declares",
    "to": 275
  }, {
    "from": 300,
    "label": "requires",
    "to": 1
  }, {
    "from": 1,
    "label": "contains",
    "to": 302
  }, {
    "from": 1,
    "label": "contains",
    "to": 303
  }, {
    "from": 1,
    "label": "provides",
    "to": 304
  }, {
    "from": 301,
    "label": "represents",
    "to": 305
  }, {
    "from": 304,
    "label": "provides",
    "to": 305
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "table2",
    "type": "module"
  }, {
    "id": 2,
    "text": "function table.transpose(t)\r\n   local tt = { }\r\n   for a, b in pairs(t) do tt[b] = a end\r\n   return tt\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "local tt = { }",
    "type": "statement:localassign"
  }, {
    "id": 4,
    "text": "for a, b in pairs(t) do tt[b] = a end",
    "type": "statement:genericfor"
  }, {
    "id": 5,
    "text": "tt[b] = a",
    "type": "statement:assign"
  }, {
    "id": 6,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 7,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 8,
    "text": "function table.iforeach(f, ...)\r\n   -- assert (type (f) == \"function\") [wouldn't allow metamethod __call]\r\n   local nargs = select(\"#\", ...)\r\n   if nargs==1 then -- Quick iforeach (most common case), just one table arg\r\n      local t = ...\r\n      assert (type (t) == \"table\")\r\n      for i = 1, #t do \r\n         local result = f (t[i])\r\n         -- If the function returns non-false, stop iteration\r\n         if result then return result end\r\n      end\r\n   else -- advanced case: boundaries and/or multiple tables\r\n      -- 1 - find boundaries if any\r\n      local  args, fargs, first, last, arg1 = {...}, { }\r\n      if     type(args[1]) ~= \"number\" then first, arg1 = 1, 1\r\n      elseif type(args[2]) ~= \"number\" then first, last, arg1 = 1, args[1], 2\r\n      else   first,  last, i = args[1], args[2], 3 end\r\n      assert (nargs > arg1)\r\n      -- 2 - determine upper boundary if not given\r\n      if not last then for i = arg1, nargs do \r\n            assert (type (args[i]) == \"table\")\r\n            last = max (#args[i], last) \r\n      end end\r\n      -- 3 - perform the iteration\r\n      for i = first, last do\r\n         for j = arg1, nargs do fargs[j] = args[j][i] end -- build args list\r\n         local result = f (unpack (fargs)) -- here is the call\r\n         -- If the function returns non-false, stop iteration\r\n         if result then return result end\r\n      end\r\n   end\r\nend",
    "type": "function"
  }, {
    "id": 9,
    "text": "local nargs = select(\"#\", ...)",
    "type": "statement:localassign"
  }, {
    "id": 10,
    "text": "if nargs==1 then -- Quick iforeach (most common case), just one table arg\r\n      local t = ...\r\n      assert (type (t) == \"table\")\r\n      for i = 1, #t do \r\n         local result = f (t[i])\r\n         -- If the function returns non-false, stop iteration\r\n         if result then return result end\r\n      end\r\n   else -- advanced case: boundaries and/or multiple tables\r\n      -- 1 - find boundaries if any\r\n      local  args, fargs, first, last, arg1 = {...}, { }\r\n      if     type(args[1]) ~= \"number\" then first, arg1 = 1, 1\r\n      elseif type(args[2]) ~= \"number\" then first, last, arg1 = 1, args[1], 2\r\n      else   first,  last, i = args[1], args[2], 3 end\r\n      assert (nargs > arg1)\r\n      -- 2 - determine upper boundary if not given\r\n      if not last then for i = arg1, nargs do \r\n            assert (type (args[i]) == \"table\")\r\n            last = max (#args[i], last) \r\n      end end\r\n      -- 3 - perform the iteration\r\n      for i = first, last do\r\n         for j = arg1, nargs do fargs[j] = args[j][i] end -- build args list\r\n         local result = f (unpack (fargs)) -- here is the call\r\n         -- If the function returns non-false, stop iteration\r\n         if result then return result end\r\n      end\r\n   end",
    "type": "statement:if"
  }, {
    "id": 11,
    "text": "local t = ...",
    "type": "statement:localassign"
  }, {
    "id": 12,
    "text": "assert (type (t) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 13,
    "text": "for i = 1, #t do \r\n         local result = f (t[i])\r\n         -- If the function returns non-false, stop iteration\r\n         if result then return result end\r\n      end",
    "type": "statement:numericfor"
  }, {
    "id": 14,
    "text": "local result = f (t[i])",
    "type": "statement:localassign"
  }, {
    "id": 15,
    "text": "if result then return result end",
    "type": "statement:if"
  }, {
    "id": 16,
    "text": "local  args, fargs, first, last, arg1 = {...}, { }",
    "type": "statement:localassign"
  }, {
    "id": 17,
    "text": "if     type(args[1]) ~= \"number\" then first, arg1 = 1, 1\r\n      elseif type(args[2]) ~= \"number\" then first, last, arg1 = 1, args[1], 2\r\n      else   first,  last, i = args[1], args[2], 3 end",
    "type": "statement:if"
  }, {
    "id": 18,
    "text": "first, arg1 = 1, 1",
    "type": "statement:assign"
  }, {
    "id": 19,
    "text": "first, last, arg1 = 1, args[1], 2",
    "type": "statement:assign"
  }, {
    "id": 20,
    "text": "first,  last, i = args[1], args[2], 3",
    "type": "statement:assign"
  }, {
    "id": 21,
    "text": "assert (nargs > arg1)",
    "type": "statement:functioncall"
  }, {
    "id": 22,
    "text": "if not last then for i = arg1, nargs do \r\n            assert (type (args[i]) == \"table\")\r\n            last = max (#args[i], last) \r\n      end end",
    "type": "statement:if"
  }, {
    "id": 23,
    "text": "for i = arg1, nargs do \r\n            assert (type (args[i]) == \"table\")\r\n            last = max (#args[i], last) \r\n      end",
    "type": "statement:numericfor"
  }, {
    "id": 24,
    "text": "assert (type (args[i]) == \"table\")",
    "type": "statement:functioncall"
  }, {
    "id": 25,
    "text": "last = max (#args[i], last)",
    "type": "statement:assign"
  }, {
    "id": 26,
    "text": "for i = first, last do\r\n         for j = arg1, nargs do fargs[j] = args[j][i] end -- build args list\r\n         local result = f (unpack (fargs)) -- here is the call\r\n         -- If the function returns non-false, stop iteration\r\n         if result then return result end\r\n      end",
    "type": "statement:numericfor"
  }, {
    "id": 27,
    "text": "for j = arg1, nargs do fargs[j] = args[j][i] end",
    "type": "statement:numericfor"
  }, {
    "id": 28,
    "text": "fargs[j] = args[j][i]",
    "type": "statement:assign"
  }, {
    "id": 29,
    "text": "local result = f (unpack (fargs))",
    "type": "statement:localassign"
  }, {
    "id": 30,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 31,
    "text": "function table.imap (f, ...)\r\n   local result, idx = { }, 1\r\n   local function g(...) result[idx] = f(...);  idx=idx+1 end\r\n   table.iforeach(g, ...)\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 32,
    "text": "local result, idx = { }, 1",
    "type": "statement:localassign"
  }, {
    "id": 33,
    "text": "local function g(...) result[idx] = f(...);  idx=idx+1 end",
    "type": "statement:localfunction"
  }, {
    "id": 34,
    "text": "result[idx] = f(...)",
    "type": "statement:assign"
  }, {
    "id": 35,
    "text": "idx=idx+1",
    "type": "statement:assign"
  }, {
    "id": 36,
    "text": "table.iforeach(g, ...)",
    "type": "statement:functioncall"
  }, {
    "id": 37,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 38,
    "text": "local function g(...) result[idx] = f(...);  idx=idx+1 end",
    "type": "function"
  }, {
    "id": 39,
    "text": "function table.ifold (f, acc, ...)\r\n   local function g(...) acc = f (acc,...) end\r\n   table.iforeach (g, ...)\r\n   return acc\r\nend",
    "type": "function"
  }, {
    "id": 40,
    "text": "local function g(...) acc = f (acc,...) end",
    "type": "statement:localfunction"
  }, {
    "id": 41,
    "text": "acc = f (acc,...)",
    "type": "statement:assign"
  }, {
    "id": 42,
    "text": "table.iforeach (g, ...)",
    "type": "statement:functioncall"
  }, {
    "id": 43,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 44,
    "text": "local function g(...) acc = f (acc,...) end",
    "type": "function"
  }, {
    "id": 45,
    "text": "function table.izip(...)\r\n   local function g(...) return {...} end\r\n   return table.imap(g, ...)\r\nend",
    "type": "function"
  }, {
    "id": 46,
    "text": "local function g(...) return {...} end",
    "type": "statement:localfunction"
  }, {
    "id": 47,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 48,
    "text": "local function g(...) return {...} end",
    "type": "function"
  }, {
    "id": 49,
    "text": "function table.ifilter(f, t)\r\n   local yes, no = { }, { }\r\n   for i=1,#t do table.insert (f(t[i]) and yes or no, t[i]) end\r\n   return yes, no\r\nend",
    "type": "function"
  }, {
    "id": 50,
    "text": "local yes, no = { }, { }",
    "type": "statement:localassign"
  }, {
    "id": 51,
    "text": "for i=1,#t do table.insert (f(t[i]) and yes or no, t[i]) end",
    "type": "statement:numericfor"
  }, {
    "id": 52,
    "text": "table.insert (f(t[i]) and yes or no, t[i])",
    "type": "statement:functioncall"
  }, {
    "id": 53,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 54,
    "text": "function table.icat(...)\r\n   local result = { }\r\n   for t in values {...} do\r\n      for x in values (t) do\r\n         table.insert (result, x)\r\n      end\r\n   end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 55,
    "text": "local result = { }",
    "type": "statement:localassign"
  }, {
    "id": 56,
    "text": "for t in values {...} do\r\n      for x in values (t) do\r\n         table.insert (result, x)\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 57,
    "text": "for x in values (t) do\r\n         table.insert (result, x)\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 58,
    "text": "table.insert (result, x)",
    "type": "statement:functioncall"
  }, {
    "id": 59,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 60,
    "text": "function table.iflatten (x) return table.icat (unpack (x)) end",
    "type": "function"
  }, {
    "id": 61,
    "text": "function table.irev (t)\r\n   local result, nt = { }, #t\r\n   for i=0, nt-1 do result[nt-i] = t[i+1] end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 62,
    "text": "local result, nt = { }, #t",
    "type": "statement:localassign"
  }, {
    "id": 63,
    "text": "for i=0, nt-1 do result[nt-i] = t[i+1] end",
    "type": "statement:numericfor"
  }, {
    "id": 64,
    "text": "result[nt-i] = t[i+1]",
    "type": "statement:assign"
  }, {
    "id": 65,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 66,
    "text": "function table.isub (t, ...)\r\n   local ti, u = table.insert, { }\r\n   local args, nargs = {...}, select(\"#\", ...)\r\n   for i=1, nargs/2 do\r\n      local a, b = args[2*i-1], args[2*i]\r\n      for i=a, b, a<=b and 1 or -1 do ti(u, t[i]) end\r\n   end\r\n   return u\r\nend",
    "type": "function"
  }, {
    "id": 67,
    "text": "local ti, u = table.insert, { }",
    "type": "statement:localassign"
  }, {
    "id": 68,
    "text": "local args, nargs = {...}, select(\"#\", ...)",
    "type": "statement:localassign"
  }, {
    "id": 69,
    "text": "for i=1, nargs/2 do\r\n      local a, b = args[2*i-1], args[2*i]\r\n      for i=a, b, a<=b and 1 or -1 do ti(u, t[i]) end\r\n   end",
    "type": "statement:numericfor"
  }, {
    "id": 70,
    "text": "local a, b = args[2*i-1], args[2*i]",
    "type": "statement:localassign"
  }, {
    "id": 71,
    "text": "for i=a, b, a<=b and 1 or -1 do ti(u, t[i]) end",
    "type": "statement:numericfor"
  }, {
    "id": 72,
    "text": "ti(u, t[i])",
    "type": "statement:functioncall"
  }, {
    "id": 73,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 74,
    "text": "function table.iall (f, ...)\r\n   local result = true\r\n   local function g(...) return not f(...) end\r\n   return not table.iforeach(g, ...)\r\n   --return result\r\nend",
    "type": "function"
  }, {
    "id": 75,
    "text": "local result = true",
    "type": "statement:localassign"
  }, {
    "id": 76,
    "text": "local function g(...) return not f(...) end",
    "type": "statement:localfunction"
  }, {
    "id": 77,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 78,
    "text": "local function g(...) return not f(...) end",
    "type": "function"
  }, {
    "id": 79,
    "text": "function table.iany (f, ...)\r\n   local function g(...) return not f(...) end\r\n   return not table.iall(g, ...)\r\nend",
    "type": "function"
  }, {
    "id": 80,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 81,
    "text": "local function g(...) return not f(...) end",
    "type": "function"
  }, {
    "id": 82,
    "text": "function table.shallow_copy(x)\r\n   local y={ }\r\n   for k, v in pairs(x) do y[k]=v end\r\n   return y\r\nend",
    "type": "function"
  }, {
    "id": 83,
    "text": "local y={ }",
    "type": "statement:localassign"
  }, {
    "id": 84,
    "text": "for k, v in pairs(x) do y[k]=v end",
    "type": "statement:genericfor"
  }, {
    "id": 85,
    "text": "y[k]=v",
    "type": "statement:assign"
  }, {
    "id": 86,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 87,
    "text": "function table.cat(...)\r\n   local y={ }\r\n   for x in values{...} do\r\n      -- cat array-part\r\n      for _, v in ipairs(x) do table.insert(y,v) end\r\n      -- cat hash-part\r\n      local lx, k = #x\r\n      if lx>0 then k=next(x,lx) else k=next(x) end\r\n      while k do y[k]=x[k]; k=next(x,k) end\r\n   end\r\n   return y\r\nend",
    "type": "function"
  }, {
    "id": 88,
    "text": "for x in values{...} do\r\n      -- cat array-part\r\n      for _, v in ipairs(x) do table.insert(y,v) end\r\n      -- cat hash-part\r\n      local lx, k = #x\r\n      if lx>0 then k=next(x,lx) else k=next(x) end\r\n      while k do y[k]=x[k]; k=next(x,k) end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 89,
    "text": "for _, v in ipairs(x) do table.insert(y,v) end",
    "type": "statement:genericfor"
  }, {
    "id": 90,
    "text": "table.insert(y,v)",
    "type": "statement:functioncall"
  }, {
    "id": 91,
    "text": "local lx, k = #x",
    "type": "statement:localassign"
  }, {
    "id": 92,
    "text": "if lx>0 then k=next(x,lx) else k=next(x) end",
    "type": "statement:if"
  }, {
    "id": 93,
    "text": "k=next(x,lx)",
    "type": "statement:assign"
  }, {
    "id": 94,
    "text": "k=next(x)",
    "type": "statement:assign"
  }, {
    "id": 95,
    "text": "while k do y[k]=x[k]; k=next(x,k) end",
    "type": "statement:while"
  }, {
    "id": 96,
    "text": "y[k]=x[k]",
    "type": "statement:assign"
  }, {
    "id": 97,
    "text": "k=next(x,k)",
    "type": "statement:assign"
  }, {
    "id": 98,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 99,
    "text": "function table.deep_copy(x) \r\n   local tracker = { }\r\n   local function aux (x)\r\n      if type(x) == \"table\" then\r\n         local y=tracker[x]\r\n         if y then return y end\r\n         y = { }; tracker[x] = y\r\n         setmetatable (y, getmetatable (x))\r\n         for k,v in pairs(x) do y[aux(k)] = aux(v) end\r\n         return y\r\n      else return x end\r\n   end\r\n   return aux(x)\r\nend",
    "type": "function"
  }, {
    "id": 100,
    "text": "local tracker = { }",
    "type": "statement:localassign"
  }, {
    "id": 101,
    "text": "local function aux (x)\r\n      if type(x) == \"table\" then\r\n         local y=tracker[x]\r\n         if y then return y end\r\n         y = { }; tracker[x] = y\r\n         setmetatable (y, getmetatable (x))\r\n         for k,v in pairs(x) do y[aux(k)] = aux(v) end\r\n         return y\r\n      else return x end\r\n   end",
    "type": "statement:localfunction"
  }, {
    "id": 102,
    "text": "if type(x) == \"table\" then\r\n         local y=tracker[x]\r\n         if y then return y end\r\n         y = { }; tracker[x] = y\r\n         setmetatable (y, getmetatable (x))\r\n         for k,v in pairs(x) do y[aux(k)] = aux(v) end\r\n         return y\r\n      else return x end",
    "type": "statement:if"
  }, {
    "id": 103,
    "text": "local y=tracker[x]",
    "type": "statement:localassign"
  }, {
    "id": 104,
    "text": "if y then return y end",
    "type": "statement:if"
  }, {
    "id": 105,
    "text": "y = { }",
    "type": "statement:assign"
  }, {
    "id": 106,
    "text": "tracker[x] = y",
    "type": "statement:assign"
  }, {
    "id": 107,
    "text": "setmetatable (y, getmetatable (x))",
    "type": "statement:functioncall"
  }, {
    "id": 108,
    "text": "for k,v in pairs(x) do y[aux(k)] = aux(v) end",
    "type": "statement:genericfor"
  }, {
    "id": 109,
    "text": "y[aux(k)] = aux(v)",
    "type": "statement:assign"
  }, {
    "id": 110,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 111,
    "text": "local function aux (x)\r\n      if type(x) == \"table\" then\r\n         local y=tracker[x]\r\n         if y then return y end\r\n         y = { }; tracker[x] = y\r\n         setmetatable (y, getmetatable (x))\r\n         for k,v in pairs(x) do y[aux(k)] = aux(v) end\r\n         return y\r\n      else return x end\r\n   end",
    "type": "function"
  }, {
    "id": 112,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 113,
    "text": "function table.override(dst, src)\r\n   for k, v in pairs(src) do dst[k] = v end\r\n   for i = #src+1, #dst   do dst[i] = nil end\r\n   return dst\r\nend",
    "type": "function"
  }, {
    "id": 114,
    "text": "for k, v in pairs(src) do dst[k] = v end",
    "type": "statement:genericfor"
  }, {
    "id": 115,
    "text": "dst[k] = v",
    "type": "statement:assign"
  }, {
    "id": 116,
    "text": "for i = #src+1, #dst   do dst[i] = nil end",
    "type": "statement:numericfor"
  }, {
    "id": 117,
    "text": "dst[i] = nil",
    "type": "statement:assign"
  }, {
    "id": 118,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 119,
    "text": "function table.range(a,b,c)\r\n   if not b then assert(not(c)); b=a; a=1\r\n   elseif not c then c = (b>=a) and 1 or -1 end\r\n   local result = { }\r\n   for i=a, b, c do table.insert(result, i) end\r\n   return result\r\nend",
    "type": "function"
  }, {
    "id": 120,
    "text": "if not b then assert(not(c)); b=a; a=1\r\n   elseif not c then c = (b>=a) and 1 or -1 end",
    "type": "statement:if"
  }, {
    "id": 121,
    "text": "assert(not(c))",
    "type": "statement:functioncall"
  }, {
    "id": 122,
    "text": "b=a",
    "type": "statement:assign"
  }, {
    "id": 123,
    "text": "a=1",
    "type": "statement:assign"
  }, {
    "id": 124,
    "text": "c = (b>=a) and 1 or -1",
    "type": "statement:assign"
  }, {
    "id": 125,
    "text": "for i=a, b, c do table.insert(result, i) end",
    "type": "statement:numericfor"
  }, {
    "id": 126,
    "text": "table.insert(result, i)",
    "type": "statement:functioncall"
  }, {
    "id": 127,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 128,
    "text": "function table.tostring(t, ...)\r\n   local PRINT_HASH, HANDLE_TAG, FIX_INDENT, LINE_MAX, INITIAL_INDENT = true, true\r\n   for _, x in ipairs {...} do\r\n      if type(x) == \"number\" then\r\n         if not LINE_MAX then LINE_MAX = x\r\n         else INITIAL_INDENT = x end\r\n      elseif x==\"nohash\" then PRINT_HASH = false\r\n      elseif x==\"notag\"  then HANDLE_TAG = false\r\n      else\r\n         local n = string['match'](x, \"^indent%s*(%d*)$\")\r\n         if n then FIX_INDENT = tonumber(n) or 3 end\r\n      end\r\n   end\r\n   LINE_MAX       = LINE_MAX or math.huge\r\n   INITIAL_INDENT = INITIAL_INDENT or 1\r\n   \r\n   local current_offset =  0  -- indentation level\r\n   local xlen_cache     = { } -- cached results for xlen()\r\n   local acc_list       = { } -- Generated bits of string\r\n   local function acc(...)    -- Accumulate a bit of string\r\n      local x = table.concat{...}\r\n      current_offset = current_offset + #x\r\n      table.insert(acc_list, x) \r\n   end\r\n   local function valid_id(x)\r\n      -- FIXME: we should also reject keywords; but the list of\r\n      -- current keywords is not fixed in metalua...\r\n      return type(x) == \"string\" \r\n         and string['match'](x, \"^[a-zA-Z_][a-zA-Z0-9_]*$\")\r\n   end\r\n   \r\n   -- Compute the number of chars it would require to display the table\r\n   -- on a single line. Helps to decide whether some carriage returns are\r\n   -- required. Since the size of each sub-table is required many times,\r\n   -- it's cached in [xlen_cache].\r\n   local xlen_type = { }\r\n   local function xlen(x, nested)\r\n      nested = nested or { }\r\n      if x==nil then return #\"nil\" end\r\n      --if nested[x] then return #tostring(x) end -- already done in table\r\n      local len = xlen_cache[x]\r\n      if len then return len end\r\n      local f = xlen_type[type(x)]\r\n      if not f then return #tostring(x) end\r\n      len = f (x, nested) \r\n      xlen_cache[x] = len\r\n      return len\r\n   end\r\n\r\n   -- optim: no need to compute lengths if I'm not going to use them\r\n   -- anyway.\r\n   if LINE_MAX == math.huge then xlen = function() return 0 end end\r\n\r\n   xlen_type[\"nil\"] = function () return 3 end\r\n   function xlen_type.number  (x) return #tostring(x) end\r\n   function xlen_type.boolean (x) return x and 4 or 5 end\r\n   function xlen_type.string  (x) return #string.format(\"%q\",x) end\r\n   function xlen_type.table   (adt, nested)\r\n\r\n      -- Circular references detection\r\n      if nested [adt] then return #tostring(adt) end\r\n      nested [adt] = true\r\n\r\n      local has_tag  = HANDLE_TAG and valid_id(adt.tag)\r\n      local alen     = #adt\r\n      local has_arr  = alen>0\r\n      local has_hash = false\r\n      local x = 0\r\n      \r\n      if PRINT_HASH then\r\n         -- first pass: count hash-part\r\n         for k, v in pairs(adt) do\r\n            if k==\"tag\" and has_tag then \r\n               -- this is the tag -> do nothing!\r\n            elseif type(k)==\"number\" and k<=alen and math.fmod(k,1)==0 then \r\n               -- array-part pair -> do nothing!\r\n            else\r\n               has_hash = true\r\n               if valid_id(k) then x=x+#k\r\n               else x = x + xlen (k, nested) + 2 end -- count surrounding brackets\r\n               x = x + xlen (v, nested) + 5          -- count \" = \" and \", \"\r\n            end\r\n         end\r\n      end\r\n\r\n      for i = 1, alen do x = x + xlen (adt[i], nested) + 2 end -- count \", \"\r\n      \r\n      nested[adt] = false -- No more nested calls\r\n\r\n      if not (has_tag or has_arr or has_hash) then return 3 end\r\n      if has_tag then x=x+#adt.tag+1 end\r\n      if not (has_arr or has_hash) then return x end\r\n      if not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n         return x-2 -- substract extraneous \", \"\r\n      end\r\n      return x+2 -- count \"{ \" and \" }\", substract extraneous \", \"\r\n   end\r\n   \r\n   -- Recursively print a (sub) table at given indentation level.\r\n   -- [newline] indicates whether newlines should be inserted.\r\n   local function rec (adt, nested, indent)\r\n      if not FIX_INDENT then indent = current_offset end\r\n      local function acc_newline()\r\n         acc (\"\\n\"); acc (string.rep (\" \", indent)) \r\n         current_offset = indent\r\n      end\r\n      local x = { }\r\n      x[\"nil\"] = function() acc \"nil\" end\r\n      function x.number()   acc (tostring (adt)) end\r\n      --function x.string()   acc (string.format (\"%q\", adt)) end\r\n      function x.string()   acc ((string.format (\"%q\", adt):gsub(\"\\\\\\n\", \"\\\\n\"))) end\r\n      function x.boolean()  acc (adt and \"true\" or \"false\") end\r\n      function x.table()\r\n         if nested[adt] then acc(tostring(adt)); return end\r\n         nested[adt]  = true\r\n\r\n\r\n         local has_tag  = HANDLE_TAG and valid_id(adt.tag)\r\n         local alen     = #adt\r\n         local has_arr  = alen>0\r\n         local has_hash = false\r\n\r\n         if has_tag then acc(\"`\"); acc(adt.tag) end\r\n\r\n         -- First pass: handle hash-part\r\n         if PRINT_HASH then\r\n            for k, v in pairs(adt) do\r\n               -- pass if the key belongs to the array-part or is the \"tag\" field\r\n               if not (k==\"tag\" and HANDLE_TAG) and \r\n                  not (type(k)==\"number\" and k<=alen and math.fmod(k,1)==0) then\r\n\r\n                  -- Is it the first time we parse a hash pair?\r\n                  if not has_hash then \r\n                     acc \"{ \"\r\n                     if not FIX_INDENT then indent = current_offset end\r\n                  else acc \", \" end\r\n\r\n                  -- Determine whether a newline is required\r\n                  local is_id, expected_len = valid_id(k)\r\n                  if is_id then expected_len = #k + xlen (v, nested) + #\" = , \"\r\n                  else expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \" end\r\n                  if has_hash and expected_len + current_offset > LINE_MAX\r\n                  then acc_newline() end\r\n                  \r\n                  -- Print the key\r\n                  if is_id then acc(k); acc \" = \" \r\n                  else  acc \"[\"; rec (k, nested, indent+(FIX_INDENT or 0)); acc \"] = \" end\r\n\r\n                  -- Print the value\r\n                  rec (v, nested, indent+(FIX_INDENT or 0))\r\n                  has_hash = true\r\n               end\r\n            end\r\n         end\r\n\r\n         -- Now we know whether there's a hash-part, an array-part, and a tag.\r\n         -- Tag and hash-part are already printed if they're present.\r\n         if not has_tag and not has_hash and not has_arr then acc \"{ }\"; \r\n         elseif has_tag and not has_hash and not has_arr then -- nothing, tag already in acc\r\n         else \r\n            assert (has_hash or has_arr)\r\n            local no_brace = false\r\n            if has_hash and has_arr then acc \", \" \r\n            elseif has_tag and not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n               -- No brace required; don't print \"{\", remember not to print \"}\"\r\n               acc (\" \"); rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               no_brace = true\r\n            elseif not has_hash then\r\n               -- Braces required, but not opened by hash-part handler yet\r\n               acc \"{ \"\r\n               if not FIX_INDENT then indent = current_offset end\r\n            end\r\n\r\n            -- 2nd pass: array-part\r\n            if not no_brace and has_arr then \r\n               rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               for i=2, alen do \r\n                  acc \", \";                   \r\n                  if   current_offset + xlen (adt[i], { }) > LINE_MAX\r\n                  then acc_newline() end\r\n                  rec (adt[i], nested, indent+(FIX_INDENT or 0)) \r\n               end\r\n            end\r\n            if not no_brace then acc \" }\" end\r\n         end\r\n         nested[adt] = false -- No more nested calls\r\n      end\r\n      local y = x[type(adt)]\r\n      if y then y() else acc(tostring(adt)) end\r\n   end\r\n   --printf(\"INITIAL_INDENT = %i\", INITIAL_INDENT)\r\n   current_offset = INITIAL_INDENT or 0\r\n   rec(t, { }, 0)\r\n   return table.concat (acc_list)\r\nend",
    "type": "function"
  }, {
    "id": 129,
    "text": "local PRINT_HASH, HANDLE_TAG, FIX_INDENT, LINE_MAX, INITIAL_INDENT = true, true",
    "type": "statement:localassign"
  }, {
    "id": 130,
    "text": "for _, x in ipairs {...} do\r\n      if type(x) == \"number\" then\r\n         if not LINE_MAX then LINE_MAX = x\r\n         else INITIAL_INDENT = x end\r\n      elseif x==\"nohash\" then PRINT_HASH = false\r\n      elseif x==\"notag\"  then HANDLE_TAG = false\r\n      else\r\n         local n = string['match'](x, \"^indent%s*(%d*)$\")\r\n         if n then FIX_INDENT = tonumber(n) or 3 end\r\n      end\r\n   end",
    "type": "statement:genericfor"
  }, {
    "id": 131,
    "text": "if type(x) == \"number\" then\r\n         if not LINE_MAX then LINE_MAX = x\r\n         else INITIAL_INDENT = x end\r\n      elseif x==\"nohash\" then PRINT_HASH = false\r\n      elseif x==\"notag\"  then HANDLE_TAG = false\r\n      else\r\n         local n = string['match'](x, \"^indent%s*(%d*)$\")\r\n         if n then FIX_INDENT = tonumber(n) or 3 end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 132,
    "text": "if not LINE_MAX then LINE_MAX = x\r\n         else INITIAL_INDENT = x end",
    "type": "statement:if"
  }, {
    "id": 133,
    "text": "LINE_MAX = x",
    "type": "statement:assign"
  }, {
    "id": 134,
    "text": "INITIAL_INDENT = x",
    "type": "statement:assign"
  }, {
    "id": 135,
    "text": "PRINT_HASH = false",
    "type": "statement:assign"
  }, {
    "id": 136,
    "text": "HANDLE_TAG = false",
    "type": "statement:assign"
  }, {
    "id": 137,
    "text": "local n = string['match'](x, \"^indent%s*(%d*)$\")",
    "type": "statement:localassign"
  }, {
    "id": 138,
    "text": "if n then FIX_INDENT = tonumber(n) or 3 end",
    "type": "statement:if"
  }, {
    "id": 139,
    "text": "FIX_INDENT = tonumber(n) or 3",
    "type": "statement:assign"
  }, {
    "id": 140,
    "text": "LINE_MAX       = LINE_MAX or math.huge",
    "type": "statement:assign"
  }, {
    "id": 141,
    "text": "INITIAL_INDENT = INITIAL_INDENT or 1",
    "type": "statement:assign"
  }, {
    "id": 142,
    "text": "local current_offset =  0",
    "type": "statement:localassign"
  }, {
    "id": 143,
    "text": "local xlen_cache     = { }",
    "type": "statement:localassign"
  }, {
    "id": 144,
    "text": "local acc_list       = { }",
    "type": "statement:localassign"
  }, {
    "id": 145,
    "text": "local function acc(...)    -- Accumulate a bit of string\r\n      local x = table.concat{...}\r\n      current_offset = current_offset + #x\r\n      table.insert(acc_list, x) \r\n   end",
    "type": "statement:localfunction"
  }, {
    "id": 146,
    "text": "local x = table.concat{...}",
    "type": "statement:localassign"
  }, {
    "id": 147,
    "text": "current_offset = current_offset + #x",
    "type": "statement:assign"
  }, {
    "id": 148,
    "text": "table.insert(acc_list, x)",
    "type": "statement:functioncall"
  }, {
    "id": 149,
    "text": "local function valid_id(x)\r\n      -- FIXME: we should also reject keywords; but the list of\r\n      -- current keywords is not fixed in metalua...\r\n      return type(x) == \"string\" \r\n         and string['match'](x, \"^[a-zA-Z_][a-zA-Z0-9_]*$\")\r\n   end",
    "type": "statement:localfunction"
  }, {
    "id": 150,
    "text": "local xlen_type = { }",
    "type": "statement:localassign"
  }, {
    "id": 151,
    "text": "local function xlen(x, nested)\r\n      nested = nested or { }\r\n      if x==nil then return #\"nil\" end\r\n      --if nested[x] then return #tostring(x) end -- already done in table\r\n      local len = xlen_cache[x]\r\n      if len then return len end\r\n      local f = xlen_type[type(x)]\r\n      if not f then return #tostring(x) end\r\n      len = f (x, nested) \r\n      xlen_cache[x] = len\r\n      return len\r\n   end",
    "type": "statement:localfunction"
  }, {
    "id": 152,
    "text": "nested = nested or { }",
    "type": "statement:assign"
  }, {
    "id": 153,
    "text": "if x==nil then return #\"nil\" end",
    "type": "statement:if"
  }, {
    "id": 154,
    "text": "local len = xlen_cache[x]",
    "type": "statement:localassign"
  }, {
    "id": 155,
    "text": "if len then return len end",
    "type": "statement:if"
  }, {
    "id": 156,
    "text": "local f = xlen_type[type(x)]",
    "type": "statement:localassign"
  }, {
    "id": 157,
    "text": "if not f then return #tostring(x) end",
    "type": "statement:if"
  }, {
    "id": 158,
    "text": "len = f (x, nested)",
    "type": "statement:assign"
  }, {
    "id": 159,
    "text": "xlen_cache[x] = len",
    "type": "statement:assign"
  }, {
    "id": 160,
    "text": "if LINE_MAX == math.huge then xlen = function() return 0 end end",
    "type": "statement:if"
  }, {
    "id": 161,
    "text": "xlen = function() return 0 end",
    "type": "statement:assign"
  }, {
    "id": 162,
    "text": "xlen_type[\"nil\"] = function () return 3 end",
    "type": "statement:assign"
  }, {
    "id": 163,
    "text": "function xlen_type.number  (x) return #tostring(x) end",
    "type": "statement:globalfunction"
  }, {
    "id": 164,
    "text": "function xlen_type.boolean (x) return x and 4 or 5 end",
    "type": "statement:globalfunction"
  }, {
    "id": 165,
    "text": "function xlen_type.string  (x) return #string.format(\"%q\",x) end",
    "type": "statement:globalfunction"
  }, {
    "id": 166,
    "text": "function xlen_type.table   (adt, nested)\r\n\r\n      -- Circular references detection\r\n      if nested [adt] then return #tostring(adt) end\r\n      nested [adt] = true\r\n\r\n      local has_tag  = HANDLE_TAG and valid_id(adt.tag)\r\n      local alen     = #adt\r\n      local has_arr  = alen>0\r\n      local has_hash = false\r\n      local x = 0\r\n      \r\n      if PRINT_HASH then\r\n         -- first pass: count hash-part\r\n         for k, v in pairs(adt) do\r\n            if k==\"tag\" and has_tag then \r\n               -- this is the tag -> do nothing!\r\n            elseif type(k)==\"number\" and k<=alen and math.fmod(k,1)==0 then \r\n               -- array-part pair -> do nothing!\r\n            else\r\n               has_hash = true\r\n               if valid_id(k) then x=x+#k\r\n               else x = x + xlen (k, nested) + 2 end -- count surrounding brackets\r\n               x = x + xlen (v, nested) + 5          -- count \" = \" and \", \"\r\n            end\r\n         end\r\n      end\r\n\r\n      for i = 1, alen do x = x + xlen (adt[i], nested) + 2 end -- count \", \"\r\n      \r\n      nested[adt] = false -- No more nested calls\r\n\r\n      if not (has_tag or has_arr or has_hash) then return 3 end\r\n      if has_tag then x=x+#adt.tag+1 end\r\n      if not (has_arr or has_hash) then return x end\r\n      if not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n         return x-2 -- substract extraneous \", \"\r\n      end\r\n      return x+2 -- count \"{ \" and \" }\", substract extraneous \", \"\r\n   end",
    "type": "statement:globalfunction"
  }, {
    "id": 167,
    "text": "if nested [adt] then return #tostring(adt) end",
    "type": "statement:if"
  }, {
    "id": 168,
    "text": "nested [adt] = true",
    "type": "statement:assign"
  }, {
    "id": 169,
    "text": "local has_tag  = HANDLE_TAG and valid_id(adt.tag)",
    "type": "statement:localassign"
  }, {
    "id": 170,
    "text": "local alen     = #adt",
    "type": "statement:localassign"
  }, {
    "id": 171,
    "text": "local has_arr  = alen>0",
    "type": "statement:localassign"
  }, {
    "id": 172,
    "text": "local has_hash = false",
    "type": "statement:localassign"
  }, {
    "id": 173,
    "text": "local x = 0",
    "type": "statement:localassign"
  }, {
    "id": 174,
    "text": "if PRINT_HASH then\r\n         -- first pass: count hash-part\r\n         for k, v in pairs(adt) do\r\n            if k==\"tag\" and has_tag then \r\n               -- this is the tag -> do nothing!\r\n            elseif type(k)==\"number\" and k<=alen and math.fmod(k,1)==0 then \r\n               -- array-part pair -> do nothing!\r\n            else\r\n               has_hash = true\r\n               if valid_id(k) then x=x+#k\r\n               else x = x + xlen (k, nested) + 2 end -- count surrounding brackets\r\n               x = x + xlen (v, nested) + 5          -- count \" = \" and \", \"\r\n            end\r\n         end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 175,
    "text": "for k, v in pairs(adt) do\r\n            if k==\"tag\" and has_tag then \r\n               -- this is the tag -> do nothing!\r\n            elseif type(k)==\"number\" and k<=alen and math.fmod(k,1)==0 then \r\n               -- array-part pair -> do nothing!\r\n            else\r\n               has_hash = true\r\n               if valid_id(k) then x=x+#k\r\n               else x = x + xlen (k, nested) + 2 end -- count surrounding brackets\r\n               x = x + xlen (v, nested) + 5          -- count \" = \" and \", \"\r\n            end\r\n         end",
    "type": "statement:genericfor"
  }, {
    "id": 176,
    "text": "if k==\"tag\" and has_tag then \r\n               -- this is the tag -> do nothing!\r\n            elseif type(k)==\"number\" and k<=alen and math.fmod(k,1)==0 then \r\n               -- array-part pair -> do nothing!\r\n            else\r\n               has_hash = true\r\n               if valid_id(k) then x=x+#k\r\n               else x = x + xlen (k, nested) + 2 end -- count surrounding brackets\r\n               x = x + xlen (v, nested) + 5          -- count \" = \" and \", \"\r\n            end",
    "type": "statement:if"
  }, {
    "id": 177,
    "text": "has_hash = true",
    "type": "statement:assign"
  }, {
    "id": 178,
    "text": "if valid_id(k) then x=x+#k\r\n               else x = x + xlen (k, nested) + 2 end",
    "type": "statement:if"
  }, {
    "id": 179,
    "text": "x=x+#k",
    "type": "statement:assign"
  }, {
    "id": 180,
    "text": "x = x + xlen (k, nested) + 2",
    "type": "statement:assign"
  }, {
    "id": 181,
    "text": "x = x + xlen (v, nested) + 5",
    "type": "statement:assign"
  }, {
    "id": 182,
    "text": "for i = 1, alen do x = x + xlen (adt[i], nested) + 2 end",
    "type": "statement:numericfor"
  }, {
    "id": 183,
    "text": "x = x + xlen (adt[i], nested) + 2",
    "type": "statement:assign"
  }, {
    "id": 184,
    "text": "nested[adt] = false",
    "type": "statement:assign"
  }, {
    "id": 185,
    "text": "if not (has_tag or has_arr or has_hash) then return 3 end",
    "type": "statement:if"
  }, {
    "id": 186,
    "text": "if has_tag then x=x+#adt.tag+1 end",
    "type": "statement:if"
  }, {
    "id": 187,
    "text": "x=x+#adt.tag+1",
    "type": "statement:assign"
  }, {
    "id": 188,
    "text": "if not (has_arr or has_hash) then return x end",
    "type": "statement:if"
  }, {
    "id": 189,
    "text": "if not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n         return x-2 -- substract extraneous \", \"\r\n      end",
    "type": "statement:if"
  }, {
    "id": 190,
    "text": "local function rec (adt, nested, indent)\r\n      if not FIX_INDENT then indent = current_offset end\r\n      local function acc_newline()\r\n         acc (\"\\n\"); acc (string.rep (\" \", indent)) \r\n         current_offset = indent\r\n      end\r\n      local x = { }\r\n      x[\"nil\"] = function() acc \"nil\" end\r\n      function x.number()   acc (tostring (adt)) end\r\n      --function x.string()   acc (string.format (\"%q\", adt)) end\r\n      function x.string()   acc ((string.format (\"%q\", adt):gsub(\"\\\\\\n\", \"\\\\n\"))) end\r\n      function x.boolean()  acc (adt and \"true\" or \"false\") end\r\n      function x.table()\r\n         if nested[adt] then acc(tostring(adt)); return end\r\n         nested[adt]  = true\r\n\r\n\r\n         local has_tag  = HANDLE_TAG and valid_id(adt.tag)\r\n         local alen     = #adt\r\n         local has_arr  = alen>0\r\n         local has_hash = false\r\n\r\n         if has_tag then acc(\"`\"); acc(adt.tag) end\r\n\r\n         -- First pass: handle hash-part\r\n         if PRINT_HASH then\r\n            for k, v in pairs(adt) do\r\n               -- pass if the key belongs to the array-part or is the \"tag\" field\r\n               if not (k==\"tag\" and HANDLE_TAG) and \r\n                  not (type(k)==\"number\" and k<=alen and math.fmod(k,1)==0) then\r\n\r\n                  -- Is it the first time we parse a hash pair?\r\n                  if not has_hash then \r\n                     acc \"{ \"\r\n                     if not FIX_INDENT then indent = current_offset end\r\n                  else acc \", \" end\r\n\r\n                  -- Determine whether a newline is required\r\n                  local is_id, expected_len = valid_id(k)\r\n                  if is_id then expected_len = #k + xlen (v, nested) + #\" = , \"\r\n                  else expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \" end\r\n                  if has_hash and expected_len + current_offset > LINE_MAX\r\n                  then acc_newline() end\r\n                  \r\n                  -- Print the key\r\n                  if is_id then acc(k); acc \" = \" \r\n                  else  acc \"[\"; rec (k, nested, indent+(FIX_INDENT or 0)); acc \"] = \" end\r\n\r\n                  -- Print the value\r\n                  rec (v, nested, indent+(FIX_INDENT or 0))\r\n                  has_hash = true\r\n               end\r\n            end\r\n         end\r\n\r\n         -- Now we know whether there's a hash-part, an array-part, and a tag.\r\n         -- Tag and hash-part are already printed if they're present.\r\n         if not has_tag and not has_hash and not has_arr then acc \"{ }\"; \r\n         elseif has_tag and not has_hash and not has_arr then -- nothing, tag already in acc\r\n         else \r\n            assert (has_hash or has_arr)\r\n            local no_brace = false\r\n            if has_hash and has_arr then acc \", \" \r\n            elseif has_tag and not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n               -- No brace required; don't print \"{\", remember not to print \"}\"\r\n               acc (\" \"); rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               no_brace = true\r\n            elseif not has_hash then\r\n               -- Braces required, but not opened by hash-part handler yet\r\n               acc \"{ \"\r\n               if not FIX_INDENT then indent = current_offset end\r\n            end\r\n\r\n            -- 2nd pass: array-part\r\n            if not no_brace and has_arr then \r\n               rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               for i=2, alen do \r\n                  acc \", \";                   \r\n                  if   current_offset + xlen (adt[i], { }) > LINE_MAX\r\n                  then acc_newline() end\r\n                  rec (adt[i], nested, indent+(FIX_INDENT or 0)) \r\n               end\r\n            end\r\n            if not no_brace then acc \" }\" end\r\n         end\r\n         nested[adt] = false -- No more nested calls\r\n      end\r\n      local y = x[type(adt)]\r\n      if y then y() else acc(tostring(adt)) end\r\n   end",
    "type": "statement:localfunction"
  }, {
    "id": 191,
    "text": "if not FIX_INDENT then indent = current_offset end",
    "type": "statement:if"
  }, {
    "id": 192,
    "text": "indent = current_offset",
    "type": "statement:assign"
  }, {
    "id": 193,
    "text": "local function acc_newline()\r\n         acc (\"\\n\"); acc (string.rep (\" \", indent)) \r\n         current_offset = indent\r\n      end",
    "type": "statement:localfunction"
  }, {
    "id": 194,
    "text": "acc (\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 195,
    "text": "acc (string.rep (\" \", indent))",
    "type": "statement:functioncall"
  }, {
    "id": 196,
    "text": "current_offset = indent",
    "type": "statement:assign"
  }, {
    "id": 197,
    "text": "local x = { }",
    "type": "statement:localassign"
  }, {
    "id": 198,
    "text": "x[\"nil\"] = function() acc \"nil\" end",
    "type": "statement:assign"
  }, {
    "id": 199,
    "text": "acc \"nil\"",
    "type": "statement:functioncall"
  }, {
    "id": 200,
    "text": "function x.number()   acc (tostring (adt)) end",
    "type": "statement:globalfunction"
  }, {
    "id": 201,
    "text": "acc (tostring (adt))",
    "type": "statement:functioncall"
  }, {
    "id": 202,
    "text": "function x.string()   acc ((string.format (\"%q\", adt):gsub(\"\\\\\\n\", \"\\\\n\"))) end",
    "type": "statement:globalfunction"
  }, {
    "id": 203,
    "text": "acc ((string.format (\"%q\", adt):gsub(\"\\\\\\n\", \"\\\\n\")))",
    "type": "statement:functioncall"
  }, {
    "id": 204,
    "text": "function x.boolean()  acc (adt and \"true\" or \"false\") end",
    "type": "statement:globalfunction"
  }, {
    "id": 205,
    "text": "acc (adt and \"true\" or \"false\")",
    "type": "statement:functioncall"
  }, {
    "id": 206,
    "text": "function x.table()\r\n         if nested[adt] then acc(tostring(adt)); return end\r\n         nested[adt]  = true\r\n\r\n\r\n         local has_tag  = HANDLE_TAG and valid_id(adt.tag)\r\n         local alen     = #adt\r\n         local has_arr  = alen>0\r\n         local has_hash = false\r\n\r\n         if has_tag then acc(\"`\"); acc(adt.tag) end\r\n\r\n         -- First pass: handle hash-part\r\n         if PRINT_HASH then\r\n            for k, v in pairs(adt) do\r\n               -- pass if the key belongs to the array-part or is the \"tag\" field\r\n               if not (k==\"tag\" and HANDLE_TAG) and \r\n                  not (type(k)==\"number\" and k<=alen and math.fmod(k,1)==0) then\r\n\r\n                  -- Is it the first time we parse a hash pair?\r\n                  if not has_hash then \r\n                     acc \"{ \"\r\n                     if not FIX_INDENT then indent = current_offset end\r\n                  else acc \", \" end\r\n\r\n                  -- Determine whether a newline is required\r\n                  local is_id, expected_len = valid_id(k)\r\n                  if is_id then expected_len = #k + xlen (v, nested) + #\" = , \"\r\n                  else expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \" end\r\n                  if has_hash and expected_len + current_offset > LINE_MAX\r\n                  then acc_newline() end\r\n                  \r\n                  -- Print the key\r\n                  if is_id then acc(k); acc \" = \" \r\n                  else  acc \"[\"; rec (k, nested, indent+(FIX_INDENT or 0)); acc \"] = \" end\r\n\r\n                  -- Print the value\r\n                  rec (v, nested, indent+(FIX_INDENT or 0))\r\n                  has_hash = true\r\n               end\r\n            end\r\n         end\r\n\r\n         -- Now we know whether there's a hash-part, an array-part, and a tag.\r\n         -- Tag and hash-part are already printed if they're present.\r\n         if not has_tag and not has_hash and not has_arr then acc \"{ }\"; \r\n         elseif has_tag and not has_hash and not has_arr then -- nothing, tag already in acc\r\n         else \r\n            assert (has_hash or has_arr)\r\n            local no_brace = false\r\n            if has_hash and has_arr then acc \", \" \r\n            elseif has_tag and not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n               -- No brace required; don't print \"{\", remember not to print \"}\"\r\n               acc (\" \"); rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               no_brace = true\r\n            elseif not has_hash then\r\n               -- Braces required, but not opened by hash-part handler yet\r\n               acc \"{ \"\r\n               if not FIX_INDENT then indent = current_offset end\r\n            end\r\n\r\n            -- 2nd pass: array-part\r\n            if not no_brace and has_arr then \r\n               rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               for i=2, alen do \r\n                  acc \", \";                   \r\n                  if   current_offset + xlen (adt[i], { }) > LINE_MAX\r\n                  then acc_newline() end\r\n                  rec (adt[i], nested, indent+(FIX_INDENT or 0)) \r\n               end\r\n            end\r\n            if not no_brace then acc \" }\" end\r\n         end\r\n         nested[adt] = false -- No more nested calls\r\n      end",
    "type": "statement:globalfunction"
  }, {
    "id": 207,
    "text": "if nested[adt] then acc(tostring(adt)); return end",
    "type": "statement:if"
  }, {
    "id": 208,
    "text": "acc(tostring(adt))",
    "type": "statement:functioncall"
  }, {
    "id": 209,
    "text": "nested[adt]  = true",
    "type": "statement:assign"
  }, {
    "id": 210,
    "text": "if has_tag then acc(\"`\"); acc(adt.tag) end",
    "type": "statement:if"
  }, {
    "id": 211,
    "text": "acc(\"`\")",
    "type": "statement:functioncall"
  }, {
    "id": 212,
    "text": "acc(adt.tag)",
    "type": "statement:functioncall"
  }, {
    "id": 213,
    "text": "if PRINT_HASH then\r\n            for k, v in pairs(adt) do\r\n               -- pass if the key belongs to the array-part or is the \"tag\" field\r\n               if not (k==\"tag\" and HANDLE_TAG) and \r\n                  not (type(k)==\"number\" and k<=alen and math.fmod(k,1)==0) then\r\n\r\n                  -- Is it the first time we parse a hash pair?\r\n                  if not has_hash then \r\n                     acc \"{ \"\r\n                     if not FIX_INDENT then indent = current_offset end\r\n                  else acc \", \" end\r\n\r\n                  -- Determine whether a newline is required\r\n                  local is_id, expected_len = valid_id(k)\r\n                  if is_id then expected_len = #k + xlen (v, nested) + #\" = , \"\r\n                  else expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \" end\r\n                  if has_hash and expected_len + current_offset > LINE_MAX\r\n                  then acc_newline() end\r\n                  \r\n                  -- Print the key\r\n                  if is_id then acc(k); acc \" = \" \r\n                  else  acc \"[\"; rec (k, nested, indent+(FIX_INDENT or 0)); acc \"] = \" end\r\n\r\n                  -- Print the value\r\n                  rec (v, nested, indent+(FIX_INDENT or 0))\r\n                  has_hash = true\r\n               end\r\n            end\r\n         end",
    "type": "statement:if"
  }, {
    "id": 214,
    "text": "for k, v in pairs(adt) do\r\n               -- pass if the key belongs to the array-part or is the \"tag\" field\r\n               if not (k==\"tag\" and HANDLE_TAG) and \r\n                  not (type(k)==\"number\" and k<=alen and math.fmod(k,1)==0) then\r\n\r\n                  -- Is it the first time we parse a hash pair?\r\n                  if not has_hash then \r\n                     acc \"{ \"\r\n                     if not FIX_INDENT then indent = current_offset end\r\n                  else acc \", \" end\r\n\r\n                  -- Determine whether a newline is required\r\n                  local is_id, expected_len = valid_id(k)\r\n                  if is_id then expected_len = #k + xlen (v, nested) + #\" = , \"\r\n                  else expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \" end\r\n                  if has_hash and expected_len + current_offset > LINE_MAX\r\n                  then acc_newline() end\r\n                  \r\n                  -- Print the key\r\n                  if is_id then acc(k); acc \" = \" \r\n                  else  acc \"[\"; rec (k, nested, indent+(FIX_INDENT or 0)); acc \"] = \" end\r\n\r\n                  -- Print the value\r\n                  rec (v, nested, indent+(FIX_INDENT or 0))\r\n                  has_hash = true\r\n               end\r\n            end",
    "type": "statement:genericfor"
  }, {
    "id": 215,
    "text": "if not (k==\"tag\" and HANDLE_TAG) and \r\n                  not (type(k)==\"number\" and k<=alen and math.fmod(k,1)==0) then\r\n\r\n                  -- Is it the first time we parse a hash pair?\r\n                  if not has_hash then \r\n                     acc \"{ \"\r\n                     if not FIX_INDENT then indent = current_offset end\r\n                  else acc \", \" end\r\n\r\n                  -- Determine whether a newline is required\r\n                  local is_id, expected_len = valid_id(k)\r\n                  if is_id then expected_len = #k + xlen (v, nested) + #\" = , \"\r\n                  else expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \" end\r\n                  if has_hash and expected_len + current_offset > LINE_MAX\r\n                  then acc_newline() end\r\n                  \r\n                  -- Print the key\r\n                  if is_id then acc(k); acc \" = \" \r\n                  else  acc \"[\"; rec (k, nested, indent+(FIX_INDENT or 0)); acc \"] = \" end\r\n\r\n                  -- Print the value\r\n                  rec (v, nested, indent+(FIX_INDENT or 0))\r\n                  has_hash = true\r\n               end",
    "type": "statement:if"
  }, {
    "id": 216,
    "text": "if not has_hash then \r\n                     acc \"{ \"\r\n                     if not FIX_INDENT then indent = current_offset end\r\n                  else acc \", \" end",
    "type": "statement:if"
  }, {
    "id": 217,
    "text": "acc \"{ \"",
    "type": "statement:functioncall"
  }, {
    "id": 218,
    "text": "acc \", \"",
    "type": "statement:functioncall"
  }, {
    "id": 219,
    "text": "local is_id, expected_len = valid_id(k)",
    "type": "statement:localassign"
  }, {
    "id": 220,
    "text": "if is_id then expected_len = #k + xlen (v, nested) + #\" = , \"\r\n                  else expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \" end",
    "type": "statement:if"
  }, {
    "id": 221,
    "text": "expected_len = #k + xlen (v, nested) + #\" = , \"",
    "type": "statement:assign"
  }, {
    "id": 222,
    "text": "expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \"",
    "type": "statement:assign"
  }, {
    "id": 223,
    "text": "if has_hash and expected_len + current_offset > LINE_MAX\r\n                  then acc_newline() end",
    "type": "statement:if"
  }, {
    "id": 224,
    "text": "acc_newline()",
    "type": "statement:functioncall"
  }, {
    "id": 225,
    "text": "if is_id then acc(k); acc \" = \" \r\n                  else  acc \"[\"; rec (k, nested, indent+(FIX_INDENT or 0)); acc \"] = \" end",
    "type": "statement:if"
  }, {
    "id": 226,
    "text": "acc(k)",
    "type": "statement:functioncall"
  }, {
    "id": 227,
    "text": "acc \" = \"",
    "type": "statement:functioncall"
  }, {
    "id": 228,
    "text": "acc \"[\"",
    "type": "statement:functioncall"
  }, {
    "id": 229,
    "text": "rec (k, nested, indent+(FIX_INDENT or 0))",
    "type": "statement:functioncall"
  }, {
    "id": 230,
    "text": "acc \"] = \"",
    "type": "statement:functioncall"
  }, {
    "id": 231,
    "text": "rec (v, nested, indent+(FIX_INDENT or 0))",
    "type": "statement:functioncall"
  }, {
    "id": 232,
    "text": "if not has_tag and not has_hash and not has_arr then acc \"{ }\"; \r\n         elseif has_tag and not has_hash and not has_arr then -- nothing, tag already in acc\r\n         else \r\n            assert (has_hash or has_arr)\r\n            local no_brace = false\r\n            if has_hash and has_arr then acc \", \" \r\n            elseif has_tag and not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n               -- No brace required; don't print \"{\", remember not to print \"}\"\r\n               acc (\" \"); rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               no_brace = true\r\n            elseif not has_hash then\r\n               -- Braces required, but not opened by hash-part handler yet\r\n               acc \"{ \"\r\n               if not FIX_INDENT then indent = current_offset end\r\n            end\r\n\r\n            -- 2nd pass: array-part\r\n            if not no_brace and has_arr then \r\n               rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               for i=2, alen do \r\n                  acc \", \";                   \r\n                  if   current_offset + xlen (adt[i], { }) > LINE_MAX\r\n                  then acc_newline() end\r\n                  rec (adt[i], nested, indent+(FIX_INDENT or 0)) \r\n               end\r\n            end\r\n            if not no_brace then acc \" }\" end\r\n         end",
    "type": "statement:if"
  }, {
    "id": 233,
    "text": "acc \"{ }\"",
    "type": "statement:functioncall"
  }, {
    "id": 234,
    "text": "assert (has_hash or has_arr)",
    "type": "statement:functioncall"
  }, {
    "id": 235,
    "text": "local no_brace = false",
    "type": "statement:localassign"
  }, {
    "id": 236,
    "text": "if has_hash and has_arr then acc \", \" \r\n            elseif has_tag and not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n               -- No brace required; don't print \"{\", remember not to print \"}\"\r\n               acc (\" \"); rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               no_brace = true\r\n            elseif not has_hash then\r\n               -- Braces required, but not opened by hash-part handler yet\r\n               acc \"{ \"\r\n               if not FIX_INDENT then indent = current_offset end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 237,
    "text": "acc (\" \")",
    "type": "statement:functioncall"
  }, {
    "id": 238,
    "text": "rec (adt[1], nested, indent+(FIX_INDENT or 0))",
    "type": "statement:functioncall"
  }, {
    "id": 239,
    "text": "no_brace = true",
    "type": "statement:assign"
  }, {
    "id": 240,
    "text": "if not no_brace and has_arr then \r\n               rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               for i=2, alen do \r\n                  acc \", \";                   \r\n                  if   current_offset + xlen (adt[i], { }) > LINE_MAX\r\n                  then acc_newline() end\r\n                  rec (adt[i], nested, indent+(FIX_INDENT or 0)) \r\n               end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 241,
    "text": "for i=2, alen do \r\n                  acc \", \";                   \r\n                  if   current_offset + xlen (adt[i], { }) > LINE_MAX\r\n                  then acc_newline() end\r\n                  rec (adt[i], nested, indent+(FIX_INDENT or 0)) \r\n               end",
    "type": "statement:numericfor"
  }, {
    "id": 242,
    "text": "if   current_offset + xlen (adt[i], { }) > LINE_MAX\r\n                  then acc_newline() end",
    "type": "statement:if"
  }, {
    "id": 243,
    "text": "rec (adt[i], nested, indent+(FIX_INDENT or 0))",
    "type": "statement:functioncall"
  }, {
    "id": 244,
    "text": "if not no_brace then acc \" }\" end",
    "type": "statement:if"
  }, {
    "id": 245,
    "text": "acc \" }\"",
    "type": "statement:functioncall"
  }, {
    "id": 246,
    "text": "local y = x[type(adt)]",
    "type": "statement:localassign"
  }, {
    "id": 247,
    "text": "if y then y() else acc(tostring(adt)) end",
    "type": "statement:if"
  }, {
    "id": 248,
    "text": "y()",
    "type": "statement:functioncall"
  }, {
    "id": 249,
    "text": "current_offset = INITIAL_INDENT or 0",
    "type": "statement:assign"
  }, {
    "id": 250,
    "text": "rec(t, { }, 0)",
    "type": "statement:functioncall"
  }, {
    "id": 251,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 252,
    "text": "local function acc(...)    -- Accumulate a bit of string\r\n      local x = table.concat{...}\r\n      current_offset = current_offset + #x\r\n      table.insert(acc_list, x) \r\n   end",
    "type": "function"
  }, {
    "id": 253,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 254,
    "text": "local function valid_id(x)\r\n      -- FIXME: we should also reject keywords; but the list of\r\n      -- current keywords is not fixed in metalua...\r\n      return type(x) == \"string\" \r\n         and string['match'](x, \"^[a-zA-Z_][a-zA-Z0-9_]*$\")\r\n   end",
    "type": "function"
  }, {
    "id": 255,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 256,
    "text": "local function xlen(x, nested)\r\n      nested = nested or { }\r\n      if x==nil then return #\"nil\" end\r\n      --if nested[x] then return #tostring(x) end -- already done in table\r\n      local len = xlen_cache[x]\r\n      if len then return len end\r\n      local f = xlen_type[type(x)]\r\n      if not f then return #tostring(x) end\r\n      len = f (x, nested) \r\n      xlen_cache[x] = len\r\n      return len\r\n   end",
    "type": "function"
  }, {
    "id": 257,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 258,
    "text": "function() return 0 end",
    "type": "function"
  }, {
    "id": 259,
    "text": "function () return 3 end",
    "type": "function"
  }, {
    "id": 260,
    "text": "function xlen_type.number  (x) return #tostring(x) end",
    "type": "function"
  }, {
    "id": 261,
    "text": "function xlen_type.boolean (x) return x and 4 or 5 end",
    "type": "function"
  }, {
    "id": 262,
    "text": "function xlen_type.string  (x) return #string.format(\"%q\",x) end",
    "type": "function"
  }, {
    "id": 263,
    "text": "function xlen_type.table   (adt, nested)\r\n\r\n      -- Circular references detection\r\n      if nested [adt] then return #tostring(adt) end\r\n      nested [adt] = true\r\n\r\n      local has_tag  = HANDLE_TAG and valid_id(adt.tag)\r\n      local alen     = #adt\r\n      local has_arr  = alen>0\r\n      local has_hash = false\r\n      local x = 0\r\n      \r\n      if PRINT_HASH then\r\n         -- first pass: count hash-part\r\n         for k, v in pairs(adt) do\r\n            if k==\"tag\" and has_tag then \r\n               -- this is the tag -> do nothing!\r\n            elseif type(k)==\"number\" and k<=alen and math.fmod(k,1)==0 then \r\n               -- array-part pair -> do nothing!\r\n            else\r\n               has_hash = true\r\n               if valid_id(k) then x=x+#k\r\n               else x = x + xlen (k, nested) + 2 end -- count surrounding brackets\r\n               x = x + xlen (v, nested) + 5          -- count \" = \" and \", \"\r\n            end\r\n         end\r\n      end\r\n\r\n      for i = 1, alen do x = x + xlen (adt[i], nested) + 2 end -- count \", \"\r\n      \r\n      nested[adt] = false -- No more nested calls\r\n\r\n      if not (has_tag or has_arr or has_hash) then return 3 end\r\n      if has_tag then x=x+#adt.tag+1 end\r\n      if not (has_arr or has_hash) then return x end\r\n      if not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n         return x-2 -- substract extraneous \", \"\r\n      end\r\n      return x+2 -- count \"{ \" and \" }\", substract extraneous \", \"\r\n   end",
    "type": "function"
  }, {
    "id": 264,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 265,
    "text": "local function rec (adt, nested, indent)\r\n      if not FIX_INDENT then indent = current_offset end\r\n      local function acc_newline()\r\n         acc (\"\\n\"); acc (string.rep (\" \", indent)) \r\n         current_offset = indent\r\n      end\r\n      local x = { }\r\n      x[\"nil\"] = function() acc \"nil\" end\r\n      function x.number()   acc (tostring (adt)) end\r\n      --function x.string()   acc (string.format (\"%q\", adt)) end\r\n      function x.string()   acc ((string.format (\"%q\", adt):gsub(\"\\\\\\n\", \"\\\\n\"))) end\r\n      function x.boolean()  acc (adt and \"true\" or \"false\") end\r\n      function x.table()\r\n         if nested[adt] then acc(tostring(adt)); return end\r\n         nested[adt]  = true\r\n\r\n\r\n         local has_tag  = HANDLE_TAG and valid_id(adt.tag)\r\n         local alen     = #adt\r\n         local has_arr  = alen>0\r\n         local has_hash = false\r\n\r\n         if has_tag then acc(\"`\"); acc(adt.tag) end\r\n\r\n         -- First pass: handle hash-part\r\n         if PRINT_HASH then\r\n            for k, v in pairs(adt) do\r\n               -- pass if the key belongs to the array-part or is the \"tag\" field\r\n               if not (k==\"tag\" and HANDLE_TAG) and \r\n                  not (type(k)==\"number\" and k<=alen and math.fmod(k,1)==0) then\r\n\r\n                  -- Is it the first time we parse a hash pair?\r\n                  if not has_hash then \r\n                     acc \"{ \"\r\n                     if not FIX_INDENT then indent = current_offset end\r\n                  else acc \", \" end\r\n\r\n                  -- Determine whether a newline is required\r\n                  local is_id, expected_len = valid_id(k)\r\n                  if is_id then expected_len = #k + xlen (v, nested) + #\" = , \"\r\n                  else expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \" end\r\n                  if has_hash and expected_len + current_offset > LINE_MAX\r\n                  then acc_newline() end\r\n                  \r\n                  -- Print the key\r\n                  if is_id then acc(k); acc \" = \" \r\n                  else  acc \"[\"; rec (k, nested, indent+(FIX_INDENT or 0)); acc \"] = \" end\r\n\r\n                  -- Print the value\r\n                  rec (v, nested, indent+(FIX_INDENT or 0))\r\n                  has_hash = true\r\n               end\r\n            end\r\n         end\r\n\r\n         -- Now we know whether there's a hash-part, an array-part, and a tag.\r\n         -- Tag and hash-part are already printed if they're present.\r\n         if not has_tag and not has_hash and not has_arr then acc \"{ }\"; \r\n         elseif has_tag and not has_hash and not has_arr then -- nothing, tag already in acc\r\n         else \r\n            assert (has_hash or has_arr)\r\n            local no_brace = false\r\n            if has_hash and has_arr then acc \", \" \r\n            elseif has_tag and not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n               -- No brace required; don't print \"{\", remember not to print \"}\"\r\n               acc (\" \"); rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               no_brace = true\r\n            elseif not has_hash then\r\n               -- Braces required, but not opened by hash-part handler yet\r\n               acc \"{ \"\r\n               if not FIX_INDENT then indent = current_offset end\r\n            end\r\n\r\n            -- 2nd pass: array-part\r\n            if not no_brace and has_arr then \r\n               rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               for i=2, alen do \r\n                  acc \", \";                   \r\n                  if   current_offset + xlen (adt[i], { }) > LINE_MAX\r\n                  then acc_newline() end\r\n                  rec (adt[i], nested, indent+(FIX_INDENT or 0)) \r\n               end\r\n            end\r\n            if not no_brace then acc \" }\" end\r\n         end\r\n         nested[adt] = false -- No more nested calls\r\n      end\r\n      local y = x[type(adt)]\r\n      if y then y() else acc(tostring(adt)) end\r\n   end",
    "type": "function"
  }, {
    "id": 266,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 267,
    "text": "local function acc_newline()\r\n         acc (\"\\n\"); acc (string.rep (\" \", indent)) \r\n         current_offset = indent\r\n      end",
    "type": "function"
  }, {
    "id": 268,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 269,
    "text": "function() acc \"nil\" end",
    "type": "function"
  }, {
    "id": 270,
    "text": "function x.number()   acc (tostring (adt)) end",
    "type": "function"
  }, {
    "id": 271,
    "text": "function x.string()   acc ((string.format (\"%q\", adt):gsub(\"\\\\\\n\", \"\\\\n\"))) end",
    "type": "function"
  }, {
    "id": 272,
    "text": "function x.boolean()  acc (adt and \"true\" or \"false\") end",
    "type": "function"
  }, {
    "id": 273,
    "text": "function x.table()\r\n         if nested[adt] then acc(tostring(adt)); return end\r\n         nested[adt]  = true\r\n\r\n\r\n         local has_tag  = HANDLE_TAG and valid_id(adt.tag)\r\n         local alen     = #adt\r\n         local has_arr  = alen>0\r\n         local has_hash = false\r\n\r\n         if has_tag then acc(\"`\"); acc(adt.tag) end\r\n\r\n         -- First pass: handle hash-part\r\n         if PRINT_HASH then\r\n            for k, v in pairs(adt) do\r\n               -- pass if the key belongs to the array-part or is the \"tag\" field\r\n               if not (k==\"tag\" and HANDLE_TAG) and \r\n                  not (type(k)==\"number\" and k<=alen and math.fmod(k,1)==0) then\r\n\r\n                  -- Is it the first time we parse a hash pair?\r\n                  if not has_hash then \r\n                     acc \"{ \"\r\n                     if not FIX_INDENT then indent = current_offset end\r\n                  else acc \", \" end\r\n\r\n                  -- Determine whether a newline is required\r\n                  local is_id, expected_len = valid_id(k)\r\n                  if is_id then expected_len = #k + xlen (v, nested) + #\" = , \"\r\n                  else expected_len = xlen (k, nested) + \r\n                                      xlen (v, nested) + #\"[] = , \" end\r\n                  if has_hash and expected_len + current_offset > LINE_MAX\r\n                  then acc_newline() end\r\n                  \r\n                  -- Print the key\r\n                  if is_id then acc(k); acc \" = \" \r\n                  else  acc \"[\"; rec (k, nested, indent+(FIX_INDENT or 0)); acc \"] = \" end\r\n\r\n                  -- Print the value\r\n                  rec (v, nested, indent+(FIX_INDENT or 0))\r\n                  has_hash = true\r\n               end\r\n            end\r\n         end\r\n\r\n         -- Now we know whether there's a hash-part, an array-part, and a tag.\r\n         -- Tag and hash-part are already printed if they're present.\r\n         if not has_tag and not has_hash and not has_arr then acc \"{ }\"; \r\n         elseif has_tag and not has_hash and not has_arr then -- nothing, tag already in acc\r\n         else \r\n            assert (has_hash or has_arr)\r\n            local no_brace = false\r\n            if has_hash and has_arr then acc \", \" \r\n            elseif has_tag and not has_hash and alen==1 and type(adt[1])~=\"table\" then\r\n               -- No brace required; don't print \"{\", remember not to print \"}\"\r\n               acc (\" \"); rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               no_brace = true\r\n            elseif not has_hash then\r\n               -- Braces required, but not opened by hash-part handler yet\r\n               acc \"{ \"\r\n               if not FIX_INDENT then indent = current_offset end\r\n            end\r\n\r\n            -- 2nd pass: array-part\r\n            if not no_brace and has_arr then \r\n               rec (adt[1], nested, indent+(FIX_INDENT or 0))\r\n               for i=2, alen do \r\n                  acc \", \";                   \r\n                  if   current_offset + xlen (adt[i], { }) > LINE_MAX\r\n                  then acc_newline() end\r\n                  rec (adt[i], nested, indent+(FIX_INDENT or 0)) \r\n               end\r\n            end\r\n            if not no_brace then acc \" }\" end\r\n         end\r\n         nested[adt] = false -- No more nested calls\r\n      end",
    "type": "function"
  }, {
    "id": 274,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 275,
    "text": "function table.print(...) return print(table.tostring(...)) end",
    "type": "function"
  }, {
    "id": 276,
    "text": "",
    "type": "function container"
  }, {
    "id": 277,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 278,
    "text": "ipairs",
    "type": "global function"
  }, {
    "id": 279,
    "text": "print",
    "type": "global function"
  }, {
    "id": 280,
    "text": "fmod",
    "type": "global function"
  }, {
    "id": 281,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 282,
    "text": "type",
    "type": "global function"
  }, {
    "id": 283,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 284,
    "text": "select",
    "type": "global function"
  }, {
    "id": 285,
    "text": "unpack",
    "type": "global function"
  }, {
    "id": 286,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 287,
    "text": "tonumber",
    "type": "global function"
  }, {
    "id": 288,
    "text": "y",
    "type": "global function"
  }, {
    "id": 289,
    "text": "next",
    "type": "global function"
  }, {
    "id": 290,
    "text": "format",
    "type": "global function"
  }, {
    "id": 291,
    "text": "string['match']",
    "type": "global function"
  }, {
    "id": 292,
    "text": "getmetatable",
    "type": "global function"
  }, {
    "id": 293,
    "text": "values",
    "type": "global function"
  }, {
    "id": 294,
    "text": "f",
    "type": "global function"
  }, {
    "id": 295,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 296,
    "text": "max",
    "type": "global function"
  }, {
    "id": 297,
    "text": "ti",
    "type": "global function"
  }, {
    "id": 298,
    "text": "rep",
    "type": "global function"
  }, {
    "id": 299,
    "text": "setmetatable",
    "type": "global function"
  }, {
    "id": 300,
    "text": "",
    "type": "global variable"
  }, {
    "id": 301,
    "text": "",
    "type": "global variable"
  }, {
    "id": 302,
    "text": "",
    "type": "variable container"
  }, {
    "id": 303,
    "text": "",
    "type": "require container"
  }, {
    "id": 304,
    "text": "",
    "type": "interface container"
  }, {
    "id": 305,
    "text": "",
    "type": "interface"
  } ]
}