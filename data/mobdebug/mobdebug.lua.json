{
  "_filename": "mobdebug.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/mobdebug/src/mobdebug.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "calls",
    "to": 577
  }, {
    "from": 3,
    "label": "has",
    "to": 4
  }, {
    "from": 3,
    "label": "has",
    "to": 5
  }, {
    "from": 5,
    "label": "has",
    "to": 6
  }, {
    "from": 5,
    "label": "has",
    "to": 7
  }, {
    "from": 5,
    "label": "has",
    "to": 8
  }, {
    "from": 3,
    "label": "has",
    "to": 9
  }, {
    "from": 3,
    "label": "has",
    "to": 9
  }, {
    "from": 3,
    "label": "has",
    "to": 10
  }, {
    "from": 11,
    "label": "has",
    "to": 9
  }, {
    "from": 12,
    "label": "has",
    "to": 13
  }, {
    "from": 12,
    "label": "has",
    "to": 14
  }, {
    "from": 14,
    "label": "has",
    "to": 15
  }, {
    "from": 12,
    "label": "has",
    "to": 9
  }, {
    "from": 12,
    "label": "has",
    "to": 16
  }, {
    "from": 17,
    "label": "has",
    "to": 18
  }, {
    "from": 17,
    "label": "has",
    "to": 19
  }, {
    "from": 19,
    "label": "has",
    "to": 20
  }, {
    "from": 17,
    "label": "has",
    "to": 21
  }, {
    "from": 17,
    "label": "has",
    "to": 22
  }, {
    "from": 23,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 25
  }, {
    "from": 24,
    "label": "has",
    "to": 26
  }, {
    "from": 24,
    "label": "has",
    "to": 27
  }, {
    "from": 24,
    "label": "has",
    "to": 28
  }, {
    "from": 24,
    "label": "has",
    "to": 29
  }, {
    "from": 24,
    "label": "has",
    "to": 30
  }, {
    "from": 24,
    "label": "has",
    "to": 31
  }, {
    "from": 31,
    "label": "has",
    "to": 9
  }, {
    "from": 31,
    "label": "has",
    "to": 32
  }, {
    "from": 32,
    "label": "has",
    "to": 33
  }, {
    "from": 32,
    "label": "has",
    "to": 34
  }, {
    "from": 31,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 35
  }, {
    "from": 35,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 36
  }, {
    "from": 36,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 37
  }, {
    "from": 37,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 38
  }, {
    "from": 38,
    "label": "has",
    "to": 39
  }, {
    "from": 38,
    "label": "has",
    "to": 40
  }, {
    "from": 38,
    "label": "has",
    "to": 41
  }, {
    "from": 38,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 42
  }, {
    "from": 42,
    "label": "has",
    "to": 43
  }, {
    "from": 42,
    "label": "has",
    "to": 44
  }, {
    "from": 44,
    "label": "has",
    "to": 9
  }, {
    "from": 42,
    "label": "has",
    "to": 45
  }, {
    "from": 45,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 46
  }, {
    "from": 46,
    "label": "has",
    "to": 47
  }, {
    "from": 46,
    "label": "has",
    "to": 48
  }, {
    "from": 46,
    "label": "has",
    "to": 49
  }, {
    "from": 46,
    "label": "has",
    "to": 50
  }, {
    "from": 50,
    "label": "has",
    "to": 51
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 52
  }, {
    "from": 52,
    "label": "has",
    "to": 9
  }, {
    "from": 52,
    "label": "has",
    "to": 53
  }, {
    "from": 52,
    "label": "has",
    "to": 54
  }, {
    "from": 54,
    "label": "has",
    "to": 55
  }, {
    "from": 54,
    "label": "has",
    "to": 56
  }, {
    "from": 52,
    "label": "has",
    "to": 57
  }, {
    "from": 46,
    "label": "has",
    "to": 58
  }, {
    "from": 58,
    "label": "has",
    "to": 59
  }, {
    "from": 58,
    "label": "has",
    "to": 53
  }, {
    "from": 58,
    "label": "has",
    "to": 60
  }, {
    "from": 58,
    "label": "has",
    "to": 61
  }, {
    "from": 58,
    "label": "has",
    "to": 62
  }, {
    "from": 62,
    "label": "has",
    "to": 63
  }, {
    "from": 58,
    "label": "has",
    "to": 64
  }, {
    "from": 64,
    "label": "has",
    "to": 65
  }, {
    "from": 64,
    "label": "has",
    "to": 66
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 67,
    "label": "has",
    "to": 68
  }, {
    "from": 67,
    "label": "has",
    "to": 69
  }, {
    "from": 58,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 58,
    "label": "has",
    "to": 72
  }, {
    "from": 72,
    "label": "has",
    "to": 73
  }, {
    "from": 58,
    "label": "has",
    "to": 74
  }, {
    "from": 58,
    "label": "has",
    "to": 75
  }, {
    "from": 75,
    "label": "has",
    "to": 76
  }, {
    "from": 75,
    "label": "has",
    "to": 77
  }, {
    "from": 77,
    "label": "has",
    "to": 78
  }, {
    "from": 78,
    "label": "has",
    "to": 79
  }, {
    "from": 78,
    "label": "has",
    "to": 80
  }, {
    "from": 78,
    "label": "has",
    "to": 81
  }, {
    "from": 77,
    "label": "has",
    "to": 79
  }, {
    "from": 77,
    "label": "has",
    "to": 82
  }, {
    "from": 77,
    "label": "has",
    "to": 83
  }, {
    "from": 77,
    "label": "has",
    "to": 84
  }, {
    "from": 58,
    "label": "has",
    "to": 85
  }, {
    "from": 58,
    "label": "has",
    "to": 86
  }, {
    "from": 58,
    "label": "has",
    "to": 87
  }, {
    "from": 58,
    "label": "has",
    "to": 88
  }, {
    "from": 58,
    "label": "has",
    "to": 53
  }, {
    "from": 58,
    "label": "has",
    "to": 53
  }, {
    "from": 58,
    "label": "has",
    "to": 89
  }, {
    "from": 58,
    "label": "has",
    "to": 90
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 91
  }, {
    "from": 24,
    "label": "has",
    "to": 92
  }, {
    "from": 24,
    "label": "has",
    "to": 93
  }, {
    "from": 24,
    "label": "has",
    "to": 94
  }, {
    "from": 24,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 95
  }, {
    "from": 96,
    "label": "has",
    "to": 9
  }, {
    "from": 96,
    "label": "has",
    "to": 32
  }, {
    "from": 32,
    "label": "has",
    "to": 33
  }, {
    "from": 32,
    "label": "has",
    "to": 34
  }, {
    "from": 96,
    "label": "has",
    "to": 9
  }, {
    "from": 96,
    "label": "has",
    "to": 97
  }, {
    "from": 98,
    "label": "has",
    "to": 9
  }, {
    "from": 98,
    "label": "has",
    "to": 99
  }, {
    "from": 100,
    "label": "has",
    "to": 9
  }, {
    "from": 101,
    "label": "has",
    "to": 9
  }, {
    "from": 101,
    "label": "has",
    "to": 102
  }, {
    "from": 103,
    "label": "has",
    "to": 39
  }, {
    "from": 103,
    "label": "has",
    "to": 40
  }, {
    "from": 103,
    "label": "has",
    "to": 41
  }, {
    "from": 103,
    "label": "has",
    "to": 9
  }, {
    "from": 103,
    "label": "has",
    "to": 104
  }, {
    "from": 105,
    "label": "has",
    "to": 9
  }, {
    "from": 106,
    "label": "has",
    "to": 43
  }, {
    "from": 106,
    "label": "has",
    "to": 44
  }, {
    "from": 44,
    "label": "has",
    "to": 9
  }, {
    "from": 106,
    "label": "has",
    "to": 45
  }, {
    "from": 45,
    "label": "has",
    "to": 9
  }, {
    "from": 106,
    "label": "has",
    "to": 107
  }, {
    "from": 108,
    "label": "has",
    "to": 47
  }, {
    "from": 108,
    "label": "has",
    "to": 48
  }, {
    "from": 108,
    "label": "has",
    "to": 49
  }, {
    "from": 108,
    "label": "has",
    "to": 50
  }, {
    "from": 50,
    "label": "has",
    "to": 51
  }, {
    "from": 108,
    "label": "has",
    "to": 9
  }, {
    "from": 108,
    "label": "has",
    "to": 52
  }, {
    "from": 52,
    "label": "has",
    "to": 9
  }, {
    "from": 52,
    "label": "has",
    "to": 53
  }, {
    "from": 52,
    "label": "has",
    "to": 54
  }, {
    "from": 54,
    "label": "has",
    "to": 55
  }, {
    "from": 54,
    "label": "has",
    "to": 56
  }, {
    "from": 52,
    "label": "has",
    "to": 57
  }, {
    "from": 108,
    "label": "has",
    "to": 58
  }, {
    "from": 58,
    "label": "has",
    "to": 59
  }, {
    "from": 58,
    "label": "has",
    "to": 53
  }, {
    "from": 58,
    "label": "has",
    "to": 60
  }, {
    "from": 58,
    "label": "has",
    "to": 61
  }, {
    "from": 58,
    "label": "has",
    "to": 62
  }, {
    "from": 62,
    "label": "has",
    "to": 63
  }, {
    "from": 58,
    "label": "has",
    "to": 64
  }, {
    "from": 64,
    "label": "has",
    "to": 65
  }, {
    "from": 64,
    "label": "has",
    "to": 66
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 67,
    "label": "has",
    "to": 68
  }, {
    "from": 67,
    "label": "has",
    "to": 69
  }, {
    "from": 58,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 58,
    "label": "has",
    "to": 72
  }, {
    "from": 72,
    "label": "has",
    "to": 73
  }, {
    "from": 58,
    "label": "has",
    "to": 74
  }, {
    "from": 58,
    "label": "has",
    "to": 75
  }, {
    "from": 75,
    "label": "has",
    "to": 76
  }, {
    "from": 75,
    "label": "has",
    "to": 77
  }, {
    "from": 77,
    "label": "has",
    "to": 78
  }, {
    "from": 78,
    "label": "has",
    "to": 79
  }, {
    "from": 78,
    "label": "has",
    "to": 80
  }, {
    "from": 78,
    "label": "has",
    "to": 81
  }, {
    "from": 77,
    "label": "has",
    "to": 79
  }, {
    "from": 77,
    "label": "has",
    "to": 82
  }, {
    "from": 77,
    "label": "has",
    "to": 83
  }, {
    "from": 77,
    "label": "has",
    "to": 84
  }, {
    "from": 58,
    "label": "has",
    "to": 85
  }, {
    "from": 58,
    "label": "has",
    "to": 86
  }, {
    "from": 58,
    "label": "has",
    "to": 87
  }, {
    "from": 58,
    "label": "has",
    "to": 88
  }, {
    "from": 58,
    "label": "has",
    "to": 53
  }, {
    "from": 58,
    "label": "has",
    "to": 53
  }, {
    "from": 58,
    "label": "has",
    "to": 89
  }, {
    "from": 58,
    "label": "has",
    "to": 90
  }, {
    "from": 108,
    "label": "has",
    "to": 9
  }, {
    "from": 108,
    "label": "has",
    "to": 9
  }, {
    "from": 108,
    "label": "has",
    "to": 9
  }, {
    "from": 108,
    "label": "has",
    "to": 9
  }, {
    "from": 108,
    "label": "has",
    "to": 9
  }, {
    "from": 108,
    "label": "has",
    "to": 9
  }, {
    "from": 108,
    "label": "has",
    "to": 109
  }, {
    "from": 110,
    "label": "has",
    "to": 111
  }, {
    "from": 111,
    "label": "has",
    "to": 9
  }, {
    "from": 111,
    "label": "has",
    "to": 112
  }, {
    "from": 110,
    "label": "has",
    "to": 113
  }, {
    "from": 110,
    "label": "has",
    "to": 114
  }, {
    "from": 114,
    "label": "has",
    "to": 115
  }, {
    "from": 110,
    "label": "has",
    "to": 116
  }, {
    "from": 110,
    "label": "has",
    "to": 9
  }, {
    "from": 110,
    "label": "has",
    "to": 117
  }, {
    "from": 117,
    "label": "has",
    "to": 118
  }, {
    "from": 110,
    "label": "has",
    "to": 9
  }, {
    "from": 110,
    "label": "has",
    "to": 119
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 121,
    "label": "has",
    "to": 122
  }, {
    "from": 122,
    "label": "has",
    "to": 123
  }, {
    "from": 120,
    "label": "has",
    "to": 9
  }, {
    "from": 124,
    "label": "has",
    "to": 125
  }, {
    "from": 124,
    "label": "has",
    "to": 9
  }, {
    "from": 124,
    "label": "has",
    "to": 9
  }, {
    "from": 124,
    "label": "has",
    "to": 126
  }, {
    "from": 127,
    "label": "has",
    "to": 128
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 128,
    "label": "has",
    "to": 130
  }, {
    "from": 128,
    "label": "has",
    "to": 131
  }, {
    "from": 128,
    "label": "has",
    "to": 132
  }, {
    "from": 132,
    "label": "has",
    "to": 133
  }, {
    "from": 132,
    "label": "has",
    "to": 134
  }, {
    "from": 132,
    "label": "has",
    "to": 135
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 132,
    "label": "has",
    "to": 137
  }, {
    "from": 128,
    "label": "has",
    "to": 138
  }, {
    "from": 128,
    "label": "has",
    "to": 139
  }, {
    "from": 139,
    "label": "has",
    "to": 140
  }, {
    "from": 139,
    "label": "has",
    "to": 141
  }, {
    "from": 139,
    "label": "has",
    "to": 142
  }, {
    "from": 139,
    "label": "has",
    "to": 137
  }, {
    "from": 128,
    "label": "has",
    "to": 138
  }, {
    "from": 128,
    "label": "has",
    "to": 143
  }, {
    "from": 128,
    "label": "has",
    "to": 144
  }, {
    "from": 144,
    "label": "has",
    "to": 145
  }, {
    "from": 144,
    "label": "has",
    "to": 134
  }, {
    "from": 144,
    "label": "has",
    "to": 146
  }, {
    "from": 144,
    "label": "has",
    "to": 137
  }, {
    "from": 128,
    "label": "has",
    "to": 9
  }, {
    "from": 127,
    "label": "has",
    "to": 147
  }, {
    "from": 127,
    "label": "has",
    "to": 148
  }, {
    "from": 127,
    "label": "has",
    "to": 149
  }, {
    "from": 149,
    "label": "has",
    "to": 150
  }, {
    "from": 149,
    "label": "has",
    "to": 151
  }, {
    "from": 149,
    "label": "has",
    "to": 152
  }, {
    "from": 149,
    "label": "has",
    "to": 153
  }, {
    "from": 153,
    "label": "has",
    "to": 154
  }, {
    "from": 153,
    "label": "has",
    "to": 155
  }, {
    "from": 155,
    "label": "has",
    "to": 156
  }, {
    "from": 149,
    "label": "has",
    "to": 157
  }, {
    "from": 149,
    "label": "has",
    "to": 158
  }, {
    "from": 127,
    "label": "has",
    "to": 9
  }, {
    "from": 127,
    "label": "has",
    "to": 159
  }, {
    "from": 160,
    "label": "has",
    "to": 129
  }, {
    "from": 160,
    "label": "has",
    "to": 130
  }, {
    "from": 160,
    "label": "has",
    "to": 131
  }, {
    "from": 160,
    "label": "has",
    "to": 132
  }, {
    "from": 132,
    "label": "has",
    "to": 133
  }, {
    "from": 132,
    "label": "has",
    "to": 134
  }, {
    "from": 132,
    "label": "has",
    "to": 135
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 132,
    "label": "has",
    "to": 137
  }, {
    "from": 160,
    "label": "has",
    "to": 138
  }, {
    "from": 160,
    "label": "has",
    "to": 139
  }, {
    "from": 139,
    "label": "has",
    "to": 140
  }, {
    "from": 139,
    "label": "has",
    "to": 141
  }, {
    "from": 139,
    "label": "has",
    "to": 142
  }, {
    "from": 139,
    "label": "has",
    "to": 137
  }, {
    "from": 160,
    "label": "has",
    "to": 138
  }, {
    "from": 160,
    "label": "has",
    "to": 143
  }, {
    "from": 160,
    "label": "has",
    "to": 144
  }, {
    "from": 144,
    "label": "has",
    "to": 145
  }, {
    "from": 144,
    "label": "has",
    "to": 134
  }, {
    "from": 144,
    "label": "has",
    "to": 146
  }, {
    "from": 144,
    "label": "has",
    "to": 137
  }, {
    "from": 160,
    "label": "has",
    "to": 9
  }, {
    "from": 160,
    "label": "has",
    "to": 161
  }, {
    "from": 162,
    "label": "has",
    "to": 163
  }, {
    "from": 163,
    "label": "has",
    "to": 164
  }, {
    "from": 163,
    "label": "has",
    "to": 165
  }, {
    "from": 162,
    "label": "has",
    "to": 166
  }, {
    "from": 166,
    "label": "has",
    "to": 167
  }, {
    "from": 162,
    "label": "has",
    "to": 168
  }, {
    "from": 162,
    "label": "has",
    "to": 169
  }, {
    "from": 170,
    "label": "has",
    "to": 171
  }, {
    "from": 171,
    "label": "has",
    "to": 164
  }, {
    "from": 171,
    "label": "has",
    "to": 172
  }, {
    "from": 171,
    "label": "has",
    "to": 165
  }, {
    "from": 170,
    "label": "has",
    "to": 173
  }, {
    "from": 173,
    "label": "has",
    "to": 174
  }, {
    "from": 170,
    "label": "has",
    "to": 175
  }, {
    "from": 176,
    "label": "has",
    "to": 9
  }, {
    "from": 176,
    "label": "has",
    "to": 177
  }, {
    "from": 178,
    "label": "has",
    "to": 179
  }, {
    "from": 178,
    "label": "has",
    "to": 9
  }, {
    "from": 178,
    "label": "has",
    "to": 130
  }, {
    "from": 178,
    "label": "has",
    "to": 180
  }, {
    "from": 180,
    "label": "has",
    "to": 181
  }, {
    "from": 180,
    "label": "has",
    "to": 134
  }, {
    "from": 180,
    "label": "has",
    "to": 137
  }, {
    "from": 178,
    "label": "has",
    "to": 182
  }, {
    "from": 178,
    "label": "has",
    "to": 183
  }, {
    "from": 178,
    "label": "has",
    "to": 184
  }, {
    "from": 184,
    "label": "has",
    "to": 181
  }, {
    "from": 184,
    "label": "has",
    "to": 185
  }, {
    "from": 185,
    "label": "has",
    "to": 186
  }, {
    "from": 186,
    "label": "has",
    "to": 187
  }, {
    "from": 185,
    "label": "has",
    "to": 188
  }, {
    "from": 184,
    "label": "has",
    "to": 182
  }, {
    "from": 178,
    "label": "has",
    "to": 138
  }, {
    "from": 178,
    "label": "has",
    "to": 189
  }, {
    "from": 178,
    "label": "has",
    "to": 190
  }, {
    "from": 190,
    "label": "has",
    "to": 191
  }, {
    "from": 190,
    "label": "has",
    "to": 134
  }, {
    "from": 190,
    "label": "has",
    "to": 192
  }, {
    "from": 192,
    "label": "has",
    "to": 193
  }, {
    "from": 193,
    "label": "has",
    "to": 194
  }, {
    "from": 192,
    "label": "has",
    "to": 188
  }, {
    "from": 190,
    "label": "has",
    "to": 137
  }, {
    "from": 178,
    "label": "has",
    "to": 195
  }, {
    "from": 196,
    "label": "has",
    "to": 197
  }, {
    "from": 196,
    "label": "has",
    "to": 198
  }, {
    "from": 196,
    "label": "has",
    "to": 130
  }, {
    "from": 196,
    "label": "has",
    "to": 199
  }, {
    "from": 199,
    "label": "has",
    "to": 145
  }, {
    "from": 199,
    "label": "has",
    "to": 134
  }, {
    "from": 199,
    "label": "has",
    "to": 200
  }, {
    "from": 200,
    "label": "has",
    "to": 201
  }, {
    "from": 199,
    "label": "has",
    "to": 137
  }, {
    "from": 196,
    "label": "has",
    "to": 138
  }, {
    "from": 196,
    "label": "has",
    "to": 202
  }, {
    "from": 202,
    "label": "has",
    "to": 203
  }, {
    "from": 202,
    "label": "has",
    "to": 134
  }, {
    "from": 202,
    "label": "has",
    "to": 200
  }, {
    "from": 200,
    "label": "has",
    "to": 201
  }, {
    "from": 202,
    "label": "has",
    "to": 137
  }, {
    "from": 196,
    "label": "has",
    "to": 204
  }, {
    "from": 196,
    "label": "has",
    "to": 9
  }, {
    "from": 196,
    "label": "has",
    "to": 205
  }, {
    "from": 206,
    "label": "has",
    "to": 207
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 206,
    "label": "has",
    "to": 9
  }, {
    "from": 206,
    "label": "has",
    "to": 9
  }, {
    "from": 206,
    "label": "has",
    "to": 209
  }, {
    "from": 210,
    "label": "has",
    "to": 211
  }, {
    "from": 210,
    "label": "has",
    "to": 9
  }, {
    "from": 210,
    "label": "has",
    "to": 212
  }, {
    "from": 212,
    "label": "has",
    "to": 213
  }, {
    "from": 212,
    "label": "has",
    "to": 214
  }, {
    "from": 212,
    "label": "has",
    "to": 215
  }, {
    "from": 210,
    "label": "has",
    "to": 9
  }, {
    "from": 210,
    "label": "has",
    "to": 9
  }, {
    "from": 210,
    "label": "has",
    "to": 9
  }, {
    "from": 210,
    "label": "has",
    "to": 216
  }, {
    "from": 217,
    "label": "has",
    "to": 218
  }, {
    "from": 217,
    "label": "has",
    "to": 219
  }, {
    "from": 219,
    "label": "has",
    "to": 213
  }, {
    "from": 219,
    "label": "has",
    "to": 220
  }, {
    "from": 219,
    "label": "has",
    "to": 221
  }, {
    "from": 217,
    "label": "has",
    "to": 9
  }, {
    "from": 217,
    "label": "has",
    "to": 9
  }, {
    "from": 217,
    "label": "has",
    "to": 9
  }, {
    "from": 217,
    "label": "has",
    "to": 222
  }, {
    "from": 223,
    "label": "has",
    "to": 224
  }, {
    "from": 224,
    "label": "has",
    "to": 225
  }, {
    "from": 224,
    "label": "has",
    "to": 226
  }, {
    "from": 224,
    "label": "has",
    "to": 227
  }, {
    "from": 224,
    "label": "has",
    "to": 228
  }, {
    "from": 223,
    "label": "has",
    "to": 9
  }, {
    "from": 223,
    "label": "has",
    "to": 229
  }, {
    "from": 230,
    "label": "has",
    "to": 225
  }, {
    "from": 230,
    "label": "has",
    "to": 231
  }, {
    "from": 230,
    "label": "has",
    "to": 227
  }, {
    "from": 230,
    "label": "has",
    "to": 9
  }, {
    "from": 230,
    "label": "has",
    "to": 232
  }, {
    "from": 233,
    "label": "has",
    "to": 234
  }, {
    "from": 233,
    "label": "has",
    "to": 9
  }, {
    "from": 233,
    "label": "has",
    "to": 235
  }, {
    "from": 235,
    "label": "has",
    "to": 236
  }, {
    "from": 233,
    "label": "has",
    "to": 237
  }, {
    "from": 233,
    "label": "has",
    "to": 9
  }, {
    "from": 233,
    "label": "has",
    "to": 238
  }, {
    "from": 233,
    "label": "has",
    "to": 239
  }, {
    "from": 233,
    "label": "has",
    "to": 9
  }, {
    "from": 233,
    "label": "has",
    "to": 240
  }, {
    "from": 233,
    "label": "has",
    "to": 241
  }, {
    "from": 241,
    "label": "has",
    "to": 242
  }, {
    "from": 242,
    "label": "has",
    "to": 243
  }, {
    "from": 233,
    "label": "has",
    "to": 9
  }, {
    "from": 233,
    "label": "has",
    "to": 244
  }, {
    "from": 233,
    "label": "has",
    "to": 245
  }, {
    "from": 245,
    "label": "has",
    "to": 246
  }, {
    "from": 245,
    "label": "has",
    "to": 247
  }, {
    "from": 233,
    "label": "has",
    "to": 9
  }, {
    "from": 233,
    "label": "has",
    "to": 248
  }, {
    "from": 233,
    "label": "has",
    "to": 249
  }, {
    "from": 250,
    "label": "has",
    "to": 251
  }, {
    "from": 250,
    "label": "has",
    "to": 252
  }, {
    "from": 252,
    "label": "has",
    "to": 253
  }, {
    "from": 250,
    "label": "has",
    "to": 254
  }, {
    "from": 254,
    "label": "has",
    "to": 255
  }, {
    "from": 250,
    "label": "has",
    "to": 9
  }, {
    "from": 250,
    "label": "has",
    "to": 256
  }, {
    "from": 257,
    "label": "has",
    "to": 258
  }, {
    "from": 258,
    "label": "has",
    "to": 259
  }, {
    "from": 258,
    "label": "has",
    "to": 260
  }, {
    "from": 260,
    "label": "has",
    "to": 261
  }, {
    "from": 258,
    "label": "has",
    "to": 262
  }, {
    "from": 258,
    "label": "has",
    "to": 263
  }, {
    "from": 257,
    "label": "has",
    "to": 9
  }, {
    "from": 257,
    "label": "has",
    "to": 264
  }, {
    "from": 264,
    "label": "has",
    "to": 265
  }, {
    "from": 257,
    "label": "has",
    "to": 266
  }, {
    "from": 257,
    "label": "has",
    "to": 9
  }, {
    "from": 257,
    "label": "has",
    "to": 267
  }, {
    "from": 267,
    "label": "has",
    "to": 268
  }, {
    "from": 267,
    "label": "has",
    "to": 269
  }, {
    "from": 267,
    "label": "has",
    "to": 270
  }, {
    "from": 270,
    "label": "has",
    "to": 271
  }, {
    "from": 270,
    "label": "has",
    "to": 272
  }, {
    "from": 272,
    "label": "has",
    "to": 273
  }, {
    "from": 270,
    "label": "has",
    "to": 274
  }, {
    "from": 267,
    "label": "has",
    "to": 275
  }, {
    "from": 275,
    "label": "has",
    "to": 276
  }, {
    "from": 267,
    "label": "has",
    "to": 277
  }, {
    "from": 267,
    "label": "has",
    "to": 278
  }, {
    "from": 267,
    "label": "has",
    "to": 279
  }, {
    "from": 267,
    "label": "has",
    "to": 280
  }, {
    "from": 267,
    "label": "has",
    "to": 281
  }, {
    "from": 281,
    "label": "has",
    "to": 282
  }, {
    "from": 281,
    "label": "has",
    "to": 283
  }, {
    "from": 283,
    "label": "has",
    "to": 284
  }, {
    "from": 283,
    "label": "has",
    "to": 285
  }, {
    "from": 285,
    "label": "has",
    "to": 286
  }, {
    "from": 283,
    "label": "has",
    "to": 287
  }, {
    "from": 287,
    "label": "has",
    "to": 288
  }, {
    "from": 283,
    "label": "has",
    "to": 289
  }, {
    "from": 289,
    "label": "has",
    "to": 165
  }, {
    "from": 283,
    "label": "has",
    "to": 290
  }, {
    "from": 290,
    "label": "has",
    "to": 291
  }, {
    "from": 290,
    "label": "has",
    "to": 292
  }, {
    "from": 283,
    "label": "has",
    "to": 293
  }, {
    "from": 283,
    "label": "has",
    "to": 294
  }, {
    "from": 281,
    "label": "has",
    "to": 295
  }, {
    "from": 281,
    "label": "has",
    "to": 296
  }, {
    "from": 267,
    "label": "has",
    "to": 297
  }, {
    "from": 297,
    "label": "has",
    "to": 298
  }, {
    "from": 267,
    "label": "has",
    "to": 299
  }, {
    "from": 267,
    "label": "has",
    "to": 300
  }, {
    "from": 300,
    "label": "has",
    "to": 301
  }, {
    "from": 300,
    "label": "has",
    "to": 302
  }, {
    "from": 302,
    "label": "has",
    "to": 303
  }, {
    "from": 302,
    "label": "has",
    "to": 304
  }, {
    "from": 302,
    "label": "has",
    "to": 305
  }, {
    "from": 305,
    "label": "has",
    "to": 306
  }, {
    "from": 267,
    "label": "has",
    "to": 307
  }, {
    "from": 267,
    "label": "has",
    "to": 308
  }, {
    "from": 308,
    "label": "has",
    "to": 309
  }, {
    "from": 308,
    "label": "has",
    "to": 310
  }, {
    "from": 308,
    "label": "has",
    "to": 311
  }, {
    "from": 308,
    "label": "has",
    "to": 312
  }, {
    "from": 267,
    "label": "has",
    "to": 313
  }, {
    "from": 313,
    "label": "has",
    "to": 314
  }, {
    "from": 314,
    "label": "has",
    "to": 315
  }, {
    "from": 315,
    "label": "has",
    "to": 316
  }, {
    "from": 314,
    "label": "has",
    "to": 317
  }, {
    "from": 314,
    "label": "has",
    "to": 318
  }, {
    "from": 267,
    "label": "has",
    "to": 319
  }, {
    "from": 319,
    "label": "has",
    "to": 320
  }, {
    "from": 320,
    "label": "has",
    "to": 321
  }, {
    "from": 319,
    "label": "has",
    "to": 322
  }, {
    "from": 322,
    "label": "has",
    "to": 323
  }, {
    "from": 319,
    "label": "has",
    "to": 324
  }, {
    "from": 319,
    "label": "has",
    "to": 325
  }, {
    "from": 325,
    "label": "has",
    "to": 265
  }, {
    "from": 319,
    "label": "has",
    "to": 326
  }, {
    "from": 267,
    "label": "has",
    "to": 315
  }, {
    "from": 315,
    "label": "has",
    "to": 316
  }, {
    "from": 267,
    "label": "has",
    "to": 327
  }, {
    "from": 327,
    "label": "has",
    "to": 328
  }, {
    "from": 257,
    "label": "has",
    "to": 9
  }, {
    "from": 257,
    "label": "has",
    "to": 9
  }, {
    "from": 257,
    "label": "has",
    "to": 9
  }, {
    "from": 257,
    "label": "has",
    "to": 9
  }, {
    "from": 257,
    "label": "has",
    "to": 329
  }, {
    "from": 330,
    "label": "has",
    "to": 331
  }, {
    "from": 330,
    "label": "has",
    "to": 9
  }, {
    "from": 330,
    "label": "has",
    "to": 332
  }, {
    "from": 330,
    "label": "has",
    "to": 333
  }, {
    "from": 333,
    "label": "has",
    "to": 334
  }, {
    "from": 333,
    "label": "has",
    "to": 335
  }, {
    "from": 330,
    "label": "has",
    "to": 9
  }, {
    "from": 330,
    "label": "has",
    "to": 336
  }, {
    "from": 337,
    "label": "has",
    "to": 9
  }, {
    "from": 337,
    "label": "has",
    "to": 338
  }, {
    "from": 339,
    "label": "has",
    "to": 340
  }, {
    "from": 339,
    "label": "has",
    "to": 9
  }, {
    "from": 339,
    "label": "has",
    "to": 341
  }, {
    "from": 341,
    "label": "has",
    "to": 342
  }, {
    "from": 342,
    "label": "has",
    "to": 343
  }, {
    "from": 343,
    "label": "has",
    "to": 344
  }, {
    "from": 339,
    "label": "has",
    "to": 345
  }, {
    "from": 339,
    "label": "has",
    "to": 346
  }, {
    "from": 339,
    "label": "has",
    "to": 347
  }, {
    "from": 339,
    "label": "has",
    "to": 348
  }, {
    "from": 339,
    "label": "has",
    "to": 349
  }, {
    "from": 339,
    "label": "has",
    "to": 350
  }, {
    "from": 351,
    "label": "has",
    "to": 352
  }, {
    "from": 351,
    "label": "has",
    "to": 353
  }, {
    "from": 351,
    "label": "has",
    "to": 354
  }, {
    "from": 351,
    "label": "has",
    "to": 355
  }, {
    "from": 355,
    "label": "has",
    "to": 9
  }, {
    "from": 351,
    "label": "has",
    "to": 356
  }, {
    "from": 351,
    "label": "has",
    "to": 357
  }, {
    "from": 357,
    "label": "has",
    "to": 358
  }, {
    "from": 351,
    "label": "has",
    "to": 359
  }, {
    "from": 359,
    "label": "has",
    "to": 360
  }, {
    "from": 359,
    "label": "has",
    "to": 361
  }, {
    "from": 359,
    "label": "has",
    "to": 362
  }, {
    "from": 362,
    "label": "has",
    "to": 363
  }, {
    "from": 359,
    "label": "has",
    "to": 364
  }, {
    "from": 364,
    "label": "has",
    "to": 365
  }, {
    "from": 364,
    "label": "has",
    "to": 366
  }, {
    "from": 366,
    "label": "has",
    "to": 367
  }, {
    "from": 366,
    "label": "has",
    "to": 368
  }, {
    "from": 368,
    "label": "has",
    "to": 369
  }, {
    "from": 368,
    "label": "has",
    "to": 370
  }, {
    "from": 368,
    "label": "has",
    "to": 371
  }, {
    "from": 368,
    "label": "has",
    "to": 372
  }, {
    "from": 372,
    "label": "has",
    "to": 373
  }, {
    "from": 373,
    "label": "has",
    "to": 374
  }, {
    "from": 372,
    "label": "has",
    "to": 375
  }, {
    "from": 375,
    "label": "has",
    "to": 376
  }, {
    "from": 375,
    "label": "has",
    "to": 377
  }, {
    "from": 375,
    "label": "has",
    "to": 378
  }, {
    "from": 372,
    "label": "has",
    "to": 379
  }, {
    "from": 372,
    "label": "has",
    "to": 380
  }, {
    "from": 372,
    "label": "has",
    "to": 381
  }, {
    "from": 368,
    "label": "has",
    "to": 382
  }, {
    "from": 366,
    "label": "has",
    "to": 383
  }, {
    "from": 366,
    "label": "has",
    "to": 384
  }, {
    "from": 384,
    "label": "has",
    "to": 385
  }, {
    "from": 384,
    "label": "has",
    "to": 248
  }, {
    "from": 359,
    "label": "has",
    "to": 386
  }, {
    "from": 386,
    "label": "has",
    "to": 387
  }, {
    "from": 359,
    "label": "has",
    "to": 388
  }, {
    "from": 359,
    "label": "has",
    "to": 389
  }, {
    "from": 389,
    "label": "has",
    "to": 390
  }, {
    "from": 389,
    "label": "has",
    "to": 391
  }, {
    "from": 391,
    "label": "has",
    "to": 246
  }, {
    "from": 391,
    "label": "has",
    "to": 392
  }, {
    "from": 391,
    "label": "has",
    "to": 393
  }, {
    "from": 389,
    "label": "has",
    "to": 390
  }, {
    "from": 389,
    "label": "has",
    "to": 394
  }, {
    "from": 394,
    "label": "has",
    "to": 247
  }, {
    "from": 394,
    "label": "has",
    "to": 392
  }, {
    "from": 394,
    "label": "has",
    "to": 393
  }, {
    "from": 389,
    "label": "has",
    "to": 395
  }, {
    "from": 389,
    "label": "has",
    "to": 396
  }, {
    "from": 396,
    "label": "has",
    "to": 397
  }, {
    "from": 396,
    "label": "has",
    "to": 398
  }, {
    "from": 396,
    "label": "has",
    "to": 399
  }, {
    "from": 399,
    "label": "has",
    "to": 400
  }, {
    "from": 399,
    "label": "has",
    "to": 401
  }, {
    "from": 396,
    "label": "has",
    "to": 402
  }, {
    "from": 402,
    "label": "has",
    "to": 403
  }, {
    "from": 403,
    "label": "has",
    "to": 404
  }, {
    "from": 402,
    "label": "has",
    "to": 405
  }, {
    "from": 402,
    "label": "has",
    "to": 406
  }, {
    "from": 402,
    "label": "has",
    "to": 407
  }, {
    "from": 407,
    "label": "has",
    "to": 408
  }, {
    "from": 402,
    "label": "has",
    "to": 409
  }, {
    "from": 402,
    "label": "has",
    "to": 406
  }, {
    "from": 396,
    "label": "has",
    "to": 393
  }, {
    "from": 389,
    "label": "has",
    "to": 410
  }, {
    "from": 389,
    "label": "has",
    "to": 411
  }, {
    "from": 389,
    "label": "has",
    "to": 412
  }, {
    "from": 412,
    "label": "has",
    "to": 413
  }, {
    "from": 413,
    "label": "has",
    "to": 414
  }, {
    "from": 412,
    "label": "has",
    "to": 415
  }, {
    "from": 415,
    "label": "has",
    "to": 416
  }, {
    "from": 415,
    "label": "has",
    "to": 417
  }, {
    "from": 412,
    "label": "has",
    "to": 418
  }, {
    "from": 418,
    "label": "has",
    "to": 419
  }, {
    "from": 419,
    "label": "has",
    "to": 420
  }, {
    "from": 412,
    "label": "has",
    "to": 421
  }, {
    "from": 421,
    "label": "has",
    "to": 417
  }, {
    "from": 421,
    "label": "has",
    "to": 422
  }, {
    "from": 421,
    "label": "has",
    "to": 423
  }, {
    "from": 421,
    "label": "has",
    "to": 424
  }, {
    "from": 424,
    "label": "has",
    "to": 425
  }, {
    "from": 424,
    "label": "has",
    "to": 426
  }, {
    "from": 426,
    "label": "has",
    "to": 417
  }, {
    "from": 426,
    "label": "has",
    "to": 427
  }, {
    "from": 426,
    "label": "has",
    "to": 422
  }, {
    "from": 426,
    "label": "has",
    "to": 409
  }, {
    "from": 426,
    "label": "has",
    "to": 406
  }, {
    "from": 424,
    "label": "has",
    "to": 393
  }, {
    "from": 389,
    "label": "has",
    "to": 428
  }, {
    "from": 389,
    "label": "has",
    "to": 429
  }, {
    "from": 429,
    "label": "has",
    "to": 430
  }, {
    "from": 429,
    "label": "has",
    "to": 431
  }, {
    "from": 431,
    "label": "has",
    "to": 432
  }, {
    "from": 431,
    "label": "has",
    "to": 433
  }, {
    "from": 431,
    "label": "has",
    "to": 434
  }, {
    "from": 431,
    "label": "has",
    "to": 435
  }, {
    "from": 431,
    "label": "has",
    "to": 409
  }, {
    "from": 431,
    "label": "has",
    "to": 406
  }, {
    "from": 429,
    "label": "has",
    "to": 393
  }, {
    "from": 389,
    "label": "has",
    "to": 436
  }, {
    "from": 389,
    "label": "has",
    "to": 437
  }, {
    "from": 389,
    "label": "has",
    "to": 438
  }, {
    "from": 438,
    "label": "has",
    "to": 439
  }, {
    "from": 438,
    "label": "has",
    "to": 440
  }, {
    "from": 438,
    "label": "has",
    "to": 392
  }, {
    "from": 438,
    "label": "has",
    "to": 393
  }, {
    "from": 389,
    "label": "has",
    "to": 392
  }, {
    "from": 389,
    "label": "has",
    "to": 441
  }, {
    "from": 389,
    "label": "has",
    "to": 442
  }, {
    "from": 389,
    "label": "has",
    "to": 443
  }, {
    "from": 443,
    "label": "has",
    "to": 444
  }, {
    "from": 443,
    "label": "has",
    "to": 445
  }, {
    "from": 443,
    "label": "has",
    "to": 446
  }, {
    "from": 443,
    "label": "has",
    "to": 447
  }, {
    "from": 389,
    "label": "has",
    "to": 392
  }, {
    "from": 389,
    "label": "has",
    "to": 448
  }, {
    "from": 389,
    "label": "has",
    "to": 441
  }, {
    "from": 389,
    "label": "has",
    "to": 442
  }, {
    "from": 389,
    "label": "has",
    "to": 443
  }, {
    "from": 443,
    "label": "has",
    "to": 444
  }, {
    "from": 443,
    "label": "has",
    "to": 445
  }, {
    "from": 443,
    "label": "has",
    "to": 446
  }, {
    "from": 443,
    "label": "has",
    "to": 447
  }, {
    "from": 389,
    "label": "has",
    "to": 392
  }, {
    "from": 389,
    "label": "has",
    "to": 449
  }, {
    "from": 389,
    "label": "has",
    "to": 450
  }, {
    "from": 450,
    "label": "has",
    "to": 451
  }, {
    "from": 450,
    "label": "has",
    "to": 452
  }, {
    "from": 389,
    "label": "has",
    "to": 441
  }, {
    "from": 389,
    "label": "has",
    "to": 442
  }, {
    "from": 389,
    "label": "has",
    "to": 443
  }, {
    "from": 443,
    "label": "has",
    "to": 444
  }, {
    "from": 443,
    "label": "has",
    "to": 445
  }, {
    "from": 443,
    "label": "has",
    "to": 446
  }, {
    "from": 443,
    "label": "has",
    "to": 447
  }, {
    "from": 389,
    "label": "has",
    "to": 453
  }, {
    "from": 389,
    "label": "has",
    "to": 454
  }, {
    "from": 454,
    "label": "has",
    "to": 455
  }, {
    "from": 454,
    "label": "has",
    "to": 456
  }, {
    "from": 454,
    "label": "has",
    "to": 392
  }, {
    "from": 454,
    "label": "has",
    "to": 393
  }, {
    "from": 389,
    "label": "has",
    "to": 457
  }, {
    "from": 389,
    "label": "has",
    "to": 458
  }, {
    "from": 389,
    "label": "has",
    "to": 459
  }, {
    "from": 459,
    "label": "has",
    "to": 460
  }, {
    "from": 389,
    "label": "has",
    "to": 461
  }, {
    "from": 461,
    "label": "has",
    "to": 462
  }, {
    "from": 461,
    "label": "has",
    "to": 463
  }, {
    "from": 461,
    "label": "has",
    "to": 464
  }, {
    "from": 461,
    "label": "has",
    "to": 465
  }, {
    "from": 465,
    "label": "has",
    "to": 466
  }, {
    "from": 465,
    "label": "has",
    "to": 467
  }, {
    "from": 465,
    "label": "has",
    "to": 406
  }, {
    "from": 389,
    "label": "has",
    "to": 468
  }, {
    "from": 389,
    "label": "has",
    "to": 469
  }, {
    "from": 469,
    "label": "has",
    "to": 470
  }, {
    "from": 469,
    "label": "has",
    "to": 471
  }, {
    "from": 471,
    "label": "has",
    "to": 472
  }, {
    "from": 472,
    "label": "has",
    "to": 473
  }, {
    "from": 472,
    "label": "has",
    "to": 474
  }, {
    "from": 474,
    "label": "has",
    "to": 475
  }, {
    "from": 472,
    "label": "has",
    "to": 476
  }, {
    "from": 476,
    "label": "has",
    "to": 477
  }, {
    "from": 472,
    "label": "has",
    "to": 478
  }, {
    "from": 472,
    "label": "has",
    "to": 479
  }, {
    "from": 469,
    "label": "has",
    "to": 480
  }, {
    "from": 480,
    "label": "has",
    "to": 481
  }, {
    "from": 469,
    "label": "has",
    "to": 392
  }, {
    "from": 469,
    "label": "has",
    "to": 393
  }, {
    "from": 389,
    "label": "has",
    "to": 392
  }, {
    "from": 389,
    "label": "has",
    "to": 482
  }, {
    "from": 389,
    "label": "has",
    "to": 393
  }, {
    "from": 351,
    "label": "has",
    "to": 9
  }, {
    "from": 351,
    "label": "has",
    "to": 483
  }, {
    "from": 484,
    "label": "has",
    "to": 9
  }, {
    "from": 485,
    "label": "has",
    "to": 376
  }, {
    "from": 485,
    "label": "has",
    "to": 377
  }, {
    "from": 485,
    "label": "has",
    "to": 378
  }, {
    "from": 485,
    "label": "has",
    "to": 486
  }, {
    "from": 487,
    "label": "has",
    "to": 488
  }, {
    "from": 487,
    "label": "has",
    "to": 9
  }, {
    "from": 487,
    "label": "has",
    "to": 489
  }, {
    "from": 490,
    "label": "has",
    "to": 491
  }, {
    "from": 490,
    "label": "has",
    "to": 492
  }, {
    "from": 490,
    "label": "has",
    "to": 9
  }, {
    "from": 490,
    "label": "has",
    "to": 493
  }, {
    "from": 493,
    "label": "has",
    "to": 494
  }, {
    "from": 490,
    "label": "has",
    "to": 495
  }, {
    "from": 490,
    "label": "has",
    "to": 496
  }, {
    "from": 496,
    "label": "has",
    "to": 497
  }, {
    "from": 490,
    "label": "has",
    "to": 498
  }, {
    "from": 490,
    "label": "has",
    "to": 9
  }, {
    "from": 490,
    "label": "has",
    "to": 9
  }, {
    "from": 490,
    "label": "has",
    "to": 499
  }, {
    "from": 500,
    "label": "has",
    "to": 501
  }, {
    "from": 500,
    "label": "has",
    "to": 9
  }, {
    "from": 500,
    "label": "has",
    "to": 502
  }, {
    "from": 500,
    "label": "has",
    "to": 503
  }, {
    "from": 500,
    "label": "has",
    "to": 504
  }, {
    "from": 500,
    "label": "has",
    "to": 505
  }, {
    "from": 500,
    "label": "has",
    "to": 506
  }, {
    "from": 500,
    "label": "has",
    "to": 507
  }, {
    "from": 500,
    "label": "has",
    "to": 508
  }, {
    "from": 508,
    "label": "has",
    "to": 509
  }, {
    "from": 508,
    "label": "has",
    "to": 510
  }, {
    "from": 510,
    "label": "has",
    "to": 511
  }, {
    "from": 510,
    "label": "has",
    "to": 512
  }, {
    "from": 512,
    "label": "has",
    "to": 513
  }, {
    "from": 513,
    "label": "has",
    "to": 514
  }, {
    "from": 513,
    "label": "has",
    "to": 515
  }, {
    "from": 515,
    "label": "has",
    "to": 516
  }, {
    "from": 515,
    "label": "has",
    "to": 517
  }, {
    "from": 517,
    "label": "has",
    "to": 518
  }, {
    "from": 512,
    "label": "has",
    "to": 9
  }, {
    "from": 512,
    "label": "has",
    "to": 9
  }, {
    "from": 512,
    "label": "has",
    "to": 9
  }, {
    "from": 508,
    "label": "has",
    "to": 519
  }, {
    "from": 508,
    "label": "has",
    "to": 520
  }, {
    "from": 508,
    "label": "has",
    "to": 348
  }, {
    "from": 508,
    "label": "has",
    "to": 448
  }, {
    "from": 508,
    "label": "has",
    "to": 521
  }, {
    "from": 500,
    "label": "has",
    "to": 9
  }, {
    "from": 500,
    "label": "has",
    "to": 522
  }, {
    "from": 523,
    "label": "has",
    "to": 513
  }, {
    "from": 513,
    "label": "has",
    "to": 514
  }, {
    "from": 513,
    "label": "has",
    "to": 515
  }, {
    "from": 515,
    "label": "has",
    "to": 516
  }, {
    "from": 515,
    "label": "has",
    "to": 517
  }, {
    "from": 517,
    "label": "has",
    "to": 518
  }, {
    "from": 523,
    "label": "has",
    "to": 9
  }, {
    "from": 523,
    "label": "has",
    "to": 9
  }, {
    "from": 523,
    "label": "has",
    "to": 9
  }, {
    "from": 523,
    "label": "has",
    "to": 524
  }, {
    "from": 525,
    "label": "has",
    "to": 501
  }, {
    "from": 525,
    "label": "has",
    "to": 9
  }, {
    "from": 525,
    "label": "has",
    "to": 502
  }, {
    "from": 525,
    "label": "has",
    "to": 503
  }, {
    "from": 525,
    "label": "has",
    "to": 504
  }, {
    "from": 525,
    "label": "has",
    "to": 505
  }, {
    "from": 525,
    "label": "has",
    "to": 526
  }, {
    "from": 525,
    "label": "has",
    "to": 506
  }, {
    "from": 525,
    "label": "has",
    "to": 507
  }, {
    "from": 525,
    "label": "has",
    "to": 527
  }, {
    "from": 527,
    "label": "has",
    "to": 528
  }, {
    "from": 528,
    "label": "has",
    "to": 529
  }, {
    "from": 528,
    "label": "has",
    "to": 530
  }, {
    "from": 528,
    "label": "has",
    "to": 531
  }, {
    "from": 528,
    "label": "has",
    "to": 9
  }, {
    "from": 527,
    "label": "has",
    "to": 295
  }, {
    "from": 527,
    "label": "has",
    "to": 519
  }, {
    "from": 527,
    "label": "has",
    "to": 532
  }, {
    "from": 532,
    "label": "has",
    "to": 448
  }, {
    "from": 532,
    "label": "has",
    "to": 533
  }, {
    "from": 532,
    "label": "has",
    "to": 534
  }, {
    "from": 534,
    "label": "has",
    "to": 277
  }, {
    "from": 532,
    "label": "has",
    "to": 535
  }, {
    "from": 532,
    "label": "has",
    "to": 536
  }, {
    "from": 532,
    "label": "has",
    "to": 537
  }, {
    "from": 532,
    "label": "has",
    "to": 538
  }, {
    "from": 538,
    "label": "has",
    "to": 539
  }, {
    "from": 538,
    "label": "has",
    "to": 540
  }, {
    "from": 540,
    "label": "has",
    "to": 541
  }, {
    "from": 540,
    "label": "has",
    "to": 542
  }, {
    "from": 540,
    "label": "has",
    "to": 543
  }, {
    "from": 540,
    "label": "has",
    "to": 544
  }, {
    "from": 540,
    "label": "has",
    "to": 545
  }, {
    "from": 527,
    "label": "has",
    "to": 521
  }, {
    "from": 525,
    "label": "has",
    "to": 9
  }, {
    "from": 525,
    "label": "has",
    "to": 9
  }, {
    "from": 525,
    "label": "has",
    "to": 546
  }, {
    "from": 547,
    "label": "has",
    "to": 529
  }, {
    "from": 547,
    "label": "has",
    "to": 530
  }, {
    "from": 547,
    "label": "has",
    "to": 531
  }, {
    "from": 547,
    "label": "has",
    "to": 9
  }, {
    "from": 547,
    "label": "has",
    "to": 548
  }, {
    "from": 549,
    "label": "has",
    "to": 9
  }, {
    "from": 549,
    "label": "has",
    "to": 550
  }, {
    "from": 551,
    "label": "has",
    "to": 9
  }, {
    "from": 551,
    "label": "has",
    "to": 552
  }, {
    "from": 553,
    "label": "has",
    "to": 340
  }, {
    "from": 553,
    "label": "has",
    "to": 9
  }, {
    "from": 553,
    "label": "has",
    "to": 554
  }, {
    "from": 553,
    "label": "has",
    "to": 555
  }, {
    "from": 555,
    "label": "has",
    "to": 556
  }, {
    "from": 553,
    "label": "has",
    "to": 557
  }, {
    "from": 557,
    "label": "has",
    "to": 558
  }, {
    "from": 557,
    "label": "has",
    "to": 559
  }, {
    "from": 557,
    "label": "has",
    "to": 560
  }, {
    "from": 560,
    "label": "has",
    "to": 561
  }, {
    "from": 557,
    "label": "has",
    "to": 520
  }, {
    "from": 553,
    "label": "has",
    "to": 562
  }, {
    "from": 563,
    "label": "has",
    "to": 340
  }, {
    "from": 563,
    "label": "has",
    "to": 9
  }, {
    "from": 563,
    "label": "has",
    "to": 554
  }, {
    "from": 563,
    "label": "has",
    "to": 555
  }, {
    "from": 555,
    "label": "has",
    "to": 556
  }, {
    "from": 563,
    "label": "has",
    "to": 564
  }, {
    "from": 564,
    "label": "has",
    "to": 565
  }, {
    "from": 564,
    "label": "has",
    "to": 566
  }, {
    "from": 566,
    "label": "has",
    "to": 344
  }, {
    "from": 564,
    "label": "has",
    "to": 567
  }, {
    "from": 567,
    "label": "has",
    "to": 568
  }, {
    "from": 564,
    "label": "has",
    "to": 569
  }, {
    "from": 569,
    "label": "has",
    "to": 345
  }, {
    "from": 563,
    "label": "has",
    "to": 570
  }, {
    "from": 570,
    "label": "has",
    "to": 571
  }, {
    "from": 570,
    "label": "has",
    "to": 572
  }, {
    "from": 572,
    "label": "has",
    "to": 573
  }, {
    "from": 573,
    "label": "has",
    "to": 574
  }, {
    "from": 570,
    "label": "has",
    "to": 575
  }, {
    "from": 575,
    "label": "has",
    "to": 345
  }, {
    "from": 563,
    "label": "has",
    "to": 576
  }, {
    "from": 577,
    "label": "has",
    "to": 578
  }, {
    "from": 577,
    "label": "has",
    "to": 579
  }, {
    "from": 577,
    "label": "has",
    "to": 580
  }, {
    "from": 577,
    "label": "has",
    "to": 581
  }, {
    "from": 577,
    "label": "has",
    "to": 582
  }, {
    "from": 582,
    "label": "has",
    "to": 583
  }, {
    "from": 582,
    "label": "has",
    "to": 584
  }, {
    "from": 582,
    "label": "has",
    "to": 585
  }, {
    "from": 585,
    "label": "has",
    "to": 586
  }, {
    "from": 585,
    "label": "has",
    "to": 587
  }, {
    "from": 585,
    "label": "has",
    "to": 588
  }, {
    "from": 588,
    "label": "has",
    "to": 589
  }, {
    "from": 585,
    "label": "has",
    "to": 590
  }, {
    "from": 585,
    "label": "has",
    "to": 591
  }, {
    "from": 591,
    "label": "has",
    "to": 592
  }, {
    "from": 591,
    "label": "has",
    "to": 593
  }, {
    "from": 593,
    "label": "has",
    "to": 594
  }, {
    "from": 591,
    "label": "has",
    "to": 595
  }, {
    "from": 591,
    "label": "has",
    "to": 596
  }, {
    "from": 596,
    "label": "has",
    "to": 597
  }, {
    "from": 591,
    "label": "has",
    "to": 598
  }, {
    "from": 591,
    "label": "has",
    "to": 599
  }, {
    "from": 599,
    "label": "has",
    "to": 600
  }, {
    "from": 599,
    "label": "has",
    "to": 601
  }, {
    "from": 599,
    "label": "has",
    "to": 602
  }, {
    "from": 599,
    "label": "has",
    "to": 603
  }, {
    "from": 603,
    "label": "has",
    "to": 604
  }, {
    "from": 599,
    "label": "has",
    "to": 605
  }, {
    "from": 591,
    "label": "has",
    "to": 606
  }, {
    "from": 591,
    "label": "has",
    "to": 607
  }, {
    "from": 607,
    "label": "has",
    "to": 608
  }, {
    "from": 607,
    "label": "has",
    "to": 609
  }, {
    "from": 591,
    "label": "has",
    "to": 610
  }, {
    "from": 585,
    "label": "has",
    "to": 611
  }, {
    "from": 582,
    "label": "has",
    "to": 583
  }, {
    "from": 582,
    "label": "has",
    "to": 612
  }, {
    "from": 582,
    "label": "has",
    "to": 613
  }, {
    "from": 613,
    "label": "has",
    "to": 614
  }, {
    "from": 614,
    "label": "has",
    "to": 615
  }, {
    "from": 614,
    "label": "has",
    "to": 616
  }, {
    "from": 613,
    "label": "has",
    "to": 617
  }, {
    "from": 613,
    "label": "has",
    "to": 618
  }, {
    "from": 618,
    "label": "has",
    "to": 619
  }, {
    "from": 618,
    "label": "has",
    "to": 620
  }, {
    "from": 613,
    "label": "has",
    "to": 621
  }, {
    "from": 582,
    "label": "has",
    "to": 622
  }, {
    "from": 582,
    "label": "has",
    "to": 623
  }, {
    "from": 623,
    "label": "has",
    "to": 624
  }, {
    "from": 623,
    "label": "has",
    "to": 625
  }, {
    "from": 623,
    "label": "has",
    "to": 626
  }, {
    "from": 623,
    "label": "has",
    "to": 627
  }, {
    "from": 627,
    "label": "has",
    "to": 628
  }, {
    "from": 627,
    "label": "has",
    "to": 629
  }, {
    "from": 627,
    "label": "has",
    "to": 630
  }, {
    "from": 627,
    "label": "has",
    "to": 631
  }, {
    "from": 631,
    "label": "has",
    "to": 632
  }, {
    "from": 631,
    "label": "has",
    "to": 633
  }, {
    "from": 631,
    "label": "has",
    "to": 634
  }, {
    "from": 623,
    "label": "has",
    "to": 621
  }, {
    "from": 582,
    "label": "has",
    "to": 612
  }, {
    "from": 582,
    "label": "has",
    "to": 635
  }, {
    "from": 635,
    "label": "has",
    "to": 614
  }, {
    "from": 614,
    "label": "has",
    "to": 615
  }, {
    "from": 614,
    "label": "has",
    "to": 616
  }, {
    "from": 635,
    "label": "has",
    "to": 636
  }, {
    "from": 635,
    "label": "has",
    "to": 637
  }, {
    "from": 637,
    "label": "has",
    "to": 638
  }, {
    "from": 637,
    "label": "has",
    "to": 639
  }, {
    "from": 635,
    "label": "has",
    "to": 621
  }, {
    "from": 582,
    "label": "has",
    "to": 640
  }, {
    "from": 582,
    "label": "has",
    "to": 641
  }, {
    "from": 582,
    "label": "has",
    "to": 642
  }, {
    "from": 642,
    "label": "has",
    "to": 638
  }, {
    "from": 642,
    "label": "has",
    "to": 643
  }, {
    "from": 582,
    "label": "has",
    "to": 644
  }, {
    "from": 582,
    "label": "has",
    "to": 645
  }, {
    "from": 645,
    "label": "has",
    "to": 646
  }, {
    "from": 645,
    "label": "has",
    "to": 647
  }, {
    "from": 647,
    "label": "has",
    "to": 648
  }, {
    "from": 647,
    "label": "has",
    "to": 649
  }, {
    "from": 645,
    "label": "has",
    "to": 621
  }, {
    "from": 582,
    "label": "has",
    "to": 650
  }, {
    "from": 650,
    "label": "has",
    "to": 646
  }, {
    "from": 650,
    "label": "has",
    "to": 651
  }, {
    "from": 651,
    "label": "has",
    "to": 648
  }, {
    "from": 651,
    "label": "has",
    "to": 652
  }, {
    "from": 582,
    "label": "has",
    "to": 622
  }, {
    "from": 582,
    "label": "has",
    "to": 653
  }, {
    "from": 653,
    "label": "has",
    "to": 654
  }, {
    "from": 654,
    "label": "has",
    "to": 655
  }, {
    "from": 654,
    "label": "has",
    "to": 656
  }, {
    "from": 656,
    "label": "has",
    "to": 657
  }, {
    "from": 654,
    "label": "has",
    "to": 658
  }, {
    "from": 654,
    "label": "has",
    "to": 659
  }, {
    "from": 654,
    "label": "has",
    "to": 660
  }, {
    "from": 654,
    "label": "has",
    "to": 661
  }, {
    "from": 661,
    "label": "has",
    "to": 662
  }, {
    "from": 654,
    "label": "has",
    "to": 663
  }, {
    "from": 654,
    "label": "has",
    "to": 664
  }, {
    "from": 654,
    "label": "has",
    "to": 665
  }, {
    "from": 654,
    "label": "has",
    "to": 666
  }, {
    "from": 666,
    "label": "has",
    "to": 667
  }, {
    "from": 666,
    "label": "has",
    "to": 668
  }, {
    "from": 666,
    "label": "has",
    "to": 669
  }, {
    "from": 654,
    "label": "has",
    "to": 670
  }, {
    "from": 654,
    "label": "has",
    "to": 671
  }, {
    "from": 654,
    "label": "has",
    "to": 672
  }, {
    "from": 654,
    "label": "has",
    "to": 673
  }, {
    "from": 654,
    "label": "has",
    "to": 616
  }, {
    "from": 654,
    "label": "has",
    "to": 663
  }, {
    "from": 654,
    "label": "has",
    "to": 674
  }, {
    "from": 674,
    "label": "has",
    "to": 664
  }, {
    "from": 653,
    "label": "has",
    "to": 675
  }, {
    "from": 675,
    "label": "has",
    "to": 676
  }, {
    "from": 675,
    "label": "has",
    "to": 677
  }, {
    "from": 675,
    "label": "has",
    "to": 586
  }, {
    "from": 675,
    "label": "has",
    "to": 678
  }, {
    "from": 675,
    "label": "has",
    "to": 679
  }, {
    "from": 679,
    "label": "has",
    "to": 680
  }, {
    "from": 679,
    "label": "has",
    "to": 681
  }, {
    "from": 681,
    "label": "has",
    "to": 682
  }, {
    "from": 681,
    "label": "has",
    "to": 683
  }, {
    "from": 681,
    "label": "has",
    "to": 684
  }, {
    "from": 681,
    "label": "has",
    "to": 685
  }, {
    "from": 685,
    "label": "has",
    "to": 686
  }, {
    "from": 685,
    "label": "has",
    "to": 687
  }, {
    "from": 687,
    "label": "has",
    "to": 688
  }, {
    "from": 687,
    "label": "has",
    "to": 689
  }, {
    "from": 681,
    "label": "has",
    "to": 690
  }, {
    "from": 690,
    "label": "has",
    "to": 691
  }, {
    "from": 681,
    "label": "has",
    "to": 692
  }, {
    "from": 679,
    "label": "has",
    "to": 693
  }, {
    "from": 679,
    "label": "has",
    "to": 694
  }, {
    "from": 679,
    "label": "has",
    "to": 695
  }, {
    "from": 695,
    "label": "has",
    "to": 600
  }, {
    "from": 695,
    "label": "has",
    "to": 601
  }, {
    "from": 695,
    "label": "has",
    "to": 602
  }, {
    "from": 695,
    "label": "has",
    "to": 603
  }, {
    "from": 603,
    "label": "has",
    "to": 604
  }, {
    "from": 695,
    "label": "has",
    "to": 605
  }, {
    "from": 679,
    "label": "has",
    "to": 680
  }, {
    "from": 679,
    "label": "has",
    "to": 696
  }, {
    "from": 679,
    "label": "has",
    "to": 697
  }, {
    "from": 679,
    "label": "has",
    "to": 610
  }, {
    "from": 675,
    "label": "has",
    "to": 611
  }, {
    "from": 653,
    "label": "has",
    "to": 621
  }, {
    "from": 582,
    "label": "has",
    "to": 698
  }, {
    "from": 698,
    "label": "has",
    "to": 699
  }, {
    "from": 699,
    "label": "has",
    "to": 700
  }, {
    "from": 582,
    "label": "has",
    "to": 701
  }, {
    "from": 701,
    "label": "has",
    "to": 702
  }, {
    "from": 582,
    "label": "has",
    "to": 703
  }, {
    "from": 582,
    "label": "has",
    "to": 704
  }, {
    "from": 582,
    "label": "has",
    "to": 705
  }, {
    "from": 582,
    "label": "has",
    "to": 706
  }, {
    "from": 582,
    "label": "has",
    "to": 707
  }, {
    "from": 707,
    "label": "has",
    "to": 708
  }, {
    "from": 707,
    "label": "has",
    "to": 709
  }, {
    "from": 709,
    "label": "has",
    "to": 710
  }, {
    "from": 707,
    "label": "has",
    "to": 711
  }, {
    "from": 707,
    "label": "has",
    "to": 712
  }, {
    "from": 712,
    "label": "has",
    "to": 713
  }, {
    "from": 707,
    "label": "has",
    "to": 714
  }, {
    "from": 714,
    "label": "has",
    "to": 715
  }, {
    "from": 707,
    "label": "has",
    "to": 716
  }, {
    "from": 707,
    "label": "has",
    "to": 680
  }, {
    "from": 707,
    "label": "has",
    "to": 717
  }, {
    "from": 707,
    "label": "has",
    "to": 697
  }, {
    "from": 707,
    "label": "has",
    "to": 610
  }, {
    "from": 582,
    "label": "has",
    "to": 718
  }, {
    "from": 582,
    "label": "has",
    "to": 719
  }, {
    "from": 719,
    "label": "has",
    "to": 720
  }, {
    "from": 719,
    "label": "has",
    "to": 721
  }, {
    "from": 719,
    "label": "has",
    "to": 722
  }, {
    "from": 722,
    "label": "has",
    "to": 723
  }, {
    "from": 719,
    "label": "has",
    "to": 724
  }, {
    "from": 719,
    "label": "has",
    "to": 725
  }, {
    "from": 725,
    "label": "has",
    "to": 726
  }, {
    "from": 725,
    "label": "has",
    "to": 727
  }, {
    "from": 725,
    "label": "has",
    "to": 728
  }, {
    "from": 725,
    "label": "has",
    "to": 610
  }, {
    "from": 719,
    "label": "has",
    "to": 621
  }, {
    "from": 582,
    "label": "has",
    "to": 729
  }, {
    "from": 582,
    "label": "has",
    "to": 730
  }, {
    "from": 730,
    "label": "has",
    "to": 731
  }, {
    "from": 730,
    "label": "has",
    "to": 732
  }, {
    "from": 732,
    "label": "has",
    "to": 733
  }, {
    "from": 730,
    "label": "has",
    "to": 734
  }, {
    "from": 730,
    "label": "has",
    "to": 735
  }, {
    "from": 735,
    "label": "has",
    "to": 736
  }, {
    "from": 730,
    "label": "has",
    "to": 737
  }, {
    "from": 730,
    "label": "has",
    "to": 738
  }, {
    "from": 730,
    "label": "has",
    "to": 721
  }, {
    "from": 730,
    "label": "has",
    "to": 722
  }, {
    "from": 722,
    "label": "has",
    "to": 723
  }, {
    "from": 730,
    "label": "has",
    "to": 724
  }, {
    "from": 730,
    "label": "has",
    "to": 739
  }, {
    "from": 739,
    "label": "has",
    "to": 740
  }, {
    "from": 739,
    "label": "has",
    "to": 610
  }, {
    "from": 730,
    "label": "has",
    "to": 741
  }, {
    "from": 582,
    "label": "has",
    "to": 742
  }, {
    "from": 582,
    "label": "has",
    "to": 743
  }, {
    "from": 582,
    "label": "has",
    "to": 744
  }, {
    "from": 582,
    "label": "has",
    "to": 745
  }, {
    "from": 582,
    "label": "has",
    "to": 746
  }, {
    "from": 582,
    "label": "has",
    "to": 747
  }, {
    "from": 582,
    "label": "has",
    "to": 748
  }, {
    "from": 582,
    "label": "has",
    "to": 749
  }, {
    "from": 582,
    "label": "has",
    "to": 750
  }, {
    "from": 582,
    "label": "has",
    "to": 751
  }, {
    "from": 582,
    "label": "has",
    "to": 752
  }, {
    "from": 582,
    "label": "has",
    "to": 753
  }, {
    "from": 582,
    "label": "has",
    "to": 754
  }, {
    "from": 582,
    "label": "has",
    "to": 755
  }, {
    "from": 582,
    "label": "has",
    "to": 756
  }, {
    "from": 582,
    "label": "has",
    "to": 757
  }, {
    "from": 582,
    "label": "has",
    "to": 758
  }, {
    "from": 582,
    "label": "has",
    "to": 759
  }, {
    "from": 582,
    "label": "has",
    "to": 760
  }, {
    "from": 582,
    "label": "has",
    "to": 761
  }, {
    "from": 582,
    "label": "has",
    "to": 762
  }, {
    "from": 582,
    "label": "has",
    "to": 763
  }, {
    "from": 582,
    "label": "has",
    "to": 764
  }, {
    "from": 764,
    "label": "has",
    "to": 621
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 9
  }, {
    "from": 577,
    "label": "has",
    "to": 765
  }, {
    "from": 767,
    "label": "has",
    "to": 768
  }, {
    "from": 767,
    "label": "has",
    "to": 769
  }, {
    "from": 767,
    "label": "has",
    "to": 770
  }, {
    "from": 767,
    "label": "has",
    "to": 771
  }, {
    "from": 767,
    "label": "has",
    "to": 772
  }, {
    "from": 767,
    "label": "has",
    "to": 773
  }, {
    "from": 767,
    "label": "has",
    "to": 774
  }, {
    "from": 767,
    "label": "has",
    "to": 775
  }, {
    "from": 767,
    "label": "has",
    "to": 584
  }, {
    "from": 767,
    "label": "has",
    "to": 587
  }, {
    "from": 767,
    "label": "has",
    "to": 776
  }, {
    "from": 767,
    "label": "has",
    "to": 777
  }, {
    "from": 777,
    "label": "has",
    "to": 778
  }, {
    "from": 777,
    "label": "has",
    "to": 779
  }, {
    "from": 777,
    "label": "has",
    "to": 780
  }, {
    "from": 777,
    "label": "has",
    "to": 781
  }, {
    "from": 781,
    "label": "has",
    "to": 782
  }, {
    "from": 781,
    "label": "has",
    "to": 783
  }, {
    "from": 767,
    "label": "has",
    "to": 784
  }, {
    "from": 784,
    "label": "has",
    "to": 785
  }, {
    "from": 784,
    "label": "has",
    "to": 786
  }, {
    "from": 784,
    "label": "has",
    "to": 787
  }, {
    "from": 767,
    "label": "has",
    "to": 788
  }, {
    "from": 767,
    "label": "has",
    "to": 789
  }, {
    "from": 790,
    "label": "has",
    "to": 791
  }, {
    "from": 790,
    "label": "has",
    "to": 9
  }, {
    "from": 790,
    "label": "has",
    "to": 792
  }, {
    "from": 790,
    "label": "has",
    "to": 793
  }, {
    "from": 793,
    "label": "has",
    "to": 9
  }, {
    "from": 793,
    "label": "has",
    "to": 794
  }, {
    "from": 793,
    "label": "has",
    "to": 9
  }, {
    "from": 790,
    "label": "has",
    "to": 795
  }, {
    "from": 796,
    "label": "has",
    "to": 9
  }, {
    "from": 796,
    "label": "has",
    "to": 794
  }, {
    "from": 796,
    "label": "has",
    "to": 9
  }, {
    "from": 796,
    "label": "has",
    "to": 797
  }, {
    "from": 798,
    "label": "has",
    "to": 799
  }, {
    "from": 798,
    "label": "has",
    "to": 9
  }, {
    "from": 798,
    "label": "has",
    "to": 800
  }, {
    "from": 798,
    "label": "has",
    "to": 801
  }, {
    "from": 798,
    "label": "has",
    "to": 9
  }, {
    "from": 798,
    "label": "has",
    "to": 802
  }, {
    "from": 802,
    "label": "has",
    "to": 803
  }, {
    "from": 802,
    "label": "has",
    "to": 804
  }, {
    "from": 802,
    "label": "has",
    "to": 805
  }, {
    "from": 802,
    "label": "has",
    "to": 806
  }, {
    "from": 806,
    "label": "has",
    "to": 9
  }, {
    "from": 806,
    "label": "has",
    "to": 794
  }, {
    "from": 806,
    "label": "has",
    "to": 9
  }, {
    "from": 802,
    "label": "has",
    "to": 9
  }, {
    "from": 798,
    "label": "has",
    "to": 807
  }, {
    "from": 808,
    "label": "has",
    "to": 9
  }, {
    "from": 808,
    "label": "has",
    "to": 794
  }, {
    "from": 808,
    "label": "has",
    "to": 9
  }, {
    "from": 808,
    "label": "has",
    "to": 809
  }, {
    "from": 810,
    "label": "has",
    "to": 803
  }, {
    "from": 810,
    "label": "has",
    "to": 804
  }, {
    "from": 810,
    "label": "has",
    "to": 805
  }, {
    "from": 810,
    "label": "has",
    "to": 806
  }, {
    "from": 806,
    "label": "has",
    "to": 9
  }, {
    "from": 806,
    "label": "has",
    "to": 794
  }, {
    "from": 806,
    "label": "has",
    "to": 9
  }, {
    "from": 810,
    "label": "has",
    "to": 9
  }, {
    "from": 810,
    "label": "has",
    "to": 811
  }, {
    "from": 812,
    "label": "has",
    "to": 448
  }, {
    "from": 813,
    "label": "has",
    "to": 814
  }, {
    "from": 814,
    "label": "has",
    "to": 815
  }, {
    "from": 813,
    "label": "has",
    "to": 9
  }, {
    "from": 816,
    "label": "has",
    "to": 817
  }, {
    "from": 816,
    "label": "has",
    "to": 9
  }, {
    "from": 816,
    "label": "has",
    "to": 818
  }, {
    "from": 819,
    "label": "has",
    "to": 32
  }, {
    "from": 32,
    "label": "has",
    "to": 33
  }, {
    "from": 32,
    "label": "has",
    "to": 34
  }, {
    "from": 819,
    "label": "has",
    "to": 9
  }, {
    "from": 820,
    "label": "has",
    "to": 9
  }, {
    "from": 820,
    "label": "has",
    "to": 821
  }, {
    "from": 822,
    "label": "has",
    "to": 9
  }, {
    "from": 823,
    "label": "has",
    "to": 9
  }, {
    "from": 824,
    "label": "has",
    "to": 112
  }, {
    "from": 825,
    "label": "has",
    "to": 9
  }, {
    "from": 826,
    "label": "has",
    "to": 9
  }, {
    "from": 827,
    "label": "has",
    "to": 9
  }, {
    "from": 828,
    "label": "has",
    "to": 829
  }, {
    "from": 828,
    "label": "has",
    "to": 830
  }, {
    "from": 828,
    "label": "has",
    "to": 831
  }, {
    "from": 828,
    "label": "has",
    "to": 832
  }, {
    "from": 828,
    "label": "has",
    "to": 833
  }, {
    "from": 828,
    "label": "has",
    "to": 834
  }, {
    "from": 828,
    "label": "has",
    "to": 835
  }, {
    "from": 835,
    "label": "has",
    "to": 836
  }, {
    "from": 828,
    "label": "has",
    "to": 837
  }, {
    "from": 837,
    "label": "has",
    "to": 838
  }, {
    "from": 828,
    "label": "has",
    "to": 839
  }, {
    "from": 839,
    "label": "has",
    "to": 840
  }, {
    "from": 840,
    "label": "has",
    "to": 841
  }, {
    "from": 828,
    "label": "has",
    "to": 24
  }, {
    "from": 24,
    "label": "has",
    "to": 25
  }, {
    "from": 24,
    "label": "has",
    "to": 26
  }, {
    "from": 24,
    "label": "has",
    "to": 27
  }, {
    "from": 24,
    "label": "has",
    "to": 28
  }, {
    "from": 24,
    "label": "has",
    "to": 29
  }, {
    "from": 24,
    "label": "has",
    "to": 30
  }, {
    "from": 24,
    "label": "has",
    "to": 31
  }, {
    "from": 31,
    "label": "has",
    "to": 9
  }, {
    "from": 31,
    "label": "has",
    "to": 32
  }, {
    "from": 32,
    "label": "has",
    "to": 33
  }, {
    "from": 32,
    "label": "has",
    "to": 34
  }, {
    "from": 31,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 35
  }, {
    "from": 35,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 36
  }, {
    "from": 36,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 37
  }, {
    "from": 37,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 38
  }, {
    "from": 38,
    "label": "has",
    "to": 39
  }, {
    "from": 38,
    "label": "has",
    "to": 40
  }, {
    "from": 38,
    "label": "has",
    "to": 41
  }, {
    "from": 38,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 42
  }, {
    "from": 42,
    "label": "has",
    "to": 43
  }, {
    "from": 42,
    "label": "has",
    "to": 44
  }, {
    "from": 44,
    "label": "has",
    "to": 9
  }, {
    "from": 42,
    "label": "has",
    "to": 45
  }, {
    "from": 45,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 46
  }, {
    "from": 46,
    "label": "has",
    "to": 47
  }, {
    "from": 46,
    "label": "has",
    "to": 48
  }, {
    "from": 46,
    "label": "has",
    "to": 49
  }, {
    "from": 46,
    "label": "has",
    "to": 50
  }, {
    "from": 50,
    "label": "has",
    "to": 51
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 52
  }, {
    "from": 52,
    "label": "has",
    "to": 9
  }, {
    "from": 52,
    "label": "has",
    "to": 53
  }, {
    "from": 52,
    "label": "has",
    "to": 54
  }, {
    "from": 54,
    "label": "has",
    "to": 55
  }, {
    "from": 54,
    "label": "has",
    "to": 56
  }, {
    "from": 52,
    "label": "has",
    "to": 57
  }, {
    "from": 46,
    "label": "has",
    "to": 58
  }, {
    "from": 58,
    "label": "has",
    "to": 59
  }, {
    "from": 58,
    "label": "has",
    "to": 53
  }, {
    "from": 58,
    "label": "has",
    "to": 60
  }, {
    "from": 58,
    "label": "has",
    "to": 61
  }, {
    "from": 58,
    "label": "has",
    "to": 62
  }, {
    "from": 62,
    "label": "has",
    "to": 63
  }, {
    "from": 58,
    "label": "has",
    "to": 64
  }, {
    "from": 64,
    "label": "has",
    "to": 65
  }, {
    "from": 64,
    "label": "has",
    "to": 66
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 67,
    "label": "has",
    "to": 68
  }, {
    "from": 67,
    "label": "has",
    "to": 69
  }, {
    "from": 58,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 58,
    "label": "has",
    "to": 72
  }, {
    "from": 72,
    "label": "has",
    "to": 73
  }, {
    "from": 58,
    "label": "has",
    "to": 74
  }, {
    "from": 58,
    "label": "has",
    "to": 75
  }, {
    "from": 75,
    "label": "has",
    "to": 76
  }, {
    "from": 75,
    "label": "has",
    "to": 77
  }, {
    "from": 77,
    "label": "has",
    "to": 78
  }, {
    "from": 78,
    "label": "has",
    "to": 79
  }, {
    "from": 78,
    "label": "has",
    "to": 80
  }, {
    "from": 78,
    "label": "has",
    "to": 81
  }, {
    "from": 77,
    "label": "has",
    "to": 79
  }, {
    "from": 77,
    "label": "has",
    "to": 82
  }, {
    "from": 77,
    "label": "has",
    "to": 83
  }, {
    "from": 77,
    "label": "has",
    "to": 84
  }, {
    "from": 58,
    "label": "has",
    "to": 85
  }, {
    "from": 58,
    "label": "has",
    "to": 86
  }, {
    "from": 58,
    "label": "has",
    "to": 87
  }, {
    "from": 58,
    "label": "has",
    "to": 88
  }, {
    "from": 58,
    "label": "has",
    "to": 53
  }, {
    "from": 58,
    "label": "has",
    "to": 53
  }, {
    "from": 58,
    "label": "has",
    "to": 89
  }, {
    "from": 58,
    "label": "has",
    "to": 90
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 46,
    "label": "has",
    "to": 9
  }, {
    "from": 24,
    "label": "has",
    "to": 91
  }, {
    "from": 24,
    "label": "has",
    "to": 92
  }, {
    "from": 24,
    "label": "has",
    "to": 93
  }, {
    "from": 24,
    "label": "has",
    "to": 94
  }, {
    "from": 24,
    "label": "has",
    "to": 9
  }, {
    "from": 828,
    "label": "has",
    "to": 110
  }, {
    "from": 110,
    "label": "has",
    "to": 111
  }, {
    "from": 111,
    "label": "has",
    "to": 9
  }, {
    "from": 111,
    "label": "has",
    "to": 112
  }, {
    "from": 110,
    "label": "has",
    "to": 113
  }, {
    "from": 110,
    "label": "has",
    "to": 114
  }, {
    "from": 114,
    "label": "has",
    "to": 115
  }, {
    "from": 110,
    "label": "has",
    "to": 116
  }, {
    "from": 110,
    "label": "has",
    "to": 9
  }, {
    "from": 110,
    "label": "has",
    "to": 117
  }, {
    "from": 117,
    "label": "has",
    "to": 118
  }, {
    "from": 110,
    "label": "has",
    "to": 9
  }, {
    "from": 828,
    "label": "has",
    "to": 120
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 121,
    "label": "has",
    "to": 122
  }, {
    "from": 122,
    "label": "has",
    "to": 123
  }, {
    "from": 120,
    "label": "has",
    "to": 9
  }, {
    "from": 828,
    "label": "has",
    "to": 9
  }, {
    "from": 828,
    "label": "has",
    "to": 9
  }, {
    "from": 828,
    "label": "has",
    "to": 9
  }, {
    "from": 828,
    "label": "has",
    "to": 9
  }, {
    "from": 828,
    "label": "has",
    "to": 842
  }, {
    "from": 843,
    "label": "has",
    "to": 472
  }, {
    "from": 472,
    "label": "has",
    "to": 473
  }, {
    "from": 472,
    "label": "has",
    "to": 474
  }, {
    "from": 474,
    "label": "has",
    "to": 475
  }, {
    "from": 472,
    "label": "has",
    "to": 476
  }, {
    "from": 476,
    "label": "has",
    "to": 477
  }, {
    "from": 472,
    "label": "has",
    "to": 478
  }, {
    "from": 472,
    "label": "has",
    "to": 479
  }, {
    "from": 843,
    "label": "has",
    "to": 844
  }, {
    "from": 845,
    "label": "has",
    "to": 794
  }, {
    "from": 845,
    "label": "has",
    "to": 9
  }, {
    "from": 845,
    "label": "has",
    "to": 846
  }, {
    "from": 847,
    "label": "has",
    "to": 794
  }, {
    "from": 847,
    "label": "has",
    "to": 9
  }, {
    "from": 847,
    "label": "has",
    "to": 848
  }, {
    "from": 849,
    "label": "calls",
    "to": 120
  }, {
    "from": 849,
    "label": "calls",
    "to": 120
  }, {
    "from": 849,
    "label": "calls",
    "to": 120
  }, {
    "from": 577,
    "label": "calls",
    "to": 861
  }, {
    "from": 577,
    "label": "calls",
    "to": 861
  }, {
    "from": 124,
    "label": "calls",
    "to": 23
  }, {
    "from": 124,
    "label": "calls",
    "to": 23
  }, {
    "from": 257,
    "label": "calls",
    "to": 23
  }, {
    "from": 849,
    "label": "calls",
    "to": 862
  }, {
    "from": 849,
    "label": "calls",
    "to": 862
  }, {
    "from": 849,
    "label": "calls",
    "to": 862
  }, {
    "from": 849,
    "label": "calls",
    "to": 862
  }, {
    "from": 849,
    "label": "calls",
    "to": 863
  }, {
    "from": 849,
    "label": "calls",
    "to": 863
  }, {
    "from": 849,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 24,
    "label": "calls",
    "to": 863
  }, {
    "from": 127,
    "label": "calls",
    "to": 863
  }, {
    "from": 127,
    "label": "calls",
    "to": 863
  }, {
    "from": 127,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 351,
    "label": "calls",
    "to": 863
  }, {
    "from": 487,
    "label": "calls",
    "to": 863
  }, {
    "from": 490,
    "label": "calls",
    "to": 863
  }, {
    "from": 525,
    "label": "calls",
    "to": 863
  }, {
    "from": 525,
    "label": "calls",
    "to": 863
  }, {
    "from": 525,
    "label": "calls",
    "to": 863
  }, {
    "from": 525,
    "label": "calls",
    "to": 863
  }, {
    "from": 577,
    "label": "calls",
    "to": 863
  }, {
    "from": 577,
    "label": "calls",
    "to": 863
  }, {
    "from": 577,
    "label": "calls",
    "to": 863
  }, {
    "from": 849,
    "label": "calls",
    "to": 864
  }, {
    "from": 24,
    "label": "calls",
    "to": 864
  }, {
    "from": 24,
    "label": "calls",
    "to": 864
  }, {
    "from": 24,
    "label": "calls",
    "to": 864
  }, {
    "from": 233,
    "label": "calls",
    "to": 864
  }, {
    "from": 233,
    "label": "calls",
    "to": 864
  }, {
    "from": 351,
    "label": "calls",
    "to": 864
  }, {
    "from": 351,
    "label": "calls",
    "to": 864
  }, {
    "from": 351,
    "label": "calls",
    "to": 864
  }, {
    "from": 351,
    "label": "calls",
    "to": 864
  }, {
    "from": 577,
    "label": "calls",
    "to": 864
  }, {
    "from": 577,
    "label": "calls",
    "to": 864
  }, {
    "from": 577,
    "label": "calls",
    "to": 864
  }, {
    "from": 577,
    "label": "calls",
    "to": 864
  }, {
    "from": 577,
    "label": "calls",
    "to": 864
  }, {
    "from": 577,
    "label": "calls",
    "to": 864
  }, {
    "from": 577,
    "label": "calls",
    "to": 864
  }, {
    "from": 24,
    "label": "calls",
    "to": 103
  }, {
    "from": 24,
    "label": "calls",
    "to": 103
  }, {
    "from": 849,
    "label": "calls",
    "to": 24
  }, {
    "from": 849,
    "label": "calls",
    "to": 24
  }, {
    "from": 849,
    "label": "calls",
    "to": 24
  }, {
    "from": 351,
    "label": "calls",
    "to": 866
  }, {
    "from": 351,
    "label": "calls",
    "to": 866
  }, {
    "from": 351,
    "label": "calls",
    "to": 866
  }, {
    "from": 351,
    "label": "calls",
    "to": 866
  }, {
    "from": 351,
    "label": "calls",
    "to": 866
  }, {
    "from": 351,
    "label": "calls",
    "to": 866
  }, {
    "from": 351,
    "label": "calls",
    "to": 866
  }, {
    "from": 351,
    "label": "calls",
    "to": 866
  }, {
    "from": 351,
    "label": "calls",
    "to": 866
  }, {
    "from": 525,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 577,
    "label": "calls",
    "to": 866
  }, {
    "from": 767,
    "label": "calls",
    "to": 866
  }, {
    "from": 767,
    "label": "calls",
    "to": 866
  }, {
    "from": 24,
    "label": "calls",
    "to": 100
  }, {
    "from": 24,
    "label": "calls",
    "to": 100
  }, {
    "from": 24,
    "label": "calls",
    "to": 100
  }, {
    "from": 24,
    "label": "calls",
    "to": 100
  }, {
    "from": 24,
    "label": "calls",
    "to": 100
  }, {
    "from": 24,
    "label": "calls",
    "to": 100
  }, {
    "from": 257,
    "label": "calls",
    "to": 233
  }, {
    "from": 790,
    "label": "calls",
    "to": 867
  }, {
    "from": 798,
    "label": "calls",
    "to": 867
  }, {
    "from": 849,
    "label": "calls",
    "to": 868
  }, {
    "from": 849,
    "label": "calls",
    "to": 868
  }, {
    "from": 24,
    "label": "calls",
    "to": 868
  }, {
    "from": 577,
    "label": "calls",
    "to": 868
  }, {
    "from": 127,
    "label": "calls",
    "to": 853
  }, {
    "from": 127,
    "label": "calls",
    "to": 853
  }, {
    "from": 178,
    "label": "calls",
    "to": 853
  }, {
    "from": 178,
    "label": "calls",
    "to": 853
  }, {
    "from": 196,
    "label": "calls",
    "to": 853
  }, {
    "from": 500,
    "label": "calls",
    "to": 766
  }, {
    "from": 525,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 577,
    "label": "calls",
    "to": 766
  }, {
    "from": 767,
    "label": "calls",
    "to": 766
  }, {
    "from": 767,
    "label": "calls",
    "to": 766
  }, {
    "from": 767,
    "label": "calls",
    "to": 766
  }, {
    "from": 767,
    "label": "calls",
    "to": 766
  }, {
    "from": 767,
    "label": "calls",
    "to": 766
  }, {
    "from": 767,
    "label": "calls",
    "to": 766
  }, {
    "from": 24,
    "label": "calls",
    "to": 101
  }, {
    "from": 24,
    "label": "calls",
    "to": 101
  }, {
    "from": 849,
    "label": "calls",
    "to": 871
  }, {
    "from": 24,
    "label": "calls",
    "to": 872
  }, {
    "from": 24,
    "label": "calls",
    "to": 873
  }, {
    "from": 351,
    "label": "calls",
    "to": 874
  }, {
    "from": 257,
    "label": "calls",
    "to": 875
  }, {
    "from": 257,
    "label": "calls",
    "to": 875
  }, {
    "from": 257,
    "label": "calls",
    "to": 875
  }, {
    "from": 257,
    "label": "calls",
    "to": 875
  }, {
    "from": 257,
    "label": "calls",
    "to": 875
  }, {
    "from": 127,
    "label": "calls",
    "to": 854
  }, {
    "from": 127,
    "label": "calls",
    "to": 854
  }, {
    "from": 178,
    "label": "calls",
    "to": 854
  }, {
    "from": 196,
    "label": "calls",
    "to": 854
  }, {
    "from": 206,
    "label": "calls",
    "to": 854
  }, {
    "from": 210,
    "label": "calls",
    "to": 854
  }, {
    "from": 217,
    "label": "calls",
    "to": 854
  }, {
    "from": 217,
    "label": "calls",
    "to": 854
  }, {
    "from": 257,
    "label": "calls",
    "to": 854
  }, {
    "from": 257,
    "label": "calls",
    "to": 854
  }, {
    "from": 351,
    "label": "calls",
    "to": 922
  }, {
    "from": 24,
    "label": "calls",
    "to": 878
  }, {
    "from": 525,
    "label": "calls",
    "to": 547
  }, {
    "from": 257,
    "label": "calls",
    "to": 217
  }, {
    "from": 257,
    "label": "calls",
    "to": 217
  }, {
    "from": 351,
    "label": "calls",
    "to": 879
  }, {
    "from": 127,
    "label": "calls",
    "to": 880
  }, {
    "from": 178,
    "label": "calls",
    "to": 880
  }, {
    "from": 178,
    "label": "calls",
    "to": 880
  }, {
    "from": 196,
    "label": "calls",
    "to": 880
  }, {
    "from": 196,
    "label": "calls",
    "to": 880
  }, {
    "from": 351,
    "label": "calls",
    "to": 880
  }, {
    "from": 339,
    "label": "calls",
    "to": 858
  }, {
    "from": 339,
    "label": "calls",
    "to": 858
  }, {
    "from": 500,
    "label": "calls",
    "to": 858
  }, {
    "from": 525,
    "label": "calls",
    "to": 858
  }, {
    "from": 553,
    "label": "calls",
    "to": 858
  }, {
    "from": 553,
    "label": "calls",
    "to": 858
  }, {
    "from": 563,
    "label": "calls",
    "to": 858
  }, {
    "from": 563,
    "label": "calls",
    "to": 858
  }, {
    "from": 563,
    "label": "calls",
    "to": 858
  }, {
    "from": 849,
    "label": "calls",
    "to": 870
  }, {
    "from": 24,
    "label": "calls",
    "to": 870
  }, {
    "from": 24,
    "label": "calls",
    "to": 870
  }, {
    "from": 24,
    "label": "calls",
    "to": 870
  }, {
    "from": 24,
    "label": "calls",
    "to": 870
  }, {
    "from": 110,
    "label": "calls",
    "to": 870
  }, {
    "from": 257,
    "label": "calls",
    "to": 870
  }, {
    "from": 257,
    "label": "calls",
    "to": 870
  }, {
    "from": 257,
    "label": "calls",
    "to": 870
  }, {
    "from": 330,
    "label": "calls",
    "to": 870
  }, {
    "from": 330,
    "label": "calls",
    "to": 870
  }, {
    "from": 351,
    "label": "calls",
    "to": 870
  }, {
    "from": 351,
    "label": "calls",
    "to": 870
  }, {
    "from": 351,
    "label": "calls",
    "to": 870
  }, {
    "from": 577,
    "label": "calls",
    "to": 870
  }, {
    "from": 577,
    "label": "calls",
    "to": 870
  }, {
    "from": 577,
    "label": "calls",
    "to": 870
  }, {
    "from": 24,
    "label": "calls",
    "to": 96
  }, {
    "from": 24,
    "label": "calls",
    "to": 96
  }, {
    "from": 127,
    "label": "calls",
    "to": 882
  }, {
    "from": 24,
    "label": "calls",
    "to": 883
  }, {
    "from": 257,
    "label": "calls",
    "to": 210
  }, {
    "from": 257,
    "label": "calls",
    "to": 210
  }, {
    "from": 196,
    "label": "calls",
    "to": 11
  }, {
    "from": 196,
    "label": "calls",
    "to": 11
  }, {
    "from": 849,
    "label": "calls",
    "to": 852
  }, {
    "from": 178,
    "label": "calls",
    "to": 852
  }, {
    "from": 233,
    "label": "calls",
    "to": 162
  }, {
    "from": 351,
    "label": "calls",
    "to": 162
  }, {
    "from": 577,
    "label": "calls",
    "to": 162
  }, {
    "from": 178,
    "label": "calls",
    "to": 851
  }, {
    "from": 127,
    "label": "calls",
    "to": 884
  }, {
    "from": 127,
    "label": "calls",
    "to": 884
  }, {
    "from": 500,
    "label": "calls",
    "to": 885
  }, {
    "from": 525,
    "label": "calls",
    "to": 885
  }, {
    "from": 577,
    "label": "calls",
    "to": 869
  }, {
    "from": 577,
    "label": "calls",
    "to": 869
  }, {
    "from": 257,
    "label": "calls",
    "to": 196
  }, {
    "from": 257,
    "label": "calls",
    "to": 196
  }, {
    "from": 525,
    "label": "calls",
    "to": 196
  }, {
    "from": 351,
    "label": "calls",
    "to": 877
  }, {
    "from": 110,
    "label": "calls",
    "to": 12
  }, {
    "from": 257,
    "label": "calls",
    "to": 12
  }, {
    "from": 351,
    "label": "calls",
    "to": 12
  }, {
    "from": 24,
    "label": "calls",
    "to": 886
  }, {
    "from": 24,
    "label": "calls",
    "to": 886
  }, {
    "from": 351,
    "label": "calls",
    "to": 886
  }, {
    "from": 233,
    "label": "calls",
    "to": 230
  }, {
    "from": 233,
    "label": "calls",
    "to": 230
  }, {
    "from": 257,
    "label": "calls",
    "to": 206
  }, {
    "from": 500,
    "label": "calls",
    "to": 206
  }, {
    "from": 849,
    "label": "calls",
    "to": 3
  }, {
    "from": 849,
    "label": "calls",
    "to": 3
  }, {
    "from": 767,
    "label": "calls",
    "to": 895
  }, {
    "from": 24,
    "label": "calls",
    "to": 106
  }, {
    "from": 337,
    "label": "calls",
    "to": 925
  }, {
    "from": 337,
    "label": "calls",
    "to": 925
  }, {
    "from": 257,
    "label": "calls",
    "to": 889
  }, {
    "from": 257,
    "label": "calls",
    "to": 888
  }, {
    "from": 257,
    "label": "calls",
    "to": 888
  }, {
    "from": 257,
    "label": "calls",
    "to": 888
  }, {
    "from": 257,
    "label": "calls",
    "to": 888
  }, {
    "from": 849,
    "label": "calls",
    "to": 899
  }, {
    "from": 849,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 899
  }, {
    "from": 178,
    "label": "calls",
    "to": 899
  }, {
    "from": 500,
    "label": "calls",
    "to": 899
  }, {
    "from": 577,
    "label": "calls",
    "to": 899
  }, {
    "from": 577,
    "label": "calls",
    "to": 899
  }, {
    "from": 577,
    "label": "calls",
    "to": 899
  }, {
    "from": 577,
    "label": "calls",
    "to": 899
  }, {
    "from": 577,
    "label": "calls",
    "to": 899
  }, {
    "from": 24,
    "label": "calls",
    "to": 98
  }, {
    "from": 24,
    "label": "calls",
    "to": 98
  }, {
    "from": 24,
    "label": "calls",
    "to": 98
  }, {
    "from": 24,
    "label": "calls",
    "to": 98
  }, {
    "from": 767,
    "label": "calls",
    "to": 896
  }, {
    "from": 127,
    "label": "calls",
    "to": 124
  }, {
    "from": 577,
    "label": "calls",
    "to": 124
  }, {
    "from": 577,
    "label": "calls",
    "to": 124
  }, {
    "from": 577,
    "label": "calls",
    "to": 124
  }, {
    "from": 500,
    "label": "calls",
    "to": 905
  }, {
    "from": 525,
    "label": "calls",
    "to": 905
  }, {
    "from": 525,
    "label": "calls",
    "to": 905
  }, {
    "from": 798,
    "label": "calls",
    "to": 887
  }, {
    "from": 233,
    "label": "calls",
    "to": 170
  }, {
    "from": 351,
    "label": "calls",
    "to": 170
  }, {
    "from": 577,
    "label": "calls",
    "to": 170
  }, {
    "from": 577,
    "label": "calls",
    "to": 170
  }, {
    "from": 162,
    "label": "calls",
    "to": 890
  }, {
    "from": 170,
    "label": "calls",
    "to": 890
  }, {
    "from": 176,
    "label": "calls",
    "to": 890
  }, {
    "from": 257,
    "label": "calls",
    "to": 890
  }, {
    "from": 351,
    "label": "calls",
    "to": 890
  }, {
    "from": 849,
    "label": "calls",
    "to": 926
  }, {
    "from": 849,
    "label": "calls",
    "to": 926
  }, {
    "from": 849,
    "label": "calls",
    "to": 926
  }, {
    "from": 849,
    "label": "calls",
    "to": 926
  }, {
    "from": 849,
    "label": "calls",
    "to": 926
  }, {
    "from": 849,
    "label": "calls",
    "to": 926
  }, {
    "from": 767,
    "label": "calls",
    "to": 926
  }, {
    "from": 849,
    "label": "calls",
    "to": 865
  }, {
    "from": 849,
    "label": "calls",
    "to": 865
  }, {
    "from": 178,
    "label": "calls",
    "to": 865
  }, {
    "from": 178,
    "label": "calls",
    "to": 865
  }, {
    "from": 351,
    "label": "calls",
    "to": 865
  }, {
    "from": 257,
    "label": "calls",
    "to": 911
  }, {
    "from": 490,
    "label": "calls",
    "to": 857
  }, {
    "from": 127,
    "label": "calls",
    "to": 160
  }, {
    "from": 351,
    "label": "calls",
    "to": 927
  }, {
    "from": 23,
    "label": "calls",
    "to": 928
  }, {
    "from": 124,
    "label": "calls",
    "to": 928
  }, {
    "from": 577,
    "label": "calls",
    "to": 928
  }, {
    "from": 577,
    "label": "calls",
    "to": 928
  }, {
    "from": 577,
    "label": "calls",
    "to": 928
  }, {
    "from": 577,
    "label": "calls",
    "to": 928
  }, {
    "from": 257,
    "label": "calls",
    "to": 898
  }, {
    "from": 257,
    "label": "calls",
    "to": 898
  }, {
    "from": 257,
    "label": "calls",
    "to": 898
  }, {
    "from": 553,
    "label": "calls",
    "to": 898
  }, {
    "from": 563,
    "label": "calls",
    "to": 898
  }, {
    "from": 257,
    "label": "calls",
    "to": 250
  }, {
    "from": 525,
    "label": "calls",
    "to": 523
  }, {
    "from": 767,
    "label": "calls",
    "to": 859
  }, {
    "from": 500,
    "label": "calls",
    "to": 900
  }, {
    "from": 500,
    "label": "calls",
    "to": 900
  }, {
    "from": 351,
    "label": "calls",
    "to": 901
  }, {
    "from": 351,
    "label": "calls",
    "to": 901
  }, {
    "from": 351,
    "label": "calls",
    "to": 901
  }, {
    "from": 351,
    "label": "calls",
    "to": 901
  }, {
    "from": 351,
    "label": "calls",
    "to": 901
  }, {
    "from": 351,
    "label": "calls",
    "to": 901
  }, {
    "from": 351,
    "label": "calls",
    "to": 901
  }, {
    "from": 351,
    "label": "calls",
    "to": 901
  }, {
    "from": 351,
    "label": "calls",
    "to": 330
  }, {
    "from": 257,
    "label": "calls",
    "to": 902
  }, {
    "from": 577,
    "label": "calls",
    "to": 902
  }, {
    "from": 790,
    "label": "calls",
    "to": 903
  }, {
    "from": 798,
    "label": "calls",
    "to": 903
  }, {
    "from": 790,
    "label": "calls",
    "to": 904
  }, {
    "from": 767,
    "label": "calls",
    "to": 577
  }, {
    "from": 849,
    "label": "calls",
    "to": 907
  }, {
    "from": 849,
    "label": "calls",
    "to": 907
  }, {
    "from": 24,
    "label": "calls",
    "to": 907
  }, {
    "from": 120,
    "label": "calls",
    "to": 907
  }, {
    "from": 257,
    "label": "calls",
    "to": 907
  }, {
    "from": 330,
    "label": "calls",
    "to": 907
  }, {
    "from": 339,
    "label": "calls",
    "to": 907
  }, {
    "from": 351,
    "label": "calls",
    "to": 907
  }, {
    "from": 351,
    "label": "calls",
    "to": 907
  }, {
    "from": 563,
    "label": "calls",
    "to": 907
  }, {
    "from": 577,
    "label": "calls",
    "to": 907
  }, {
    "from": 577,
    "label": "calls",
    "to": 907
  }, {
    "from": 577,
    "label": "calls",
    "to": 907
  }, {
    "from": 577,
    "label": "calls",
    "to": 907
  }, {
    "from": 257,
    "label": "calls",
    "to": 178
  }, {
    "from": 257,
    "label": "calls",
    "to": 178
  }, {
    "from": 849,
    "label": "calls",
    "to": 906
  }, {
    "from": 849,
    "label": "calls",
    "to": 906
  }, {
    "from": 577,
    "label": "calls",
    "to": 906
  }, {
    "from": 577,
    "label": "calls",
    "to": 906
  }, {
    "from": 24,
    "label": "calls",
    "to": 914
  }, {
    "from": 849,
    "label": "calls",
    "to": 908
  }, {
    "from": 24,
    "label": "calls",
    "to": 908
  }, {
    "from": 110,
    "label": "calls",
    "to": 908
  }, {
    "from": 257,
    "label": "calls",
    "to": 908
  }, {
    "from": 257,
    "label": "calls",
    "to": 908
  }, {
    "from": 257,
    "label": "calls",
    "to": 908
  }, {
    "from": 351,
    "label": "calls",
    "to": 908
  }, {
    "from": 351,
    "label": "calls",
    "to": 909
  }, {
    "from": 24,
    "label": "calls",
    "to": 108
  }, {
    "from": 24,
    "label": "calls",
    "to": 108
  }, {
    "from": 24,
    "label": "calls",
    "to": 108
  }, {
    "from": 24,
    "label": "calls",
    "to": 108
  }, {
    "from": 24,
    "label": "calls",
    "to": 913
  }, {
    "from": 339,
    "label": "calls",
    "to": 337
  }, {
    "from": 500,
    "label": "calls",
    "to": 337
  }, {
    "from": 525,
    "label": "calls",
    "to": 337
  }, {
    "from": 553,
    "label": "calls",
    "to": 337
  }, {
    "from": 563,
    "label": "calls",
    "to": 337
  }, {
    "from": 577,
    "label": "calls",
    "to": 912
  }, {
    "from": 577,
    "label": "calls",
    "to": 910
  }, {
    "from": 351,
    "label": "calls",
    "to": 915
  }, {
    "from": 351,
    "label": "calls",
    "to": 916
  }, {
    "from": 500,
    "label": "calls",
    "to": 916
  }, {
    "from": 798,
    "label": "calls",
    "to": 917
  }, {
    "from": 257,
    "label": "calls",
    "to": 223
  }, {
    "from": 257,
    "label": "calls",
    "to": 223
  }, {
    "from": 257,
    "label": "calls",
    "to": 223
  }, {
    "from": 257,
    "label": "calls",
    "to": 918
  }, {
    "from": 257,
    "label": "calls",
    "to": 919
  }, {
    "from": 257,
    "label": "calls",
    "to": 919
  }, {
    "from": 257,
    "label": "calls",
    "to": 919
  }, {
    "from": 525,
    "label": "calls",
    "to": 919
  }, {
    "from": 525,
    "label": "calls",
    "to": 919
  }, {
    "from": 24,
    "label": "calls",
    "to": 920
  }, {
    "from": 577,
    "label": "calls",
    "to": 897
  }, {
    "from": 577,
    "label": "calls",
    "to": 897
  }, {
    "from": 351,
    "label": "calls",
    "to": 921
  }, {
    "from": 351,
    "label": "calls",
    "to": 921
  }, {
    "from": 351,
    "label": "calls",
    "to": 921
  }, {
    "from": 549,
    "label": "calls",
    "to": 525
  }, {
    "from": 551,
    "label": "calls",
    "to": 525
  }, {
    "from": 849,
    "label": "calls",
    "to": 923
  }, {
    "from": 110,
    "label": "calls",
    "to": 923
  }, {
    "from": 196,
    "label": "calls",
    "to": 923
  }, {
    "from": 849,
    "label": "calls",
    "to": 924
  }, {
    "from": 24,
    "label": "calls",
    "to": 924
  }, {
    "from": 24,
    "label": "calls",
    "to": 924
  }, {
    "from": 351,
    "label": "calls",
    "to": 924
  }, {
    "from": 500,
    "label": "calls",
    "to": 924
  }, {
    "from": 3,
    "label": "calls",
    "to": 855
  }, {
    "from": 127,
    "label": "calls",
    "to": 855
  }, {
    "from": 178,
    "label": "calls",
    "to": 855
  }, {
    "from": 196,
    "label": "calls",
    "to": 855
  }, {
    "from": 351,
    "label": "calls",
    "to": 893
  }, {
    "from": 525,
    "label": "calls",
    "to": 893
  }, {
    "from": 577,
    "label": "calls",
    "to": 893
  }, {
    "from": 849,
    "label": "calls",
    "to": 892
  }, {
    "from": 849,
    "label": "calls",
    "to": 892
  }, {
    "from": 24,
    "label": "calls",
    "to": 892
  }, {
    "from": 798,
    "label": "calls",
    "to": 892
  }, {
    "from": 257,
    "label": "calls",
    "to": 176
  }, {
    "from": 351,
    "label": "calls",
    "to": 891
  }, {
    "from": 1,
    "label": "contains",
    "to": 849
  }, {
    "from": 849,
    "label": "declares",
    "to": 3
  }, {
    "from": 849,
    "label": "declares",
    "to": 11
  }, {
    "from": 849,
    "label": "declares",
    "to": 12
  }, {
    "from": 849,
    "label": "declares",
    "to": 17
  }, {
    "from": 849,
    "label": "declares",
    "to": 23
  }, {
    "from": 849,
    "label": "declares",
    "to": 24
  }, {
    "from": 849,
    "label": "declares",
    "to": 96
  }, {
    "from": 849,
    "label": "declares",
    "to": 98
  }, {
    "from": 849,
    "label": "declares",
    "to": 100
  }, {
    "from": 849,
    "label": "declares",
    "to": 101
  }, {
    "from": 849,
    "label": "declares",
    "to": 103
  }, {
    "from": 849,
    "label": "declares",
    "to": 105
  }, {
    "from": 849,
    "label": "declares",
    "to": 106
  }, {
    "from": 849,
    "label": "declares",
    "to": 108
  }, {
    "from": 849,
    "label": "declares",
    "to": 110
  }, {
    "from": 849,
    "label": "declares",
    "to": 120
  }, {
    "from": 849,
    "label": "declares",
    "to": 124
  }, {
    "from": 849,
    "label": "declares",
    "to": 127
  }, {
    "from": 849,
    "label": "declares",
    "to": 160
  }, {
    "from": 849,
    "label": "declares",
    "to": 162
  }, {
    "from": 849,
    "label": "declares",
    "to": 170
  }, {
    "from": 849,
    "label": "declares",
    "to": 176
  }, {
    "from": 849,
    "label": "declares",
    "to": 178
  }, {
    "from": 849,
    "label": "declares",
    "to": 196
  }, {
    "from": 849,
    "label": "declares",
    "to": 206
  }, {
    "from": 849,
    "label": "declares",
    "to": 210
  }, {
    "from": 849,
    "label": "declares",
    "to": 217
  }, {
    "from": 849,
    "label": "declares",
    "to": 223
  }, {
    "from": 849,
    "label": "declares",
    "to": 230
  }, {
    "from": 849,
    "label": "declares",
    "to": 233
  }, {
    "from": 849,
    "label": "declares",
    "to": 250
  }, {
    "from": 849,
    "label": "declares",
    "to": 257
  }, {
    "from": 849,
    "label": "declares",
    "to": 330
  }, {
    "from": 849,
    "label": "declares",
    "to": 337
  }, {
    "from": 849,
    "label": "declares",
    "to": 339
  }, {
    "from": 849,
    "label": "declares",
    "to": 351
  }, {
    "from": 849,
    "label": "declares",
    "to": 484
  }, {
    "from": 849,
    "label": "declares",
    "to": 485
  }, {
    "from": 849,
    "label": "declares",
    "to": 487
  }, {
    "from": 849,
    "label": "declares",
    "to": 490
  }, {
    "from": 849,
    "label": "declares",
    "to": 500
  }, {
    "from": 849,
    "label": "declares",
    "to": 523
  }, {
    "from": 849,
    "label": "declares",
    "to": 525
  }, {
    "from": 849,
    "label": "declares",
    "to": 547
  }, {
    "from": 849,
    "label": "declares",
    "to": 549
  }, {
    "from": 849,
    "label": "declares",
    "to": 551
  }, {
    "from": 849,
    "label": "declares",
    "to": 553
  }, {
    "from": 849,
    "label": "declares",
    "to": 563
  }, {
    "from": 849,
    "label": "declares",
    "to": 577
  }, {
    "from": 849,
    "label": "declares",
    "to": 766
  }, {
    "from": 849,
    "label": "declares",
    "to": 767
  }, {
    "from": 849,
    "label": "declares",
    "to": 790
  }, {
    "from": 849,
    "label": "declares",
    "to": 796
  }, {
    "from": 849,
    "label": "declares",
    "to": 798
  }, {
    "from": 849,
    "label": "declares",
    "to": 808
  }, {
    "from": 849,
    "label": "declares",
    "to": 810
  }, {
    "from": 849,
    "label": "declares",
    "to": 812
  }, {
    "from": 849,
    "label": "declares",
    "to": 813
  }, {
    "from": 849,
    "label": "declares",
    "to": 816
  }, {
    "from": 849,
    "label": "declares",
    "to": 819
  }, {
    "from": 849,
    "label": "declares",
    "to": 820
  }, {
    "from": 849,
    "label": "declares",
    "to": 822
  }, {
    "from": 849,
    "label": "declares",
    "to": 823
  }, {
    "from": 849,
    "label": "declares",
    "to": 824
  }, {
    "from": 849,
    "label": "declares",
    "to": 825
  }, {
    "from": 849,
    "label": "declares",
    "to": 826
  }, {
    "from": 849,
    "label": "declares",
    "to": 827
  }, {
    "from": 849,
    "label": "declares",
    "to": 828
  }, {
    "from": 849,
    "label": "declares",
    "to": 843
  }, {
    "from": 849,
    "label": "declares",
    "to": 845
  }, {
    "from": 849,
    "label": "declares",
    "to": 847
  }, {
    "from": 1,
    "label": "declares",
    "to": 867
  }, {
    "from": 1,
    "label": "declares",
    "to": 879
  }, {
    "from": 1,
    "label": "declares",
    "to": 885
  }, {
    "from": 1,
    "label": "declares",
    "to": 889
  }, {
    "from": 1,
    "label": "declares",
    "to": 902
  }, {
    "from": 1,
    "label": "declares",
    "to": 918
  }, {
    "from": 1,
    "label": "declares",
    "to": 921
  }, {
    "from": 1,
    "label": "declares",
    "to": 927
  }, {
    "from": 929,
    "label": "requires",
    "to": 1
  }, {
    "from": 1,
    "label": "contains",
    "to": 930
  }, {
    "from": 1,
    "label": "contains",
    "to": 931
  }, {
    "from": 930,
    "label": "initializes",
    "to": 932
  }, {
    "from": 932,
    "label": "assigns",
    "to": 933
  }, {
    "from": 930,
    "label": "initializes",
    "to": 934
  }, {
    "from": 934,
    "label": "assigns",
    "to": 935
  }, {
    "from": 930,
    "label": "initializes",
    "to": 936
  }, {
    "from": 936,
    "label": "assigns",
    "to": 937
  }, {
    "from": 937,
    "label": "assigns",
    "to": 938
  }, {
    "from": 938,
    "label": "assigns",
    "to": 939
  }, {
    "from": 937,
    "label": "assigns",
    "to": 940
  }, {
    "from": 940,
    "label": "assigns",
    "to": 941
  }, {
    "from": 937,
    "label": "assigns",
    "to": 942
  }, {
    "from": 942,
    "label": "assigns",
    "to": 943
  }, {
    "from": 937,
    "label": "assigns",
    "to": 944
  }, {
    "from": 944,
    "label": "assigns",
    "to": 945
  }, {
    "from": 937,
    "label": "assigns",
    "to": 946
  }, {
    "from": 946,
    "label": "assigns",
    "to": 947
  }, {
    "from": 937,
    "label": "assigns",
    "to": 948
  }, {
    "from": 948,
    "label": "assigns",
    "to": 949
  }, {
    "from": 937,
    "label": "assigns",
    "to": 950
  }, {
    "from": 950,
    "label": "assigns",
    "to": 951
  }, {
    "from": 937,
    "label": "assigns",
    "to": 952
  }, {
    "from": 952,
    "label": "assigns",
    "to": 953
  }, {
    "from": 930,
    "label": "initializes",
    "to": 954
  }, {
    "from": 954,
    "label": "assigns",
    "to": 955
  }, {
    "from": 930,
    "label": "initializes",
    "to": 956
  }, {
    "from": 956,
    "label": "assigns",
    "to": 957
  }, {
    "from": 930,
    "label": "initializes",
    "to": 958
  }, {
    "from": 958,
    "label": "assigns",
    "to": 959
  }, {
    "from": 930,
    "label": "initializes",
    "to": 960
  }, {
    "from": 960,
    "label": "assigns",
    "to": 961
  }, {
    "from": 930,
    "label": "initializes",
    "to": 962
  }, {
    "from": 962,
    "label": "assigns",
    "to": 963
  }, {
    "from": 930,
    "label": "initializes",
    "to": 964
  }, {
    "from": 964,
    "label": "assigns",
    "to": 965
  }, {
    "from": 930,
    "label": "initializes",
    "to": 966
  }, {
    "from": 966,
    "label": "assigns",
    "to": 967
  }, {
    "from": 930,
    "label": "initializes",
    "to": 968
  }, {
    "from": 968,
    "label": "assigns",
    "to": 969
  }, {
    "from": 930,
    "label": "initializes",
    "to": 970
  }, {
    "from": 970,
    "label": "assigns",
    "to": 971
  }, {
    "from": 930,
    "label": "initializes",
    "to": 972
  }, {
    "from": 972,
    "label": "assigns",
    "to": 973
  }, {
    "from": 930,
    "label": "initializes",
    "to": 974
  }, {
    "from": 974,
    "label": "assigns",
    "to": 975
  }, {
    "from": 930,
    "label": "initializes",
    "to": 976
  }, {
    "from": 976,
    "label": "assigns",
    "to": 977
  }, {
    "from": 930,
    "label": "initializes",
    "to": 978
  }, {
    "from": 978,
    "label": "assigns",
    "to": 979
  }, {
    "from": 930,
    "label": "initializes",
    "to": 980
  }, {
    "from": 980,
    "label": "assigns",
    "to": 981
  }, {
    "from": 930,
    "label": "initializes",
    "to": 982
  }, {
    "from": 982,
    "label": "assigns",
    "to": 983
  }, {
    "from": 930,
    "label": "initializes",
    "to": 984
  }, {
    "from": 984,
    "label": "assigns",
    "to": 985
  }, {
    "from": 930,
    "label": "initializes",
    "to": 986
  }, {
    "from": 986,
    "label": "assigns",
    "to": 987
  }, {
    "from": 930,
    "label": "initializes",
    "to": 988
  }, {
    "from": 988,
    "label": "assigns",
    "to": 989
  }, {
    "from": 930,
    "label": "initializes",
    "to": 990
  }, {
    "from": 990,
    "label": "assigns",
    "to": 991
  }, {
    "from": 930,
    "label": "initializes",
    "to": 992
  }, {
    "from": 992,
    "label": "assigns",
    "to": 993
  }, {
    "from": 930,
    "label": "initializes",
    "to": 994
  }, {
    "from": 994,
    "label": "assigns",
    "to": 995
  }, {
    "from": 930,
    "label": "initializes",
    "to": 996
  }, {
    "from": 996,
    "label": "assigns",
    "to": 997
  }, {
    "from": 930,
    "label": "initializes",
    "to": 998
  }, {
    "from": 998,
    "label": "assigns",
    "to": 999
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1000
  }, {
    "from": 1000,
    "label": "assigns",
    "to": 1001
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1002
  }, {
    "from": 1002,
    "label": "assigns",
    "to": 1003
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1004
  }, {
    "from": 1004,
    "label": "assigns",
    "to": 1005
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1006
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1007
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1008
  }, {
    "from": 1008,
    "label": "assigns",
    "to": 1009
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1010
  }, {
    "from": 1010,
    "label": "assigns",
    "to": 1011
  }, {
    "from": 1011,
    "label": "assigns",
    "to": 1012
  }, {
    "from": 1012,
    "label": "assigns",
    "to": 1013
  }, {
    "from": 1011,
    "label": "assigns",
    "to": 1014
  }, {
    "from": 1014,
    "label": "assigns",
    "to": 1015
  }, {
    "from": 1011,
    "label": "assigns",
    "to": 1016
  }, {
    "from": 1016,
    "label": "assigns",
    "to": 1017
  }, {
    "from": 1011,
    "label": "assigns",
    "to": 1018
  }, {
    "from": 1018,
    "label": "assigns",
    "to": 1019
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1020
  }, {
    "from": 1020,
    "label": "assigns",
    "to": 1021
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1022
  }, {
    "from": 1022,
    "label": "assigns",
    "to": 1023
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1024
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1025
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1026
  }, {
    "from": 1026,
    "label": "assigns",
    "to": 1027
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1028
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1029
  }, {
    "from": 1029,
    "label": "assigns",
    "to": 1030
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1031
  }, {
    "from": 1031,
    "label": "assigns",
    "to": 1032
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1033
  }, {
    "from": 1033,
    "label": "assigns",
    "to": 1034
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1035
  }, {
    "from": 1035,
    "label": "assigns",
    "to": 1036
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1037
  }, {
    "from": 1037,
    "label": "assigns",
    "to": 1038
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1039
  }, {
    "from": 1039,
    "label": "assigns",
    "to": 1040
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1041
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1042
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1043
  }, {
    "from": 1043,
    "label": "assigns",
    "to": 1044
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1045
  }, {
    "from": 1045,
    "label": "assigns",
    "to": 1046
  }, {
    "from": 1046,
    "label": "assigns",
    "to": 1047
  }, {
    "from": 1047,
    "label": "assigns",
    "to": 1048
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1049
  }, {
    "from": 1049,
    "label": "assigns",
    "to": 1050
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1051
  }, {
    "from": 1051,
    "label": "assigns",
    "to": 1052
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1053
  }, {
    "from": 1053,
    "label": "assigns",
    "to": 1054
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1055
  }, {
    "from": 1055,
    "label": "assigns",
    "to": 1056
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1057
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1058
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1059
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1060
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1061
  }, {
    "from": 1061,
    "label": "assigns",
    "to": 1062
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1063
  }, {
    "from": 1063,
    "label": "assigns",
    "to": 1064
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1065
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1066
  }, {
    "from": 1066,
    "label": "assigns",
    "to": 1067
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1068
  }, {
    "from": 1068,
    "label": "assigns",
    "to": 1069
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1070
  }, {
    "from": 1070,
    "label": "assigns",
    "to": 1071
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1072
  }, {
    "from": 1072,
    "label": "assigns",
    "to": 1073
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1074
  }, {
    "from": 1074,
    "label": "assigns",
    "to": 1075
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1076
  }, {
    "from": 1076,
    "label": "assigns",
    "to": 1077
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1078
  }, {
    "from": 1078,
    "label": "assigns",
    "to": 1079
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1080
  }, {
    "from": 1080,
    "label": "assigns",
    "to": 1081
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1082
  }, {
    "from": 1082,
    "label": "assigns",
    "to": 1083
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1084
  }, {
    "from": 1084,
    "label": "assigns",
    "to": 1085
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1086
  }, {
    "from": 1086,
    "label": "assigns",
    "to": 1087
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1088
  }, {
    "from": 1088,
    "label": "assigns",
    "to": 1089
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1090
  }, {
    "from": 1090,
    "label": "assigns",
    "to": 1091
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1092
  }, {
    "from": 1092,
    "label": "assigns",
    "to": 1093
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1094
  }, {
    "from": 1094,
    "label": "assigns",
    "to": 1095
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1096
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1097
  }, {
    "from": 1097,
    "label": "assigns",
    "to": 1098
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1099
  }, {
    "from": 1099,
    "label": "assigns",
    "to": 1100
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1101
  }, {
    "from": 930,
    "label": "initializes",
    "to": 1102
  }, {
    "from": 1102,
    "label": "assigns",
    "to": 1103
  }, {
    "from": 931,
    "label": "initializes",
    "to": 1104
  }, {
    "from": 1104,
    "label": "requires",
    "to": 894
  }, {
    "from": 931,
    "label": "initializes",
    "to": 1105
  }, {
    "from": 1105,
    "label": "requires",
    "to": 881
  }, {
    "from": 931,
    "label": "initializes",
    "to": 1106
  }, {
    "from": 1106,
    "label": "requires",
    "to": 860
  }, {
    "from": 931,
    "label": "initializes",
    "to": 1107
  }, {
    "from": 1107,
    "label": "requires",
    "to": 876
  }, {
    "from": 931,
    "label": "initializes",
    "to": 1108
  }, {
    "from": 1108,
    "label": "requires",
    "to": 850
  }, {
    "from": 931,
    "label": "initializes",
    "to": 1109
  }, {
    "from": 1109,
    "label": "requires",
    "to": 856
  }, {
    "from": 931,
    "label": "initializes",
    "to": 1110
  }, {
    "from": 1110,
    "label": "requires",
    "to": 856
  }, {
    "from": 1,
    "label": "provides",
    "to": 1111
  }, {
    "from": 936,
    "label": "represents",
    "to": 1112
  }, {
    "from": 1111,
    "label": "provides",
    "to": 1112
  }, {
    "from": 45,
    "label": "hasArgument",
    "to": 820
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "mobdebug",
    "type": "module"
  }, {
    "id": 2,
    "text": "",
    "type": "function container"
  }, {
    "id": 3,
    "text": "local function findenv(f)\r\n    local level = 1\r\n    repeat\r\n      local name, value = debug.getupvalue(f, level)\r\n      if name == '_ENV' then return level, value end\r\n      level = level + 1\r\n    until name == nil\r\n    return nil end",
    "type": "function"
  }, {
    "id": 4,
    "text": "local level = 1",
    "type": "statement:localassign"
  }, {
    "id": 5,
    "text": "repeat\r\n      local name, value = debug.getupvalue(f, level)\r\n      if name == '_ENV' then return level, value end\r\n      level = level + 1\r\n    until name == nil",
    "type": "statement:repeat"
  }, {
    "id": 6,
    "text": "local name, value = debug.getupvalue(f, level)",
    "type": "statement:localassign"
  }, {
    "id": 7,
    "text": "if name == '_ENV' then return level, value end",
    "type": "statement:if"
  }, {
    "id": 8,
    "text": "level = level + 1",
    "type": "statement:assign"
  }, {
    "id": 9,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 10,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 11,
    "text": "function (f) return(select(2, findenv(f)) or _G) end",
    "type": "function"
  }, {
    "id": 12,
    "text": "function (f, t)\r\n    local level = findenv(f)\r\n    if level then debug.setupvalue(f, level, t) end\r\n    return f end",
    "type": "function"
  }, {
    "id": 13,
    "text": "local level = findenv(f)",
    "type": "statement:localassign"
  }, {
    "id": 14,
    "text": "if level then debug.setupvalue(f, level, t) end",
    "type": "statement:if"
  }, {
    "id": 15,
    "text": "debug.setupvalue(f, level, t)",
    "type": "statement:functioncall"
  }, {
    "id": 16,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 17,
    "text": "function ()\r\n  local a = 1\r\n  for _ = 1, 10 do a = a + 1 end\r\n  error(deferror)\r\nend",
    "type": "function"
  }, {
    "id": 18,
    "text": "local a = 1",
    "type": "statement:localassign"
  }, {
    "id": 19,
    "text": "for _ = 1, 10 do a = a + 1 end",
    "type": "statement:numericfor"
  }, {
    "id": 20,
    "text": "a = a + 1",
    "type": "statement:assign"
  }, {
    "id": 21,
    "text": "error(deferror)",
    "type": "statement:functioncall"
  }, {
    "id": 22,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 23,
    "text": "local function q(s) return string.gsub(s, '([%(%)%.%%%+%-%*%?%[%^%$%]])','%%%1') end",
    "type": "function"
  }, {
    "id": 24,
    "text": "local function s(t, opts)\r\n  local name, indent, fatal, maxnum = opts.name, opts.indent, opts.fatal, opts.maxnum\r\n  local sparse, custom, huge = opts.sparse, opts.custom, not opts.nohuge\r\n  local space, maxl = (opts.compact and '' or ' '), (opts.maxlevel or math.huge)\r\n  local iname, comm = '_'..(name or ''), opts.comment and (tonumber(opts.comment) or math.huge)\r\n  local numformat = opts.numformat or \"%.17g\"\r\n  local seen, sref, syms, symn = {}, {'local '..iname..'={}'}, {}, 0\r\n  local function gensym(val) return '_'..(tostring(tostring(val)):gsub(\"[^%w]\",\"\"):gsub(\"(%d%w+)\",\r\n    -- tostring(val) is needed because __tostring may return a non-string value\r\n    function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end)) end\r\n  local function safestr(s) return type(s) == \"number\" and tostring(huge and snum[tostring(s)] or numformat:format(s))\r\n    or type(s) ~= \"string\" and tostring(s) -- escape NEWLINE/010 and EOF/026\r\n    or (\"%q\"):format(s):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\") end\r\n  local function comment(s,l) return comm and (l or 0) < comm and ' --[['..select(2, pcall(tostring, s))..']]' or '' end\r\n  local function globerr(s,l) return globals[s] and globals[s]..comment(s,l) or not fatal\r\n    and safestr(select(2, pcall(tostring, s))) or error(\"Can't serialize \"..tostring(s)) end\r\n  local function safename(path, name) -- generates foo.bar, foo[3], or foo['b a r']\r\n    local n = name == nil and '' or name\r\n    local plain = type(n) == \"string\" and n:match(\"^[%l%u_][%w_]*$\") and not keyword[n]\r\n    local safe = plain and n or '['..safestr(n)..']'\r\n    return (path or '')..(plain and path and '.' or '')..safe, safe end\r\n  local alphanumsort = type(opts.sortkeys) == 'function' and opts.sortkeys or function(k, o, n) -- k=keys, o=originaltable, n=padding\r\n    local maxn, to = tonumber(n) or 12, {number = 'a', string = 'b'}\r\n    local function padnum(d) return (\"%0\"..tostring(maxn)..\"d\"):format(tonumber(d)) end\r\n    table.sort(k, function(a,b)\r\n      -- sort numeric keys first: k[key] is not nil for numerical keys\r\n      return (k[a] ~= nil and 0 or to[type(a)] or 'z')..(tostring(a):gsub(\"%d+\",padnum))\r\n           < (k[b] ~= nil and 0 or to[type(b)] or 'z')..(tostring(b):gsub(\"%d+\",padnum)) end) end\r\n  local function val2str(t, name, indent, insref, path, plainindex, level)\r\n    local ttype, level, mt = type(t), (level or 0), getmetatable(t)\r\n    local spath, sname = safename(path, name)\r\n    local tag = plainindex and\r\n      ((type(name) == \"number\") and '' or name..space..'='..space) or\r\n      (name ~= nil and sname..space..'='..space or '')\r\n    if seen[t] then -- already seen this element\r\n      sref[#sref+1] = spath..space..'='..space..seen[t]\r\n      return tag..'nil'..comment('ref', level) end\r\n    -- protect from those cases where __tostring may fail\r\n    if type(mt) == 'table' and pcall(function() return mt.__tostring and mt.__tostring(t) end)\r\n    and (mt.__serialize or mt.__tostring) then -- knows how to serialize itself\r\n      seen[t] = insref or spath\r\n      if mt.__serialize then t = mt.__serialize(t) else t = tostring(t) end\r\n      ttype = type(t) end -- new value falls through to be serialized\r\n    if ttype == \"table\" then\r\n      if level >= maxl then return tag..'{}'..comment('max', level) end\r\n      seen[t] = insref or spath\r\n      if next(t) == nil then return tag..'{}'..comment(t, level) end -- table empty\r\n      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}\r\n      for key = 1, maxn do o[key] = key end\r\n      if not maxnum or #o < maxnum then\r\n        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables\r\n        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end\r\n      if maxnum and #o > maxnum then o[maxnum+1] = nil end\r\n      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end\r\n      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)\r\n      for n, key in ipairs(o) do\r\n        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse\r\n        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\r\n        or opts.keyallow and not opts.keyallow[key]\r\n        or opts.keyignore and opts.keyignore[key]\r\n        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\r\n        or sparse and value == nil then -- skipping nils; do nothing\r\n        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then\r\n          if not seen[key] and not globals[key] then\r\n            sref[#sref+1] = 'placeholder'\r\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\r\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\r\n          sref[#sref+1] = 'placeholder'\r\n          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'\r\n          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))\r\n        else\r\n          out[#out+1] = val2str(value,key,indent,insref,seen[t],plainindex,level+1)\r\n        end\r\n      end\r\n      local prefix = string.rep(indent or '', level)\r\n      local head = indent and '{\\n'..prefix..indent or '{'\r\n      local body = table.concat(out, ','..(indent and '\\n'..prefix..indent or space))\r\n      local tail = indent and \"\\n\"..prefix..'}' or '}'\r\n      return (custom and custom(tag,head,body,tail) or tag..head..body..tail)..comment(t, level)\r\n    elseif badtype[ttype] then\r\n      seen[t] = insref or spath\r\n      return tag..globerr(t, level)\r\n    elseif ttype == 'function' then\r\n      seen[t] = insref or spath\r\n      local ok, res = pcall(string.dump, t)\r\n      local func = ok and ((opts.nocode and \"function() --[[..skipped..]] end\" or\r\n        \"((loadstring or load)(\"..safestr(res)..\",'@serialized'))\")..comment(t, level))\r\n      return tag..(func or globerr(t, level))\r\n    else return tag..safestr(t) end -- handle all other types\r\n  end\r\n  local sepr = indent and \"\\n\" or \";\"..space\r\n  local body = val2str(t, name, indent) -- this call also populates sref\r\n  local tail = #sref>1 and table.concat(sref, sepr)..sepr or ''\r\n  local warn = opts.comment and #sref>1 and space..\"--[[incomplete output with shared/self-references skipped]]\" or ''\r\n  return not name and body..warn or \"do local \"..body..sepr..tail..\"return \"..name..sepr..\"end\"\r\nend",
    "type": "function"
  }, {
    "id": 25,
    "text": "local name, indent, fatal, maxnum = opts.name, opts.indent, opts.fatal, opts.maxnum",
    "type": "statement:localassign"
  }, {
    "id": 26,
    "text": "local sparse, custom, huge = opts.sparse, opts.custom, not opts.nohuge",
    "type": "statement:localassign"
  }, {
    "id": 27,
    "text": "local space, maxl = (opts.compact and '' or ' '), (opts.maxlevel or math.huge)",
    "type": "statement:localassign"
  }, {
    "id": 28,
    "text": "local iname, comm = '_'..(name or ''), opts.comment and (tonumber(opts.comment) or math.huge)",
    "type": "statement:localassign"
  }, {
    "id": 29,
    "text": "local numformat = opts.numformat or \"%.17g\"",
    "type": "statement:localassign"
  }, {
    "id": 30,
    "text": "local seen, sref, syms, symn = {}, {'local '..iname..'={}'}, {}, 0",
    "type": "statement:localassign"
  }, {
    "id": 31,
    "text": "local function gensym(val) return '_'..(tostring(tostring(val)):gsub(\"[^%w]\",\"\"):gsub(\"(%d%w+)\",\r\n    -- tostring(val) is needed because __tostring may return a non-string value\r\n    function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end)) end",
    "type": "statement:localfunction"
  }, {
    "id": 32,
    "text": "if not syms[s] then symn = symn+1; syms[s] = symn end",
    "type": "statement:if"
  }, {
    "id": 33,
    "text": "symn = symn+1",
    "type": "statement:assign"
  }, {
    "id": 34,
    "text": "syms[s] = symn",
    "type": "statement:assign"
  }, {
    "id": 35,
    "text": "local function safestr(s) return type(s) == \"number\" and tostring(huge and snum[tostring(s)] or numformat:format(s))\r\n    or type(s) ~= \"string\" and tostring(s) -- escape NEWLINE/010 and EOF/026\r\n    or (\"%q\"):format(s):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\") end",
    "type": "statement:localfunction"
  }, {
    "id": 36,
    "text": "local function comment(s,l) return comm and (l or 0) < comm and ' --[['..select(2, pcall(tostring, s))..']]' or '' end",
    "type": "statement:localfunction"
  }, {
    "id": 37,
    "text": "local function globerr(s,l) return globals[s] and globals[s]..comment(s,l) or not fatal\r\n    and safestr(select(2, pcall(tostring, s))) or error(\"Can't serialize \"..tostring(s)) end",
    "type": "statement:localfunction"
  }, {
    "id": 38,
    "text": "local function safename(path, name) -- generates foo.bar, foo[3], or foo['b a r']\r\n    local n = name == nil and '' or name\r\n    local plain = type(n) == \"string\" and n:match(\"^[%l%u_][%w_]*$\") and not keyword[n]\r\n    local safe = plain and n or '['..safestr(n)..']'\r\n    return (path or '')..(plain and path and '.' or '')..safe, safe end",
    "type": "statement:localfunction"
  }, {
    "id": 39,
    "text": "local n = name == nil and '' or name",
    "type": "statement:localassign"
  }, {
    "id": 40,
    "text": "local plain = type(n) == \"string\" and n:match(\"^[%l%u_][%w_]*$\") and not keyword[n]",
    "type": "statement:localassign"
  }, {
    "id": 41,
    "text": "local safe = plain and n or '['..safestr(n)..']'",
    "type": "statement:localassign"
  }, {
    "id": 42,
    "text": "local alphanumsort = type(opts.sortkeys) == 'function' and opts.sortkeys or function(k, o, n) -- k=keys, o=originaltable, n=padding\r\n    local maxn, to = tonumber(n) or 12, {number = 'a', string = 'b'}\r\n    local function padnum(d) return (\"%0\"..tostring(maxn)..\"d\"):format(tonumber(d)) end\r\n    table.sort(k, function(a,b)\r\n      -- sort numeric keys first: k[key] is not nil for numerical keys\r\n      return (k[a] ~= nil and 0 or to[type(a)] or 'z')..(tostring(a):gsub(\"%d+\",padnum))\r\n           < (k[b] ~= nil and 0 or to[type(b)] or 'z')..(tostring(b):gsub(\"%d+\",padnum)) end) end",
    "type": "statement:localassign"
  }, {
    "id": 43,
    "text": "local maxn, to = tonumber(n) or 12, {number = 'a', string = 'b'}",
    "type": "statement:localassign"
  }, {
    "id": 44,
    "text": "local function padnum(d) return (\"%0\"..tostring(maxn)..\"d\"):format(tonumber(d)) end",
    "type": "statement:localfunction"
  }, {
    "id": 45,
    "text": "table.sort(k, function(a,b)\r\n      -- sort numeric keys first: k[key] is not nil for numerical keys\r\n      return (k[a] ~= nil and 0 or to[type(a)] or 'z')..(tostring(a):gsub(\"%d+\",padnum))\r\n           < (k[b] ~= nil and 0 or to[type(b)] or 'z')..(tostring(b):gsub(\"%d+\",padnum)) end)",
    "type": "statement:functioncall"
  }, {
    "id": 46,
    "text": "local function val2str(t, name, indent, insref, path, plainindex, level)\r\n    local ttype, level, mt = type(t), (level or 0), getmetatable(t)\r\n    local spath, sname = safename(path, name)\r\n    local tag = plainindex and\r\n      ((type(name) == \"number\") and '' or name..space..'='..space) or\r\n      (name ~= nil and sname..space..'='..space or '')\r\n    if seen[t] then -- already seen this element\r\n      sref[#sref+1] = spath..space..'='..space..seen[t]\r\n      return tag..'nil'..comment('ref', level) end\r\n    -- protect from those cases where __tostring may fail\r\n    if type(mt) == 'table' and pcall(function() return mt.__tostring and mt.__tostring(t) end)\r\n    and (mt.__serialize or mt.__tostring) then -- knows how to serialize itself\r\n      seen[t] = insref or spath\r\n      if mt.__serialize then t = mt.__serialize(t) else t = tostring(t) end\r\n      ttype = type(t) end -- new value falls through to be serialized\r\n    if ttype == \"table\" then\r\n      if level >= maxl then return tag..'{}'..comment('max', level) end\r\n      seen[t] = insref or spath\r\n      if next(t) == nil then return tag..'{}'..comment(t, level) end -- table empty\r\n      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}\r\n      for key = 1, maxn do o[key] = key end\r\n      if not maxnum or #o < maxnum then\r\n        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables\r\n        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end\r\n      if maxnum and #o > maxnum then o[maxnum+1] = nil end\r\n      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end\r\n      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)\r\n      for n, key in ipairs(o) do\r\n        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse\r\n        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\r\n        or opts.keyallow and not opts.keyallow[key]\r\n        or opts.keyignore and opts.keyignore[key]\r\n        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\r\n        or sparse and value == nil then -- skipping nils; do nothing\r\n        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then\r\n          if not seen[key] and not globals[key] then\r\n            sref[#sref+1] = 'placeholder'\r\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\r\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\r\n          sref[#sref+1] = 'placeholder'\r\n          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'\r\n          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))\r\n        else\r\n          out[#out+1] = val2str(value,key,indent,insref,seen[t],plainindex,level+1)\r\n        end\r\n      end\r\n      local prefix = string.rep(indent or '', level)\r\n      local head = indent and '{\\n'..prefix..indent or '{'\r\n      local body = table.concat(out, ','..(indent and '\\n'..prefix..indent or space))\r\n      local tail = indent and \"\\n\"..prefix..'}' or '}'\r\n      return (custom and custom(tag,head,body,tail) or tag..head..body..tail)..comment(t, level)\r\n    elseif badtype[ttype] then\r\n      seen[t] = insref or spath\r\n      return tag..globerr(t, level)\r\n    elseif ttype == 'function' then\r\n      seen[t] = insref or spath\r\n      local ok, res = pcall(string.dump, t)\r\n      local func = ok and ((opts.nocode and \"function() --[[..skipped..]] end\" or\r\n        \"((loadstring or load)(\"..safestr(res)..\",'@serialized'))\")..comment(t, level))\r\n      return tag..(func or globerr(t, level))\r\n    else return tag..safestr(t) end -- handle all other types\r\n  end",
    "type": "statement:localfunction"
  }, {
    "id": 47,
    "text": "local ttype, level, mt = type(t), (level or 0), getmetatable(t)",
    "type": "statement:localassign"
  }, {
    "id": 48,
    "text": "local spath, sname = safename(path, name)",
    "type": "statement:localassign"
  }, {
    "id": 49,
    "text": "local tag = plainindex and\r\n      ((type(name) == \"number\") and '' or name..space..'='..space) or\r\n      (name ~= nil and sname..space..'='..space or '')",
    "type": "statement:localassign"
  }, {
    "id": 50,
    "text": "if seen[t] then -- already seen this element\r\n      sref[#sref+1] = spath..space..'='..space..seen[t]\r\n      return tag..'nil'..comment('ref', level) end",
    "type": "statement:if"
  }, {
    "id": 51,
    "text": "sref[#sref+1] = spath..space..'='..space..seen[t]",
    "type": "statement:assign"
  }, {
    "id": 52,
    "text": "if type(mt) == 'table' and pcall(function() return mt.__tostring and mt.__tostring(t) end)\r\n    and (mt.__serialize or mt.__tostring) then -- knows how to serialize itself\r\n      seen[t] = insref or spath\r\n      if mt.__serialize then t = mt.__serialize(t) else t = tostring(t) end\r\n      ttype = type(t) end",
    "type": "statement:if"
  }, {
    "id": 53,
    "text": "seen[t] = insref or spath",
    "type": "statement:assign"
  }, {
    "id": 54,
    "text": "if mt.__serialize then t = mt.__serialize(t) else t = tostring(t) end",
    "type": "statement:if"
  }, {
    "id": 55,
    "text": "t = mt.__serialize(t)",
    "type": "statement:assign"
  }, {
    "id": 56,
    "text": "t = tostring(t)",
    "type": "statement:assign"
  }, {
    "id": 57,
    "text": "ttype = type(t)",
    "type": "statement:assign"
  }, {
    "id": 58,
    "text": "if ttype == \"table\" then\r\n      if level >= maxl then return tag..'{}'..comment('max', level) end\r\n      seen[t] = insref or spath\r\n      if next(t) == nil then return tag..'{}'..comment(t, level) end -- table empty\r\n      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}\r\n      for key = 1, maxn do o[key] = key end\r\n      if not maxnum or #o < maxnum then\r\n        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables\r\n        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end\r\n      if maxnum and #o > maxnum then o[maxnum+1] = nil end\r\n      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end\r\n      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)\r\n      for n, key in ipairs(o) do\r\n        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse\r\n        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\r\n        or opts.keyallow and not opts.keyallow[key]\r\n        or opts.keyignore and opts.keyignore[key]\r\n        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\r\n        or sparse and value == nil then -- skipping nils; do nothing\r\n        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then\r\n          if not seen[key] and not globals[key] then\r\n            sref[#sref+1] = 'placeholder'\r\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\r\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\r\n          sref[#sref+1] = 'placeholder'\r\n          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'\r\n          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))\r\n        else\r\n          out[#out+1] = val2str(value,key,indent,insref,seen[t],plainindex,level+1)\r\n        end\r\n      end\r\n      local prefix = string.rep(indent or '', level)\r\n      local head = indent and '{\\n'..prefix..indent or '{'\r\n      local body = table.concat(out, ','..(indent and '\\n'..prefix..indent or space))\r\n      local tail = indent and \"\\n\"..prefix..'}' or '}'\r\n      return (custom and custom(tag,head,body,tail) or tag..head..body..tail)..comment(t, level)\r\n    elseif badtype[ttype] then\r\n      seen[t] = insref or spath\r\n      return tag..globerr(t, level)\r\n    elseif ttype == 'function' then\r\n      seen[t] = insref or spath\r\n      local ok, res = pcall(string.dump, t)\r\n      local func = ok and ((opts.nocode and \"function() --[[..skipped..]] end\" or\r\n        \"((loadstring or load)(\"..safestr(res)..\",'@serialized'))\")..comment(t, level))\r\n      return tag..(func or globerr(t, level))\r\n    else return tag..safestr(t) end",
    "type": "statement:if"
  }, {
    "id": 59,
    "text": "if level >= maxl then return tag..'{}'..comment('max', level) end",
    "type": "statement:if"
  }, {
    "id": 60,
    "text": "if next(t) == nil then return tag..'{}'..comment(t, level) end",
    "type": "statement:if"
  }, {
    "id": 61,
    "text": "local maxn, o, out = math.min(#t, maxnum or #t), {}, {}",
    "type": "statement:localassign"
  }, {
    "id": 62,
    "text": "for key = 1, maxn do o[key] = key end",
    "type": "statement:numericfor"
  }, {
    "id": 63,
    "text": "o[key] = key",
    "type": "statement:assign"
  }, {
    "id": 64,
    "text": "if not maxnum or #o < maxnum then\r\n        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables\r\n        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end",
    "type": "statement:if"
  }, {
    "id": 65,
    "text": "local n = #o",
    "type": "statement:localassign"
  }, {
    "id": 66,
    "text": "for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end",
    "type": "statement:genericfor"
  }, {
    "id": 67,
    "text": "if o[key] ~= key then n = n + 1; o[n] = key end",
    "type": "statement:if"
  }, {
    "id": 68,
    "text": "n = n + 1",
    "type": "statement:assign"
  }, {
    "id": 69,
    "text": "o[n] = key",
    "type": "statement:assign"
  }, {
    "id": 70,
    "text": "if maxnum and #o > maxnum then o[maxnum+1] = nil end",
    "type": "statement:if"
  }, {
    "id": 71,
    "text": "o[maxnum+1] = nil",
    "type": "statement:assign"
  }, {
    "id": 72,
    "text": "if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end",
    "type": "statement:if"
  }, {
    "id": 73,
    "text": "alphanumsort(o, t, opts.sortkeys)",
    "type": "statement:functioncall"
  }, {
    "id": 74,
    "text": "local sparse = sparse and #o > maxn",
    "type": "statement:localassign"
  }, {
    "id": 75,
    "text": "for n, key in ipairs(o) do\r\n        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse\r\n        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\r\n        or opts.keyallow and not opts.keyallow[key]\r\n        or opts.keyignore and opts.keyignore[key]\r\n        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\r\n        or sparse and value == nil then -- skipping nils; do nothing\r\n        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then\r\n          if not seen[key] and not globals[key] then\r\n            sref[#sref+1] = 'placeholder'\r\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\r\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\r\n          sref[#sref+1] = 'placeholder'\r\n          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'\r\n          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))\r\n        else\r\n          out[#out+1] = val2str(value,key,indent,insref,seen[t],plainindex,level+1)\r\n        end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 76,
    "text": "local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse",
    "type": "statement:localassign"
  }, {
    "id": 77,
    "text": "if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\r\n        or opts.keyallow and not opts.keyallow[key]\r\n        or opts.keyignore and opts.keyignore[key]\r\n        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\r\n        or sparse and value == nil then -- skipping nils; do nothing\r\n        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then\r\n          if not seen[key] and not globals[key] then\r\n            sref[#sref+1] = 'placeholder'\r\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\r\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\r\n          sref[#sref+1] = 'placeholder'\r\n          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'\r\n          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))\r\n        else\r\n          out[#out+1] = val2str(value,key,indent,insref,seen[t],plainindex,level+1)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 78,
    "text": "if not seen[key] and not globals[key] then\r\n            sref[#sref+1] = 'placeholder'\r\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\r\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end",
    "type": "statement:if"
  }, {
    "id": 79,
    "text": "sref[#sref+1] = 'placeholder'",
    "type": "statement:assign"
  }, {
    "id": 80,
    "text": "local sname = safename(iname, gensym(key))",
    "type": "statement:localassign"
  }, {
    "id": 81,
    "text": "sref[#sref] = val2str(key,sname,indent,sname,iname,true)",
    "type": "statement:assign"
  }, {
    "id": 82,
    "text": "local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'",
    "type": "statement:localassign"
  }, {
    "id": 83,
    "text": "sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))",
    "type": "statement:assign"
  }, {
    "id": 84,
    "text": "out[#out+1] = val2str(value,key,indent,insref,seen[t],plainindex,level+1)",
    "type": "statement:assign"
  }, {
    "id": 85,
    "text": "local prefix = string.rep(indent or '', level)",
    "type": "statement:localassign"
  }, {
    "id": 86,
    "text": "local head = indent and '{\\n'..prefix..indent or '{'",
    "type": "statement:localassign"
  }, {
    "id": 87,
    "text": "local body = table.concat(out, ','..(indent and '\\n'..prefix..indent or space))",
    "type": "statement:localassign"
  }, {
    "id": 88,
    "text": "local tail = indent and \"\\n\"..prefix..'}' or '}'",
    "type": "statement:localassign"
  }, {
    "id": 89,
    "text": "local ok, res = pcall(string.dump, t)",
    "type": "statement:localassign"
  }, {
    "id": 90,
    "text": "local func = ok and ((opts.nocode and \"function() --[[..skipped..]] end\" or\r\n        \"((loadstring or load)(\"..safestr(res)..\",'@serialized'))\")..comment(t, level))",
    "type": "statement:localassign"
  }, {
    "id": 91,
    "text": "local sepr = indent and \"\\n\" or \";\"..space",
    "type": "statement:localassign"
  }, {
    "id": 92,
    "text": "local body = val2str(t, name, indent)",
    "type": "statement:localassign"
  }, {
    "id": 93,
    "text": "local tail = #sref>1 and table.concat(sref, sepr)..sepr or ''",
    "type": "statement:localassign"
  }, {
    "id": 94,
    "text": "local warn = opts.comment and #sref>1 and space..\"--[[incomplete output with shared/self-references skipped]]\" or ''",
    "type": "statement:localassign"
  }, {
    "id": 95,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 96,
    "text": "local function gensym(val) return '_'..(tostring(tostring(val)):gsub(\"[^%w]\",\"\"):gsub(\"(%d%w+)\",\r\n    -- tostring(val) is needed because __tostring may return a non-string value\r\n    function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end)) end",
    "type": "function"
  }, {
    "id": 97,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 98,
    "text": "local function safestr(s) return type(s) == \"number\" and tostring(huge and snum[tostring(s)] or numformat:format(s))\r\n    or type(s) ~= \"string\" and tostring(s) -- escape NEWLINE/010 and EOF/026\r\n    or (\"%q\"):format(s):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\") end",
    "type": "function"
  }, {
    "id": 99,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 100,
    "text": "local function comment(s,l) return comm and (l or 0) < comm and ' --[['..select(2, pcall(tostring, s))..']]' or '' end",
    "type": "function"
  }, {
    "id": 101,
    "text": "local function globerr(s,l) return globals[s] and globals[s]..comment(s,l) or not fatal\r\n    and safestr(select(2, pcall(tostring, s))) or error(\"Can't serialize \"..tostring(s)) end",
    "type": "function"
  }, {
    "id": 102,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 103,
    "text": "local function safename(path, name) -- generates foo.bar, foo[3], or foo['b a r']\r\n    local n = name == nil and '' or name\r\n    local plain = type(n) == \"string\" and n:match(\"^[%l%u_][%w_]*$\") and not keyword[n]\r\n    local safe = plain and n or '['..safestr(n)..']'\r\n    return (path or '')..(plain and path and '.' or '')..safe, safe end",
    "type": "function"
  }, {
    "id": 104,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 105,
    "text": "local function padnum(d) return (\"%0\"..tostring(maxn)..\"d\"):format(tonumber(d)) end",
    "type": "function"
  }, {
    "id": 106,
    "text": "function(k, o, n) -- k=keys, o=originaltable, n=padding\r\n    local maxn, to = tonumber(n) or 12, {number = 'a', string = 'b'}\r\n    local function padnum(d) return (\"%0\"..tostring(maxn)..\"d\"):format(tonumber(d)) end\r\n    table.sort(k, function(a,b)\r\n      -- sort numeric keys first: k[key] is not nil for numerical keys\r\n      return (k[a] ~= nil and 0 or to[type(a)] or 'z')..(tostring(a):gsub(\"%d+\",padnum))\r\n           < (k[b] ~= nil and 0 or to[type(b)] or 'z')..(tostring(b):gsub(\"%d+\",padnum)) end) end",
    "type": "function"
  }, {
    "id": 107,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 108,
    "text": "local function val2str(t, name, indent, insref, path, plainindex, level)\r\n    local ttype, level, mt = type(t), (level or 0), getmetatable(t)\r\n    local spath, sname = safename(path, name)\r\n    local tag = plainindex and\r\n      ((type(name) == \"number\") and '' or name..space..'='..space) or\r\n      (name ~= nil and sname..space..'='..space or '')\r\n    if seen[t] then -- already seen this element\r\n      sref[#sref+1] = spath..space..'='..space..seen[t]\r\n      return tag..'nil'..comment('ref', level) end\r\n    -- protect from those cases where __tostring may fail\r\n    if type(mt) == 'table' and pcall(function() return mt.__tostring and mt.__tostring(t) end)\r\n    and (mt.__serialize or mt.__tostring) then -- knows how to serialize itself\r\n      seen[t] = insref or spath\r\n      if mt.__serialize then t = mt.__serialize(t) else t = tostring(t) end\r\n      ttype = type(t) end -- new value falls through to be serialized\r\n    if ttype == \"table\" then\r\n      if level >= maxl then return tag..'{}'..comment('max', level) end\r\n      seen[t] = insref or spath\r\n      if next(t) == nil then return tag..'{}'..comment(t, level) end -- table empty\r\n      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}\r\n      for key = 1, maxn do o[key] = key end\r\n      if not maxnum or #o < maxnum then\r\n        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables\r\n        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end\r\n      if maxnum and #o > maxnum then o[maxnum+1] = nil end\r\n      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end\r\n      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)\r\n      for n, key in ipairs(o) do\r\n        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse\r\n        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\r\n        or opts.keyallow and not opts.keyallow[key]\r\n        or opts.keyignore and opts.keyignore[key]\r\n        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\r\n        or sparse and value == nil then -- skipping nils; do nothing\r\n        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then\r\n          if not seen[key] and not globals[key] then\r\n            sref[#sref+1] = 'placeholder'\r\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\r\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\r\n          sref[#sref+1] = 'placeholder'\r\n          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'\r\n          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))\r\n        else\r\n          out[#out+1] = val2str(value,key,indent,insref,seen[t],plainindex,level+1)\r\n        end\r\n      end\r\n      local prefix = string.rep(indent or '', level)\r\n      local head = indent and '{\\n'..prefix..indent or '{'\r\n      local body = table.concat(out, ','..(indent and '\\n'..prefix..indent or space))\r\n      local tail = indent and \"\\n\"..prefix..'}' or '}'\r\n      return (custom and custom(tag,head,body,tail) or tag..head..body..tail)..comment(t, level)\r\n    elseif badtype[ttype] then\r\n      seen[t] = insref or spath\r\n      return tag..globerr(t, level)\r\n    elseif ttype == 'function' then\r\n      seen[t] = insref or spath\r\n      local ok, res = pcall(string.dump, t)\r\n      local func = ok and ((opts.nocode and \"function() --[[..skipped..]] end\" or\r\n        \"((loadstring or load)(\"..safestr(res)..\",'@serialized'))\")..comment(t, level))\r\n      return tag..(func or globerr(t, level))\r\n    else return tag..safestr(t) end -- handle all other types\r\n  end",
    "type": "function"
  }, {
    "id": 109,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 110,
    "text": "local function deserialize(data, opts)\r\n  local env = (opts and opts.safe == false) and G\r\n    or setmetatable({}, {\r\n        __index = function(t,k) return t end,\r\n        __call = function(t,...) error(\"cannot call functions\") end\r\n      })\r\n  local f, res = (loadstring or load)('return '..data, nil, nil, env)\r\n  if not f then f, res = (loadstring or load)(data, nil, nil, env) end\r\n  if not f then return f, res end\r\n  if setfenv then setfenv(f, env) end\r\n  return pcall(f)\r\nend",
    "type": "function"
  }, {
    "id": 111,
    "text": "local env = (opts and opts.safe == false) and G\r\n    or setmetatable({}, {\r\n        __index = function(t,k) return t end,\r\n        __call = function(t,...) error(\"cannot call functions\") end\r\n      })",
    "type": "statement:localassign"
  }, {
    "id": 112,
    "text": "error(\"cannot call functions\")",
    "type": "statement:functioncall"
  }, {
    "id": 113,
    "text": "local f, res = (loadstring or load)('return '..data, nil, nil, env)",
    "type": "statement:localassign"
  }, {
    "id": 114,
    "text": "if not f then f, res = (loadstring or load)(data, nil, nil, env) end",
    "type": "statement:if"
  }, {
    "id": 115,
    "text": "f, res = (loadstring or load)(data, nil, nil, env)",
    "type": "statement:assign"
  }, {
    "id": 116,
    "text": "if not f then return f, res end",
    "type": "statement:if"
  }, {
    "id": 117,
    "text": "if setfenv then setfenv(f, env) end",
    "type": "statement:if"
  }, {
    "id": 118,
    "text": "setfenv(f, env)",
    "type": "statement:functioncall"
  }, {
    "id": 119,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 120,
    "text": "local function merge(a, b) if b then for k,v in pairs(b) do a[k] = v end end; return a; end",
    "type": "function"
  }, {
    "id": 121,
    "text": "if b then for k,v in pairs(b) do a[k] = v end end",
    "type": "statement:if"
  }, {
    "id": 122,
    "text": "for k,v in pairs(b) do a[k] = v end",
    "type": "statement:genericfor"
  }, {
    "id": 123,
    "text": "a[k] = v",
    "type": "statement:assign"
  }, {
    "id": 124,
    "text": "local function removebasedir(path, basedir)\r\n  if iscasepreserving then\r\n    -- check if the lowercased path matches the basedir\r\n    -- if so, return substring of the original path (to not lowercase it)\r\n    return path:lower():find('^'..q(basedir:lower()))\r\n      and path:sub(#basedir+1) or path\r\n  else\r\n    return string.gsub(path, '^'..q(basedir), '')\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 125,
    "text": "if iscasepreserving then\r\n    -- check if the lowercased path matches the basedir\r\n    -- if so, return substring of the original path (to not lowercase it)\r\n    return path:lower():find('^'..q(basedir:lower()))\r\n      and path:sub(#basedir+1) or path\r\n  else\r\n    return string.gsub(path, '^'..q(basedir), '')\r\n  end",
    "type": "statement:if"
  }, {
    "id": 126,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 127,
    "text": "local function stack(start)\r\n  local function vars(f)\r\n    local func = debug.getinfo(f, \"f\").func\r\n    local i = 1\r\n    local locals = {}\r\n    -- get locals\r\n    while true do\r\n      local name, value = debug.getlocal(f, i)\r\n      if not name then break end\r\n      if string.sub(name, 1, 1) ~= '(' then locals[name] = {value, tostring(value)} end\r\n      i = i + 1\r\n    end\r\n    -- get varargs (these use negative indices)\r\n    i = 1\r\n    while true do\r\n      local name, value = debug.getlocal(f, -i)\r\n      -- `not name` should be enough, but LuaJIT 2.0.0 incorrectly reports `(*temporary)` names here\r\n      if not name or name ~= \"(*vararg)\" then break end\r\n      locals[name:gsub(\"%)$\",\" \"..i..\")\")] = {value, tostring(value)}\r\n      i = i + 1\r\n    end\r\n    -- get upvalues\r\n    i = 1\r\n    local ups = {}\r\n    while func do -- check for func as it may be nil for tail calls\r\n      local name, value = debug.getupvalue(func, i)\r\n      if not name then break end\r\n      ups[name] = {value, tostring(value)}\r\n      i = i + 1\r\n    end\r\n    return locals, ups\r\n  end\r\n\r\n  local stack = {}\r\n  local linemap = mobdebug.linemap\r\n  for i = (start or 0), 100 do\r\n    local source = debug.getinfo(i, \"Snl\")\r\n    if not source then break end\r\n\r\n    local src = source.source\r\n    if src:find(\"@\") == 1 then\r\n      src = src:sub(2):gsub(\"\\\\\", \"/\")\r\n      if src:find(\"%./\") == 1 then src = src:sub(3) end\r\n    end\r\n\r\n    table.insert(stack, { -- remove basedir from source\r\n      {source.name, removebasedir(src, basedir),\r\n       linemap and linemap(source.linedefined, source.source) or source.linedefined,\r\n       linemap and linemap(source.currentline, source.source) or source.currentline,\r\n       source.what, source.namewhat, source.short_src},\r\n      vars(i+1)})\r\n    if source.what == 'main' then break end\r\n  end\r\n  return stack\r\nend",
    "type": "function"
  }, {
    "id": 128,
    "text": "local function vars(f)\r\n    local func = debug.getinfo(f, \"f\").func\r\n    local i = 1\r\n    local locals = {}\r\n    -- get locals\r\n    while true do\r\n      local name, value = debug.getlocal(f, i)\r\n      if not name then break end\r\n      if string.sub(name, 1, 1) ~= '(' then locals[name] = {value, tostring(value)} end\r\n      i = i + 1\r\n    end\r\n    -- get varargs (these use negative indices)\r\n    i = 1\r\n    while true do\r\n      local name, value = debug.getlocal(f, -i)\r\n      -- `not name` should be enough, but LuaJIT 2.0.0 incorrectly reports `(*temporary)` names here\r\n      if not name or name ~= \"(*vararg)\" then break end\r\n      locals[name:gsub(\"%)$\",\" \"..i..\")\")] = {value, tostring(value)}\r\n      i = i + 1\r\n    end\r\n    -- get upvalues\r\n    i = 1\r\n    local ups = {}\r\n    while func do -- check for func as it may be nil for tail calls\r\n      local name, value = debug.getupvalue(func, i)\r\n      if not name then break end\r\n      ups[name] = {value, tostring(value)}\r\n      i = i + 1\r\n    end\r\n    return locals, ups\r\n  end",
    "type": "statement:localfunction"
  }, {
    "id": 129,
    "text": "local func = debug.getinfo(f, \"f\").func",
    "type": "statement:localassign"
  }, {
    "id": 130,
    "text": "local i = 1",
    "type": "statement:localassign"
  }, {
    "id": 131,
    "text": "local locals = {}",
    "type": "statement:localassign"
  }, {
    "id": 132,
    "text": "while true do\r\n      local name, value = debug.getlocal(f, i)\r\n      if not name then break end\r\n      if string.sub(name, 1, 1) ~= '(' then locals[name] = {value, tostring(value)} end\r\n      i = i + 1\r\n    end",
    "type": "statement:while"
  }, {
    "id": 133,
    "text": "local name, value = debug.getlocal(f, i)",
    "type": "statement:localassign"
  }, {
    "id": 134,
    "text": "if not name then break end",
    "type": "statement:if"
  }, {
    "id": 135,
    "text": "if string.sub(name, 1, 1) ~= '(' then locals[name] = {value, tostring(value)} end",
    "type": "statement:if"
  }, {
    "id": 136,
    "text": "locals[name] = {value, tostring(value)}",
    "type": "statement:assign"
  }, {
    "id": 137,
    "text": "i = i + 1",
    "type": "statement:assign"
  }, {
    "id": 138,
    "text": "i = 1",
    "type": "statement:assign"
  }, {
    "id": 139,
    "text": "while true do\r\n      local name, value = debug.getlocal(f, -i)\r\n      -- `not name` should be enough, but LuaJIT 2.0.0 incorrectly reports `(*temporary)` names here\r\n      if not name or name ~= \"(*vararg)\" then break end\r\n      locals[name:gsub(\"%)$\",\" \"..i..\")\")] = {value, tostring(value)}\r\n      i = i + 1\r\n    end",
    "type": "statement:while"
  }, {
    "id": 140,
    "text": "local name, value = debug.getlocal(f, -i)",
    "type": "statement:localassign"
  }, {
    "id": 141,
    "text": "if not name or name ~= \"(*vararg)\" then break end",
    "type": "statement:if"
  }, {
    "id": 142,
    "text": "locals[name:gsub(\"%)$\",\" \"..i..\")\")] = {value, tostring(value)}",
    "type": "statement:assign"
  }, {
    "id": 143,
    "text": "local ups = {}",
    "type": "statement:localassign"
  }, {
    "id": 144,
    "text": "while func do -- check for func as it may be nil for tail calls\r\n      local name, value = debug.getupvalue(func, i)\r\n      if not name then break end\r\n      ups[name] = {value, tostring(value)}\r\n      i = i + 1\r\n    end",
    "type": "statement:while"
  }, {
    "id": 145,
    "text": "local name, value = debug.getupvalue(func, i)",
    "type": "statement:localassign"
  }, {
    "id": 146,
    "text": "ups[name] = {value, tostring(value)}",
    "type": "statement:assign"
  }, {
    "id": 147,
    "text": "local stack = {}",
    "type": "statement:localassign"
  }, {
    "id": 148,
    "text": "local linemap = mobdebug.linemap",
    "type": "statement:localassign"
  }, {
    "id": 149,
    "text": "for i = (start or 0), 100 do\r\n    local source = debug.getinfo(i, \"Snl\")\r\n    if not source then break end\r\n\r\n    local src = source.source\r\n    if src:find(\"@\") == 1 then\r\n      src = src:sub(2):gsub(\"\\\\\", \"/\")\r\n      if src:find(\"%./\") == 1 then src = src:sub(3) end\r\n    end\r\n\r\n    table.insert(stack, { -- remove basedir from source\r\n      {source.name, removebasedir(src, basedir),\r\n       linemap and linemap(source.linedefined, source.source) or source.linedefined,\r\n       linemap and linemap(source.currentline, source.source) or source.currentline,\r\n       source.what, source.namewhat, source.short_src},\r\n      vars(i+1)})\r\n    if source.what == 'main' then break end\r\n  end",
    "type": "statement:numericfor"
  }, {
    "id": 150,
    "text": "local source = debug.getinfo(i, \"Snl\")",
    "type": "statement:localassign"
  }, {
    "id": 151,
    "text": "if not source then break end",
    "type": "statement:if"
  }, {
    "id": 152,
    "text": "local src = source.source",
    "type": "statement:localassign"
  }, {
    "id": 153,
    "text": "if src:find(\"@\") == 1 then\r\n      src = src:sub(2):gsub(\"\\\\\", \"/\")\r\n      if src:find(\"%./\") == 1 then src = src:sub(3) end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 154,
    "text": "src = src:sub(2):gsub(\"\\\\\", \"/\")",
    "type": "statement:assign"
  }, {
    "id": 155,
    "text": "if src:find(\"%./\") == 1 then src = src:sub(3) end",
    "type": "statement:if"
  }, {
    "id": 156,
    "text": "src = src:sub(3)",
    "type": "statement:assign"
  }, {
    "id": 157,
    "text": "table.insert(stack, { -- remove basedir from source\r\n      {source.name, removebasedir(src, basedir),\r\n       linemap and linemap(source.linedefined, source.source) or source.linedefined,\r\n       linemap and linemap(source.currentline, source.source) or source.currentline,\r\n       source.what, source.namewhat, source.short_src},\r\n      vars(i+1)})",
    "type": "statement:functioncall"
  }, {
    "id": 158,
    "text": "if source.what == 'main' then break end",
    "type": "statement:if"
  }, {
    "id": 159,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 160,
    "text": "local function vars(f)\r\n    local func = debug.getinfo(f, \"f\").func\r\n    local i = 1\r\n    local locals = {}\r\n    -- get locals\r\n    while true do\r\n      local name, value = debug.getlocal(f, i)\r\n      if not name then break end\r\n      if string.sub(name, 1, 1) ~= '(' then locals[name] = {value, tostring(value)} end\r\n      i = i + 1\r\n    end\r\n    -- get varargs (these use negative indices)\r\n    i = 1\r\n    while true do\r\n      local name, value = debug.getlocal(f, -i)\r\n      -- `not name` should be enough, but LuaJIT 2.0.0 incorrectly reports `(*temporary)` names here\r\n      if not name or name ~= \"(*vararg)\" then break end\r\n      locals[name:gsub(\"%)$\",\" \"..i..\")\")] = {value, tostring(value)}\r\n      i = i + 1\r\n    end\r\n    -- get upvalues\r\n    i = 1\r\n    local ups = {}\r\n    while func do -- check for func as it may be nil for tail calls\r\n      local name, value = debug.getupvalue(func, i)\r\n      if not name then break end\r\n      ups[name] = {value, tostring(value)}\r\n      i = i + 1\r\n    end\r\n    return locals, ups\r\n  end",
    "type": "function"
  }, {
    "id": 161,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 162,
    "text": "local function set_breakpoint(file, line)\r\n  if file == '-' and lastfile then file = lastfile\r\n  elseif iscasepreserving then file = string.lower(file) end\r\n  if not breakpoints[line] then breakpoints[line] = {} end\r\n  breakpoints[line][file] = true\r\nend",
    "type": "function"
  }, {
    "id": 163,
    "text": "if file == '-' and lastfile then file = lastfile\r\n  elseif iscasepreserving then file = string.lower(file) end",
    "type": "statement:if"
  }, {
    "id": 164,
    "text": "file = lastfile",
    "type": "statement:assign"
  }, {
    "id": 165,
    "text": "file = string.lower(file)",
    "type": "statement:assign"
  }, {
    "id": 166,
    "text": "if not breakpoints[line] then breakpoints[line] = {} end",
    "type": "statement:if"
  }, {
    "id": 167,
    "text": "breakpoints[line] = {}",
    "type": "statement:assign"
  }, {
    "id": 168,
    "text": "breakpoints[line][file] = true",
    "type": "statement:assign"
  }, {
    "id": 169,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 170,
    "text": "local function remove_breakpoint(file, line)\r\n  if file == '-' and lastfile then file = lastfile\r\n  elseif file == '*' and line == 0 then breakpoints = {}\r\n  elseif iscasepreserving then file = string.lower(file) end\r\n  if breakpoints[line] then breakpoints[line][file] = nil end\r\nend",
    "type": "function"
  }, {
    "id": 171,
    "text": "if file == '-' and lastfile then file = lastfile\r\n  elseif file == '*' and line == 0 then breakpoints = {}\r\n  elseif iscasepreserving then file = string.lower(file) end",
    "type": "statement:if"
  }, {
    "id": 172,
    "text": "breakpoints = {}",
    "type": "statement:assign"
  }, {
    "id": 173,
    "text": "if breakpoints[line] then breakpoints[line][file] = nil end",
    "type": "statement:if"
  }, {
    "id": 174,
    "text": "breakpoints[line][file] = nil",
    "type": "statement:assign"
  }, {
    "id": 175,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 176,
    "text": "local function has_breakpoint(file, line)\r\n  return breakpoints[line]\r\n     and breakpoints[line][iscasepreserving and string.lower(file) or file]\r\nend",
    "type": "function"
  }, {
    "id": 177,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 178,
    "text": "local function restore_vars(vars)\r\n  if type(vars) ~= 'table' then return end\r\n\r\n  -- locals need to be processed in the reverse order, starting from\r\n  -- the inner block out, to make sure that the localized variables\r\n  -- are correctly updated with only the closest variable with\r\n  -- the same name being changed\r\n  -- first loop find how many local variables there is, while\r\n  -- the second loop processes them from i to 1\r\n  local i = 1\r\n  while true do\r\n    local name = debug.getlocal(3, i)\r\n    if not name then break end\r\n    i = i + 1\r\n  end\r\n  i = i - 1\r\n  local written_vars = {}\r\n  while i > 0 do\r\n    local name = debug.getlocal(3, i)\r\n    if not written_vars[name] then\r\n      if string.sub(name, 1, 1) ~= '(' then\r\n        debug.setlocal(3, i, rawget(vars, name))\r\n      end\r\n      written_vars[name] = true\r\n    end\r\n    i = i - 1\r\n  end\r\n\r\n  i = 1\r\n  local func = debug.getinfo(3, \"f\").func\r\n  while true do\r\n    local name = debug.getupvalue(func, i)\r\n    if not name then break end\r\n    if not written_vars[name] then\r\n      if string.sub(name, 1, 1) ~= '(' then\r\n        debug.setupvalue(func, i, rawget(vars, name))\r\n      end\r\n      written_vars[name] = true\r\n    end\r\n    i = i + 1\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 179,
    "text": "if type(vars) ~= 'table' then return end",
    "type": "statement:if"
  }, {
    "id": 180,
    "text": "while true do\r\n    local name = debug.getlocal(3, i)\r\n    if not name then break end\r\n    i = i + 1\r\n  end",
    "type": "statement:while"
  }, {
    "id": 181,
    "text": "local name = debug.getlocal(3, i)",
    "type": "statement:localassign"
  }, {
    "id": 182,
    "text": "i = i - 1",
    "type": "statement:assign"
  }, {
    "id": 183,
    "text": "local written_vars = {}",
    "type": "statement:localassign"
  }, {
    "id": 184,
    "text": "while i > 0 do\r\n    local name = debug.getlocal(3, i)\r\n    if not written_vars[name] then\r\n      if string.sub(name, 1, 1) ~= '(' then\r\n        debug.setlocal(3, i, rawget(vars, name))\r\n      end\r\n      written_vars[name] = true\r\n    end\r\n    i = i - 1\r\n  end",
    "type": "statement:while"
  }, {
    "id": 185,
    "text": "if not written_vars[name] then\r\n      if string.sub(name, 1, 1) ~= '(' then\r\n        debug.setlocal(3, i, rawget(vars, name))\r\n      end\r\n      written_vars[name] = true\r\n    end",
    "type": "statement:if"
  }, {
    "id": 186,
    "text": "if string.sub(name, 1, 1) ~= '(' then\r\n        debug.setlocal(3, i, rawget(vars, name))\r\n      end",
    "type": "statement:if"
  }, {
    "id": 187,
    "text": "debug.setlocal(3, i, rawget(vars, name))",
    "type": "statement:functioncall"
  }, {
    "id": 188,
    "text": "written_vars[name] = true",
    "type": "statement:assign"
  }, {
    "id": 189,
    "text": "local func = debug.getinfo(3, \"f\").func",
    "type": "statement:localassign"
  }, {
    "id": 190,
    "text": "while true do\r\n    local name = debug.getupvalue(func, i)\r\n    if not name then break end\r\n    if not written_vars[name] then\r\n      if string.sub(name, 1, 1) ~= '(' then\r\n        debug.setupvalue(func, i, rawget(vars, name))\r\n      end\r\n      written_vars[name] = true\r\n    end\r\n    i = i + 1\r\n  end",
    "type": "statement:while"
  }, {
    "id": 191,
    "text": "local name = debug.getupvalue(func, i)",
    "type": "statement:localassign"
  }, {
    "id": 192,
    "text": "if not written_vars[name] then\r\n      if string.sub(name, 1, 1) ~= '(' then\r\n        debug.setupvalue(func, i, rawget(vars, name))\r\n      end\r\n      written_vars[name] = true\r\n    end",
    "type": "statement:if"
  }, {
    "id": 193,
    "text": "if string.sub(name, 1, 1) ~= '(' then\r\n        debug.setupvalue(func, i, rawget(vars, name))\r\n      end",
    "type": "statement:if"
  }, {
    "id": 194,
    "text": "debug.setupvalue(func, i, rawget(vars, name))",
    "type": "statement:functioncall"
  }, {
    "id": 195,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 196,
    "text": "local function capture_vars(level)\r\n  local vars = {}\r\n  local func = debug.getinfo(level or 3, \"f\").func\r\n  local i = 1\r\n  while true do\r\n    local name, value = debug.getupvalue(func, i)\r\n    if not name then break end\r\n    if string.sub(name, 1, 1) ~= '(' then vars[name] = value end\r\n    i = i + 1\r\n  end\r\n  i = 1\r\n  while true do\r\n    local name, value = debug.getlocal(level or 3, i)\r\n    if not name then break end\r\n    if string.sub(name, 1, 1) ~= '(' then vars[name] = value end\r\n    i = i + 1\r\n  end\r\n  -- returned 'vars' table plays a dual role: (1) it captures local values\r\n  -- and upvalues to be restored later (in case they are modified in \"eval\"),\r\n  -- and (2) it provides an environment for evaluated chunks.\r\n  -- getfenv(func) is needed to provide proper environment for functions,\r\n  -- including access to globals, but this causes vars[name] to fail in\r\n  -- restore_vars on local variables or upvalues with `nil` values when\r\n  -- 'strict' is in effect. To avoid this `rawget` is used in restore_vars.\r\n  setmetatable(vars, { __index = getfenv(func), __newindex = getfenv(func) })\r\n  return vars\r\nend",
    "type": "function"
  }, {
    "id": 197,
    "text": "local vars = {}",
    "type": "statement:localassign"
  }, {
    "id": 198,
    "text": "local func = debug.getinfo(level or 3, \"f\").func",
    "type": "statement:localassign"
  }, {
    "id": 199,
    "text": "while true do\r\n    local name, value = debug.getupvalue(func, i)\r\n    if not name then break end\r\n    if string.sub(name, 1, 1) ~= '(' then vars[name] = value end\r\n    i = i + 1\r\n  end",
    "type": "statement:while"
  }, {
    "id": 200,
    "text": "if string.sub(name, 1, 1) ~= '(' then vars[name] = value end",
    "type": "statement:if"
  }, {
    "id": 201,
    "text": "vars[name] = value",
    "type": "statement:assign"
  }, {
    "id": 202,
    "text": "while true do\r\n    local name, value = debug.getlocal(level or 3, i)\r\n    if not name then break end\r\n    if string.sub(name, 1, 1) ~= '(' then vars[name] = value end\r\n    i = i + 1\r\n  end",
    "type": "statement:while"
  }, {
    "id": 203,
    "text": "local name, value = debug.getlocal(level or 3, i)",
    "type": "statement:localassign"
  }, {
    "id": 204,
    "text": "setmetatable(vars, { __index = getfenv(func), __newindex = getfenv(func) })",
    "type": "statement:functioncall"
  }, {
    "id": 205,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 206,
    "text": "local function stack_depth(start_depth)\r\n  for i = start_depth, 0, -1 do\r\n    if debug.getinfo(i, \"l\") then return i+1 end\r\n  end\r\n  return start_depth\r\nend",
    "type": "function"
  }, {
    "id": 207,
    "text": "for i = start_depth, 0, -1 do\r\n    if debug.getinfo(i, \"l\") then return i+1 end\r\n  end",
    "type": "statement:numericfor"
  }, {
    "id": 208,
    "text": "if debug.getinfo(i, \"l\") then return i+1 end",
    "type": "statement:if"
  }, {
    "id": 209,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 210,
    "text": "local function is_safe(stack_level)\r\n  -- the stack grows up: 0 is getinfo, 1 is is_safe, 2 is debug_hook, 3 is user function\r\n  if stack_level == 3 then return true end\r\n  for i = 3, stack_level do\r\n    -- return if it is not safe to abort\r\n    local info = debug.getinfo(i, \"S\")\r\n    if not info then return true end\r\n    if info.what == \"C\" then return false end\r\n  end\r\n  return true\r\nend",
    "type": "function"
  }, {
    "id": 211,
    "text": "if stack_level == 3 then return true end",
    "type": "statement:if"
  }, {
    "id": 212,
    "text": "for i = 3, stack_level do\r\n    -- return if it is not safe to abort\r\n    local info = debug.getinfo(i, \"S\")\r\n    if not info then return true end\r\n    if info.what == \"C\" then return false end\r\n  end",
    "type": "statement:numericfor"
  }, {
    "id": 213,
    "text": "local info = debug.getinfo(i, \"S\")",
    "type": "statement:localassign"
  }, {
    "id": 214,
    "text": "if not info then return true end",
    "type": "statement:if"
  }, {
    "id": 215,
    "text": "if info.what == \"C\" then return false end",
    "type": "statement:if"
  }, {
    "id": 216,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 217,
    "text": "local function in_debugger()\r\n  local this = debug.getinfo(1, \"S\").source\r\n  -- only need to check few frames as mobdebug frames should be close\r\n  for i = 3, 7 do\r\n    local info = debug.getinfo(i, \"S\")\r\n    if not info then return false end\r\n    if info.source == this then return true end\r\n  end\r\n  return false\r\nend",
    "type": "function"
  }, {
    "id": 218,
    "text": "local this = debug.getinfo(1, \"S\").source",
    "type": "statement:localassign"
  }, {
    "id": 219,
    "text": "for i = 3, 7 do\r\n    local info = debug.getinfo(i, \"S\")\r\n    if not info then return false end\r\n    if info.source == this then return true end\r\n  end",
    "type": "statement:numericfor"
  }, {
    "id": 220,
    "text": "if not info then return false end",
    "type": "statement:if"
  }, {
    "id": 221,
    "text": "if info.source == this then return true end",
    "type": "statement:if"
  }, {
    "id": 222,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 223,
    "text": "local function is_pending(peer)\r\n  -- if there is something already in the buffer, skip check\r\n  if not buf and checkcount >= mobdebug.checkcount then\r\n    peer:settimeout(0) -- non-blocking\r\n    buf = peer:receive(1)\r\n    peer:settimeout() -- back to blocking\r\n    checkcount = 0\r\n  end\r\n  return buf\r\nend",
    "type": "function"
  }, {
    "id": 224,
    "text": "if not buf and checkcount >= mobdebug.checkcount then\r\n    peer:settimeout(0) -- non-blocking\r\n    buf = peer:receive(1)\r\n    peer:settimeout() -- back to blocking\r\n    checkcount = 0\r\n  end",
    "type": "statement:if"
  }, {
    "id": 225,
    "text": "peer:settimeout(0)",
    "type": "statement:functioncall"
  }, {
    "id": 226,
    "text": "buf = peer:receive(1)",
    "type": "statement:assign"
  }, {
    "id": 227,
    "text": "peer:settimeout()",
    "type": "statement:functioncall"
  }, {
    "id": 228,
    "text": "checkcount = 0",
    "type": "statement:assign"
  }, {
    "id": 229,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 230,
    "text": "local function readnext(peer, num)\r\n  peer:settimeout(0) -- non-blocking\r\n  local res, err, partial = peer:receive(num)\r\n  peer:settimeout() -- back to blocking\r\n  return res or partial or '', err\r\nend",
    "type": "function"
  }, {
    "id": 231,
    "text": "local res, err, partial = peer:receive(num)",
    "type": "statement:localassign"
  }, {
    "id": 232,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 233,
    "text": "local function handle_breakpoint(peer)\r\n  -- check if the buffer has the beginning of SETB/DELB command;\r\n  -- this is to avoid reading the entire line for commands that\r\n  -- don't need to be handled here.\r\n  if not buf or not (buf:sub(1,1) == 'S' or buf:sub(1,1) == 'D') then return end\r\n\r\n  -- check second character to avoid reading STEP or other S* and D* commands\r\n  if #buf == 1 then buf = buf .. readnext(peer, 1) end\r\n  if buf:sub(2,2) ~= 'E' then return end\r\n\r\n  -- need to read few more characters\r\n  buf = buf .. readnext(peer, 5-#buf)\r\n  if buf ~= 'SETB ' and buf ~= 'DELB ' then return end\r\n\r\n  local res, _, partial = peer:receive() -- get the rest of the line; blocking\r\n  if not res then\r\n    if partial then buf = buf .. partial end\r\n    return\r\n  end\r\n\r\n  local _, _, cmd, file, line = (buf..res):find(\"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\r\n  if cmd == 'SETB' then set_breakpoint(file, tonumber(line))\r\n  elseif cmd == 'DELB' then remove_breakpoint(file, tonumber(line))\r\n  else\r\n    -- this looks like a breakpoint command, but something went wrong;\r\n    -- return here to let the \"normal\" processing to handle,\r\n    -- although this is likely to not go well.\r\n    return\r\n  end\r\n\r\n  buf = nil\r\nend",
    "type": "function"
  }, {
    "id": 234,
    "text": "if not buf or not (buf:sub(1,1) == 'S' or buf:sub(1,1) == 'D') then return end",
    "type": "statement:if"
  }, {
    "id": 235,
    "text": "if #buf == 1 then buf = buf .. readnext(peer, 1) end",
    "type": "statement:if"
  }, {
    "id": 236,
    "text": "buf = buf .. readnext(peer, 1)",
    "type": "statement:assign"
  }, {
    "id": 237,
    "text": "if buf:sub(2,2) ~= 'E' then return end",
    "type": "statement:if"
  }, {
    "id": 238,
    "text": "buf = buf .. readnext(peer, 5-#buf)",
    "type": "statement:assign"
  }, {
    "id": 239,
    "text": "if buf ~= 'SETB ' and buf ~= 'DELB ' then return end",
    "type": "statement:if"
  }, {
    "id": 240,
    "text": "local res, _, partial = peer:receive()",
    "type": "statement:localassign"
  }, {
    "id": 241,
    "text": "if not res then\r\n    if partial then buf = buf .. partial end\r\n    return\r\n  end",
    "type": "statement:if"
  }, {
    "id": 242,
    "text": "if partial then buf = buf .. partial end",
    "type": "statement:if"
  }, {
    "id": 243,
    "text": "buf = buf .. partial",
    "type": "statement:assign"
  }, {
    "id": 244,
    "text": "local _, _, cmd, file, line = (buf..res):find(\"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 245,
    "text": "if cmd == 'SETB' then set_breakpoint(file, tonumber(line))\r\n  elseif cmd == 'DELB' then remove_breakpoint(file, tonumber(line))\r\n  else\r\n    -- this looks like a breakpoint command, but something went wrong;\r\n    -- return here to let the \"normal\" processing to handle,\r\n    -- although this is likely to not go well.\r\n    return\r\n  end",
    "type": "statement:if"
  }, {
    "id": 246,
    "text": "set_breakpoint(file, tonumber(line))",
    "type": "statement:functioncall"
  }, {
    "id": 247,
    "text": "remove_breakpoint(file, tonumber(line))",
    "type": "statement:functioncall"
  }, {
    "id": 248,
    "text": "buf = nil",
    "type": "statement:assign"
  }, {
    "id": 249,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 250,
    "text": "local function normalize_path(file)\r\n  local n\r\n  repeat\r\n    file, n = file:gsub(\"/+%.?/+\",\"/\") -- remove all `//` and `/./` references\r\n  until n == 0\r\n  -- collapse all up-dir references: this will clobber UNC prefix (\\\\?\\)\r\n  -- and disk on Windows when there are too many up-dir references: `D:\\foo\\..\\..\\bar`;\r\n  -- handle the case of multiple up-dir references: `foo/bar/baz/../../../more`;\r\n  -- only remove one at a time as otherwise `../../` could be removed;\r\n  repeat\r\n    file, n = file:gsub(\"[^/]+/%.%./\", \"\", 1)\r\n  until n == 0\r\n  -- there may still be a leading up-dir reference left (as `/../` or `../`); remove it\r\n  return (file:gsub(\"%.%./\", \"\", 1))\r\nend",
    "type": "function"
  }, {
    "id": 251,
    "text": "local n",
    "type": "statement:localassign"
  }, {
    "id": 252,
    "text": "repeat\r\n    file, n = file:gsub(\"/+%.?/+\",\"/\") -- remove all `//` and `/./` references\r\n  until n == 0",
    "type": "statement:repeat"
  }, {
    "id": 253,
    "text": "file, n = file:gsub(\"/+%.?/+\",\"/\")",
    "type": "statement:assign"
  }, {
    "id": 254,
    "text": "repeat\r\n    file, n = file:gsub(\"[^/]+/%.%./\", \"\", 1)\r\n  until n == 0",
    "type": "statement:repeat"
  }, {
    "id": 255,
    "text": "file, n = file:gsub(\"[^/]+/%.%./\", \"\", 1)",
    "type": "statement:assign"
  }, {
    "id": 256,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 257,
    "text": "local function debug_hook(event, line)\r\n  -- (1) LuaJIT needs special treatment. Because debug_hook is set for\r\n  -- *all* coroutines, and not just the one being debugged as in regular Lua\r\n  -- (http://lua-users.org/lists/lua-l/2011-06/msg00513.html),\r\n  -- need to avoid debugging mobdebug's own code as LuaJIT doesn't\r\n  -- always correctly generate call/return hook events (there are more\r\n  -- calls than returns, which breaks stack depth calculation and\r\n  -- 'step' and 'step over' commands stop working; possibly because\r\n  -- 'tail return' events are not generated by LuaJIT).\r\n  -- the next line checks if the debugger is run under LuaJIT and if\r\n  -- one of debugger methods is present in the stack, it simply returns.\r\n  if jit then\r\n    -- when luajit is compiled with LUAJIT_ENABLE_LUA52COMPAT,\r\n    -- coroutine.running() returns non-nil for the main thread.\r\n    local coro, main = coroutine.running()\r\n    if not coro or main then coro = 'main' end\r\n    local disabled = coroutines[coro] == false\r\n      or coroutines[coro] == nil and coro ~= (coro_debugee or 'main')\r\n    if coro_debugee and disabled or not coro_debugee and (disabled or in_debugger())\r\n    then return end\r\n  end\r\n\r\n  -- (2) check if abort has been requested and it's safe to abort\r\n  if abort and is_safe(stack_level) then error(abort) end\r\n\r\n  -- (3) also check if this debug hook has not been visited for any reason.\r\n  -- this check is needed to avoid stepping in too early\r\n  -- (for example, when coroutine.resume() is executed inside start()).\r\n  if not seen_hook and in_debugger() then return end\r\n\r\n  if event == \"call\" then\r\n    stack_level = stack_level + 1\r\n  elseif event == \"return\" or event == \"tail return\" then\r\n    stack_level = stack_level - 1\r\n  elseif event == \"line\" then\r\n    if mobdebug.linemap then\r\n      local ok, mappedline = pcall(mobdebug.linemap, line, debug.getinfo(2, \"S\").source)\r\n      if ok then line = mappedline end\r\n      if not line then return end\r\n    end\r\n\r\n    -- may need to fall through because of the following:\r\n    -- (1) step_into\r\n    -- (2) step_over and stack_level <= step_level (need stack_level)\r\n    -- (3) breakpoint; check for line first as it's known; then for file\r\n    -- (4) socket call (only do every Xth check)\r\n    -- (5) at least one watch is registered\r\n    if not (\r\n      step_into or step_over or breakpoints[line] or watchescnt > 0\r\n      or is_pending(server)\r\n    ) then checkcount = checkcount + 1; return end\r\n\r\n    checkcount = mobdebug.checkcount -- force check on the next command\r\n\r\n    -- this is needed to check if the stack got shorter or longer.\r\n    -- unfortunately counting call/return calls is not reliable.\r\n    -- the discrepancy may happen when \"pcall(load, '')\" call is made\r\n    -- or when \"error()\" is called in a function.\r\n    -- in either case there are more \"call\" than \"return\" events reported.\r\n    -- this validation is done for every \"line\" event, but should be \"cheap\"\r\n    -- as it checks for the stack to get shorter (or longer by one call).\r\n    -- start from one level higher just in case we need to grow the stack.\r\n    -- this may happen after coroutine.resume call to a function that doesn't\r\n    -- have any other instructions to execute. it triggers three returns:\r\n    -- \"return, tail return, return\", which needs to be accounted for.\r\n    stack_level = stack_depth(stack_level+1)\r\n\r\n    local caller = debug.getinfo(2, \"S\")\r\n\r\n    -- grab the filename and fix it if needed\r\n    local file = lastfile\r\n    if (lastsource ~= caller.source) then\r\n      file, lastsource = caller.source, caller.source\r\n      -- technically, users can supply names that may not use '@',\r\n      -- for example when they call loadstring('...', 'filename.lua').\r\n      -- Unfortunately, there is no reliable/quick way to figure out\r\n      -- what is the filename and what is the source code.\r\n      -- If the name doesn't start with `@`, assume it's a file name if it's all on one line.\r\n      if find(file, \"^@\") or not find(file, \"[\\r\\n]\") then\r\n        file = gsub(gsub(file, \"^@\", \"\"), \"\\\\\", \"/\")\r\n        -- normalize paths that may include up-dir or same-dir references\r\n        -- if the path starts from the up-dir or reference,\r\n        -- prepend `basedir` to generate absolute path to keep breakpoints working.\r\n        -- ignore qualified relative path (`D:../`) and UNC paths (`\\\\?\\`)\r\n        if find(file, \"^%.%./\") then file = basedir..file end\r\n        if find(file, \"/%.%.?/\") then file = normalize_path(file) end\r\n        -- need this conversion to be applied to relative and absolute\r\n        -- file names as you may write \"require 'Foo'\" to\r\n        -- load \"foo.lua\" (on a case insensitive file system) and breakpoints\r\n        -- set on foo.lua will not work if not converted to the same case.\r\n        if iscasepreserving then file = string.lower(file) end\r\n        if find(file, \"^%./\") then file = sub(file, 3)\r\n        else file = gsub(file, \"^\"..q(basedir), \"\") end\r\n        -- some file systems allow newlines in file names; remove these.\r\n        file = gsub(file, \"\\n\", ' ')\r\n      else\r\n        file = mobdebug.line(file)\r\n      end\r\n\r\n      -- set to true if we got here; this only needs to be done once per\r\n      -- session, so do it here to at least avoid setting it for every line.\r\n      seen_hook = true\r\n      lastfile = file\r\n    end\r\n\r\n    if is_pending(server) then handle_breakpoint(server) end\r\n\r\n    local vars, status, res\r\n    if (watchescnt > 0) then\r\n      vars = capture_vars()\r\n      for index, value in pairs(watches) do\r\n        setfenv(value, vars)\r\n        local ok, fired = pcall(value)\r\n        if ok and fired then\r\n          status, res = cororesume(coro_debugger, events.WATCH, vars, file, line, index)\r\n          break -- any one watch is enough; don't check multiple times\r\n        end\r\n      end\r\n    end\r\n\r\n    -- need to get into the \"regular\" debug handler, but only if there was\r\n    -- no watch that was fired. If there was a watch, handle its result.\r\n    local getin = (status == nil) and\r\n      (step_into\r\n      -- when coroutine.running() return `nil` (main thread in Lua 5.1),\r\n      -- step_over will equal 'main', so need to check for that explicitly.\r\n      or (step_over and step_over == (coroutine.running() or 'main') and stack_level <= step_level)\r\n      or has_breakpoint(file, line)\r\n      or is_pending(server))\r\n\r\n    if getin then\r\n      vars = vars or capture_vars()\r\n      step_into = false\r\n      step_over = false\r\n      status, res = cororesume(coro_debugger, events.BREAK, vars, file, line)\r\n    end\r\n\r\n    -- handle 'stack' command that provides stack() information to the debugger\r\n    if status and res == 'stack' then\r\n      while status and res == 'stack' do\r\n        -- resume with the stack trace and variables\r\n        if vars then restore_vars(vars) end -- restore vars so they are reflected in stack values\r\n        -- this may fail if __tostring method fails at run-time\r\n        local ok, snapshot = pcall(stack, ngx and 5 or 4)\r\n        status, res = cororesume(coro_debugger, ok and events.STACK or events.BREAK, snapshot, file, line)\r\n      end\r\n    end\r\n\r\n    -- need to recheck once more as resume after 'stack' command may\r\n    -- return something else (for example, 'exit'), which needs to be handled\r\n    if status and res and res ~= 'stack' then\r\n      if not abort and res == \"exit\" then mobdebug.onexit(1, true); return end\r\n      if not abort and res == \"done\" then mobdebug.done(); return end\r\n      abort = res\r\n      -- only abort if safe; if not, there is another (earlier) check inside\r\n      -- debug_hook, which will abort execution at the first safe opportunity\r\n      if is_safe(stack_level) then error(abort) end\r\n    elseif not status and res then\r\n      error(res, 2) -- report any other (internal) errors back to the application\r\n    end\r\n\r\n    if vars then restore_vars(vars) end\r\n\r\n    -- last command requested Step Over/Out; store the current thread\r\n    if step_over == true then step_over = coroutine.running() or 'main' end\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 258,
    "text": "if jit then\r\n    -- when luajit is compiled with LUAJIT_ENABLE_LUA52COMPAT,\r\n    -- coroutine.running() returns non-nil for the main thread.\r\n    local coro, main = coroutine.running()\r\n    if not coro or main then coro = 'main' end\r\n    local disabled = coroutines[coro] == false\r\n      or coroutines[coro] == nil and coro ~= (coro_debugee or 'main')\r\n    if coro_debugee and disabled or not coro_debugee and (disabled or in_debugger())\r\n    then return end\r\n  end",
    "type": "statement:if"
  }, {
    "id": 259,
    "text": "local coro, main = coroutine.running()",
    "type": "statement:localassign"
  }, {
    "id": 260,
    "text": "if not coro or main then coro = 'main' end",
    "type": "statement:if"
  }, {
    "id": 261,
    "text": "coro = 'main'",
    "type": "statement:assign"
  }, {
    "id": 262,
    "text": "local disabled = coroutines[coro] == false\r\n      or coroutines[coro] == nil and coro ~= (coro_debugee or 'main')",
    "type": "statement:localassign"
  }, {
    "id": 263,
    "text": "if coro_debugee and disabled or not coro_debugee and (disabled or in_debugger())\r\n    then return end",
    "type": "statement:if"
  }, {
    "id": 264,
    "text": "if abort and is_safe(stack_level) then error(abort) end",
    "type": "statement:if"
  }, {
    "id": 265,
    "text": "error(abort)",
    "type": "statement:functioncall"
  }, {
    "id": 266,
    "text": "if not seen_hook and in_debugger() then return end",
    "type": "statement:if"
  }, {
    "id": 267,
    "text": "if event == \"call\" then\r\n    stack_level = stack_level + 1\r\n  elseif event == \"return\" or event == \"tail return\" then\r\n    stack_level = stack_level - 1\r\n  elseif event == \"line\" then\r\n    if mobdebug.linemap then\r\n      local ok, mappedline = pcall(mobdebug.linemap, line, debug.getinfo(2, \"S\").source)\r\n      if ok then line = mappedline end\r\n      if not line then return end\r\n    end\r\n\r\n    -- may need to fall through because of the following:\r\n    -- (1) step_into\r\n    -- (2) step_over and stack_level <= step_level (need stack_level)\r\n    -- (3) breakpoint; check for line first as it's known; then for file\r\n    -- (4) socket call (only do every Xth check)\r\n    -- (5) at least one watch is registered\r\n    if not (\r\n      step_into or step_over or breakpoints[line] or watchescnt > 0\r\n      or is_pending(server)\r\n    ) then checkcount = checkcount + 1; return end\r\n\r\n    checkcount = mobdebug.checkcount -- force check on the next command\r\n\r\n    -- this is needed to check if the stack got shorter or longer.\r\n    -- unfortunately counting call/return calls is not reliable.\r\n    -- the discrepancy may happen when \"pcall(load, '')\" call is made\r\n    -- or when \"error()\" is called in a function.\r\n    -- in either case there are more \"call\" than \"return\" events reported.\r\n    -- this validation is done for every \"line\" event, but should be \"cheap\"\r\n    -- as it checks for the stack to get shorter (or longer by one call).\r\n    -- start from one level higher just in case we need to grow the stack.\r\n    -- this may happen after coroutine.resume call to a function that doesn't\r\n    -- have any other instructions to execute. it triggers three returns:\r\n    -- \"return, tail return, return\", which needs to be accounted for.\r\n    stack_level = stack_depth(stack_level+1)\r\n\r\n    local caller = debug.getinfo(2, \"S\")\r\n\r\n    -- grab the filename and fix it if needed\r\n    local file = lastfile\r\n    if (lastsource ~= caller.source) then\r\n      file, lastsource = caller.source, caller.source\r\n      -- technically, users can supply names that may not use '@',\r\n      -- for example when they call loadstring('...', 'filename.lua').\r\n      -- Unfortunately, there is no reliable/quick way to figure out\r\n      -- what is the filename and what is the source code.\r\n      -- If the name doesn't start with `@`, assume it's a file name if it's all on one line.\r\n      if find(file, \"^@\") or not find(file, \"[\\r\\n]\") then\r\n        file = gsub(gsub(file, \"^@\", \"\"), \"\\\\\", \"/\")\r\n        -- normalize paths that may include up-dir or same-dir references\r\n        -- if the path starts from the up-dir or reference,\r\n        -- prepend `basedir` to generate absolute path to keep breakpoints working.\r\n        -- ignore qualified relative path (`D:../`) and UNC paths (`\\\\?\\`)\r\n        if find(file, \"^%.%./\") then file = basedir..file end\r\n        if find(file, \"/%.%.?/\") then file = normalize_path(file) end\r\n        -- need this conversion to be applied to relative and absolute\r\n        -- file names as you may write \"require 'Foo'\" to\r\n        -- load \"foo.lua\" (on a case insensitive file system) and breakpoints\r\n        -- set on foo.lua will not work if not converted to the same case.\r\n        if iscasepreserving then file = string.lower(file) end\r\n        if find(file, \"^%./\") then file = sub(file, 3)\r\n        else file = gsub(file, \"^\"..q(basedir), \"\") end\r\n        -- some file systems allow newlines in file names; remove these.\r\n        file = gsub(file, \"\\n\", ' ')\r\n      else\r\n        file = mobdebug.line(file)\r\n      end\r\n\r\n      -- set to true if we got here; this only needs to be done once per\r\n      -- session, so do it here to at least avoid setting it for every line.\r\n      seen_hook = true\r\n      lastfile = file\r\n    end\r\n\r\n    if is_pending(server) then handle_breakpoint(server) end\r\n\r\n    local vars, status, res\r\n    if (watchescnt > 0) then\r\n      vars = capture_vars()\r\n      for index, value in pairs(watches) do\r\n        setfenv(value, vars)\r\n        local ok, fired = pcall(value)\r\n        if ok and fired then\r\n          status, res = cororesume(coro_debugger, events.WATCH, vars, file, line, index)\r\n          break -- any one watch is enough; don't check multiple times\r\n        end\r\n      end\r\n    end\r\n\r\n    -- need to get into the \"regular\" debug handler, but only if there was\r\n    -- no watch that was fired. If there was a watch, handle its result.\r\n    local getin = (status == nil) and\r\n      (step_into\r\n      -- when coroutine.running() return `nil` (main thread in Lua 5.1),\r\n      -- step_over will equal 'main', so need to check for that explicitly.\r\n      or (step_over and step_over == (coroutine.running() or 'main') and stack_level <= step_level)\r\n      or has_breakpoint(file, line)\r\n      or is_pending(server))\r\n\r\n    if getin then\r\n      vars = vars or capture_vars()\r\n      step_into = false\r\n      step_over = false\r\n      status, res = cororesume(coro_debugger, events.BREAK, vars, file, line)\r\n    end\r\n\r\n    -- handle 'stack' command that provides stack() information to the debugger\r\n    if status and res == 'stack' then\r\n      while status and res == 'stack' do\r\n        -- resume with the stack trace and variables\r\n        if vars then restore_vars(vars) end -- restore vars so they are reflected in stack values\r\n        -- this may fail if __tostring method fails at run-time\r\n        local ok, snapshot = pcall(stack, ngx and 5 or 4)\r\n        status, res = cororesume(coro_debugger, ok and events.STACK or events.BREAK, snapshot, file, line)\r\n      end\r\n    end\r\n\r\n    -- need to recheck once more as resume after 'stack' command may\r\n    -- return something else (for example, 'exit'), which needs to be handled\r\n    if status and res and res ~= 'stack' then\r\n      if not abort and res == \"exit\" then mobdebug.onexit(1, true); return end\r\n      if not abort and res == \"done\" then mobdebug.done(); return end\r\n      abort = res\r\n      -- only abort if safe; if not, there is another (earlier) check inside\r\n      -- debug_hook, which will abort execution at the first safe opportunity\r\n      if is_safe(stack_level) then error(abort) end\r\n    elseif not status and res then\r\n      error(res, 2) -- report any other (internal) errors back to the application\r\n    end\r\n\r\n    if vars then restore_vars(vars) end\r\n\r\n    -- last command requested Step Over/Out; store the current thread\r\n    if step_over == true then step_over = coroutine.running() or 'main' end\r\n  end",
    "type": "statement:if"
  }, {
    "id": 268,
    "text": "stack_level = stack_level + 1",
    "type": "statement:assign"
  }, {
    "id": 269,
    "text": "stack_level = stack_level - 1",
    "type": "statement:assign"
  }, {
    "id": 270,
    "text": "if mobdebug.linemap then\r\n      local ok, mappedline = pcall(mobdebug.linemap, line, debug.getinfo(2, \"S\").source)\r\n      if ok then line = mappedline end\r\n      if not line then return end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 271,
    "text": "local ok, mappedline = pcall(mobdebug.linemap, line, debug.getinfo(2, \"S\").source)",
    "type": "statement:localassign"
  }, {
    "id": 272,
    "text": "if ok then line = mappedline end",
    "type": "statement:if"
  }, {
    "id": 273,
    "text": "line = mappedline",
    "type": "statement:assign"
  }, {
    "id": 274,
    "text": "if not line then return end",
    "type": "statement:if"
  }, {
    "id": 275,
    "text": "if not (\r\n      step_into or step_over or breakpoints[line] or watchescnt > 0\r\n      or is_pending(server)\r\n    ) then checkcount = checkcount + 1; return end",
    "type": "statement:if"
  }, {
    "id": 276,
    "text": "checkcount = checkcount + 1",
    "type": "statement:assign"
  }, {
    "id": 277,
    "text": "checkcount = mobdebug.checkcount",
    "type": "statement:assign"
  }, {
    "id": 278,
    "text": "stack_level = stack_depth(stack_level+1)",
    "type": "statement:assign"
  }, {
    "id": 279,
    "text": "local caller = debug.getinfo(2, \"S\")",
    "type": "statement:localassign"
  }, {
    "id": 280,
    "text": "local file = lastfile",
    "type": "statement:localassign"
  }, {
    "id": 281,
    "text": "if (lastsource ~= caller.source) then\r\n      file, lastsource = caller.source, caller.source\r\n      -- technically, users can supply names that may not use '@',\r\n      -- for example when they call loadstring('...', 'filename.lua').\r\n      -- Unfortunately, there is no reliable/quick way to figure out\r\n      -- what is the filename and what is the source code.\r\n      -- If the name doesn't start with `@`, assume it's a file name if it's all on one line.\r\n      if find(file, \"^@\") or not find(file, \"[\\r\\n]\") then\r\n        file = gsub(gsub(file, \"^@\", \"\"), \"\\\\\", \"/\")\r\n        -- normalize paths that may include up-dir or same-dir references\r\n        -- if the path starts from the up-dir or reference,\r\n        -- prepend `basedir` to generate absolute path to keep breakpoints working.\r\n        -- ignore qualified relative path (`D:../`) and UNC paths (`\\\\?\\`)\r\n        if find(file, \"^%.%./\") then file = basedir..file end\r\n        if find(file, \"/%.%.?/\") then file = normalize_path(file) end\r\n        -- need this conversion to be applied to relative and absolute\r\n        -- file names as you may write \"require 'Foo'\" to\r\n        -- load \"foo.lua\" (on a case insensitive file system) and breakpoints\r\n        -- set on foo.lua will not work if not converted to the same case.\r\n        if iscasepreserving then file = string.lower(file) end\r\n        if find(file, \"^%./\") then file = sub(file, 3)\r\n        else file = gsub(file, \"^\"..q(basedir), \"\") end\r\n        -- some file systems allow newlines in file names; remove these.\r\n        file = gsub(file, \"\\n\", ' ')\r\n      else\r\n        file = mobdebug.line(file)\r\n      end\r\n\r\n      -- set to true if we got here; this only needs to be done once per\r\n      -- session, so do it here to at least avoid setting it for every line.\r\n      seen_hook = true\r\n      lastfile = file\r\n    end",
    "type": "statement:if"
  }, {
    "id": 282,
    "text": "file, lastsource = caller.source, caller.source",
    "type": "statement:assign"
  }, {
    "id": 283,
    "text": "if find(file, \"^@\") or not find(file, \"[\\r\\n]\") then\r\n        file = gsub(gsub(file, \"^@\", \"\"), \"\\\\\", \"/\")\r\n        -- normalize paths that may include up-dir or same-dir references\r\n        -- if the path starts from the up-dir or reference,\r\n        -- prepend `basedir` to generate absolute path to keep breakpoints working.\r\n        -- ignore qualified relative path (`D:../`) and UNC paths (`\\\\?\\`)\r\n        if find(file, \"^%.%./\") then file = basedir..file end\r\n        if find(file, \"/%.%.?/\") then file = normalize_path(file) end\r\n        -- need this conversion to be applied to relative and absolute\r\n        -- file names as you may write \"require 'Foo'\" to\r\n        -- load \"foo.lua\" (on a case insensitive file system) and breakpoints\r\n        -- set on foo.lua will not work if not converted to the same case.\r\n        if iscasepreserving then file = string.lower(file) end\r\n        if find(file, \"^%./\") then file = sub(file, 3)\r\n        else file = gsub(file, \"^\"..q(basedir), \"\") end\r\n        -- some file systems allow newlines in file names; remove these.\r\n        file = gsub(file, \"\\n\", ' ')\r\n      else\r\n        file = mobdebug.line(file)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 284,
    "text": "file = gsub(gsub(file, \"^@\", \"\"), \"\\\\\", \"/\")",
    "type": "statement:assign"
  }, {
    "id": 285,
    "text": "if find(file, \"^%.%./\") then file = basedir..file end",
    "type": "statement:if"
  }, {
    "id": 286,
    "text": "file = basedir..file",
    "type": "statement:assign"
  }, {
    "id": 287,
    "text": "if find(file, \"/%.%.?/\") then file = normalize_path(file) end",
    "type": "statement:if"
  }, {
    "id": 288,
    "text": "file = normalize_path(file)",
    "type": "statement:assign"
  }, {
    "id": 289,
    "text": "if iscasepreserving then file = string.lower(file) end",
    "type": "statement:if"
  }, {
    "id": 290,
    "text": "if find(file, \"^%./\") then file = sub(file, 3)\r\n        else file = gsub(file, \"^\"..q(basedir), \"\") end",
    "type": "statement:if"
  }, {
    "id": 291,
    "text": "file = sub(file, 3)",
    "type": "statement:assign"
  }, {
    "id": 292,
    "text": "file = gsub(file, \"^\"..q(basedir), \"\")",
    "type": "statement:assign"
  }, {
    "id": 293,
    "text": "file = gsub(file, \"\\n\", ' ')",
    "type": "statement:assign"
  }, {
    "id": 294,
    "text": "file = mobdebug.line(file)",
    "type": "statement:assign"
  }, {
    "id": 295,
    "text": "seen_hook = true",
    "type": "statement:assign"
  }, {
    "id": 296,
    "text": "lastfile = file",
    "type": "statement:assign"
  }, {
    "id": 297,
    "text": "if is_pending(server) then handle_breakpoint(server) end",
    "type": "statement:if"
  }, {
    "id": 298,
    "text": "handle_breakpoint(server)",
    "type": "statement:functioncall"
  }, {
    "id": 299,
    "text": "local vars, status, res",
    "type": "statement:localassign"
  }, {
    "id": 300,
    "text": "if (watchescnt > 0) then\r\n      vars = capture_vars()\r\n      for index, value in pairs(watches) do\r\n        setfenv(value, vars)\r\n        local ok, fired = pcall(value)\r\n        if ok and fired then\r\n          status, res = cororesume(coro_debugger, events.WATCH, vars, file, line, index)\r\n          break -- any one watch is enough; don't check multiple times\r\n        end\r\n      end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 301,
    "text": "vars = capture_vars()",
    "type": "statement:assign"
  }, {
    "id": 302,
    "text": "for index, value in pairs(watches) do\r\n        setfenv(value, vars)\r\n        local ok, fired = pcall(value)\r\n        if ok and fired then\r\n          status, res = cororesume(coro_debugger, events.WATCH, vars, file, line, index)\r\n          break -- any one watch is enough; don't check multiple times\r\n        end\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 303,
    "text": "setfenv(value, vars)",
    "type": "statement:functioncall"
  }, {
    "id": 304,
    "text": "local ok, fired = pcall(value)",
    "type": "statement:localassign"
  }, {
    "id": 305,
    "text": "if ok and fired then\r\n          status, res = cororesume(coro_debugger, events.WATCH, vars, file, line, index)\r\n          break -- any one watch is enough; don't check multiple times\r\n        end",
    "type": "statement:if"
  }, {
    "id": 306,
    "text": "status, res = cororesume(coro_debugger, events.WATCH, vars, file, line, index)",
    "type": "statement:assign"
  }, {
    "id": 307,
    "text": "local getin = (status == nil) and\r\n      (step_into\r\n      -- when coroutine.running() return `nil` (main thread in Lua 5.1),\r\n      -- step_over will equal 'main', so need to check for that explicitly.\r\n      or (step_over and step_over == (coroutine.running() or 'main') and stack_level <= step_level)\r\n      or has_breakpoint(file, line)\r\n      or is_pending(server))",
    "type": "statement:localassign"
  }, {
    "id": 308,
    "text": "if getin then\r\n      vars = vars or capture_vars()\r\n      step_into = false\r\n      step_over = false\r\n      status, res = cororesume(coro_debugger, events.BREAK, vars, file, line)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 309,
    "text": "vars = vars or capture_vars()",
    "type": "statement:assign"
  }, {
    "id": 310,
    "text": "step_into = false",
    "type": "statement:assign"
  }, {
    "id": 311,
    "text": "step_over = false",
    "type": "statement:assign"
  }, {
    "id": 312,
    "text": "status, res = cororesume(coro_debugger, events.BREAK, vars, file, line)",
    "type": "statement:assign"
  }, {
    "id": 313,
    "text": "if status and res == 'stack' then\r\n      while status and res == 'stack' do\r\n        -- resume with the stack trace and variables\r\n        if vars then restore_vars(vars) end -- restore vars so they are reflected in stack values\r\n        -- this may fail if __tostring method fails at run-time\r\n        local ok, snapshot = pcall(stack, ngx and 5 or 4)\r\n        status, res = cororesume(coro_debugger, ok and events.STACK or events.BREAK, snapshot, file, line)\r\n      end\r\n    end",
    "type": "statement:if"
  }, {
    "id": 314,
    "text": "while status and res == 'stack' do\r\n        -- resume with the stack trace and variables\r\n        if vars then restore_vars(vars) end -- restore vars so they are reflected in stack values\r\n        -- this may fail if __tostring method fails at run-time\r\n        local ok, snapshot = pcall(stack, ngx and 5 or 4)\r\n        status, res = cororesume(coro_debugger, ok and events.STACK or events.BREAK, snapshot, file, line)\r\n      end",
    "type": "statement:while"
  }, {
    "id": 315,
    "text": "if vars then restore_vars(vars) end",
    "type": "statement:if"
  }, {
    "id": 316,
    "text": "restore_vars(vars)",
    "type": "statement:functioncall"
  }, {
    "id": 317,
    "text": "local ok, snapshot = pcall(stack, ngx and 5 or 4)",
    "type": "statement:localassign"
  }, {
    "id": 318,
    "text": "status, res = cororesume(coro_debugger, ok and events.STACK or events.BREAK, snapshot, file, line)",
    "type": "statement:assign"
  }, {
    "id": 319,
    "text": "if status and res and res ~= 'stack' then\r\n      if not abort and res == \"exit\" then mobdebug.onexit(1, true); return end\r\n      if not abort and res == \"done\" then mobdebug.done(); return end\r\n      abort = res\r\n      -- only abort if safe; if not, there is another (earlier) check inside\r\n      -- debug_hook, which will abort execution at the first safe opportunity\r\n      if is_safe(stack_level) then error(abort) end\r\n    elseif not status and res then\r\n      error(res, 2) -- report any other (internal) errors back to the application\r\n    end",
    "type": "statement:if"
  }, {
    "id": 320,
    "text": "if not abort and res == \"exit\" then mobdebug.onexit(1, true); return end",
    "type": "statement:if"
  }, {
    "id": 321,
    "text": "mobdebug.onexit(1, true)",
    "type": "statement:functioncall"
  }, {
    "id": 322,
    "text": "if not abort and res == \"done\" then mobdebug.done(); return end",
    "type": "statement:if"
  }, {
    "id": 323,
    "text": "mobdebug.done()",
    "type": "statement:functioncall"
  }, {
    "id": 324,
    "text": "abort = res",
    "type": "statement:assign"
  }, {
    "id": 325,
    "text": "if is_safe(stack_level) then error(abort) end",
    "type": "statement:if"
  }, {
    "id": 326,
    "text": "error(res, 2)",
    "type": "statement:functioncall"
  }, {
    "id": 327,
    "text": "if step_over == true then step_over = coroutine.running() or 'main' end",
    "type": "statement:if"
  }, {
    "id": 328,
    "text": "step_over = coroutine.running() or 'main'",
    "type": "statement:assign"
  }, {
    "id": 329,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 330,
    "text": "local function stringify_results(status, ...)\r\n  if not status then return status, ... end -- on error report as it\r\n\r\n  local t = {...}\r\n  for i,v in pairs(t) do -- stringify each of the returned values\r\n    local ok, res = pcall(mobdebug.line, v, {nocode = true, comment = 1})\r\n    t[i] = ok and res or (\"%q\"):format(res):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\")\r\n  end\r\n  -- stringify table with all returned values\r\n  -- this is done to allow each returned value to be used (serialized or not)\r\n  -- intependently and to preserve \"original\" comments\r\n  return pcall(mobdebug.dump, t, {sparse = false})\r\nend",
    "type": "function"
  }, {
    "id": 331,
    "text": "if not status then return status, ... end",
    "type": "statement:if"
  }, {
    "id": 332,
    "text": "local t = {...}",
    "type": "statement:localassign"
  }, {
    "id": 333,
    "text": "for i,v in pairs(t) do -- stringify each of the returned values\r\n    local ok, res = pcall(mobdebug.line, v, {nocode = true, comment = 1})\r\n    t[i] = ok and res or (\"%q\"):format(res):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\")\r\n  end",
    "type": "statement:genericfor"
  }, {
    "id": 334,
    "text": "local ok, res = pcall(mobdebug.line, v, {nocode = true, comment = 1})",
    "type": "statement:localassign"
  }, {
    "id": 335,
    "text": "t[i] = ok and res or (\"%q\"):format(res):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\")",
    "type": "statement:assign"
  }, {
    "id": 336,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 337,
    "text": "local function isrunning()\r\n  return coro_debugger and (corostatus(coro_debugger) == 'suspended' or corostatus(coro_debugger) == 'running')\r\nend",
    "type": "function"
  }, {
    "id": 338,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 339,
    "text": "local function done()\r\n  if not (isrunning() and server) then return end\r\n\r\n  if not jit then\r\n    for co, debugged in pairs(coroutines) do\r\n      if debugged then debug.sethook(co) end\r\n    end\r\n  end\r\n\r\n  debug.sethook()\r\n  server:close()\r\n\r\n  coro_debugger = nil -- to make sure isrunning() returns `false`\r\n  seen_hook = nil -- to make sure that the next start() call works\r\n  abort = nil -- to make sure that callback calls use proper \"abort\" value\r\nend",
    "type": "function"
  }, {
    "id": 340,
    "text": "if not (isrunning() and server) then return end",
    "type": "statement:if"
  }, {
    "id": 341,
    "text": "if not jit then\r\n    for co, debugged in pairs(coroutines) do\r\n      if debugged then debug.sethook(co) end\r\n    end\r\n  end",
    "type": "statement:if"
  }, {
    "id": 342,
    "text": "for co, debugged in pairs(coroutines) do\r\n      if debugged then debug.sethook(co) end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 343,
    "text": "if debugged then debug.sethook(co) end",
    "type": "statement:if"
  }, {
    "id": 344,
    "text": "debug.sethook(co)",
    "type": "statement:functioncall"
  }, {
    "id": 345,
    "text": "debug.sethook()",
    "type": "statement:functioncall"
  }, {
    "id": 346,
    "text": "server:close()",
    "type": "statement:functioncall"
  }, {
    "id": 347,
    "text": "coro_debugger = nil",
    "type": "statement:assign"
  }, {
    "id": 348,
    "text": "seen_hook = nil",
    "type": "statement:assign"
  }, {
    "id": 349,
    "text": "abort = nil",
    "type": "statement:assign"
  }, {
    "id": 350,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 351,
    "text": "local function debugger_loop(sev, svars, sfile, sline)\r\n  local command\r\n  local app, osname\r\n  local eval_env = svars or {}\r\n  local function emptyWatch () return false end\r\n  local loaded = {}\r\n  for k in pairs(package.loaded) do loaded[k] = true end\r\n\r\n  while true do\r\n    local line, err\r\n    local wx = rawget(genv, \"wx\") -- use rawread to make strict.lua happy\r\n    if (wx or mobdebug.yield) and server.settimeout then server:settimeout(mobdebug.yieldtimeout) end\r\n    while true do\r\n      line, err = server:receive()\r\n      if not line and err == \"timeout\" then\r\n        -- yield for wx GUI applications if possible to avoid \"busyness\"\r\n        app = app or (wx and wx.wxGetApp and wx.wxGetApp())\r\n        if app then\r\n          local win = app:GetTopWindow()\r\n          local inloop = app:IsMainLoopRunning()\r\n          osname = osname or wx.wxPlatformInfo.Get():GetOperatingSystemFamilyName()\r\n          if win and not inloop then\r\n            -- process messages in a regular way\r\n            -- and exit as soon as the event loop is idle\r\n            if osname == 'Unix' then wx.wxTimer(app):Start(10, true) end\r\n            local exitLoop = function()\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)\r\n              app:ExitMainLoop()\r\n            end\r\n            win:Connect(wx.wxEVT_IDLE, exitLoop)\r\n            win:Connect(wx.wxEVT_TIMER, exitLoop)\r\n            app:MainLoop()\r\n          end\r\n        elseif mobdebug.yield then mobdebug.yield()\r\n        end\r\n      elseif not line and err == \"closed\" then\r\n        error(\"Debugger connection closed\", 0)\r\n      else\r\n        -- if there is something in the pending buffer, prepend it to the line\r\n        if buf then line = buf .. line; buf = nil end\r\n        break\r\n      end\r\n    end\r\n    if server.settimeout then server:settimeout() end -- back to blocking\r\n    command = string.sub(line, string.find(line, \"^[A-Z]+\"))\r\n    if command == \"SETB\" then\r\n      local _, _, _, file, line = string.find(line, \"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\r\n      if file and line then\r\n        set_breakpoint(file, tonumber(line))\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"DELB\" then\r\n      local _, _, _, file, line = string.find(line, \"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\r\n      if file and line then\r\n        remove_breakpoint(file, tonumber(line))\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"EXEC\" then\r\n      local _, _, chunk = string.find(line, \"^[A-Z]+%s+(.+)$\")\r\n      if chunk then\r\n        local func, res = mobdebug.loadstring(chunk)\r\n        local status\r\n        if func then\r\n          setfenv(func, eval_env)\r\n          status, res = stringify_results(pcall(func))\r\n        end\r\n        if status then\r\n          if mobdebug.onscratch then mobdebug.onscratch(res) end\r\n          server:send(\"200 OK \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        else\r\n          -- fix error if not set (for example, when loadstring is not present)\r\n          if not res then res = \"Unknown error\" end\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"LOAD\" then\r\n      local _, _, size, name = string.find(line, \"^[A-Z]+%s+(%d+)%s+(%S.-)%s*$\")\r\n      size = tonumber(size)\r\n\r\n      if abort == nil then -- no LOAD/RELOAD allowed inside start()\r\n        if size > 0 then server:receive(size) end\r\n        if sfile and sline then\r\n          server:send(\"201 Started \" .. sfile .. \" \" .. tostring(sline) .. \"\\n\")\r\n        else\r\n          server:send(\"200 OK 0\\n\")\r\n        end\r\n      else\r\n        -- reset environment to allow required modules to load again\r\n        -- remove those packages that weren't loaded when debugger started\r\n        for k in pairs(package.loaded) do\r\n          if not loaded[k] then package.loaded[k] = nil end\r\n        end\r\n\r\n        if size == 0 and name == '-' then -- RELOAD the current script being debugged\r\n          server:send(\"200 OK 0\\n\")\r\n          coroyield(\"load\")\r\n        else\r\n          -- receiving 0 bytes blocks (at least in luasocket 2.0.2), so skip reading\r\n          local chunk = size == 0 and \"\" or server:receive(size)\r\n          if chunk then -- LOAD a new script for debugging\r\n            local func, res = mobdebug.loadstring(chunk, \"@\"..name)\r\n            if func then\r\n              server:send(\"200 OK 0\\n\")\r\n              debugee = func\r\n              coroyield(\"load\")\r\n            else\r\n              server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n              server:send(res)\r\n            end\r\n          else\r\n            server:send(\"400 Bad Request\\n\")\r\n          end\r\n        end\r\n      end\r\n    elseif command == \"SETW\" then\r\n      local _, _, exp = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")\r\n      if exp then\r\n        local func, res = mobdebug.loadstring(\"return(\" .. exp .. \")\")\r\n        if func then\r\n          watchescnt = watchescnt + 1\r\n          local newidx = #watches + 1\r\n          watches[newidx] = func\r\n          server:send(\"200 OK \" .. tostring(newidx) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"DELW\" then\r\n      local _, _, index = string.find(line, \"^[A-Z]+%s+(%d+)%s*$\")\r\n      index = tonumber(index)\r\n      if index > 0 and index <= #watches then\r\n        watchescnt = watchescnt - (watches[index] ~= emptyWatch and 1 or 0)\r\n        watches[index] = emptyWatch\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"RUN\" then\r\n      server:send(\"200 OK\\n\")\r\n\r\n      local ev, vars, file, line, idx_watch = coroyield()\r\n      eval_env = vars\r\n      if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end\r\n    elseif command == \"STEP\" then\r\n      server:send(\"200 OK\\n\")\r\n      step_into = true\r\n\r\n      local ev, vars, file, line, idx_watch = coroyield()\r\n      eval_env = vars\r\n      if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end\r\n    elseif command == \"OVER\" or command == \"OUT\" then\r\n      server:send(\"200 OK\\n\")\r\n      step_over = true\r\n\r\n      -- OVER and OUT are very similar except for\r\n      -- the stack level value at which to stop\r\n      if command == \"OUT\" then step_level = stack_level - 1\r\n      else step_level = stack_level end\r\n\r\n      local ev, vars, file, line, idx_watch = coroyield()\r\n      eval_env = vars\r\n      if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end\r\n    elseif command == \"BASEDIR\" then\r\n      local _, _, dir = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")\r\n      if dir then\r\n        basedir = iscasepreserving and string.lower(dir) or dir\r\n        -- reset cached source as it may change with basedir\r\n        lastsource = nil\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"SUSPEND\" then\r\n      -- do nothing; it already fulfilled its role\r\n    elseif command == \"DONE\" then\r\n      coroyield(\"done\")\r\n      return -- done with all the debugging\r\n    elseif command == \"STACK\" then\r\n      -- first check if we can execute the stack command\r\n      -- as it requires yielding back to debug_hook it cannot be executed\r\n      -- if we have not seen the hook yet as happens after start().\r\n      -- in this case we simply return an empty result\r\n      local vars, ev = {}\r\n      if seen_hook then\r\n        ev, vars = coroyield(\"stack\")\r\n      end\r\n      if ev and ev ~= events.STACK then\r\n        server:send(\"401 Error in Execution \" .. tostring(#vars) .. \"\\n\")\r\n        server:send(vars)\r\n      else\r\n        local ok, res = pcall(mobdebug.dump, vars, {nocode = true, sparse = false})\r\n        if ok then\r\n          server:send(\"200 OK \" .. tostring(res) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Execution \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      end\r\n    elseif command == \"OUTPUT\" then\r\n      local _, _, stream, mode = string.find(line, \"^[A-Z]+%s+(%w+)%s+([dcr])%s*$\")\r\n      if stream and mode and stream == \"stdout\" then\r\n        -- assign \"print\" in the global environment\r\n        local default = mode == 'd'\r\n        genv.print = default and iobase.print or corowrap(function()\r\n          -- wrapping into coroutine.wrap protects this function from\r\n          -- being stepped through in the debugger.\r\n          -- don't use vararg (...) as it adds a reference for its values,\r\n          -- which may affect how they are garbage collected\r\n          while true do\r\n            local tbl = {coroutine.yield()}\r\n            if mode == 'c' then iobase.print(unpack(tbl)) end\r\n            for n = 1, #tbl do\r\n              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end\r\n            local file = table.concat(tbl, \"\\t\")..\"\\n\"\r\n            server:send(\"204 Output \" .. stream .. \" \" .. tostring(#file) .. \"\\n\" .. file)\r\n          end\r\n        end)\r\n        if not default then genv.print() end -- \"fake\" print to start printing loop\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"EXIT\" then\r\n      server:send(\"200 OK\\n\")\r\n      coroyield(\"exit\")\r\n    else\r\n      server:send(\"400 Bad Request\\n\")\r\n    end\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 352,
    "text": "local command",
    "type": "statement:localassign"
  }, {
    "id": 353,
    "text": "local app, osname",
    "type": "statement:localassign"
  }, {
    "id": 354,
    "text": "local eval_env = svars or {}",
    "type": "statement:localassign"
  }, {
    "id": 355,
    "text": "local function emptyWatch () return false end",
    "type": "statement:localfunction"
  }, {
    "id": 356,
    "text": "local loaded = {}",
    "type": "statement:localassign"
  }, {
    "id": 357,
    "text": "for k in pairs(package.loaded) do loaded[k] = true end",
    "type": "statement:genericfor"
  }, {
    "id": 358,
    "text": "loaded[k] = true",
    "type": "statement:assign"
  }, {
    "id": 359,
    "text": "while true do\r\n    local line, err\r\n    local wx = rawget(genv, \"wx\") -- use rawread to make strict.lua happy\r\n    if (wx or mobdebug.yield) and server.settimeout then server:settimeout(mobdebug.yieldtimeout) end\r\n    while true do\r\n      line, err = server:receive()\r\n      if not line and err == \"timeout\" then\r\n        -- yield for wx GUI applications if possible to avoid \"busyness\"\r\n        app = app or (wx and wx.wxGetApp and wx.wxGetApp())\r\n        if app then\r\n          local win = app:GetTopWindow()\r\n          local inloop = app:IsMainLoopRunning()\r\n          osname = osname or wx.wxPlatformInfo.Get():GetOperatingSystemFamilyName()\r\n          if win and not inloop then\r\n            -- process messages in a regular way\r\n            -- and exit as soon as the event loop is idle\r\n            if osname == 'Unix' then wx.wxTimer(app):Start(10, true) end\r\n            local exitLoop = function()\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)\r\n              app:ExitMainLoop()\r\n            end\r\n            win:Connect(wx.wxEVT_IDLE, exitLoop)\r\n            win:Connect(wx.wxEVT_TIMER, exitLoop)\r\n            app:MainLoop()\r\n          end\r\n        elseif mobdebug.yield then mobdebug.yield()\r\n        end\r\n      elseif not line and err == \"closed\" then\r\n        error(\"Debugger connection closed\", 0)\r\n      else\r\n        -- if there is something in the pending buffer, prepend it to the line\r\n        if buf then line = buf .. line; buf = nil end\r\n        break\r\n      end\r\n    end\r\n    if server.settimeout then server:settimeout() end -- back to blocking\r\n    command = string.sub(line, string.find(line, \"^[A-Z]+\"))\r\n    if command == \"SETB\" then\r\n      local _, _, _, file, line = string.find(line, \"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\r\n      if file and line then\r\n        set_breakpoint(file, tonumber(line))\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"DELB\" then\r\n      local _, _, _, file, line = string.find(line, \"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\r\n      if file and line then\r\n        remove_breakpoint(file, tonumber(line))\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"EXEC\" then\r\n      local _, _, chunk = string.find(line, \"^[A-Z]+%s+(.+)$\")\r\n      if chunk then\r\n        local func, res = mobdebug.loadstring(chunk)\r\n        local status\r\n        if func then\r\n          setfenv(func, eval_env)\r\n          status, res = stringify_results(pcall(func))\r\n        end\r\n        if status then\r\n          if mobdebug.onscratch then mobdebug.onscratch(res) end\r\n          server:send(\"200 OK \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        else\r\n          -- fix error if not set (for example, when loadstring is not present)\r\n          if not res then res = \"Unknown error\" end\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"LOAD\" then\r\n      local _, _, size, name = string.find(line, \"^[A-Z]+%s+(%d+)%s+(%S.-)%s*$\")\r\n      size = tonumber(size)\r\n\r\n      if abort == nil then -- no LOAD/RELOAD allowed inside start()\r\n        if size > 0 then server:receive(size) end\r\n        if sfile and sline then\r\n          server:send(\"201 Started \" .. sfile .. \" \" .. tostring(sline) .. \"\\n\")\r\n        else\r\n          server:send(\"200 OK 0\\n\")\r\n        end\r\n      else\r\n        -- reset environment to allow required modules to load again\r\n        -- remove those packages that weren't loaded when debugger started\r\n        for k in pairs(package.loaded) do\r\n          if not loaded[k] then package.loaded[k] = nil end\r\n        end\r\n\r\n        if size == 0 and name == '-' then -- RELOAD the current script being debugged\r\n          server:send(\"200 OK 0\\n\")\r\n          coroyield(\"load\")\r\n        else\r\n          -- receiving 0 bytes blocks (at least in luasocket 2.0.2), so skip reading\r\n          local chunk = size == 0 and \"\" or server:receive(size)\r\n          if chunk then -- LOAD a new script for debugging\r\n            local func, res = mobdebug.loadstring(chunk, \"@\"..name)\r\n            if func then\r\n              server:send(\"200 OK 0\\n\")\r\n              debugee = func\r\n              coroyield(\"load\")\r\n            else\r\n              server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n              server:send(res)\r\n            end\r\n          else\r\n            server:send(\"400 Bad Request\\n\")\r\n          end\r\n        end\r\n      end\r\n    elseif command == \"SETW\" then\r\n      local _, _, exp = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")\r\n      if exp then\r\n        local func, res = mobdebug.loadstring(\"return(\" .. exp .. \")\")\r\n        if func then\r\n          watchescnt = watchescnt + 1\r\n          local newidx = #watches + 1\r\n          watches[newidx] = func\r\n          server:send(\"200 OK \" .. tostring(newidx) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"DELW\" then\r\n      local _, _, index = string.find(line, \"^[A-Z]+%s+(%d+)%s*$\")\r\n      index = tonumber(index)\r\n      if index > 0 and index <= #watches then\r\n        watchescnt = watchescnt - (watches[index] ~= emptyWatch and 1 or 0)\r\n        watches[index] = emptyWatch\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"RUN\" then\r\n      server:send(\"200 OK\\n\")\r\n\r\n      local ev, vars, file, line, idx_watch = coroyield()\r\n      eval_env = vars\r\n      if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end\r\n    elseif command == \"STEP\" then\r\n      server:send(\"200 OK\\n\")\r\n      step_into = true\r\n\r\n      local ev, vars, file, line, idx_watch = coroyield()\r\n      eval_env = vars\r\n      if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end\r\n    elseif command == \"OVER\" or command == \"OUT\" then\r\n      server:send(\"200 OK\\n\")\r\n      step_over = true\r\n\r\n      -- OVER and OUT are very similar except for\r\n      -- the stack level value at which to stop\r\n      if command == \"OUT\" then step_level = stack_level - 1\r\n      else step_level = stack_level end\r\n\r\n      local ev, vars, file, line, idx_watch = coroyield()\r\n      eval_env = vars\r\n      if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end\r\n    elseif command == \"BASEDIR\" then\r\n      local _, _, dir = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")\r\n      if dir then\r\n        basedir = iscasepreserving and string.lower(dir) or dir\r\n        -- reset cached source as it may change with basedir\r\n        lastsource = nil\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"SUSPEND\" then\r\n      -- do nothing; it already fulfilled its role\r\n    elseif command == \"DONE\" then\r\n      coroyield(\"done\")\r\n      return -- done with all the debugging\r\n    elseif command == \"STACK\" then\r\n      -- first check if we can execute the stack command\r\n      -- as it requires yielding back to debug_hook it cannot be executed\r\n      -- if we have not seen the hook yet as happens after start().\r\n      -- in this case we simply return an empty result\r\n      local vars, ev = {}\r\n      if seen_hook then\r\n        ev, vars = coroyield(\"stack\")\r\n      end\r\n      if ev and ev ~= events.STACK then\r\n        server:send(\"401 Error in Execution \" .. tostring(#vars) .. \"\\n\")\r\n        server:send(vars)\r\n      else\r\n        local ok, res = pcall(mobdebug.dump, vars, {nocode = true, sparse = false})\r\n        if ok then\r\n          server:send(\"200 OK \" .. tostring(res) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Execution \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      end\r\n    elseif command == \"OUTPUT\" then\r\n      local _, _, stream, mode = string.find(line, \"^[A-Z]+%s+(%w+)%s+([dcr])%s*$\")\r\n      if stream and mode and stream == \"stdout\" then\r\n        -- assign \"print\" in the global environment\r\n        local default = mode == 'd'\r\n        genv.print = default and iobase.print or corowrap(function()\r\n          -- wrapping into coroutine.wrap protects this function from\r\n          -- being stepped through in the debugger.\r\n          -- don't use vararg (...) as it adds a reference for its values,\r\n          -- which may affect how they are garbage collected\r\n          while true do\r\n            local tbl = {coroutine.yield()}\r\n            if mode == 'c' then iobase.print(unpack(tbl)) end\r\n            for n = 1, #tbl do\r\n              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end\r\n            local file = table.concat(tbl, \"\\t\")..\"\\n\"\r\n            server:send(\"204 Output \" .. stream .. \" \" .. tostring(#file) .. \"\\n\" .. file)\r\n          end\r\n        end)\r\n        if not default then genv.print() end -- \"fake\" print to start printing loop\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"EXIT\" then\r\n      server:send(\"200 OK\\n\")\r\n      coroyield(\"exit\")\r\n    else\r\n      server:send(\"400 Bad Request\\n\")\r\n    end\r\n  end",
    "type": "statement:while"
  }, {
    "id": 360,
    "text": "local line, err",
    "type": "statement:localassign"
  }, {
    "id": 361,
    "text": "local wx = rawget(genv, \"wx\")",
    "type": "statement:localassign"
  }, {
    "id": 362,
    "text": "if (wx or mobdebug.yield) and server.settimeout then server:settimeout(mobdebug.yieldtimeout) end",
    "type": "statement:if"
  }, {
    "id": 363,
    "text": "server:settimeout(mobdebug.yieldtimeout)",
    "type": "statement:functioncall"
  }, {
    "id": 364,
    "text": "while true do\r\n      line, err = server:receive()\r\n      if not line and err == \"timeout\" then\r\n        -- yield for wx GUI applications if possible to avoid \"busyness\"\r\n        app = app or (wx and wx.wxGetApp and wx.wxGetApp())\r\n        if app then\r\n          local win = app:GetTopWindow()\r\n          local inloop = app:IsMainLoopRunning()\r\n          osname = osname or wx.wxPlatformInfo.Get():GetOperatingSystemFamilyName()\r\n          if win and not inloop then\r\n            -- process messages in a regular way\r\n            -- and exit as soon as the event loop is idle\r\n            if osname == 'Unix' then wx.wxTimer(app):Start(10, true) end\r\n            local exitLoop = function()\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)\r\n              app:ExitMainLoop()\r\n            end\r\n            win:Connect(wx.wxEVT_IDLE, exitLoop)\r\n            win:Connect(wx.wxEVT_TIMER, exitLoop)\r\n            app:MainLoop()\r\n          end\r\n        elseif mobdebug.yield then mobdebug.yield()\r\n        end\r\n      elseif not line and err == \"closed\" then\r\n        error(\"Debugger connection closed\", 0)\r\n      else\r\n        -- if there is something in the pending buffer, prepend it to the line\r\n        if buf then line = buf .. line; buf = nil end\r\n        break\r\n      end\r\n    end",
    "type": "statement:while"
  }, {
    "id": 365,
    "text": "line, err = server:receive()",
    "type": "statement:assign"
  }, {
    "id": 366,
    "text": "if not line and err == \"timeout\" then\r\n        -- yield for wx GUI applications if possible to avoid \"busyness\"\r\n        app = app or (wx and wx.wxGetApp and wx.wxGetApp())\r\n        if app then\r\n          local win = app:GetTopWindow()\r\n          local inloop = app:IsMainLoopRunning()\r\n          osname = osname or wx.wxPlatformInfo.Get():GetOperatingSystemFamilyName()\r\n          if win and not inloop then\r\n            -- process messages in a regular way\r\n            -- and exit as soon as the event loop is idle\r\n            if osname == 'Unix' then wx.wxTimer(app):Start(10, true) end\r\n            local exitLoop = function()\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)\r\n              app:ExitMainLoop()\r\n            end\r\n            win:Connect(wx.wxEVT_IDLE, exitLoop)\r\n            win:Connect(wx.wxEVT_TIMER, exitLoop)\r\n            app:MainLoop()\r\n          end\r\n        elseif mobdebug.yield then mobdebug.yield()\r\n        end\r\n      elseif not line and err == \"closed\" then\r\n        error(\"Debugger connection closed\", 0)\r\n      else\r\n        -- if there is something in the pending buffer, prepend it to the line\r\n        if buf then line = buf .. line; buf = nil end\r\n        break\r\n      end",
    "type": "statement:if"
  }, {
    "id": 367,
    "text": "app = app or (wx and wx.wxGetApp and wx.wxGetApp())",
    "type": "statement:assign"
  }, {
    "id": 368,
    "text": "if app then\r\n          local win = app:GetTopWindow()\r\n          local inloop = app:IsMainLoopRunning()\r\n          osname = osname or wx.wxPlatformInfo.Get():GetOperatingSystemFamilyName()\r\n          if win and not inloop then\r\n            -- process messages in a regular way\r\n            -- and exit as soon as the event loop is idle\r\n            if osname == 'Unix' then wx.wxTimer(app):Start(10, true) end\r\n            local exitLoop = function()\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)\r\n              app:ExitMainLoop()\r\n            end\r\n            win:Connect(wx.wxEVT_IDLE, exitLoop)\r\n            win:Connect(wx.wxEVT_TIMER, exitLoop)\r\n            app:MainLoop()\r\n          end\r\n        elseif mobdebug.yield then mobdebug.yield()\r\n        end",
    "type": "statement:if"
  }, {
    "id": 369,
    "text": "local win = app:GetTopWindow()",
    "type": "statement:localassign"
  }, {
    "id": 370,
    "text": "local inloop = app:IsMainLoopRunning()",
    "type": "statement:localassign"
  }, {
    "id": 371,
    "text": "osname = osname or wx.wxPlatformInfo.Get():GetOperatingSystemFamilyName()",
    "type": "statement:assign"
  }, {
    "id": 372,
    "text": "if win and not inloop then\r\n            -- process messages in a regular way\r\n            -- and exit as soon as the event loop is idle\r\n            if osname == 'Unix' then wx.wxTimer(app):Start(10, true) end\r\n            local exitLoop = function()\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)\r\n              app:ExitMainLoop()\r\n            end\r\n            win:Connect(wx.wxEVT_IDLE, exitLoop)\r\n            win:Connect(wx.wxEVT_TIMER, exitLoop)\r\n            app:MainLoop()\r\n          end",
    "type": "statement:if"
  }, {
    "id": 373,
    "text": "if osname == 'Unix' then wx.wxTimer(app):Start(10, true) end",
    "type": "statement:if"
  }, {
    "id": 374,
    "text": "wx.wxTimer(app):Start(10, true)",
    "type": "statement:functioncall"
  }, {
    "id": 375,
    "text": "local exitLoop = function()\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)\r\n              app:ExitMainLoop()\r\n            end",
    "type": "statement:localassign"
  }, {
    "id": 376,
    "text": "win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)",
    "type": "statement:functioncall"
  }, {
    "id": 377,
    "text": "win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)",
    "type": "statement:functioncall"
  }, {
    "id": 378,
    "text": "app:ExitMainLoop()",
    "type": "statement:functioncall"
  }, {
    "id": 379,
    "text": "win:Connect(wx.wxEVT_IDLE, exitLoop)",
    "type": "statement:functioncall"
  }, {
    "id": 380,
    "text": "win:Connect(wx.wxEVT_TIMER, exitLoop)",
    "type": "statement:functioncall"
  }, {
    "id": 381,
    "text": "app:MainLoop()",
    "type": "statement:functioncall"
  }, {
    "id": 382,
    "text": "mobdebug.yield()",
    "type": "statement:functioncall"
  }, {
    "id": 383,
    "text": "error(\"Debugger connection closed\", 0)",
    "type": "statement:functioncall"
  }, {
    "id": 384,
    "text": "if buf then line = buf .. line; buf = nil end",
    "type": "statement:if"
  }, {
    "id": 385,
    "text": "line = buf .. line",
    "type": "statement:assign"
  }, {
    "id": 386,
    "text": "if server.settimeout then server:settimeout() end",
    "type": "statement:if"
  }, {
    "id": 387,
    "text": "server:settimeout()",
    "type": "statement:functioncall"
  }, {
    "id": 388,
    "text": "command = string.sub(line, string.find(line, \"^[A-Z]+\"))",
    "type": "statement:assign"
  }, {
    "id": 389,
    "text": "if command == \"SETB\" then\r\n      local _, _, _, file, line = string.find(line, \"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\r\n      if file and line then\r\n        set_breakpoint(file, tonumber(line))\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"DELB\" then\r\n      local _, _, _, file, line = string.find(line, \"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")\r\n      if file and line then\r\n        remove_breakpoint(file, tonumber(line))\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"EXEC\" then\r\n      local _, _, chunk = string.find(line, \"^[A-Z]+%s+(.+)$\")\r\n      if chunk then\r\n        local func, res = mobdebug.loadstring(chunk)\r\n        local status\r\n        if func then\r\n          setfenv(func, eval_env)\r\n          status, res = stringify_results(pcall(func))\r\n        end\r\n        if status then\r\n          if mobdebug.onscratch then mobdebug.onscratch(res) end\r\n          server:send(\"200 OK \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        else\r\n          -- fix error if not set (for example, when loadstring is not present)\r\n          if not res then res = \"Unknown error\" end\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"LOAD\" then\r\n      local _, _, size, name = string.find(line, \"^[A-Z]+%s+(%d+)%s+(%S.-)%s*$\")\r\n      size = tonumber(size)\r\n\r\n      if abort == nil then -- no LOAD/RELOAD allowed inside start()\r\n        if size > 0 then server:receive(size) end\r\n        if sfile and sline then\r\n          server:send(\"201 Started \" .. sfile .. \" \" .. tostring(sline) .. \"\\n\")\r\n        else\r\n          server:send(\"200 OK 0\\n\")\r\n        end\r\n      else\r\n        -- reset environment to allow required modules to load again\r\n        -- remove those packages that weren't loaded when debugger started\r\n        for k in pairs(package.loaded) do\r\n          if not loaded[k] then package.loaded[k] = nil end\r\n        end\r\n\r\n        if size == 0 and name == '-' then -- RELOAD the current script being debugged\r\n          server:send(\"200 OK 0\\n\")\r\n          coroyield(\"load\")\r\n        else\r\n          -- receiving 0 bytes blocks (at least in luasocket 2.0.2), so skip reading\r\n          local chunk = size == 0 and \"\" or server:receive(size)\r\n          if chunk then -- LOAD a new script for debugging\r\n            local func, res = mobdebug.loadstring(chunk, \"@\"..name)\r\n            if func then\r\n              server:send(\"200 OK 0\\n\")\r\n              debugee = func\r\n              coroyield(\"load\")\r\n            else\r\n              server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n              server:send(res)\r\n            end\r\n          else\r\n            server:send(\"400 Bad Request\\n\")\r\n          end\r\n        end\r\n      end\r\n    elseif command == \"SETW\" then\r\n      local _, _, exp = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")\r\n      if exp then\r\n        local func, res = mobdebug.loadstring(\"return(\" .. exp .. \")\")\r\n        if func then\r\n          watchescnt = watchescnt + 1\r\n          local newidx = #watches + 1\r\n          watches[newidx] = func\r\n          server:send(\"200 OK \" .. tostring(newidx) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"DELW\" then\r\n      local _, _, index = string.find(line, \"^[A-Z]+%s+(%d+)%s*$\")\r\n      index = tonumber(index)\r\n      if index > 0 and index <= #watches then\r\n        watchescnt = watchescnt - (watches[index] ~= emptyWatch and 1 or 0)\r\n        watches[index] = emptyWatch\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"RUN\" then\r\n      server:send(\"200 OK\\n\")\r\n\r\n      local ev, vars, file, line, idx_watch = coroyield()\r\n      eval_env = vars\r\n      if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end\r\n    elseif command == \"STEP\" then\r\n      server:send(\"200 OK\\n\")\r\n      step_into = true\r\n\r\n      local ev, vars, file, line, idx_watch = coroyield()\r\n      eval_env = vars\r\n      if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end\r\n    elseif command == \"OVER\" or command == \"OUT\" then\r\n      server:send(\"200 OK\\n\")\r\n      step_over = true\r\n\r\n      -- OVER and OUT are very similar except for\r\n      -- the stack level value at which to stop\r\n      if command == \"OUT\" then step_level = stack_level - 1\r\n      else step_level = stack_level end\r\n\r\n      local ev, vars, file, line, idx_watch = coroyield()\r\n      eval_env = vars\r\n      if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end\r\n    elseif command == \"BASEDIR\" then\r\n      local _, _, dir = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")\r\n      if dir then\r\n        basedir = iscasepreserving and string.lower(dir) or dir\r\n        -- reset cached source as it may change with basedir\r\n        lastsource = nil\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"SUSPEND\" then\r\n      -- do nothing; it already fulfilled its role\r\n    elseif command == \"DONE\" then\r\n      coroyield(\"done\")\r\n      return -- done with all the debugging\r\n    elseif command == \"STACK\" then\r\n      -- first check if we can execute the stack command\r\n      -- as it requires yielding back to debug_hook it cannot be executed\r\n      -- if we have not seen the hook yet as happens after start().\r\n      -- in this case we simply return an empty result\r\n      local vars, ev = {}\r\n      if seen_hook then\r\n        ev, vars = coroyield(\"stack\")\r\n      end\r\n      if ev and ev ~= events.STACK then\r\n        server:send(\"401 Error in Execution \" .. tostring(#vars) .. \"\\n\")\r\n        server:send(vars)\r\n      else\r\n        local ok, res = pcall(mobdebug.dump, vars, {nocode = true, sparse = false})\r\n        if ok then\r\n          server:send(\"200 OK \" .. tostring(res) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Execution \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      end\r\n    elseif command == \"OUTPUT\" then\r\n      local _, _, stream, mode = string.find(line, \"^[A-Z]+%s+(%w+)%s+([dcr])%s*$\")\r\n      if stream and mode and stream == \"stdout\" then\r\n        -- assign \"print\" in the global environment\r\n        local default = mode == 'd'\r\n        genv.print = default and iobase.print or corowrap(function()\r\n          -- wrapping into coroutine.wrap protects this function from\r\n          -- being stepped through in the debugger.\r\n          -- don't use vararg (...) as it adds a reference for its values,\r\n          -- which may affect how they are garbage collected\r\n          while true do\r\n            local tbl = {coroutine.yield()}\r\n            if mode == 'c' then iobase.print(unpack(tbl)) end\r\n            for n = 1, #tbl do\r\n              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end\r\n            local file = table.concat(tbl, \"\\t\")..\"\\n\"\r\n            server:send(\"204 Output \" .. stream .. \" \" .. tostring(#file) .. \"\\n\" .. file)\r\n          end\r\n        end)\r\n        if not default then genv.print() end -- \"fake\" print to start printing loop\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end\r\n    elseif command == \"EXIT\" then\r\n      server:send(\"200 OK\\n\")\r\n      coroyield(\"exit\")\r\n    else\r\n      server:send(\"400 Bad Request\\n\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 390,
    "text": "local _, _, _, file, line = string.find(line, \"^([A-Z]+)%s+(.-)%s+(%d+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 391,
    "text": "if file and line then\r\n        set_breakpoint(file, tonumber(line))\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 392,
    "text": "server:send(\"200 OK\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 393,
    "text": "server:send(\"400 Bad Request\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 394,
    "text": "if file and line then\r\n        remove_breakpoint(file, tonumber(line))\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 395,
    "text": "local _, _, chunk = string.find(line, \"^[A-Z]+%s+(.+)$\")",
    "type": "statement:localassign"
  }, {
    "id": 396,
    "text": "if chunk then\r\n        local func, res = mobdebug.loadstring(chunk)\r\n        local status\r\n        if func then\r\n          setfenv(func, eval_env)\r\n          status, res = stringify_results(pcall(func))\r\n        end\r\n        if status then\r\n          if mobdebug.onscratch then mobdebug.onscratch(res) end\r\n          server:send(\"200 OK \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        else\r\n          -- fix error if not set (for example, when loadstring is not present)\r\n          if not res then res = \"Unknown error\" end\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 397,
    "text": "local func, res = mobdebug.loadstring(chunk)",
    "type": "statement:localassign"
  }, {
    "id": 398,
    "text": "local status",
    "type": "statement:localassign"
  }, {
    "id": 399,
    "text": "if func then\r\n          setfenv(func, eval_env)\r\n          status, res = stringify_results(pcall(func))\r\n        end",
    "type": "statement:if"
  }, {
    "id": 400,
    "text": "setfenv(func, eval_env)",
    "type": "statement:functioncall"
  }, {
    "id": 401,
    "text": "status, res = stringify_results(pcall(func))",
    "type": "statement:assign"
  }, {
    "id": 402,
    "text": "if status then\r\n          if mobdebug.onscratch then mobdebug.onscratch(res) end\r\n          server:send(\"200 OK \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        else\r\n          -- fix error if not set (for example, when loadstring is not present)\r\n          if not res then res = \"Unknown error\" end\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 403,
    "text": "if mobdebug.onscratch then mobdebug.onscratch(res) end",
    "type": "statement:if"
  }, {
    "id": 404,
    "text": "mobdebug.onscratch(res)",
    "type": "statement:functioncall"
  }, {
    "id": 405,
    "text": "server:send(\"200 OK \" .. tostring(#res) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 406,
    "text": "server:send(res)",
    "type": "statement:functioncall"
  }, {
    "id": 407,
    "text": "if not res then res = \"Unknown error\" end",
    "type": "statement:if"
  }, {
    "id": 408,
    "text": "res = \"Unknown error\"",
    "type": "statement:assign"
  }, {
    "id": 409,
    "text": "server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 410,
    "text": "local _, _, size, name = string.find(line, \"^[A-Z]+%s+(%d+)%s+(%S.-)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 411,
    "text": "size = tonumber(size)",
    "type": "statement:assign"
  }, {
    "id": 412,
    "text": "if abort == nil then -- no LOAD/RELOAD allowed inside start()\r\n        if size > 0 then server:receive(size) end\r\n        if sfile and sline then\r\n          server:send(\"201 Started \" .. sfile .. \" \" .. tostring(sline) .. \"\\n\")\r\n        else\r\n          server:send(\"200 OK 0\\n\")\r\n        end\r\n      else\r\n        -- reset environment to allow required modules to load again\r\n        -- remove those packages that weren't loaded when debugger started\r\n        for k in pairs(package.loaded) do\r\n          if not loaded[k] then package.loaded[k] = nil end\r\n        end\r\n\r\n        if size == 0 and name == '-' then -- RELOAD the current script being debugged\r\n          server:send(\"200 OK 0\\n\")\r\n          coroyield(\"load\")\r\n        else\r\n          -- receiving 0 bytes blocks (at least in luasocket 2.0.2), so skip reading\r\n          local chunk = size == 0 and \"\" or server:receive(size)\r\n          if chunk then -- LOAD a new script for debugging\r\n            local func, res = mobdebug.loadstring(chunk, \"@\"..name)\r\n            if func then\r\n              server:send(\"200 OK 0\\n\")\r\n              debugee = func\r\n              coroyield(\"load\")\r\n            else\r\n              server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n              server:send(res)\r\n            end\r\n          else\r\n            server:send(\"400 Bad Request\\n\")\r\n          end\r\n        end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 413,
    "text": "if size > 0 then server:receive(size) end",
    "type": "statement:if"
  }, {
    "id": 414,
    "text": "server:receive(size)",
    "type": "statement:functioncall"
  }, {
    "id": 415,
    "text": "if sfile and sline then\r\n          server:send(\"201 Started \" .. sfile .. \" \" .. tostring(sline) .. \"\\n\")\r\n        else\r\n          server:send(\"200 OK 0\\n\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 416,
    "text": "server:send(\"201 Started \" .. sfile .. \" \" .. tostring(sline) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 417,
    "text": "server:send(\"200 OK 0\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 418,
    "text": "for k in pairs(package.loaded) do\r\n          if not loaded[k] then package.loaded[k] = nil end\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 419,
    "text": "if not loaded[k] then package.loaded[k] = nil end",
    "type": "statement:if"
  }, {
    "id": 420,
    "text": "package.loaded[k] = nil",
    "type": "statement:assign"
  }, {
    "id": 421,
    "text": "if size == 0 and name == '-' then -- RELOAD the current script being debugged\r\n          server:send(\"200 OK 0\\n\")\r\n          coroyield(\"load\")\r\n        else\r\n          -- receiving 0 bytes blocks (at least in luasocket 2.0.2), so skip reading\r\n          local chunk = size == 0 and \"\" or server:receive(size)\r\n          if chunk then -- LOAD a new script for debugging\r\n            local func, res = mobdebug.loadstring(chunk, \"@\"..name)\r\n            if func then\r\n              server:send(\"200 OK 0\\n\")\r\n              debugee = func\r\n              coroyield(\"load\")\r\n            else\r\n              server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n              server:send(res)\r\n            end\r\n          else\r\n            server:send(\"400 Bad Request\\n\")\r\n          end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 422,
    "text": "coroyield(\"load\")",
    "type": "statement:functioncall"
  }, {
    "id": 423,
    "text": "local chunk = size == 0 and \"\" or server:receive(size)",
    "type": "statement:localassign"
  }, {
    "id": 424,
    "text": "if chunk then -- LOAD a new script for debugging\r\n            local func, res = mobdebug.loadstring(chunk, \"@\"..name)\r\n            if func then\r\n              server:send(\"200 OK 0\\n\")\r\n              debugee = func\r\n              coroyield(\"load\")\r\n            else\r\n              server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n              server:send(res)\r\n            end\r\n          else\r\n            server:send(\"400 Bad Request\\n\")\r\n          end",
    "type": "statement:if"
  }, {
    "id": 425,
    "text": "local func, res = mobdebug.loadstring(chunk, \"@\"..name)",
    "type": "statement:localassign"
  }, {
    "id": 426,
    "text": "if func then\r\n              server:send(\"200 OK 0\\n\")\r\n              debugee = func\r\n              coroyield(\"load\")\r\n            else\r\n              server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n              server:send(res)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 427,
    "text": "debugee = func",
    "type": "statement:assign"
  }, {
    "id": 428,
    "text": "local _, _, exp = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 429,
    "text": "if exp then\r\n        local func, res = mobdebug.loadstring(\"return(\" .. exp .. \")\")\r\n        if func then\r\n          watchescnt = watchescnt + 1\r\n          local newidx = #watches + 1\r\n          watches[newidx] = func\r\n          server:send(\"200 OK \" .. tostring(newidx) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 430,
    "text": "local func, res = mobdebug.loadstring(\"return(\" .. exp .. \")\")",
    "type": "statement:localassign"
  }, {
    "id": 431,
    "text": "if func then\r\n          watchescnt = watchescnt + 1\r\n          local newidx = #watches + 1\r\n          watches[newidx] = func\r\n          server:send(\"200 OK \" .. tostring(newidx) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Expression \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 432,
    "text": "watchescnt = watchescnt + 1",
    "type": "statement:assign"
  }, {
    "id": 433,
    "text": "local newidx = #watches + 1",
    "type": "statement:localassign"
  }, {
    "id": 434,
    "text": "watches[newidx] = func",
    "type": "statement:assign"
  }, {
    "id": 435,
    "text": "server:send(\"200 OK \" .. tostring(newidx) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 436,
    "text": "local _, _, index = string.find(line, \"^[A-Z]+%s+(%d+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 437,
    "text": "index = tonumber(index)",
    "type": "statement:assign"
  }, {
    "id": 438,
    "text": "if index > 0 and index <= #watches then\r\n        watchescnt = watchescnt - (watches[index] ~= emptyWatch and 1 or 0)\r\n        watches[index] = emptyWatch\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 439,
    "text": "watchescnt = watchescnt - (watches[index] ~= emptyWatch and 1 or 0)",
    "type": "statement:assign"
  }, {
    "id": 440,
    "text": "watches[index] = emptyWatch",
    "type": "statement:assign"
  }, {
    "id": 441,
    "text": "local ev, vars, file, line, idx_watch = coroyield()",
    "type": "statement:localassign"
  }, {
    "id": 442,
    "text": "eval_env = vars",
    "type": "statement:assign"
  }, {
    "id": 443,
    "text": "if ev == events.BREAK then\r\n        server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n      elseif ev == events.WATCH then\r\n        server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")\r\n      elseif ev == events.RESTART then\r\n        -- nothing to do\r\n      else\r\n        server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")\r\n        server:send(file)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 444,
    "text": "server:send(\"202 Paused \" .. file .. \" \" .. tostring(line) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 445,
    "text": "server:send(\"203 Paused \" .. file .. \" \" .. tostring(line) .. \" \" .. tostring(idx_watch) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 446,
    "text": "server:send(\"401 Error in Execution \" .. tostring(#file) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 447,
    "text": "server:send(file)",
    "type": "statement:functioncall"
  }, {
    "id": 448,
    "text": "step_into = true",
    "type": "statement:assign"
  }, {
    "id": 449,
    "text": "step_over = true",
    "type": "statement:assign"
  }, {
    "id": 450,
    "text": "if command == \"OUT\" then step_level = stack_level - 1\r\n      else step_level = stack_level end",
    "type": "statement:if"
  }, {
    "id": 451,
    "text": "step_level = stack_level - 1",
    "type": "statement:assign"
  }, {
    "id": 452,
    "text": "step_level = stack_level",
    "type": "statement:assign"
  }, {
    "id": 453,
    "text": "local _, _, dir = string.find(line, \"^[A-Z]+%s+(.+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 454,
    "text": "if dir then\r\n        basedir = iscasepreserving and string.lower(dir) or dir\r\n        -- reset cached source as it may change with basedir\r\n        lastsource = nil\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 455,
    "text": "basedir = iscasepreserving and string.lower(dir) or dir",
    "type": "statement:assign"
  }, {
    "id": 456,
    "text": "lastsource = nil",
    "type": "statement:assign"
  }, {
    "id": 457,
    "text": "coroyield(\"done\")",
    "type": "statement:functioncall"
  }, {
    "id": 458,
    "text": "local vars, ev = {}",
    "type": "statement:localassign"
  }, {
    "id": 459,
    "text": "if seen_hook then\r\n        ev, vars = coroyield(\"stack\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 460,
    "text": "ev, vars = coroyield(\"stack\")",
    "type": "statement:assign"
  }, {
    "id": 461,
    "text": "if ev and ev ~= events.STACK then\r\n        server:send(\"401 Error in Execution \" .. tostring(#vars) .. \"\\n\")\r\n        server:send(vars)\r\n      else\r\n        local ok, res = pcall(mobdebug.dump, vars, {nocode = true, sparse = false})\r\n        if ok then\r\n          server:send(\"200 OK \" .. tostring(res) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Execution \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 462,
    "text": "server:send(\"401 Error in Execution \" .. tostring(#vars) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 463,
    "text": "server:send(vars)",
    "type": "statement:functioncall"
  }, {
    "id": 464,
    "text": "local ok, res = pcall(mobdebug.dump, vars, {nocode = true, sparse = false})",
    "type": "statement:localassign"
  }, {
    "id": 465,
    "text": "if ok then\r\n          server:send(\"200 OK \" .. tostring(res) .. \"\\n\")\r\n        else\r\n          server:send(\"401 Error in Execution \" .. tostring(#res) .. \"\\n\")\r\n          server:send(res)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 466,
    "text": "server:send(\"200 OK \" .. tostring(res) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 467,
    "text": "server:send(\"401 Error in Execution \" .. tostring(#res) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 468,
    "text": "local _, _, stream, mode = string.find(line, \"^[A-Z]+%s+(%w+)%s+([dcr])%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 469,
    "text": "if stream and mode and stream == \"stdout\" then\r\n        -- assign \"print\" in the global environment\r\n        local default = mode == 'd'\r\n        genv.print = default and iobase.print or corowrap(function()\r\n          -- wrapping into coroutine.wrap protects this function from\r\n          -- being stepped through in the debugger.\r\n          -- don't use vararg (...) as it adds a reference for its values,\r\n          -- which may affect how they are garbage collected\r\n          while true do\r\n            local tbl = {coroutine.yield()}\r\n            if mode == 'c' then iobase.print(unpack(tbl)) end\r\n            for n = 1, #tbl do\r\n              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end\r\n            local file = table.concat(tbl, \"\\t\")..\"\\n\"\r\n            server:send(\"204 Output \" .. stream .. \" \" .. tostring(#file) .. \"\\n\" .. file)\r\n          end\r\n        end)\r\n        if not default then genv.print() end -- \"fake\" print to start printing loop\r\n        server:send(\"200 OK\\n\")\r\n      else\r\n        server:send(\"400 Bad Request\\n\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 470,
    "text": "local default = mode == 'd'",
    "type": "statement:localassign"
  }, {
    "id": 471,
    "text": "genv.print = default and iobase.print or corowrap(function()\r\n          -- wrapping into coroutine.wrap protects this function from\r\n          -- being stepped through in the debugger.\r\n          -- don't use vararg (...) as it adds a reference for its values,\r\n          -- which may affect how they are garbage collected\r\n          while true do\r\n            local tbl = {coroutine.yield()}\r\n            if mode == 'c' then iobase.print(unpack(tbl)) end\r\n            for n = 1, #tbl do\r\n              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end\r\n            local file = table.concat(tbl, \"\\t\")..\"\\n\"\r\n            server:send(\"204 Output \" .. stream .. \" \" .. tostring(#file) .. \"\\n\" .. file)\r\n          end\r\n        end)",
    "type": "statement:assign"
  }, {
    "id": 472,
    "text": "while true do\r\n            local tbl = {coroutine.yield()}\r\n            if mode == 'c' then iobase.print(unpack(tbl)) end\r\n            for n = 1, #tbl do\r\n              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end\r\n            local file = table.concat(tbl, \"\\t\")..\"\\n\"\r\n            server:send(\"204 Output \" .. stream .. \" \" .. tostring(#file) .. \"\\n\" .. file)\r\n          end",
    "type": "statement:while"
  }, {
    "id": 473,
    "text": "local tbl = {coroutine.yield()}",
    "type": "statement:localassign"
  }, {
    "id": 474,
    "text": "if mode == 'c' then iobase.print(unpack(tbl)) end",
    "type": "statement:if"
  }, {
    "id": 475,
    "text": "iobase.print(unpack(tbl))",
    "type": "statement:functioncall"
  }, {
    "id": 476,
    "text": "for n = 1, #tbl do\r\n              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end",
    "type": "statement:numericfor"
  }, {
    "id": 477,
    "text": "tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false}))",
    "type": "statement:assign"
  }, {
    "id": 478,
    "text": "local file = table.concat(tbl, \"\\t\")..\"\\n\"",
    "type": "statement:localassign"
  }, {
    "id": 479,
    "text": "server:send(\"204 Output \" .. stream .. \" \" .. tostring(#file) .. \"\\n\" .. file)",
    "type": "statement:functioncall"
  }, {
    "id": 480,
    "text": "if not default then genv.print() end",
    "type": "statement:if"
  }, {
    "id": 481,
    "text": "genv.print()",
    "type": "statement:functioncall"
  }, {
    "id": 482,
    "text": "coroyield(\"exit\")",
    "type": "statement:functioncall"
  }, {
    "id": 483,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 484,
    "text": "local function emptyWatch () return false end",
    "type": "function"
  }, {
    "id": 485,
    "text": "function()\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)\r\n              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)\r\n              app:ExitMainLoop()\r\n            end",
    "type": "function"
  }, {
    "id": 486,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 487,
    "text": "local function output(stream, data)\r\n  if server then return server:send(\"204 Output \"..stream..\" \"..tostring(#data)..\"\\n\"..data) end\r\nend",
    "type": "function"
  }, {
    "id": 488,
    "text": "if server then return server:send(\"204 Output \"..stream..\" \"..tostring(#data)..\"\\n\"..data) end",
    "type": "statement:if"
  }, {
    "id": 489,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 490,
    "text": "local function connect(controller_host, controller_port)\r\n  local sock, err = socket.tcp()\r\n  if not sock then return nil, err end\r\n\r\n  if sock.settimeout then sock:settimeout(mobdebug.connecttimeout) end\r\n  local res, err = sock:connect(controller_host, tostring(controller_port))\r\n  if sock.settimeout then sock:settimeout() end\r\n\r\n  if not res then return nil, err end\r\n  return sock\r\nend",
    "type": "function"
  }, {
    "id": 491,
    "text": "local sock, err = socket.tcp()",
    "type": "statement:localassign"
  }, {
    "id": 492,
    "text": "if not sock then return nil, err end",
    "type": "statement:if"
  }, {
    "id": 493,
    "text": "if sock.settimeout then sock:settimeout(mobdebug.connecttimeout) end",
    "type": "statement:if"
  }, {
    "id": 494,
    "text": "sock:settimeout(mobdebug.connecttimeout)",
    "type": "statement:functioncall"
  }, {
    "id": 495,
    "text": "local res, err = sock:connect(controller_host, tostring(controller_port))",
    "type": "statement:localassign"
  }, {
    "id": 496,
    "text": "if sock.settimeout then sock:settimeout() end",
    "type": "statement:if"
  }, {
    "id": 497,
    "text": "sock:settimeout()",
    "type": "statement:functioncall"
  }, {
    "id": 498,
    "text": "if not res then return nil, err end",
    "type": "statement:if"
  }, {
    "id": 499,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 500,
    "text": "local function start(controller_host, controller_port)\r\n  -- only one debugging session can be run (as there is only one debug hook)\r\n  if isrunning() then return end\r\n\r\n  lasthost = controller_host or lasthost\r\n  lastport = controller_port or lastport\r\n\r\n  controller_host = lasthost or \"localhost\"\r\n  controller_port = lastport or mobdebug.port\r\n\r\n  local err\r\n  server, err = mobdebug.connect(controller_host, controller_port)\r\n  if server then\r\n    -- correct stack depth which already has some calls on it\r\n    -- so it doesn't go into negative when those calls return\r\n    -- as this breaks subsequence checks in stack_depth().\r\n    -- start from 16th frame, which is sufficiently large for this check.\r\n    stack_level = stack_depth(16)\r\n\r\n    -- provide our own traceback function to report the error remotely\r\n    do\r\n      local dtraceback = debug.traceback\r\n      debug.traceback = function (...)\r\n        if select('#', ...) >= 1 then\r\n          local err, lvl = ...\r\n          if err and type(err) ~= 'thread' then\r\n            local trace = dtraceback(err, (lvl or 2)+1)\r\n            if genv.print == iobase.print then -- no remote redirect\r\n              return trace\r\n            else\r\n              genv.print(trace) -- report the error remotely\r\n              return -- don't report locally to avoid double reporting\r\n            end\r\n          end\r\n        end\r\n        -- direct call to debug.traceback: return the original.\r\n        -- debug.traceback(nil, level) doesn't work in Lua 5.1\r\n        -- (http://lua-users.org/lists/lua-l/2011-06/msg00574.html), so\r\n        -- simply remove first frame from the stack trace\r\n        return (dtraceback(...):gsub(\"(stack traceback:\\n)[^\\n]*\\n\", \"%1\"))\r\n      end\r\n    end\r\n    coro_debugger = corocreate(debugger_loop)\r\n    debug.sethook(debug_hook, HOOKMASK)\r\n    seen_hook = nil -- reset in case the last start() call was refused\r\n    step_into = true -- start with step command\r\n    return true\r\n  else\r\n    print((\"Could not connect to %s:%s: %s\")\r\n      :format(controller_host, controller_port, err or \"unknown error\"))\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 501,
    "text": "if isrunning() then return end",
    "type": "statement:if"
  }, {
    "id": 502,
    "text": "lasthost = controller_host or lasthost",
    "type": "statement:assign"
  }, {
    "id": 503,
    "text": "lastport = controller_port or lastport",
    "type": "statement:assign"
  }, {
    "id": 504,
    "text": "controller_host = lasthost or \"localhost\"",
    "type": "statement:assign"
  }, {
    "id": 505,
    "text": "controller_port = lastport or mobdebug.port",
    "type": "statement:assign"
  }, {
    "id": 506,
    "text": "local err",
    "type": "statement:localassign"
  }, {
    "id": 507,
    "text": "server, err = mobdebug.connect(controller_host, controller_port)",
    "type": "statement:assign"
  }, {
    "id": 508,
    "text": "if server then\r\n    -- correct stack depth which already has some calls on it\r\n    -- so it doesn't go into negative when those calls return\r\n    -- as this breaks subsequence checks in stack_depth().\r\n    -- start from 16th frame, which is sufficiently large for this check.\r\n    stack_level = stack_depth(16)\r\n\r\n    -- provide our own traceback function to report the error remotely\r\n    do\r\n      local dtraceback = debug.traceback\r\n      debug.traceback = function (...)\r\n        if select('#', ...) >= 1 then\r\n          local err, lvl = ...\r\n          if err and type(err) ~= 'thread' then\r\n            local trace = dtraceback(err, (lvl or 2)+1)\r\n            if genv.print == iobase.print then -- no remote redirect\r\n              return trace\r\n            else\r\n              genv.print(trace) -- report the error remotely\r\n              return -- don't report locally to avoid double reporting\r\n            end\r\n          end\r\n        end\r\n        -- direct call to debug.traceback: return the original.\r\n        -- debug.traceback(nil, level) doesn't work in Lua 5.1\r\n        -- (http://lua-users.org/lists/lua-l/2011-06/msg00574.html), so\r\n        -- simply remove first frame from the stack trace\r\n        return (dtraceback(...):gsub(\"(stack traceback:\\n)[^\\n]*\\n\", \"%1\"))\r\n      end\r\n    end\r\n    coro_debugger = corocreate(debugger_loop)\r\n    debug.sethook(debug_hook, HOOKMASK)\r\n    seen_hook = nil -- reset in case the last start() call was refused\r\n    step_into = true -- start with step command\r\n    return true\r\n  else\r\n    print((\"Could not connect to %s:%s: %s\")\r\n      :format(controller_host, controller_port, err or \"unknown error\"))\r\n  end",
    "type": "statement:if"
  }, {
    "id": 509,
    "text": "stack_level = stack_depth(16)",
    "type": "statement:assign"
  }, {
    "id": 510,
    "text": "do\r\n      local dtraceback = debug.traceback\r\n      debug.traceback = function (...)\r\n        if select('#', ...) >= 1 then\r\n          local err, lvl = ...\r\n          if err and type(err) ~= 'thread' then\r\n            local trace = dtraceback(err, (lvl or 2)+1)\r\n            if genv.print == iobase.print then -- no remote redirect\r\n              return trace\r\n            else\r\n              genv.print(trace) -- report the error remotely\r\n              return -- don't report locally to avoid double reporting\r\n            end\r\n          end\r\n        end\r\n        -- direct call to debug.traceback: return the original.\r\n        -- debug.traceback(nil, level) doesn't work in Lua 5.1\r\n        -- (http://lua-users.org/lists/lua-l/2011-06/msg00574.html), so\r\n        -- simply remove first frame from the stack trace\r\n        return (dtraceback(...):gsub(\"(stack traceback:\\n)[^\\n]*\\n\", \"%1\"))\r\n      end\r\n    end",
    "type": "statement:do"
  }, {
    "id": 511,
    "text": "local dtraceback = debug.traceback",
    "type": "statement:localassign"
  }, {
    "id": 512,
    "text": "debug.traceback = function (...)\r\n        if select('#', ...) >= 1 then\r\n          local err, lvl = ...\r\n          if err and type(err) ~= 'thread' then\r\n            local trace = dtraceback(err, (lvl or 2)+1)\r\n            if genv.print == iobase.print then -- no remote redirect\r\n              return trace\r\n            else\r\n              genv.print(trace) -- report the error remotely\r\n              return -- don't report locally to avoid double reporting\r\n            end\r\n          end\r\n        end\r\n        -- direct call to debug.traceback: return the original.\r\n        -- debug.traceback(nil, level) doesn't work in Lua 5.1\r\n        -- (http://lua-users.org/lists/lua-l/2011-06/msg00574.html), so\r\n        -- simply remove first frame from the stack trace\r\n        return (dtraceback(...):gsub(\"(stack traceback:\\n)[^\\n]*\\n\", \"%1\"))\r\n      end",
    "type": "statement:assign"
  }, {
    "id": 513,
    "text": "if select('#', ...) >= 1 then\r\n          local err, lvl = ...\r\n          if err and type(err) ~= 'thread' then\r\n            local trace = dtraceback(err, (lvl or 2)+1)\r\n            if genv.print == iobase.print then -- no remote redirect\r\n              return trace\r\n            else\r\n              genv.print(trace) -- report the error remotely\r\n              return -- don't report locally to avoid double reporting\r\n            end\r\n          end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 514,
    "text": "local err, lvl = ...",
    "type": "statement:localassign"
  }, {
    "id": 515,
    "text": "if err and type(err) ~= 'thread' then\r\n            local trace = dtraceback(err, (lvl or 2)+1)\r\n            if genv.print == iobase.print then -- no remote redirect\r\n              return trace\r\n            else\r\n              genv.print(trace) -- report the error remotely\r\n              return -- don't report locally to avoid double reporting\r\n            end\r\n          end",
    "type": "statement:if"
  }, {
    "id": 516,
    "text": "local trace = dtraceback(err, (lvl or 2)+1)",
    "type": "statement:localassign"
  }, {
    "id": 517,
    "text": "if genv.print == iobase.print then -- no remote redirect\r\n              return trace\r\n            else\r\n              genv.print(trace) -- report the error remotely\r\n              return -- don't report locally to avoid double reporting\r\n            end",
    "type": "statement:if"
  }, {
    "id": 518,
    "text": "genv.print(trace)",
    "type": "statement:functioncall"
  }, {
    "id": 519,
    "text": "coro_debugger = corocreate(debugger_loop)",
    "type": "statement:assign"
  }, {
    "id": 520,
    "text": "debug.sethook(debug_hook, HOOKMASK)",
    "type": "statement:functioncall"
  }, {
    "id": 521,
    "text": "print((\"Could not connect to %s:%s: %s\")\r\n      :format(controller_host, controller_port, err or \"unknown error\"))",
    "type": "statement:functioncall"
  }, {
    "id": 522,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 523,
    "text": "function (...)\r\n        if select('#', ...) >= 1 then\r\n          local err, lvl = ...\r\n          if err and type(err) ~= 'thread' then\r\n            local trace = dtraceback(err, (lvl or 2)+1)\r\n            if genv.print == iobase.print then -- no remote redirect\r\n              return trace\r\n            else\r\n              genv.print(trace) -- report the error remotely\r\n              return -- don't report locally to avoid double reporting\r\n            end\r\n          end\r\n        end\r\n        -- direct call to debug.traceback: return the original.\r\n        -- debug.traceback(nil, level) doesn't work in Lua 5.1\r\n        -- (http://lua-users.org/lists/lua-l/2011-06/msg00574.html), so\r\n        -- simply remove first frame from the stack trace\r\n        return (dtraceback(...):gsub(\"(stack traceback:\\n)[^\\n]*\\n\", \"%1\"))\r\n      end",
    "type": "function"
  }, {
    "id": 524,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 525,
    "text": "local function controller(controller_host, controller_port, scratchpad)\r\n  -- only one debugging session can be run (as there is only one debug hook)\r\n  if isrunning() then return end\r\n\r\n  lasthost = controller_host or lasthost\r\n  lastport = controller_port or lastport\r\n\r\n  controller_host = lasthost or \"localhost\"\r\n  controller_port = lastport or mobdebug.port\r\n\r\n  local exitonerror = not scratchpad\r\n  local err\r\n  server, err = mobdebug.connect(controller_host, controller_port)\r\n  if server then\r\n    local function report(trace, err)\r\n      local msg = err .. \"\\n\" .. trace\r\n      server:send(\"401 Error in Execution \" .. tostring(#msg) .. \"\\n\")\r\n      server:send(msg)\r\n      return err\r\n    end\r\n\r\n    seen_hook = true -- allow to accept all commands\r\n    coro_debugger = corocreate(debugger_loop)\r\n\r\n    while true do\r\n      step_into = true -- start with step command\r\n      abort = false -- reset abort flag from the previous loop\r\n      if scratchpad then checkcount = mobdebug.checkcount end -- force suspend right away\r\n\r\n      coro_debugee = corocreate(debugee)\r\n      debug.sethook(coro_debugee, debug_hook, HOOKMASK)\r\n      local status, err = cororesume(coro_debugee, unpack(arg or {}))\r\n\r\n      -- was there an error or is the script done?\r\n      -- 'abort' state is allowed here; ignore it\r\n      if abort then\r\n        if tostring(abort) == 'exit' then break end\r\n      else\r\n        if status then -- normal execution is done\r\n          break\r\n        elseif err and not string.find(tostring(err), deferror) then\r\n          -- report the error back\r\n          -- err is not necessarily a string, so convert to string to report\r\n          report(debug.traceback(coro_debugee), tostring(err))\r\n          if exitonerror then break end\r\n          -- check if the debugging is done (coro_debugger is nil)\r\n          if not coro_debugger then break end\r\n          -- resume once more to clear the response the debugger wants to send\r\n          -- need to use capture_vars(2) as three would be the level of\r\n          -- the caller for controller(), but because of the tail call,\r\n          -- the caller may not exist;\r\n          -- This is not entirely safe as the user may see the local\r\n          -- variable from console, but they will be reset anyway.\r\n          -- This functionality is used when scratchpad is paused to\r\n          -- gain access to remote console to modify global variables.\r\n          local status, err = cororesume(coro_debugger, events.RESTART, capture_vars(2))\r\n          if not status or status and err == \"exit\" then break end\r\n        end\r\n      end\r\n    end\r\n  else\r\n    print((\"Could not connect to %s:%s: %s\")\r\n      :format(controller_host, controller_port, err or \"unknown error\"))\r\n    return false\r\n  end\r\n  return true\r\nend",
    "type": "function"
  }, {
    "id": 526,
    "text": "local exitonerror = not scratchpad",
    "type": "statement:localassign"
  }, {
    "id": 527,
    "text": "if server then\r\n    local function report(trace, err)\r\n      local msg = err .. \"\\n\" .. trace\r\n      server:send(\"401 Error in Execution \" .. tostring(#msg) .. \"\\n\")\r\n      server:send(msg)\r\n      return err\r\n    end\r\n\r\n    seen_hook = true -- allow to accept all commands\r\n    coro_debugger = corocreate(debugger_loop)\r\n\r\n    while true do\r\n      step_into = true -- start with step command\r\n      abort = false -- reset abort flag from the previous loop\r\n      if scratchpad then checkcount = mobdebug.checkcount end -- force suspend right away\r\n\r\n      coro_debugee = corocreate(debugee)\r\n      debug.sethook(coro_debugee, debug_hook, HOOKMASK)\r\n      local status, err = cororesume(coro_debugee, unpack(arg or {}))\r\n\r\n      -- was there an error or is the script done?\r\n      -- 'abort' state is allowed here; ignore it\r\n      if abort then\r\n        if tostring(abort) == 'exit' then break end\r\n      else\r\n        if status then -- normal execution is done\r\n          break\r\n        elseif err and not string.find(tostring(err), deferror) then\r\n          -- report the error back\r\n          -- err is not necessarily a string, so convert to string to report\r\n          report(debug.traceback(coro_debugee), tostring(err))\r\n          if exitonerror then break end\r\n          -- check if the debugging is done (coro_debugger is nil)\r\n          if not coro_debugger then break end\r\n          -- resume once more to clear the response the debugger wants to send\r\n          -- need to use capture_vars(2) as three would be the level of\r\n          -- the caller for controller(), but because of the tail call,\r\n          -- the caller may not exist;\r\n          -- This is not entirely safe as the user may see the local\r\n          -- variable from console, but they will be reset anyway.\r\n          -- This functionality is used when scratchpad is paused to\r\n          -- gain access to remote console to modify global variables.\r\n          local status, err = cororesume(coro_debugger, events.RESTART, capture_vars(2))\r\n          if not status or status and err == \"exit\" then break end\r\n        end\r\n      end\r\n    end\r\n  else\r\n    print((\"Could not connect to %s:%s: %s\")\r\n      :format(controller_host, controller_port, err or \"unknown error\"))\r\n    return false\r\n  end",
    "type": "statement:if"
  }, {
    "id": 528,
    "text": "local function report(trace, err)\r\n      local msg = err .. \"\\n\" .. trace\r\n      server:send(\"401 Error in Execution \" .. tostring(#msg) .. \"\\n\")\r\n      server:send(msg)\r\n      return err\r\n    end",
    "type": "statement:localfunction"
  }, {
    "id": 529,
    "text": "local msg = err .. \"\\n\" .. trace",
    "type": "statement:localassign"
  }, {
    "id": 530,
    "text": "server:send(\"401 Error in Execution \" .. tostring(#msg) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 531,
    "text": "server:send(msg)",
    "type": "statement:functioncall"
  }, {
    "id": 532,
    "text": "while true do\r\n      step_into = true -- start with step command\r\n      abort = false -- reset abort flag from the previous loop\r\n      if scratchpad then checkcount = mobdebug.checkcount end -- force suspend right away\r\n\r\n      coro_debugee = corocreate(debugee)\r\n      debug.sethook(coro_debugee, debug_hook, HOOKMASK)\r\n      local status, err = cororesume(coro_debugee, unpack(arg or {}))\r\n\r\n      -- was there an error or is the script done?\r\n      -- 'abort' state is allowed here; ignore it\r\n      if abort then\r\n        if tostring(abort) == 'exit' then break end\r\n      else\r\n        if status then -- normal execution is done\r\n          break\r\n        elseif err and not string.find(tostring(err), deferror) then\r\n          -- report the error back\r\n          -- err is not necessarily a string, so convert to string to report\r\n          report(debug.traceback(coro_debugee), tostring(err))\r\n          if exitonerror then break end\r\n          -- check if the debugging is done (coro_debugger is nil)\r\n          if not coro_debugger then break end\r\n          -- resume once more to clear the response the debugger wants to send\r\n          -- need to use capture_vars(2) as three would be the level of\r\n          -- the caller for controller(), but because of the tail call,\r\n          -- the caller may not exist;\r\n          -- This is not entirely safe as the user may see the local\r\n          -- variable from console, but they will be reset anyway.\r\n          -- This functionality is used when scratchpad is paused to\r\n          -- gain access to remote console to modify global variables.\r\n          local status, err = cororesume(coro_debugger, events.RESTART, capture_vars(2))\r\n          if not status or status and err == \"exit\" then break end\r\n        end\r\n      end\r\n    end",
    "type": "statement:while"
  }, {
    "id": 533,
    "text": "abort = false",
    "type": "statement:assign"
  }, {
    "id": 534,
    "text": "if scratchpad then checkcount = mobdebug.checkcount end",
    "type": "statement:if"
  }, {
    "id": 535,
    "text": "coro_debugee = corocreate(debugee)",
    "type": "statement:assign"
  }, {
    "id": 536,
    "text": "debug.sethook(coro_debugee, debug_hook, HOOKMASK)",
    "type": "statement:functioncall"
  }, {
    "id": 537,
    "text": "local status, err = cororesume(coro_debugee, unpack(arg or {}))",
    "type": "statement:localassign"
  }, {
    "id": 538,
    "text": "if abort then\r\n        if tostring(abort) == 'exit' then break end\r\n      else\r\n        if status then -- normal execution is done\r\n          break\r\n        elseif err and not string.find(tostring(err), deferror) then\r\n          -- report the error back\r\n          -- err is not necessarily a string, so convert to string to report\r\n          report(debug.traceback(coro_debugee), tostring(err))\r\n          if exitonerror then break end\r\n          -- check if the debugging is done (coro_debugger is nil)\r\n          if not coro_debugger then break end\r\n          -- resume once more to clear the response the debugger wants to send\r\n          -- need to use capture_vars(2) as three would be the level of\r\n          -- the caller for controller(), but because of the tail call,\r\n          -- the caller may not exist;\r\n          -- This is not entirely safe as the user may see the local\r\n          -- variable from console, but they will be reset anyway.\r\n          -- This functionality is used when scratchpad is paused to\r\n          -- gain access to remote console to modify global variables.\r\n          local status, err = cororesume(coro_debugger, events.RESTART, capture_vars(2))\r\n          if not status or status and err == \"exit\" then break end\r\n        end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 539,
    "text": "if tostring(abort) == 'exit' then break end",
    "type": "statement:if"
  }, {
    "id": 540,
    "text": "if status then -- normal execution is done\r\n          break\r\n        elseif err and not string.find(tostring(err), deferror) then\r\n          -- report the error back\r\n          -- err is not necessarily a string, so convert to string to report\r\n          report(debug.traceback(coro_debugee), tostring(err))\r\n          if exitonerror then break end\r\n          -- check if the debugging is done (coro_debugger is nil)\r\n          if not coro_debugger then break end\r\n          -- resume once more to clear the response the debugger wants to send\r\n          -- need to use capture_vars(2) as three would be the level of\r\n          -- the caller for controller(), but because of the tail call,\r\n          -- the caller may not exist;\r\n          -- This is not entirely safe as the user may see the local\r\n          -- variable from console, but they will be reset anyway.\r\n          -- This functionality is used when scratchpad is paused to\r\n          -- gain access to remote console to modify global variables.\r\n          local status, err = cororesume(coro_debugger, events.RESTART, capture_vars(2))\r\n          if not status or status and err == \"exit\" then break end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 541,
    "text": "report(debug.traceback(coro_debugee), tostring(err))",
    "type": "statement:functioncall"
  }, {
    "id": 542,
    "text": "if exitonerror then break end",
    "type": "statement:if"
  }, {
    "id": 543,
    "text": "if not coro_debugger then break end",
    "type": "statement:if"
  }, {
    "id": 544,
    "text": "local status, err = cororesume(coro_debugger, events.RESTART, capture_vars(2))",
    "type": "statement:localassign"
  }, {
    "id": 545,
    "text": "if not status or status and err == \"exit\" then break end",
    "type": "statement:if"
  }, {
    "id": 546,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 547,
    "text": "local function report(trace, err)\r\n      local msg = err .. \"\\n\" .. trace\r\n      server:send(\"401 Error in Execution \" .. tostring(#msg) .. \"\\n\")\r\n      server:send(msg)\r\n      return err\r\n    end",
    "type": "function"
  }, {
    "id": 548,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 549,
    "text": "local function scratchpad(controller_host, controller_port)\r\n  return controller(controller_host, controller_port, true)\r\nend",
    "type": "function"
  }, {
    "id": 550,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 551,
    "text": "local function loop(controller_host, controller_port)\r\n  return controller(controller_host, controller_port, false)\r\nend",
    "type": "function"
  }, {
    "id": 552,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 553,
    "text": "local function on()\r\n  if not (isrunning() and server) then return end\r\n\r\n  -- main is set to true under Lua5.2 for the \"main\" chunk.\r\n  -- Lua5.1 returns co as `nil` in that case.\r\n  local co, main = coroutine.running()\r\n  if main then co = nil end\r\n  if co then\r\n    coroutines[co] = true\r\n    debug.sethook(co, debug_hook, HOOKMASK)\r\n  else\r\n    if jit then coroutines.main = true end\r\n    debug.sethook(debug_hook, HOOKMASK)\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 554,
    "text": "local co, main = coroutine.running()",
    "type": "statement:localassign"
  }, {
    "id": 555,
    "text": "if main then co = nil end",
    "type": "statement:if"
  }, {
    "id": 556,
    "text": "co = nil",
    "type": "statement:assign"
  }, {
    "id": 557,
    "text": "if co then\r\n    coroutines[co] = true\r\n    debug.sethook(co, debug_hook, HOOKMASK)\r\n  else\r\n    if jit then coroutines.main = true end\r\n    debug.sethook(debug_hook, HOOKMASK)\r\n  end",
    "type": "statement:if"
  }, {
    "id": 558,
    "text": "coroutines[co] = true",
    "type": "statement:assign"
  }, {
    "id": 559,
    "text": "debug.sethook(co, debug_hook, HOOKMASK)",
    "type": "statement:functioncall"
  }, {
    "id": 560,
    "text": "if jit then coroutines.main = true end",
    "type": "statement:if"
  }, {
    "id": 561,
    "text": "coroutines.main = true",
    "type": "statement:assign"
  }, {
    "id": 562,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 563,
    "text": "local function off()\r\n  if not (isrunning() and server) then return end\r\n\r\n  -- main is set to true under Lua5.2 for the \"main\" chunk.\r\n  -- Lua5.1 returns co as `nil` in that case.\r\n  local co, main = coroutine.running()\r\n  if main then co = nil end\r\n\r\n  -- don't remove coroutine hook under LuaJIT as there is only one (global) hook\r\n  if co then\r\n    coroutines[co] = false\r\n    if not jit then debug.sethook(co) end\r\n  else\r\n    if jit then coroutines.main = false end\r\n    if not jit then debug.sethook() end\r\n  end\r\n\r\n  -- check if there is any thread that is still being debugged under LuaJIT;\r\n  -- if not, turn the debugging off\r\n  if jit then\r\n    local remove = true\r\n    for _, debugged in pairs(coroutines) do\r\n      if debugged then remove = false; break end\r\n    end\r\n    if remove then debug.sethook() end\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 564,
    "text": "if co then\r\n    coroutines[co] = false\r\n    if not jit then debug.sethook(co) end\r\n  else\r\n    if jit then coroutines.main = false end\r\n    if not jit then debug.sethook() end\r\n  end",
    "type": "statement:if"
  }, {
    "id": 565,
    "text": "coroutines[co] = false",
    "type": "statement:assign"
  }, {
    "id": 566,
    "text": "if not jit then debug.sethook(co) end",
    "type": "statement:if"
  }, {
    "id": 567,
    "text": "if jit then coroutines.main = false end",
    "type": "statement:if"
  }, {
    "id": 568,
    "text": "coroutines.main = false",
    "type": "statement:assign"
  }, {
    "id": 569,
    "text": "if not jit then debug.sethook() end",
    "type": "statement:if"
  }, {
    "id": 570,
    "text": "if jit then\r\n    local remove = true\r\n    for _, debugged in pairs(coroutines) do\r\n      if debugged then remove = false; break end\r\n    end\r\n    if remove then debug.sethook() end\r\n  end",
    "type": "statement:if"
  }, {
    "id": 571,
    "text": "local remove = true",
    "type": "statement:localassign"
  }, {
    "id": 572,
    "text": "for _, debugged in pairs(coroutines) do\r\n      if debugged then remove = false; break end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 573,
    "text": "if debugged then remove = false; break end",
    "type": "statement:if"
  }, {
    "id": 574,
    "text": "remove = false",
    "type": "statement:assign"
  }, {
    "id": 575,
    "text": "if remove then debug.sethook() end",
    "type": "statement:if"
  }, {
    "id": 576,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 577,
    "text": "local function handle(params, client, options)\r\n  -- when `options.verbose` is not provided, use normal `print`; verbose output can be\r\n  -- disabled (`options.verbose == false`) or redirected (`options.verbose == function()...end`)\r\n  local verbose = not options or options.verbose ~= nil and options.verbose\r\n  local print = verbose and (type(verbose) == \"function\" and verbose or print) or function() end\r\n  local file, line, watch_idx\r\n  local _, _, command = string.find(params, \"^([a-z]+)\")\r\n  if command == \"run\" or command == \"step\" or command == \"out\"\r\n  or command == \"over\" or command == \"exit\" then\r\n    client:send(string.upper(command) .. \"\\n\")\r\n    client:receive() -- this should consume the first '200 OK' response\r\n    while true do\r\n      local done = true\r\n      local breakpoint = client:receive()\r\n      if not breakpoint then\r\n        print(\"Program finished\")\r\n        return nil, nil, false\r\n      end\r\n      local _, _, status = string.find(breakpoint, \"^(%d+)\")\r\n      if status == \"200\" then\r\n        -- don't need to do anything\r\n      elseif status == \"202\" then\r\n        _, _, file, line = string.find(breakpoint, \"^202 Paused%s+(.-)%s+(%d+)%s*$\")\r\n        if file and line then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line)\r\n        end\r\n      elseif status == \"203\" then\r\n        _, _, file, line, watch_idx = string.find(breakpoint, \"^203 Paused%s+(.-)%s+(%d+)%s+(%d+)%s*$\")\r\n        if file and line and watch_idx then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line .. \" (watch expression \" .. watch_idx .. \": [\" .. watches[watch_idx] .. \"])\")\r\n        end\r\n      elseif status == \"204\" then\r\n        local _, _, stream, size = string.find(breakpoint, \"^204 Output (%w+) (%d+)$\")\r\n        if stream and size then\r\n          local size = tonumber(size)\r\n          local msg = size > 0 and client:receive(size) or \"\"\r\n          print(msg)\r\n          if outputs[stream] then outputs[stream](msg) end\r\n          -- this was just the output, so go back reading the response\r\n          done = false\r\n        end\r\n      elseif status == \"401\" then\r\n        local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)$\")\r\n        if size then\r\n          local msg = client:receive(tonumber(size))\r\n          print(\"Error in remote application: \" .. msg)\r\n          return nil, nil, msg\r\n        end\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: unexpected response '\" .. breakpoint .. \"'\"\r\n      end\r\n      if done then break end\r\n    end\r\n  elseif command == \"done\" then\r\n    client:send(string.upper(command) .. \"\\n\")\r\n    -- no response is expected\r\n  elseif command == \"setb\" or command == \"asetb\" then\r\n    _, _, _, file, line = string.find(params, \"^([a-z]+)%s+(.-)%s+(%d+)%s*$\")\r\n    if file and line then\r\n      -- if this is a file name, and not a file source\r\n      if not file:find('^\".*\"$') then\r\n        file = string.gsub(file, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n      end\r\n      client:send(\"SETB \" .. file .. \" \" .. line .. \"\\n\")\r\n      if command == \"asetb\" or client:receive() == \"200 OK\" then\r\n        set_breakpoint(file, line)\r\n      else\r\n        print(\"Error: breakpoint not inserted\")\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"setw\" then\r\n    local _, _, exp = string.find(params, \"^[a-z]+%s+(.+)$\")\r\n    if exp then\r\n      client:send(\"SETW \" .. exp .. \"\\n\")\r\n      local answer = client:receive()\r\n      local _, _, watch_idx = string.find(answer, \"^200 OK (%d+)%s*$\")\r\n      if watch_idx then\r\n        watches[watch_idx] = exp\r\n        print(\"Inserted watch exp no. \" .. watch_idx)\r\n      else\r\n        local _, _, size = string.find(answer, \"^401 Error in Expression (%d+)$\")\r\n        if size then\r\n          local err = client:receive(tonumber(size)):gsub(\".-:%d+:%s*\",\"\")\r\n          print(\"Error: watch expression not set: \" .. err)\r\n        else\r\n          print(\"Error: watch expression not set\")\r\n        end\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"delb\" or command == \"adelb\" then\r\n    _, _, _, file, line = string.find(params, \"^([a-z]+)%s+(.-)%s+(%d+)%s*$\")\r\n    if file and line then\r\n      -- if this is a file name, and not a file source\r\n      if not file:find('^\".*\"$') then\r\n        file = string.gsub(file, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n      end\r\n      client:send(\"DELB \" .. file .. \" \" .. line .. \"\\n\")\r\n      if command == \"adelb\" or client:receive() == \"200 OK\" then\r\n        remove_breakpoint(file, line)\r\n      else\r\n        print(\"Error: breakpoint not removed\")\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"delallb\" then\r\n    local file, line = \"*\", 0\r\n    client:send(\"DELB \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n    if client:receive() == \"200 OK\" then\r\n      remove_breakpoint(file, line)\r\n    else\r\n      print(\"Error: all breakpoints not removed\")\r\n    end\r\n  elseif command == \"delw\" then\r\n    local _, _, index = string.find(params, \"^[a-z]+%s+(%d+)%s*$\")\r\n    if index then\r\n      client:send(\"DELW \" .. index .. \"\\n\")\r\n      if client:receive() == \"200 OK\" then\r\n        watches[index] = nil\r\n      else\r\n        print(\"Error: watch expression not removed\")\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"delallw\" then\r\n    for index, exp in pairs(watches) do\r\n      client:send(\"DELW \" .. index .. \"\\n\")\r\n      if client:receive() == \"200 OK\" then\r\n        watches[index] = nil\r\n      else\r\n        print(\"Error: watch expression at index \" .. index .. \" [\" .. exp .. \"] not removed\")\r\n      end\r\n    end\r\n  elseif command == \"eval\" or command == \"exec\"\r\n      or command == \"load\" or command == \"loadstring\"\r\n      or command == \"reload\" then\r\n    local _, _, exp = string.find(params, \"^[a-z]+%s+(.+)$\")\r\n    if exp or (command == \"reload\") then\r\n      if command == \"eval\" or command == \"exec\" then\r\n        exp = (exp:gsub(\"%-%-%[(=*)%[.-%]%1%]\", \"\") -- remove comments\r\n                  :gsub(\"%-%-.-\\n\", \" \") -- remove line comments\r\n                  :gsub(\"\\n\", \" \")) -- convert new lines\r\n        if command == \"eval\" then exp = \"return \" .. exp end\r\n        client:send(\"EXEC \" .. exp .. \"\\n\")\r\n      elseif command == \"reload\" then\r\n        client:send(\"LOAD 0 -\\n\")\r\n      elseif command == \"loadstring\" then\r\n        local _, _, _, file, lines = string.find(exp, \"^([\\\"'])(.-)%1%s+(.+)\")\r\n        if not file then\r\n           _, _, file, lines = string.find(exp, \"^(%S+)%s+(.+)\")\r\n        end\r\n        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\r\n        client:send(lines)\r\n      else\r\n        local file = io.open(exp, \"r\")\r\n        if not file and pcall(require, \"winapi\") then\r\n          -- if file is not open and winapi is there, try with a short path;\r\n          -- this may be needed for unicode paths on windows\r\n          winapi.set_encoding(winapi.CP_UTF8)\r\n          local shortp = winapi.short_path(exp)\r\n          file = shortp and io.open(shortp, \"r\")\r\n        end\r\n        if not file then return nil, nil, \"Cannot open file \" .. exp end\r\n        -- read the file and remove the shebang line as it causes a compilation error\r\n        local lines = file:read(\"*all\"):gsub(\"^#!.-\\n\", \"\\n\")\r\n        file:close()\r\n\r\n        local file = string.gsub(exp, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\r\n        if #lines > 0 then client:send(lines) end\r\n      end\r\n      while true do\r\n        local params, err = client:receive()\r\n        if not params then\r\n          return nil, nil, \"Debugger connection \" .. (err or \"error\")\r\n        end\r\n        local done = true\r\n        local _, _, status, len = string.find(params, \"^(%d+).-%s+(%d+)%s*$\")\r\n        if status == \"200\" then\r\n          len = tonumber(len)\r\n          if len > 0 then\r\n            local status, res\r\n            local str = client:receive(len)\r\n            -- handle serialized table with results\r\n            local func, err = loadstring(str)\r\n            if func then\r\n              status, res = pcall(func)\r\n              if not status then err = res\r\n              elseif type(res) ~= \"table\" then\r\n                err = \"received \"..type(res)..\" instead of expected 'table'\"\r\n              end\r\n            end\r\n            if err then\r\n              print(\"Error in processing results: \" .. err)\r\n              return nil, nil, \"Error in processing results: \" .. err\r\n            end\r\n            print(unpack(res))\r\n            return res[1], res\r\n          end\r\n        elseif status == \"201\" then\r\n          _, _, file, line = string.find(params, \"^201 Started%s+(.-)%s+(%d+)%s*$\")\r\n        elseif status == \"202\" or params == \"200 OK\" then\r\n          -- do nothing; this only happens when RE/LOAD command gets the response\r\n          -- that was for the original command that was aborted\r\n        elseif status == \"204\" then\r\n          local _, _, stream, size = string.find(params, \"^204 Output (%w+) (%d+)$\")\r\n          if stream and size then\r\n            local size = tonumber(size)\r\n            local msg = size > 0 and client:receive(size) or \"\"\r\n            print(msg)\r\n            if outputs[stream] then outputs[stream](msg) end\r\n            -- this was just the output, so go back reading the response\r\n            done = false\r\n          end\r\n        elseif status == \"401\" then\r\n          len = tonumber(len)\r\n          local res = client:receive(len)\r\n          print(\"Error in expression: \" .. res)\r\n          return nil, nil, res\r\n        else\r\n          print(\"Unknown error\")\r\n          return nil, nil, \"Debugger error: unexpected response after EXEC/LOAD '\" .. params .. \"'\"\r\n        end\r\n        if done then break end\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"listb\" then\r\n    for l, v in pairs(breakpoints) do\r\n      for f in pairs(v) do\r\n        print(f .. \": \" .. l)\r\n      end\r\n    end\r\n  elseif command == \"listw\" then\r\n    for i, v in pairs(watches) do\r\n      print(\"Watch exp. \" .. i .. \": \" .. v)\r\n    end\r\n  elseif command == \"suspend\" then\r\n    client:send(\"SUSPEND\\n\")\r\n  elseif command == \"stack\" then\r\n    client:send(\"STACK\\n\")\r\n    local resp = client:receive()\r\n    local _, _, status, res = string.find(resp, \"^(%d+)%s+%w+%s+(.+)%s*$\")\r\n    if status == \"200\" then\r\n      local func, err = loadstring(res)\r\n      if func == nil then\r\n        print(\"Error in stack information: \" .. err)\r\n        return nil, nil, err\r\n      end\r\n      local ok, stack = pcall(func)\r\n      if not ok then\r\n        print(\"Error in stack information: \" .. stack)\r\n        return nil, nil, stack\r\n      end\r\n      for _,frame in ipairs(stack) do\r\n        print(mobdebug.line(frame[1], {comment = false}))\r\n      end\r\n      return stack\r\n    elseif status == \"401\" then\r\n      local _, _, len = string.find(resp, \"%s+(%d+)%s*$\")\r\n      len = tonumber(len)\r\n      local res = len > 0 and client:receive(len) or \"Invalid stack information.\"\r\n      print(\"Error in expression: \" .. res)\r\n      return nil, nil, res\r\n    else\r\n      print(\"Unknown error\")\r\n      return nil, nil, \"Debugger error: unexpected response after STACK\"\r\n    end\r\n  elseif command == \"output\" then\r\n    local _, _, stream, mode = string.find(params, \"^[a-z]+%s+(%w+)%s+([dcr])%s*$\")\r\n    if stream and mode then\r\n      client:send(\"OUTPUT \"..stream..\" \"..mode..\"\\n\")\r\n      local resp, err = client:receive()\r\n      if not resp then\r\n        print(\"Unknown error: \"..err)\r\n        return nil, nil, \"Debugger connection error: \"..err\r\n      end\r\n      local _, _, status = string.find(resp, \"^(%d+)%s+%w+%s*$\")\r\n      if status == \"200\" then\r\n        print(\"Stream \"..stream..\" redirected\")\r\n        outputs[stream] = type(options) == 'table' and options.handler or nil\r\n      -- the client knows when she is doing, so install the handler\r\n      elseif type(options) == 'table' and options.handler then\r\n        outputs[stream] = options.handler\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: can't redirect \"..stream\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"basedir\" then\r\n    local _, _, dir = string.find(params, \"^[a-z]+%s+(.+)$\")\r\n    if dir then\r\n      dir = string.gsub(dir, \"\\\\\", \"/\") -- convert slash\r\n      if not string.find(dir, \"/$\") then dir = dir .. \"/\" end\r\n\r\n      local remdir = dir:match(\"\\t(.+)\")\r\n      if remdir then dir = dir:gsub(\"/?\\t.+\", \"/\") end\r\n      basedir = dir\r\n\r\n      client:send(\"BASEDIR \"..(remdir or dir)..\"\\n\")\r\n      local resp, err = client:receive()\r\n      if not resp then\r\n        print(\"Unknown error: \"..err)\r\n        return nil, nil, \"Debugger connection error: \"..err\r\n      end\r\n      local _, _, status = string.find(resp, \"^(%d+)%s+%w+%s*$\")\r\n      if status == \"200\" then\r\n        print(\"New base directory is \" .. basedir)\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: unexpected response after BASEDIR\"\r\n      end\r\n    else\r\n      print(basedir)\r\n    end\r\n  elseif command == \"help\" then\r\n    print(\"setb <file> <line>    -- sets a breakpoint\")\r\n    print(\"delb <file> <line>    -- removes a breakpoint\")\r\n    print(\"delallb               -- removes all breakpoints\")\r\n    print(\"setw <exp>            -- adds a new watch expression\")\r\n    print(\"delw <index>          -- removes the watch expression at index\")\r\n    print(\"delallw               -- removes all watch expressions\")\r\n    print(\"run                   -- runs until next breakpoint\")\r\n    print(\"step                  -- runs until next line, stepping into function calls\")\r\n    print(\"over                  -- runs until next line, stepping over function calls\")\r\n    print(\"out                   -- runs until line after returning from current function\")\r\n    print(\"listb                 -- lists breakpoints\")\r\n    print(\"listw                 -- lists watch expressions\")\r\n    print(\"eval <exp>            -- evaluates expression on the current context and returns its value\")\r\n    print(\"exec <stmt>           -- executes statement on the current context\")\r\n    print(\"load <file>           -- loads a local file for debugging\")\r\n    print(\"reload                -- restarts the current debugging session\")\r\n    print(\"stack                 -- reports stack trace\")\r\n    print(\"output stdout <d|c|r> -- capture and redirect io stream (default|copy|redirect)\")\r\n    print(\"basedir [<path>]      -- sets the base path of the remote application, or shows the current one\")\r\n    print(\"done                  -- stops the debugger and continues application execution\")\r\n    print(\"exit                  -- exits debugger and the application\")\r\n  else\r\n    local _, _, spaces = string.find(params, \"^(%s*)$\")\r\n    if spaces then\r\n      return nil, nil, \"Empty command\"\r\n    else\r\n      print(\"Invalid command\")\r\n      return nil, nil, \"Invalid command\"\r\n    end\r\n  end\r\n  return file, line\r\nend",
    "type": "function"
  }, {
    "id": 578,
    "text": "local verbose = not options or options.verbose ~= nil and options.verbose",
    "type": "statement:localassign"
  }, {
    "id": 579,
    "text": "local print = verbose and (type(verbose) == \"function\" and verbose or print) or function() end",
    "type": "statement:localassign"
  }, {
    "id": 580,
    "text": "local file, line, watch_idx",
    "type": "statement:localassign"
  }, {
    "id": 581,
    "text": "local _, _, command = string.find(params, \"^([a-z]+)\")",
    "type": "statement:localassign"
  }, {
    "id": 582,
    "text": "if command == \"run\" or command == \"step\" or command == \"out\"\r\n  or command == \"over\" or command == \"exit\" then\r\n    client:send(string.upper(command) .. \"\\n\")\r\n    client:receive() -- this should consume the first '200 OK' response\r\n    while true do\r\n      local done = true\r\n      local breakpoint = client:receive()\r\n      if not breakpoint then\r\n        print(\"Program finished\")\r\n        return nil, nil, false\r\n      end\r\n      local _, _, status = string.find(breakpoint, \"^(%d+)\")\r\n      if status == \"200\" then\r\n        -- don't need to do anything\r\n      elseif status == \"202\" then\r\n        _, _, file, line = string.find(breakpoint, \"^202 Paused%s+(.-)%s+(%d+)%s*$\")\r\n        if file and line then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line)\r\n        end\r\n      elseif status == \"203\" then\r\n        _, _, file, line, watch_idx = string.find(breakpoint, \"^203 Paused%s+(.-)%s+(%d+)%s+(%d+)%s*$\")\r\n        if file and line and watch_idx then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line .. \" (watch expression \" .. watch_idx .. \": [\" .. watches[watch_idx] .. \"])\")\r\n        end\r\n      elseif status == \"204\" then\r\n        local _, _, stream, size = string.find(breakpoint, \"^204 Output (%w+) (%d+)$\")\r\n        if stream and size then\r\n          local size = tonumber(size)\r\n          local msg = size > 0 and client:receive(size) or \"\"\r\n          print(msg)\r\n          if outputs[stream] then outputs[stream](msg) end\r\n          -- this was just the output, so go back reading the response\r\n          done = false\r\n        end\r\n      elseif status == \"401\" then\r\n        local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)$\")\r\n        if size then\r\n          local msg = client:receive(tonumber(size))\r\n          print(\"Error in remote application: \" .. msg)\r\n          return nil, nil, msg\r\n        end\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: unexpected response '\" .. breakpoint .. \"'\"\r\n      end\r\n      if done then break end\r\n    end\r\n  elseif command == \"done\" then\r\n    client:send(string.upper(command) .. \"\\n\")\r\n    -- no response is expected\r\n  elseif command == \"setb\" or command == \"asetb\" then\r\n    _, _, _, file, line = string.find(params, \"^([a-z]+)%s+(.-)%s+(%d+)%s*$\")\r\n    if file and line then\r\n      -- if this is a file name, and not a file source\r\n      if not file:find('^\".*\"$') then\r\n        file = string.gsub(file, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n      end\r\n      client:send(\"SETB \" .. file .. \" \" .. line .. \"\\n\")\r\n      if command == \"asetb\" or client:receive() == \"200 OK\" then\r\n        set_breakpoint(file, line)\r\n      else\r\n        print(\"Error: breakpoint not inserted\")\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"setw\" then\r\n    local _, _, exp = string.find(params, \"^[a-z]+%s+(.+)$\")\r\n    if exp then\r\n      client:send(\"SETW \" .. exp .. \"\\n\")\r\n      local answer = client:receive()\r\n      local _, _, watch_idx = string.find(answer, \"^200 OK (%d+)%s*$\")\r\n      if watch_idx then\r\n        watches[watch_idx] = exp\r\n        print(\"Inserted watch exp no. \" .. watch_idx)\r\n      else\r\n        local _, _, size = string.find(answer, \"^401 Error in Expression (%d+)$\")\r\n        if size then\r\n          local err = client:receive(tonumber(size)):gsub(\".-:%d+:%s*\",\"\")\r\n          print(\"Error: watch expression not set: \" .. err)\r\n        else\r\n          print(\"Error: watch expression not set\")\r\n        end\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"delb\" or command == \"adelb\" then\r\n    _, _, _, file, line = string.find(params, \"^([a-z]+)%s+(.-)%s+(%d+)%s*$\")\r\n    if file and line then\r\n      -- if this is a file name, and not a file source\r\n      if not file:find('^\".*\"$') then\r\n        file = string.gsub(file, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n      end\r\n      client:send(\"DELB \" .. file .. \" \" .. line .. \"\\n\")\r\n      if command == \"adelb\" or client:receive() == \"200 OK\" then\r\n        remove_breakpoint(file, line)\r\n      else\r\n        print(\"Error: breakpoint not removed\")\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"delallb\" then\r\n    local file, line = \"*\", 0\r\n    client:send(\"DELB \" .. file .. \" \" .. tostring(line) .. \"\\n\")\r\n    if client:receive() == \"200 OK\" then\r\n      remove_breakpoint(file, line)\r\n    else\r\n      print(\"Error: all breakpoints not removed\")\r\n    end\r\n  elseif command == \"delw\" then\r\n    local _, _, index = string.find(params, \"^[a-z]+%s+(%d+)%s*$\")\r\n    if index then\r\n      client:send(\"DELW \" .. index .. \"\\n\")\r\n      if client:receive() == \"200 OK\" then\r\n        watches[index] = nil\r\n      else\r\n        print(\"Error: watch expression not removed\")\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"delallw\" then\r\n    for index, exp in pairs(watches) do\r\n      client:send(\"DELW \" .. index .. \"\\n\")\r\n      if client:receive() == \"200 OK\" then\r\n        watches[index] = nil\r\n      else\r\n        print(\"Error: watch expression at index \" .. index .. \" [\" .. exp .. \"] not removed\")\r\n      end\r\n    end\r\n  elseif command == \"eval\" or command == \"exec\"\r\n      or command == \"load\" or command == \"loadstring\"\r\n      or command == \"reload\" then\r\n    local _, _, exp = string.find(params, \"^[a-z]+%s+(.+)$\")\r\n    if exp or (command == \"reload\") then\r\n      if command == \"eval\" or command == \"exec\" then\r\n        exp = (exp:gsub(\"%-%-%[(=*)%[.-%]%1%]\", \"\") -- remove comments\r\n                  :gsub(\"%-%-.-\\n\", \" \") -- remove line comments\r\n                  :gsub(\"\\n\", \" \")) -- convert new lines\r\n        if command == \"eval\" then exp = \"return \" .. exp end\r\n        client:send(\"EXEC \" .. exp .. \"\\n\")\r\n      elseif command == \"reload\" then\r\n        client:send(\"LOAD 0 -\\n\")\r\n      elseif command == \"loadstring\" then\r\n        local _, _, _, file, lines = string.find(exp, \"^([\\\"'])(.-)%1%s+(.+)\")\r\n        if not file then\r\n           _, _, file, lines = string.find(exp, \"^(%S+)%s+(.+)\")\r\n        end\r\n        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\r\n        client:send(lines)\r\n      else\r\n        local file = io.open(exp, \"r\")\r\n        if not file and pcall(require, \"winapi\") then\r\n          -- if file is not open and winapi is there, try with a short path;\r\n          -- this may be needed for unicode paths on windows\r\n          winapi.set_encoding(winapi.CP_UTF8)\r\n          local shortp = winapi.short_path(exp)\r\n          file = shortp and io.open(shortp, \"r\")\r\n        end\r\n        if not file then return nil, nil, \"Cannot open file \" .. exp end\r\n        -- read the file and remove the shebang line as it causes a compilation error\r\n        local lines = file:read(\"*all\"):gsub(\"^#!.-\\n\", \"\\n\")\r\n        file:close()\r\n\r\n        local file = string.gsub(exp, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\r\n        if #lines > 0 then client:send(lines) end\r\n      end\r\n      while true do\r\n        local params, err = client:receive()\r\n        if not params then\r\n          return nil, nil, \"Debugger connection \" .. (err or \"error\")\r\n        end\r\n        local done = true\r\n        local _, _, status, len = string.find(params, \"^(%d+).-%s+(%d+)%s*$\")\r\n        if status == \"200\" then\r\n          len = tonumber(len)\r\n          if len > 0 then\r\n            local status, res\r\n            local str = client:receive(len)\r\n            -- handle serialized table with results\r\n            local func, err = loadstring(str)\r\n            if func then\r\n              status, res = pcall(func)\r\n              if not status then err = res\r\n              elseif type(res) ~= \"table\" then\r\n                err = \"received \"..type(res)..\" instead of expected 'table'\"\r\n              end\r\n            end\r\n            if err then\r\n              print(\"Error in processing results: \" .. err)\r\n              return nil, nil, \"Error in processing results: \" .. err\r\n            end\r\n            print(unpack(res))\r\n            return res[1], res\r\n          end\r\n        elseif status == \"201\" then\r\n          _, _, file, line = string.find(params, \"^201 Started%s+(.-)%s+(%d+)%s*$\")\r\n        elseif status == \"202\" or params == \"200 OK\" then\r\n          -- do nothing; this only happens when RE/LOAD command gets the response\r\n          -- that was for the original command that was aborted\r\n        elseif status == \"204\" then\r\n          local _, _, stream, size = string.find(params, \"^204 Output (%w+) (%d+)$\")\r\n          if stream and size then\r\n            local size = tonumber(size)\r\n            local msg = size > 0 and client:receive(size) or \"\"\r\n            print(msg)\r\n            if outputs[stream] then outputs[stream](msg) end\r\n            -- this was just the output, so go back reading the response\r\n            done = false\r\n          end\r\n        elseif status == \"401\" then\r\n          len = tonumber(len)\r\n          local res = client:receive(len)\r\n          print(\"Error in expression: \" .. res)\r\n          return nil, nil, res\r\n        else\r\n          print(\"Unknown error\")\r\n          return nil, nil, \"Debugger error: unexpected response after EXEC/LOAD '\" .. params .. \"'\"\r\n        end\r\n        if done then break end\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"listb\" then\r\n    for l, v in pairs(breakpoints) do\r\n      for f in pairs(v) do\r\n        print(f .. \": \" .. l)\r\n      end\r\n    end\r\n  elseif command == \"listw\" then\r\n    for i, v in pairs(watches) do\r\n      print(\"Watch exp. \" .. i .. \": \" .. v)\r\n    end\r\n  elseif command == \"suspend\" then\r\n    client:send(\"SUSPEND\\n\")\r\n  elseif command == \"stack\" then\r\n    client:send(\"STACK\\n\")\r\n    local resp = client:receive()\r\n    local _, _, status, res = string.find(resp, \"^(%d+)%s+%w+%s+(.+)%s*$\")\r\n    if status == \"200\" then\r\n      local func, err = loadstring(res)\r\n      if func == nil then\r\n        print(\"Error in stack information: \" .. err)\r\n        return nil, nil, err\r\n      end\r\n      local ok, stack = pcall(func)\r\n      if not ok then\r\n        print(\"Error in stack information: \" .. stack)\r\n        return nil, nil, stack\r\n      end\r\n      for _,frame in ipairs(stack) do\r\n        print(mobdebug.line(frame[1], {comment = false}))\r\n      end\r\n      return stack\r\n    elseif status == \"401\" then\r\n      local _, _, len = string.find(resp, \"%s+(%d+)%s*$\")\r\n      len = tonumber(len)\r\n      local res = len > 0 and client:receive(len) or \"Invalid stack information.\"\r\n      print(\"Error in expression: \" .. res)\r\n      return nil, nil, res\r\n    else\r\n      print(\"Unknown error\")\r\n      return nil, nil, \"Debugger error: unexpected response after STACK\"\r\n    end\r\n  elseif command == \"output\" then\r\n    local _, _, stream, mode = string.find(params, \"^[a-z]+%s+(%w+)%s+([dcr])%s*$\")\r\n    if stream and mode then\r\n      client:send(\"OUTPUT \"..stream..\" \"..mode..\"\\n\")\r\n      local resp, err = client:receive()\r\n      if not resp then\r\n        print(\"Unknown error: \"..err)\r\n        return nil, nil, \"Debugger connection error: \"..err\r\n      end\r\n      local _, _, status = string.find(resp, \"^(%d+)%s+%w+%s*$\")\r\n      if status == \"200\" then\r\n        print(\"Stream \"..stream..\" redirected\")\r\n        outputs[stream] = type(options) == 'table' and options.handler or nil\r\n      -- the client knows when she is doing, so install the handler\r\n      elseif type(options) == 'table' and options.handler then\r\n        outputs[stream] = options.handler\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: can't redirect \"..stream\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end\r\n  elseif command == \"basedir\" then\r\n    local _, _, dir = string.find(params, \"^[a-z]+%s+(.+)$\")\r\n    if dir then\r\n      dir = string.gsub(dir, \"\\\\\", \"/\") -- convert slash\r\n      if not string.find(dir, \"/$\") then dir = dir .. \"/\" end\r\n\r\n      local remdir = dir:match(\"\\t(.+)\")\r\n      if remdir then dir = dir:gsub(\"/?\\t.+\", \"/\") end\r\n      basedir = dir\r\n\r\n      client:send(\"BASEDIR \"..(remdir or dir)..\"\\n\")\r\n      local resp, err = client:receive()\r\n      if not resp then\r\n        print(\"Unknown error: \"..err)\r\n        return nil, nil, \"Debugger connection error: \"..err\r\n      end\r\n      local _, _, status = string.find(resp, \"^(%d+)%s+%w+%s*$\")\r\n      if status == \"200\" then\r\n        print(\"New base directory is \" .. basedir)\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: unexpected response after BASEDIR\"\r\n      end\r\n    else\r\n      print(basedir)\r\n    end\r\n  elseif command == \"help\" then\r\n    print(\"setb <file> <line>    -- sets a breakpoint\")\r\n    print(\"delb <file> <line>    -- removes a breakpoint\")\r\n    print(\"delallb               -- removes all breakpoints\")\r\n    print(\"setw <exp>            -- adds a new watch expression\")\r\n    print(\"delw <index>          -- removes the watch expression at index\")\r\n    print(\"delallw               -- removes all watch expressions\")\r\n    print(\"run                   -- runs until next breakpoint\")\r\n    print(\"step                  -- runs until next line, stepping into function calls\")\r\n    print(\"over                  -- runs until next line, stepping over function calls\")\r\n    print(\"out                   -- runs until line after returning from current function\")\r\n    print(\"listb                 -- lists breakpoints\")\r\n    print(\"listw                 -- lists watch expressions\")\r\n    print(\"eval <exp>            -- evaluates expression on the current context and returns its value\")\r\n    print(\"exec <stmt>           -- executes statement on the current context\")\r\n    print(\"load <file>           -- loads a local file for debugging\")\r\n    print(\"reload                -- restarts the current debugging session\")\r\n    print(\"stack                 -- reports stack trace\")\r\n    print(\"output stdout <d|c|r> -- capture and redirect io stream (default|copy|redirect)\")\r\n    print(\"basedir [<path>]      -- sets the base path of the remote application, or shows the current one\")\r\n    print(\"done                  -- stops the debugger and continues application execution\")\r\n    print(\"exit                  -- exits debugger and the application\")\r\n  else\r\n    local _, _, spaces = string.find(params, \"^(%s*)$\")\r\n    if spaces then\r\n      return nil, nil, \"Empty command\"\r\n    else\r\n      print(\"Invalid command\")\r\n      return nil, nil, \"Invalid command\"\r\n    end\r\n  end",
    "type": "statement:if"
  }, {
    "id": 583,
    "text": "client:send(string.upper(command) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 584,
    "text": "client:receive()",
    "type": "statement:functioncall"
  }, {
    "id": 585,
    "text": "while true do\r\n      local done = true\r\n      local breakpoint = client:receive()\r\n      if not breakpoint then\r\n        print(\"Program finished\")\r\n        return nil, nil, false\r\n      end\r\n      local _, _, status = string.find(breakpoint, \"^(%d+)\")\r\n      if status == \"200\" then\r\n        -- don't need to do anything\r\n      elseif status == \"202\" then\r\n        _, _, file, line = string.find(breakpoint, \"^202 Paused%s+(.-)%s+(%d+)%s*$\")\r\n        if file and line then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line)\r\n        end\r\n      elseif status == \"203\" then\r\n        _, _, file, line, watch_idx = string.find(breakpoint, \"^203 Paused%s+(.-)%s+(%d+)%s+(%d+)%s*$\")\r\n        if file and line and watch_idx then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line .. \" (watch expression \" .. watch_idx .. \": [\" .. watches[watch_idx] .. \"])\")\r\n        end\r\n      elseif status == \"204\" then\r\n        local _, _, stream, size = string.find(breakpoint, \"^204 Output (%w+) (%d+)$\")\r\n        if stream and size then\r\n          local size = tonumber(size)\r\n          local msg = size > 0 and client:receive(size) or \"\"\r\n          print(msg)\r\n          if outputs[stream] then outputs[stream](msg) end\r\n          -- this was just the output, so go back reading the response\r\n          done = false\r\n        end\r\n      elseif status == \"401\" then\r\n        local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)$\")\r\n        if size then\r\n          local msg = client:receive(tonumber(size))\r\n          print(\"Error in remote application: \" .. msg)\r\n          return nil, nil, msg\r\n        end\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: unexpected response '\" .. breakpoint .. \"'\"\r\n      end\r\n      if done then break end\r\n    end",
    "type": "statement:while"
  }, {
    "id": 586,
    "text": "local done = true",
    "type": "statement:localassign"
  }, {
    "id": 587,
    "text": "local breakpoint = client:receive()",
    "type": "statement:localassign"
  }, {
    "id": 588,
    "text": "if not breakpoint then\r\n        print(\"Program finished\")\r\n        return nil, nil, false\r\n      end",
    "type": "statement:if"
  }, {
    "id": 589,
    "text": "print(\"Program finished\")",
    "type": "statement:functioncall"
  }, {
    "id": 590,
    "text": "local _, _, status = string.find(breakpoint, \"^(%d+)\")",
    "type": "statement:localassign"
  }, {
    "id": 591,
    "text": "if status == \"200\" then\r\n        -- don't need to do anything\r\n      elseif status == \"202\" then\r\n        _, _, file, line = string.find(breakpoint, \"^202 Paused%s+(.-)%s+(%d+)%s*$\")\r\n        if file and line then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line)\r\n        end\r\n      elseif status == \"203\" then\r\n        _, _, file, line, watch_idx = string.find(breakpoint, \"^203 Paused%s+(.-)%s+(%d+)%s+(%d+)%s*$\")\r\n        if file and line and watch_idx then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line .. \" (watch expression \" .. watch_idx .. \": [\" .. watches[watch_idx] .. \"])\")\r\n        end\r\n      elseif status == \"204\" then\r\n        local _, _, stream, size = string.find(breakpoint, \"^204 Output (%w+) (%d+)$\")\r\n        if stream and size then\r\n          local size = tonumber(size)\r\n          local msg = size > 0 and client:receive(size) or \"\"\r\n          print(msg)\r\n          if outputs[stream] then outputs[stream](msg) end\r\n          -- this was just the output, so go back reading the response\r\n          done = false\r\n        end\r\n      elseif status == \"401\" then\r\n        local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)$\")\r\n        if size then\r\n          local msg = client:receive(tonumber(size))\r\n          print(\"Error in remote application: \" .. msg)\r\n          return nil, nil, msg\r\n        end\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: unexpected response '\" .. breakpoint .. \"'\"\r\n      end",
    "type": "statement:if"
  }, {
    "id": 592,
    "text": "_, _, file, line = string.find(breakpoint, \"^202 Paused%s+(.-)%s+(%d+)%s*$\")",
    "type": "statement:assign"
  }, {
    "id": 593,
    "text": "if file and line then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 594,
    "text": "print(\"Paused at file \" .. file .. \" line \" .. line)",
    "type": "statement:functioncall"
  }, {
    "id": 595,
    "text": "_, _, file, line, watch_idx = string.find(breakpoint, \"^203 Paused%s+(.-)%s+(%d+)%s+(%d+)%s*$\")",
    "type": "statement:assign"
  }, {
    "id": 596,
    "text": "if file and line and watch_idx then\r\n          print(\"Paused at file \" .. file .. \" line \" .. line .. \" (watch expression \" .. watch_idx .. \": [\" .. watches[watch_idx] .. \"])\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 597,
    "text": "print(\"Paused at file \" .. file .. \" line \" .. line .. \" (watch expression \" .. watch_idx .. \": [\" .. watches[watch_idx] .. \"])\")",
    "type": "statement:functioncall"
  }, {
    "id": 598,
    "text": "local _, _, stream, size = string.find(breakpoint, \"^204 Output (%w+) (%d+)$\")",
    "type": "statement:localassign"
  }, {
    "id": 599,
    "text": "if stream and size then\r\n          local size = tonumber(size)\r\n          local msg = size > 0 and client:receive(size) or \"\"\r\n          print(msg)\r\n          if outputs[stream] then outputs[stream](msg) end\r\n          -- this was just the output, so go back reading the response\r\n          done = false\r\n        end",
    "type": "statement:if"
  }, {
    "id": 600,
    "text": "local size = tonumber(size)",
    "type": "statement:localassign"
  }, {
    "id": 601,
    "text": "local msg = size > 0 and client:receive(size) or \"\"",
    "type": "statement:localassign"
  }, {
    "id": 602,
    "text": "print(msg)",
    "type": "statement:functioncall"
  }, {
    "id": 603,
    "text": "if outputs[stream] then outputs[stream](msg) end",
    "type": "statement:if"
  }, {
    "id": 604,
    "text": "outputs[stream](msg)",
    "type": "statement:functioncall"
  }, {
    "id": 605,
    "text": "done = false",
    "type": "statement:assign"
  }, {
    "id": 606,
    "text": "local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)$\")",
    "type": "statement:localassign"
  }, {
    "id": 607,
    "text": "if size then\r\n          local msg = client:receive(tonumber(size))\r\n          print(\"Error in remote application: \" .. msg)\r\n          return nil, nil, msg\r\n        end",
    "type": "statement:if"
  }, {
    "id": 608,
    "text": "local msg = client:receive(tonumber(size))",
    "type": "statement:localassign"
  }, {
    "id": 609,
    "text": "print(\"Error in remote application: \" .. msg)",
    "type": "statement:functioncall"
  }, {
    "id": 610,
    "text": "print(\"Unknown error\")",
    "type": "statement:functioncall"
  }, {
    "id": 611,
    "text": "if done then break end",
    "type": "statement:if"
  }, {
    "id": 612,
    "text": "_, _, _, file, line = string.find(params, \"^([a-z]+)%s+(.-)%s+(%d+)%s*$\")",
    "type": "statement:assign"
  }, {
    "id": 613,
    "text": "if file and line then\r\n      -- if this is a file name, and not a file source\r\n      if not file:find('^\".*\"$') then\r\n        file = string.gsub(file, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n      end\r\n      client:send(\"SETB \" .. file .. \" \" .. line .. \"\\n\")\r\n      if command == \"asetb\" or client:receive() == \"200 OK\" then\r\n        set_breakpoint(file, line)\r\n      else\r\n        print(\"Error: breakpoint not inserted\")\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 614,
    "text": "if not file:find('^\".*\"$') then\r\n        file = string.gsub(file, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n      end",
    "type": "statement:if"
  }, {
    "id": 615,
    "text": "file = string.gsub(file, \"\\\\\", \"/\")",
    "type": "statement:assign"
  }, {
    "id": 616,
    "text": "file = removebasedir(file, basedir)",
    "type": "statement:assign"
  }, {
    "id": 617,
    "text": "client:send(\"SETB \" .. file .. \" \" .. line .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 618,
    "text": "if command == \"asetb\" or client:receive() == \"200 OK\" then\r\n        set_breakpoint(file, line)\r\n      else\r\n        print(\"Error: breakpoint not inserted\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 619,
    "text": "set_breakpoint(file, line)",
    "type": "statement:functioncall"
  }, {
    "id": 620,
    "text": "print(\"Error: breakpoint not inserted\")",
    "type": "statement:functioncall"
  }, {
    "id": 621,
    "text": "print(\"Invalid command\")",
    "type": "statement:functioncall"
  }, {
    "id": 622,
    "text": "local _, _, exp = string.find(params, \"^[a-z]+%s+(.+)$\")",
    "type": "statement:localassign"
  }, {
    "id": 623,
    "text": "if exp then\r\n      client:send(\"SETW \" .. exp .. \"\\n\")\r\n      local answer = client:receive()\r\n      local _, _, watch_idx = string.find(answer, \"^200 OK (%d+)%s*$\")\r\n      if watch_idx then\r\n        watches[watch_idx] = exp\r\n        print(\"Inserted watch exp no. \" .. watch_idx)\r\n      else\r\n        local _, _, size = string.find(answer, \"^401 Error in Expression (%d+)$\")\r\n        if size then\r\n          local err = client:receive(tonumber(size)):gsub(\".-:%d+:%s*\",\"\")\r\n          print(\"Error: watch expression not set: \" .. err)\r\n        else\r\n          print(\"Error: watch expression not set\")\r\n        end\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 624,
    "text": "client:send(\"SETW \" .. exp .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 625,
    "text": "local answer = client:receive()",
    "type": "statement:localassign"
  }, {
    "id": 626,
    "text": "local _, _, watch_idx = string.find(answer, \"^200 OK (%d+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 627,
    "text": "if watch_idx then\r\n        watches[watch_idx] = exp\r\n        print(\"Inserted watch exp no. \" .. watch_idx)\r\n      else\r\n        local _, _, size = string.find(answer, \"^401 Error in Expression (%d+)$\")\r\n        if size then\r\n          local err = client:receive(tonumber(size)):gsub(\".-:%d+:%s*\",\"\")\r\n          print(\"Error: watch expression not set: \" .. err)\r\n        else\r\n          print(\"Error: watch expression not set\")\r\n        end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 628,
    "text": "watches[watch_idx] = exp",
    "type": "statement:assign"
  }, {
    "id": 629,
    "text": "print(\"Inserted watch exp no. \" .. watch_idx)",
    "type": "statement:functioncall"
  }, {
    "id": 630,
    "text": "local _, _, size = string.find(answer, \"^401 Error in Expression (%d+)$\")",
    "type": "statement:localassign"
  }, {
    "id": 631,
    "text": "if size then\r\n          local err = client:receive(tonumber(size)):gsub(\".-:%d+:%s*\",\"\")\r\n          print(\"Error: watch expression not set: \" .. err)\r\n        else\r\n          print(\"Error: watch expression not set\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 632,
    "text": "local err = client:receive(tonumber(size)):gsub(\".-:%d+:%s*\",\"\")",
    "type": "statement:localassign"
  }, {
    "id": 633,
    "text": "print(\"Error: watch expression not set: \" .. err)",
    "type": "statement:functioncall"
  }, {
    "id": 634,
    "text": "print(\"Error: watch expression not set\")",
    "type": "statement:functioncall"
  }, {
    "id": 635,
    "text": "if file and line then\r\n      -- if this is a file name, and not a file source\r\n      if not file:find('^\".*\"$') then\r\n        file = string.gsub(file, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n      end\r\n      client:send(\"DELB \" .. file .. \" \" .. line .. \"\\n\")\r\n      if command == \"adelb\" or client:receive() == \"200 OK\" then\r\n        remove_breakpoint(file, line)\r\n      else\r\n        print(\"Error: breakpoint not removed\")\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 636,
    "text": "client:send(\"DELB \" .. file .. \" \" .. line .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 637,
    "text": "if command == \"adelb\" or client:receive() == \"200 OK\" then\r\n        remove_breakpoint(file, line)\r\n      else\r\n        print(\"Error: breakpoint not removed\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 638,
    "text": "remove_breakpoint(file, line)",
    "type": "statement:functioncall"
  }, {
    "id": 639,
    "text": "print(\"Error: breakpoint not removed\")",
    "type": "statement:functioncall"
  }, {
    "id": 640,
    "text": "local file, line = \"*\", 0",
    "type": "statement:localassign"
  }, {
    "id": 641,
    "text": "client:send(\"DELB \" .. file .. \" \" .. tostring(line) .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 642,
    "text": "if client:receive() == \"200 OK\" then\r\n      remove_breakpoint(file, line)\r\n    else\r\n      print(\"Error: all breakpoints not removed\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 643,
    "text": "print(\"Error: all breakpoints not removed\")",
    "type": "statement:functioncall"
  }, {
    "id": 644,
    "text": "local _, _, index = string.find(params, \"^[a-z]+%s+(%d+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 645,
    "text": "if index then\r\n      client:send(\"DELW \" .. index .. \"\\n\")\r\n      if client:receive() == \"200 OK\" then\r\n        watches[index] = nil\r\n      else\r\n        print(\"Error: watch expression not removed\")\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 646,
    "text": "client:send(\"DELW \" .. index .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 647,
    "text": "if client:receive() == \"200 OK\" then\r\n        watches[index] = nil\r\n      else\r\n        print(\"Error: watch expression not removed\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 648,
    "text": "watches[index] = nil",
    "type": "statement:assign"
  }, {
    "id": 649,
    "text": "print(\"Error: watch expression not removed\")",
    "type": "statement:functioncall"
  }, {
    "id": 650,
    "text": "for index, exp in pairs(watches) do\r\n      client:send(\"DELW \" .. index .. \"\\n\")\r\n      if client:receive() == \"200 OK\" then\r\n        watches[index] = nil\r\n      else\r\n        print(\"Error: watch expression at index \" .. index .. \" [\" .. exp .. \"] not removed\")\r\n      end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 651,
    "text": "if client:receive() == \"200 OK\" then\r\n        watches[index] = nil\r\n      else\r\n        print(\"Error: watch expression at index \" .. index .. \" [\" .. exp .. \"] not removed\")\r\n      end",
    "type": "statement:if"
  }, {
    "id": 652,
    "text": "print(\"Error: watch expression at index \" .. index .. \" [\" .. exp .. \"] not removed\")",
    "type": "statement:functioncall"
  }, {
    "id": 653,
    "text": "if exp or (command == \"reload\") then\r\n      if command == \"eval\" or command == \"exec\" then\r\n        exp = (exp:gsub(\"%-%-%[(=*)%[.-%]%1%]\", \"\") -- remove comments\r\n                  :gsub(\"%-%-.-\\n\", \" \") -- remove line comments\r\n                  :gsub(\"\\n\", \" \")) -- convert new lines\r\n        if command == \"eval\" then exp = \"return \" .. exp end\r\n        client:send(\"EXEC \" .. exp .. \"\\n\")\r\n      elseif command == \"reload\" then\r\n        client:send(\"LOAD 0 -\\n\")\r\n      elseif command == \"loadstring\" then\r\n        local _, _, _, file, lines = string.find(exp, \"^([\\\"'])(.-)%1%s+(.+)\")\r\n        if not file then\r\n           _, _, file, lines = string.find(exp, \"^(%S+)%s+(.+)\")\r\n        end\r\n        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\r\n        client:send(lines)\r\n      else\r\n        local file = io.open(exp, \"r\")\r\n        if not file and pcall(require, \"winapi\") then\r\n          -- if file is not open and winapi is there, try with a short path;\r\n          -- this may be needed for unicode paths on windows\r\n          winapi.set_encoding(winapi.CP_UTF8)\r\n          local shortp = winapi.short_path(exp)\r\n          file = shortp and io.open(shortp, \"r\")\r\n        end\r\n        if not file then return nil, nil, \"Cannot open file \" .. exp end\r\n        -- read the file and remove the shebang line as it causes a compilation error\r\n        local lines = file:read(\"*all\"):gsub(\"^#!.-\\n\", \"\\n\")\r\n        file:close()\r\n\r\n        local file = string.gsub(exp, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\r\n        if #lines > 0 then client:send(lines) end\r\n      end\r\n      while true do\r\n        local params, err = client:receive()\r\n        if not params then\r\n          return nil, nil, \"Debugger connection \" .. (err or \"error\")\r\n        end\r\n        local done = true\r\n        local _, _, status, len = string.find(params, \"^(%d+).-%s+(%d+)%s*$\")\r\n        if status == \"200\" then\r\n          len = tonumber(len)\r\n          if len > 0 then\r\n            local status, res\r\n            local str = client:receive(len)\r\n            -- handle serialized table with results\r\n            local func, err = loadstring(str)\r\n            if func then\r\n              status, res = pcall(func)\r\n              if not status then err = res\r\n              elseif type(res) ~= \"table\" then\r\n                err = \"received \"..type(res)..\" instead of expected 'table'\"\r\n              end\r\n            end\r\n            if err then\r\n              print(\"Error in processing results: \" .. err)\r\n              return nil, nil, \"Error in processing results: \" .. err\r\n            end\r\n            print(unpack(res))\r\n            return res[1], res\r\n          end\r\n        elseif status == \"201\" then\r\n          _, _, file, line = string.find(params, \"^201 Started%s+(.-)%s+(%d+)%s*$\")\r\n        elseif status == \"202\" or params == \"200 OK\" then\r\n          -- do nothing; this only happens when RE/LOAD command gets the response\r\n          -- that was for the original command that was aborted\r\n        elseif status == \"204\" then\r\n          local _, _, stream, size = string.find(params, \"^204 Output (%w+) (%d+)$\")\r\n          if stream and size then\r\n            local size = tonumber(size)\r\n            local msg = size > 0 and client:receive(size) or \"\"\r\n            print(msg)\r\n            if outputs[stream] then outputs[stream](msg) end\r\n            -- this was just the output, so go back reading the response\r\n            done = false\r\n          end\r\n        elseif status == \"401\" then\r\n          len = tonumber(len)\r\n          local res = client:receive(len)\r\n          print(\"Error in expression: \" .. res)\r\n          return nil, nil, res\r\n        else\r\n          print(\"Unknown error\")\r\n          return nil, nil, \"Debugger error: unexpected response after EXEC/LOAD '\" .. params .. \"'\"\r\n        end\r\n        if done then break end\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 654,
    "text": "if command == \"eval\" or command == \"exec\" then\r\n        exp = (exp:gsub(\"%-%-%[(=*)%[.-%]%1%]\", \"\") -- remove comments\r\n                  :gsub(\"%-%-.-\\n\", \" \") -- remove line comments\r\n                  :gsub(\"\\n\", \" \")) -- convert new lines\r\n        if command == \"eval\" then exp = \"return \" .. exp end\r\n        client:send(\"EXEC \" .. exp .. \"\\n\")\r\n      elseif command == \"reload\" then\r\n        client:send(\"LOAD 0 -\\n\")\r\n      elseif command == \"loadstring\" then\r\n        local _, _, _, file, lines = string.find(exp, \"^([\\\"'])(.-)%1%s+(.+)\")\r\n        if not file then\r\n           _, _, file, lines = string.find(exp, \"^(%S+)%s+(.+)\")\r\n        end\r\n        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\r\n        client:send(lines)\r\n      else\r\n        local file = io.open(exp, \"r\")\r\n        if not file and pcall(require, \"winapi\") then\r\n          -- if file is not open and winapi is there, try with a short path;\r\n          -- this may be needed for unicode paths on windows\r\n          winapi.set_encoding(winapi.CP_UTF8)\r\n          local shortp = winapi.short_path(exp)\r\n          file = shortp and io.open(shortp, \"r\")\r\n        end\r\n        if not file then return nil, nil, \"Cannot open file \" .. exp end\r\n        -- read the file and remove the shebang line as it causes a compilation error\r\n        local lines = file:read(\"*all\"):gsub(\"^#!.-\\n\", \"\\n\")\r\n        file:close()\r\n\r\n        local file = string.gsub(exp, \"\\\\\", \"/\") -- convert slash\r\n        file = removebasedir(file, basedir)\r\n        client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")\r\n        if #lines > 0 then client:send(lines) end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 655,
    "text": "exp = (exp:gsub(\"%-%-%[(=*)%[.-%]%1%]\", \"\") -- remove comments\r\n                  :gsub(\"%-%-.-\\n\", \" \") -- remove line comments\r\n                  :gsub(\"\\n\", \" \"))",
    "type": "statement:assign"
  }, {
    "id": 656,
    "text": "if command == \"eval\" then exp = \"return \" .. exp end",
    "type": "statement:if"
  }, {
    "id": 657,
    "text": "exp = \"return \" .. exp",
    "type": "statement:assign"
  }, {
    "id": 658,
    "text": "client:send(\"EXEC \" .. exp .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 659,
    "text": "client:send(\"LOAD 0 -\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 660,
    "text": "local _, _, _, file, lines = string.find(exp, \"^([\\\"'])(.-)%1%s+(.+)\")",
    "type": "statement:localassign"
  }, {
    "id": 661,
    "text": "if not file then\r\n           _, _, file, lines = string.find(exp, \"^(%S+)%s+(.+)\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 662,
    "text": "_, _, file, lines = string.find(exp, \"^(%S+)%s+(.+)\")",
    "type": "statement:assign"
  }, {
    "id": 663,
    "text": "client:send(\"LOAD \" .. tostring(#lines) .. \" \" .. file .. \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 664,
    "text": "client:send(lines)",
    "type": "statement:functioncall"
  }, {
    "id": 665,
    "text": "local file = io.open(exp, \"r\")",
    "type": "statement:localassign"
  }, {
    "id": 666,
    "text": "if not file and pcall(require, \"winapi\") then\r\n          -- if file is not open and winapi is there, try with a short path;\r\n          -- this may be needed for unicode paths on windows\r\n          winapi.set_encoding(winapi.CP_UTF8)\r\n          local shortp = winapi.short_path(exp)\r\n          file = shortp and io.open(shortp, \"r\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 667,
    "text": "winapi.set_encoding(winapi.CP_UTF8)",
    "type": "statement:functioncall"
  }, {
    "id": 668,
    "text": "local shortp = winapi.short_path(exp)",
    "type": "statement:localassign"
  }, {
    "id": 669,
    "text": "file = shortp and io.open(shortp, \"r\")",
    "type": "statement:assign"
  }, {
    "id": 670,
    "text": "if not file then return nil, nil, \"Cannot open file \" .. exp end",
    "type": "statement:if"
  }, {
    "id": 671,
    "text": "local lines = file:read(\"*all\"):gsub(\"^#!.-\\n\", \"\\n\")",
    "type": "statement:localassign"
  }, {
    "id": 672,
    "text": "file:close()",
    "type": "statement:functioncall"
  }, {
    "id": 673,
    "text": "local file = string.gsub(exp, \"\\\\\", \"/\")",
    "type": "statement:localassign"
  }, {
    "id": 674,
    "text": "if #lines > 0 then client:send(lines) end",
    "type": "statement:if"
  }, {
    "id": 675,
    "text": "while true do\r\n        local params, err = client:receive()\r\n        if not params then\r\n          return nil, nil, \"Debugger connection \" .. (err or \"error\")\r\n        end\r\n        local done = true\r\n        local _, _, status, len = string.find(params, \"^(%d+).-%s+(%d+)%s*$\")\r\n        if status == \"200\" then\r\n          len = tonumber(len)\r\n          if len > 0 then\r\n            local status, res\r\n            local str = client:receive(len)\r\n            -- handle serialized table with results\r\n            local func, err = loadstring(str)\r\n            if func then\r\n              status, res = pcall(func)\r\n              if not status then err = res\r\n              elseif type(res) ~= \"table\" then\r\n                err = \"received \"..type(res)..\" instead of expected 'table'\"\r\n              end\r\n            end\r\n            if err then\r\n              print(\"Error in processing results: \" .. err)\r\n              return nil, nil, \"Error in processing results: \" .. err\r\n            end\r\n            print(unpack(res))\r\n            return res[1], res\r\n          end\r\n        elseif status == \"201\" then\r\n          _, _, file, line = string.find(params, \"^201 Started%s+(.-)%s+(%d+)%s*$\")\r\n        elseif status == \"202\" or params == \"200 OK\" then\r\n          -- do nothing; this only happens when RE/LOAD command gets the response\r\n          -- that was for the original command that was aborted\r\n        elseif status == \"204\" then\r\n          local _, _, stream, size = string.find(params, \"^204 Output (%w+) (%d+)$\")\r\n          if stream and size then\r\n            local size = tonumber(size)\r\n            local msg = size > 0 and client:receive(size) or \"\"\r\n            print(msg)\r\n            if outputs[stream] then outputs[stream](msg) end\r\n            -- this was just the output, so go back reading the response\r\n            done = false\r\n          end\r\n        elseif status == \"401\" then\r\n          len = tonumber(len)\r\n          local res = client:receive(len)\r\n          print(\"Error in expression: \" .. res)\r\n          return nil, nil, res\r\n        else\r\n          print(\"Unknown error\")\r\n          return nil, nil, \"Debugger error: unexpected response after EXEC/LOAD '\" .. params .. \"'\"\r\n        end\r\n        if done then break end\r\n      end",
    "type": "statement:while"
  }, {
    "id": 676,
    "text": "local params, err = client:receive()",
    "type": "statement:localassign"
  }, {
    "id": 677,
    "text": "if not params then\r\n          return nil, nil, \"Debugger connection \" .. (err or \"error\")\r\n        end",
    "type": "statement:if"
  }, {
    "id": 678,
    "text": "local _, _, status, len = string.find(params, \"^(%d+).-%s+(%d+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 679,
    "text": "if status == \"200\" then\r\n          len = tonumber(len)\r\n          if len > 0 then\r\n            local status, res\r\n            local str = client:receive(len)\r\n            -- handle serialized table with results\r\n            local func, err = loadstring(str)\r\n            if func then\r\n              status, res = pcall(func)\r\n              if not status then err = res\r\n              elseif type(res) ~= \"table\" then\r\n                err = \"received \"..type(res)..\" instead of expected 'table'\"\r\n              end\r\n            end\r\n            if err then\r\n              print(\"Error in processing results: \" .. err)\r\n              return nil, nil, \"Error in processing results: \" .. err\r\n            end\r\n            print(unpack(res))\r\n            return res[1], res\r\n          end\r\n        elseif status == \"201\" then\r\n          _, _, file, line = string.find(params, \"^201 Started%s+(.-)%s+(%d+)%s*$\")\r\n        elseif status == \"202\" or params == \"200 OK\" then\r\n          -- do nothing; this only happens when RE/LOAD command gets the response\r\n          -- that was for the original command that was aborted\r\n        elseif status == \"204\" then\r\n          local _, _, stream, size = string.find(params, \"^204 Output (%w+) (%d+)$\")\r\n          if stream and size then\r\n            local size = tonumber(size)\r\n            local msg = size > 0 and client:receive(size) or \"\"\r\n            print(msg)\r\n            if outputs[stream] then outputs[stream](msg) end\r\n            -- this was just the output, so go back reading the response\r\n            done = false\r\n          end\r\n        elseif status == \"401\" then\r\n          len = tonumber(len)\r\n          local res = client:receive(len)\r\n          print(\"Error in expression: \" .. res)\r\n          return nil, nil, res\r\n        else\r\n          print(\"Unknown error\")\r\n          return nil, nil, \"Debugger error: unexpected response after EXEC/LOAD '\" .. params .. \"'\"\r\n        end",
    "type": "statement:if"
  }, {
    "id": 680,
    "text": "len = tonumber(len)",
    "type": "statement:assign"
  }, {
    "id": 681,
    "text": "if len > 0 then\r\n            local status, res\r\n            local str = client:receive(len)\r\n            -- handle serialized table with results\r\n            local func, err = loadstring(str)\r\n            if func then\r\n              status, res = pcall(func)\r\n              if not status then err = res\r\n              elseif type(res) ~= \"table\" then\r\n                err = \"received \"..type(res)..\" instead of expected 'table'\"\r\n              end\r\n            end\r\n            if err then\r\n              print(\"Error in processing results: \" .. err)\r\n              return nil, nil, \"Error in processing results: \" .. err\r\n            end\r\n            print(unpack(res))\r\n            return res[1], res\r\n          end",
    "type": "statement:if"
  }, {
    "id": 682,
    "text": "local status, res",
    "type": "statement:localassign"
  }, {
    "id": 683,
    "text": "local str = client:receive(len)",
    "type": "statement:localassign"
  }, {
    "id": 684,
    "text": "local func, err = loadstring(str)",
    "type": "statement:localassign"
  }, {
    "id": 685,
    "text": "if func then\r\n              status, res = pcall(func)\r\n              if not status then err = res\r\n              elseif type(res) ~= \"table\" then\r\n                err = \"received \"..type(res)..\" instead of expected 'table'\"\r\n              end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 686,
    "text": "status, res = pcall(func)",
    "type": "statement:assign"
  }, {
    "id": 687,
    "text": "if not status then err = res\r\n              elseif type(res) ~= \"table\" then\r\n                err = \"received \"..type(res)..\" instead of expected 'table'\"\r\n              end",
    "type": "statement:if"
  }, {
    "id": 688,
    "text": "err = res",
    "type": "statement:assign"
  }, {
    "id": 689,
    "text": "err = \"received \"..type(res)..\" instead of expected 'table'\"",
    "type": "statement:assign"
  }, {
    "id": 690,
    "text": "if err then\r\n              print(\"Error in processing results: \" .. err)\r\n              return nil, nil, \"Error in processing results: \" .. err\r\n            end",
    "type": "statement:if"
  }, {
    "id": 691,
    "text": "print(\"Error in processing results: \" .. err)",
    "type": "statement:functioncall"
  }, {
    "id": 692,
    "text": "print(unpack(res))",
    "type": "statement:functioncall"
  }, {
    "id": 693,
    "text": "_, _, file, line = string.find(params, \"^201 Started%s+(.-)%s+(%d+)%s*$\")",
    "type": "statement:assign"
  }, {
    "id": 694,
    "text": "local _, _, stream, size = string.find(params, \"^204 Output (%w+) (%d+)$\")",
    "type": "statement:localassign"
  }, {
    "id": 695,
    "text": "if stream and size then\r\n            local size = tonumber(size)\r\n            local msg = size > 0 and client:receive(size) or \"\"\r\n            print(msg)\r\n            if outputs[stream] then outputs[stream](msg) end\r\n            -- this was just the output, so go back reading the response\r\n            done = false\r\n          end",
    "type": "statement:if"
  }, {
    "id": 696,
    "text": "local res = client:receive(len)",
    "type": "statement:localassign"
  }, {
    "id": 697,
    "text": "print(\"Error in expression: \" .. res)",
    "type": "statement:functioncall"
  }, {
    "id": 698,
    "text": "for l, v in pairs(breakpoints) do\r\n      for f in pairs(v) do\r\n        print(f .. \": \" .. l)\r\n      end\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 699,
    "text": "for f in pairs(v) do\r\n        print(f .. \": \" .. l)\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 700,
    "text": "print(f .. \": \" .. l)",
    "type": "statement:functioncall"
  }, {
    "id": 701,
    "text": "for i, v in pairs(watches) do\r\n      print(\"Watch exp. \" .. i .. \": \" .. v)\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 702,
    "text": "print(\"Watch exp. \" .. i .. \": \" .. v)",
    "type": "statement:functioncall"
  }, {
    "id": 703,
    "text": "client:send(\"SUSPEND\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 704,
    "text": "client:send(\"STACK\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 705,
    "text": "local resp = client:receive()",
    "type": "statement:localassign"
  }, {
    "id": 706,
    "text": "local _, _, status, res = string.find(resp, \"^(%d+)%s+%w+%s+(.+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 707,
    "text": "if status == \"200\" then\r\n      local func, err = loadstring(res)\r\n      if func == nil then\r\n        print(\"Error in stack information: \" .. err)\r\n        return nil, nil, err\r\n      end\r\n      local ok, stack = pcall(func)\r\n      if not ok then\r\n        print(\"Error in stack information: \" .. stack)\r\n        return nil, nil, stack\r\n      end\r\n      for _,frame in ipairs(stack) do\r\n        print(mobdebug.line(frame[1], {comment = false}))\r\n      end\r\n      return stack\r\n    elseif status == \"401\" then\r\n      local _, _, len = string.find(resp, \"%s+(%d+)%s*$\")\r\n      len = tonumber(len)\r\n      local res = len > 0 and client:receive(len) or \"Invalid stack information.\"\r\n      print(\"Error in expression: \" .. res)\r\n      return nil, nil, res\r\n    else\r\n      print(\"Unknown error\")\r\n      return nil, nil, \"Debugger error: unexpected response after STACK\"\r\n    end",
    "type": "statement:if"
  }, {
    "id": 708,
    "text": "local func, err = loadstring(res)",
    "type": "statement:localassign"
  }, {
    "id": 709,
    "text": "if func == nil then\r\n        print(\"Error in stack information: \" .. err)\r\n        return nil, nil, err\r\n      end",
    "type": "statement:if"
  }, {
    "id": 710,
    "text": "print(\"Error in stack information: \" .. err)",
    "type": "statement:functioncall"
  }, {
    "id": 711,
    "text": "local ok, stack = pcall(func)",
    "type": "statement:localassign"
  }, {
    "id": 712,
    "text": "if not ok then\r\n        print(\"Error in stack information: \" .. stack)\r\n        return nil, nil, stack\r\n      end",
    "type": "statement:if"
  }, {
    "id": 713,
    "text": "print(\"Error in stack information: \" .. stack)",
    "type": "statement:functioncall"
  }, {
    "id": 714,
    "text": "for _,frame in ipairs(stack) do\r\n        print(mobdebug.line(frame[1], {comment = false}))\r\n      end",
    "type": "statement:genericfor"
  }, {
    "id": 715,
    "text": "print(mobdebug.line(frame[1], {comment = false}))",
    "type": "statement:functioncall"
  }, {
    "id": 716,
    "text": "local _, _, len = string.find(resp, \"%s+(%d+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 717,
    "text": "local res = len > 0 and client:receive(len) or \"Invalid stack information.\"",
    "type": "statement:localassign"
  }, {
    "id": 718,
    "text": "local _, _, stream, mode = string.find(params, \"^[a-z]+%s+(%w+)%s+([dcr])%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 719,
    "text": "if stream and mode then\r\n      client:send(\"OUTPUT \"..stream..\" \"..mode..\"\\n\")\r\n      local resp, err = client:receive()\r\n      if not resp then\r\n        print(\"Unknown error: \"..err)\r\n        return nil, nil, \"Debugger connection error: \"..err\r\n      end\r\n      local _, _, status = string.find(resp, \"^(%d+)%s+%w+%s*$\")\r\n      if status == \"200\" then\r\n        print(\"Stream \"..stream..\" redirected\")\r\n        outputs[stream] = type(options) == 'table' and options.handler or nil\r\n      -- the client knows when she is doing, so install the handler\r\n      elseif type(options) == 'table' and options.handler then\r\n        outputs[stream] = options.handler\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: can't redirect \"..stream\r\n      end\r\n    else\r\n      print(\"Invalid command\")\r\n    end",
    "type": "statement:if"
  }, {
    "id": 720,
    "text": "client:send(\"OUTPUT \"..stream..\" \"..mode..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 721,
    "text": "local resp, err = client:receive()",
    "type": "statement:localassign"
  }, {
    "id": 722,
    "text": "if not resp then\r\n        print(\"Unknown error: \"..err)\r\n        return nil, nil, \"Debugger connection error: \"..err\r\n      end",
    "type": "statement:if"
  }, {
    "id": 723,
    "text": "print(\"Unknown error: \"..err)",
    "type": "statement:functioncall"
  }, {
    "id": 724,
    "text": "local _, _, status = string.find(resp, \"^(%d+)%s+%w+%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 725,
    "text": "if status == \"200\" then\r\n        print(\"Stream \"..stream..\" redirected\")\r\n        outputs[stream] = type(options) == 'table' and options.handler or nil\r\n      -- the client knows when she is doing, so install the handler\r\n      elseif type(options) == 'table' and options.handler then\r\n        outputs[stream] = options.handler\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: can't redirect \"..stream\r\n      end",
    "type": "statement:if"
  }, {
    "id": 726,
    "text": "print(\"Stream \"..stream..\" redirected\")",
    "type": "statement:functioncall"
  }, {
    "id": 727,
    "text": "outputs[stream] = type(options) == 'table' and options.handler or nil",
    "type": "statement:assign"
  }, {
    "id": 728,
    "text": "outputs[stream] = options.handler",
    "type": "statement:assign"
  }, {
    "id": 729,
    "text": "local _, _, dir = string.find(params, \"^[a-z]+%s+(.+)$\")",
    "type": "statement:localassign"
  }, {
    "id": 730,
    "text": "if dir then\r\n      dir = string.gsub(dir, \"\\\\\", \"/\") -- convert slash\r\n      if not string.find(dir, \"/$\") then dir = dir .. \"/\" end\r\n\r\n      local remdir = dir:match(\"\\t(.+)\")\r\n      if remdir then dir = dir:gsub(\"/?\\t.+\", \"/\") end\r\n      basedir = dir\r\n\r\n      client:send(\"BASEDIR \"..(remdir or dir)..\"\\n\")\r\n      local resp, err = client:receive()\r\n      if not resp then\r\n        print(\"Unknown error: \"..err)\r\n        return nil, nil, \"Debugger connection error: \"..err\r\n      end\r\n      local _, _, status = string.find(resp, \"^(%d+)%s+%w+%s*$\")\r\n      if status == \"200\" then\r\n        print(\"New base directory is \" .. basedir)\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: unexpected response after BASEDIR\"\r\n      end\r\n    else\r\n      print(basedir)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 731,
    "text": "dir = string.gsub(dir, \"\\\\\", \"/\")",
    "type": "statement:assign"
  }, {
    "id": 732,
    "text": "if not string.find(dir, \"/$\") then dir = dir .. \"/\" end",
    "type": "statement:if"
  }, {
    "id": 733,
    "text": "dir = dir .. \"/\"",
    "type": "statement:assign"
  }, {
    "id": 734,
    "text": "local remdir = dir:match(\"\\t(.+)\")",
    "type": "statement:localassign"
  }, {
    "id": 735,
    "text": "if remdir then dir = dir:gsub(\"/?\\t.+\", \"/\") end",
    "type": "statement:if"
  }, {
    "id": 736,
    "text": "dir = dir:gsub(\"/?\\t.+\", \"/\")",
    "type": "statement:assign"
  }, {
    "id": 737,
    "text": "basedir = dir",
    "type": "statement:assign"
  }, {
    "id": 738,
    "text": "client:send(\"BASEDIR \"..(remdir or dir)..\"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 739,
    "text": "if status == \"200\" then\r\n        print(\"New base directory is \" .. basedir)\r\n      else\r\n        print(\"Unknown error\")\r\n        return nil, nil, \"Debugger error: unexpected response after BASEDIR\"\r\n      end",
    "type": "statement:if"
  }, {
    "id": 740,
    "text": "print(\"New base directory is \" .. basedir)",
    "type": "statement:functioncall"
  }, {
    "id": 741,
    "text": "print(basedir)",
    "type": "statement:functioncall"
  }, {
    "id": 742,
    "text": "print(\"setb <file> <line>    -- sets a breakpoint\")",
    "type": "statement:functioncall"
  }, {
    "id": 743,
    "text": "print(\"delb <file> <line>    -- removes a breakpoint\")",
    "type": "statement:functioncall"
  }, {
    "id": 744,
    "text": "print(\"delallb               -- removes all breakpoints\")",
    "type": "statement:functioncall"
  }, {
    "id": 745,
    "text": "print(\"setw <exp>            -- adds a new watch expression\")",
    "type": "statement:functioncall"
  }, {
    "id": 746,
    "text": "print(\"delw <index>          -- removes the watch expression at index\")",
    "type": "statement:functioncall"
  }, {
    "id": 747,
    "text": "print(\"delallw               -- removes all watch expressions\")",
    "type": "statement:functioncall"
  }, {
    "id": 748,
    "text": "print(\"run                   -- runs until next breakpoint\")",
    "type": "statement:functioncall"
  }, {
    "id": 749,
    "text": "print(\"step                  -- runs until next line, stepping into function calls\")",
    "type": "statement:functioncall"
  }, {
    "id": 750,
    "text": "print(\"over                  -- runs until next line, stepping over function calls\")",
    "type": "statement:functioncall"
  }, {
    "id": 751,
    "text": "print(\"out                   -- runs until line after returning from current function\")",
    "type": "statement:functioncall"
  }, {
    "id": 752,
    "text": "print(\"listb                 -- lists breakpoints\")",
    "type": "statement:functioncall"
  }, {
    "id": 753,
    "text": "print(\"listw                 -- lists watch expressions\")",
    "type": "statement:functioncall"
  }, {
    "id": 754,
    "text": "print(\"eval <exp>            -- evaluates expression on the current context and returns its value\")",
    "type": "statement:functioncall"
  }, {
    "id": 755,
    "text": "print(\"exec <stmt>           -- executes statement on the current context\")",
    "type": "statement:functioncall"
  }, {
    "id": 756,
    "text": "print(\"load <file>           -- loads a local file for debugging\")",
    "type": "statement:functioncall"
  }, {
    "id": 757,
    "text": "print(\"reload                -- restarts the current debugging session\")",
    "type": "statement:functioncall"
  }, {
    "id": 758,
    "text": "print(\"stack                 -- reports stack trace\")",
    "type": "statement:functioncall"
  }, {
    "id": 759,
    "text": "print(\"output stdout <d|c|r> -- capture and redirect io stream (default|copy|redirect)\")",
    "type": "statement:functioncall"
  }, {
    "id": 760,
    "text": "print(\"basedir [<path>]      -- sets the base path of the remote application, or shows the current one\")",
    "type": "statement:functioncall"
  }, {
    "id": 761,
    "text": "print(\"done                  -- stops the debugger and continues application execution\")",
    "type": "statement:functioncall"
  }, {
    "id": 762,
    "text": "print(\"exit                  -- exits debugger and the application\")",
    "type": "statement:functioncall"
  }, {
    "id": 763,
    "text": "local _, _, spaces = string.find(params, \"^(%s*)$\")",
    "type": "statement:localassign"
  }, {
    "id": 764,
    "text": "if spaces then\r\n      return nil, nil, \"Empty command\"\r\n    else\r\n      print(\"Invalid command\")\r\n      return nil, nil, \"Invalid command\"\r\n    end",
    "type": "statement:if"
  }, {
    "id": 765,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 766,
    "text": "function() end",
    "type": "function"
  }, {
    "id": 767,
    "text": "local function listen(host, port)\r\n  host = host or \"*\"\r\n  port = port or mobdebug.port\r\n\r\n  local socket = require \"socket\"\r\n\r\n  print(\"Lua Remote Debugger\")\r\n  print(\"Run the program you wish to debug\")\r\n\r\n  local server = socket.bind(host, port)\r\n  local client = server:accept()\r\n\r\n  client:send(\"STEP\\n\")\r\n  client:receive()\r\n\r\n  local breakpoint = client:receive()\r\n  local _, _, file, line = string.find(breakpoint, \"^202 Paused%s+(.-)%s+(%d+)%s*$\")\r\n  if file and line then\r\n    print(\"Paused at file \" .. file )\r\n    print(\"Type 'help' for commands\")\r\n  else\r\n    local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)%s*$\")\r\n    if size then\r\n      print(\"Error in remote application: \")\r\n      print(client:receive(size))\r\n    end\r\n  end\r\n\r\n  while true do\r\n    io.write(\"> \")\r\n    local file, line, err = handle(io.read(\"*line\"), client)\r\n    if not file and err == false then break end -- completed debugging\r\n  end\r\n\r\n  client:close()\r\nend",
    "type": "function"
  }, {
    "id": 768,
    "text": "host = host or \"*\"",
    "type": "statement:assign"
  }, {
    "id": 769,
    "text": "port = port or mobdebug.port",
    "type": "statement:assign"
  }, {
    "id": 770,
    "text": "local socket = require \"socket\"",
    "type": "statement:localassign"
  }, {
    "id": 771,
    "text": "print(\"Lua Remote Debugger\")",
    "type": "statement:functioncall"
  }, {
    "id": 772,
    "text": "print(\"Run the program you wish to debug\")",
    "type": "statement:functioncall"
  }, {
    "id": 773,
    "text": "local server = socket.bind(host, port)",
    "type": "statement:localassign"
  }, {
    "id": 774,
    "text": "local client = server:accept()",
    "type": "statement:localassign"
  }, {
    "id": 775,
    "text": "client:send(\"STEP\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 776,
    "text": "local _, _, file, line = string.find(breakpoint, \"^202 Paused%s+(.-)%s+(%d+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 777,
    "text": "if file and line then\r\n    print(\"Paused at file \" .. file )\r\n    print(\"Type 'help' for commands\")\r\n  else\r\n    local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)%s*$\")\r\n    if size then\r\n      print(\"Error in remote application: \")\r\n      print(client:receive(size))\r\n    end\r\n  end",
    "type": "statement:if"
  }, {
    "id": 778,
    "text": "print(\"Paused at file \" .. file )",
    "type": "statement:functioncall"
  }, {
    "id": 779,
    "text": "print(\"Type 'help' for commands\")",
    "type": "statement:functioncall"
  }, {
    "id": 780,
    "text": "local _, _, size = string.find(breakpoint, \"^401 Error in Execution (%d+)%s*$\")",
    "type": "statement:localassign"
  }, {
    "id": 781,
    "text": "if size then\r\n      print(\"Error in remote application: \")\r\n      print(client:receive(size))\r\n    end",
    "type": "statement:if"
  }, {
    "id": 782,
    "text": "print(\"Error in remote application: \")",
    "type": "statement:functioncall"
  }, {
    "id": 783,
    "text": "print(client:receive(size))",
    "type": "statement:functioncall"
  }, {
    "id": 784,
    "text": "while true do\r\n    io.write(\"> \")\r\n    local file, line, err = handle(io.read(\"*line\"), client)\r\n    if not file and err == false then break end -- completed debugging\r\n  end",
    "type": "statement:while"
  }, {
    "id": 785,
    "text": "io.write(\"> \")",
    "type": "statement:functioncall"
  }, {
    "id": 786,
    "text": "local file, line, err = handle(io.read(\"*line\"), client)",
    "type": "statement:localassign"
  }, {
    "id": 787,
    "text": "if not file and err == false then break end",
    "type": "statement:if"
  }, {
    "id": 788,
    "text": "client:close()",
    "type": "statement:functioncall"
  }, {
    "id": 789,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 790,
    "text": "local function coro()\r\n  if cocreate then return end -- only set once\r\n  cocreate = cocreate or coroutine.create\r\n  coroutine.create = function(f, ...)\r\n    return cocreate(function(...)\r\n      mobdebug.on()\r\n      return f(...)\r\n    end, ...)\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 791,
    "text": "if cocreate then return end",
    "type": "statement:if"
  }, {
    "id": 792,
    "text": "cocreate = cocreate or coroutine.create",
    "type": "statement:assign"
  }, {
    "id": 793,
    "text": "coroutine.create = function(f, ...)\r\n    return cocreate(function(...)\r\n      mobdebug.on()\r\n      return f(...)\r\n    end, ...)\r\n  end",
    "type": "statement:assign"
  }, {
    "id": 794,
    "text": "mobdebug.on()",
    "type": "statement:functioncall"
  }, {
    "id": 795,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 796,
    "text": "function(f, ...)\r\n    return cocreate(function(...)\r\n      mobdebug.on()\r\n      return f(...)\r\n    end, ...)\r\n  end",
    "type": "function"
  }, {
    "id": 797,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 798,
    "text": "local function moai()\r\n  if moconew then return end -- only set once\r\n  moconew = moconew or (MOAICoroutine and MOAICoroutine.new)\r\n  if not moconew then return end\r\n  MOAICoroutine.new = function(...)\r\n    local thread = moconew(...)\r\n    -- need to support both thread.run and getmetatable(thread).run, which\r\n    -- was used in earlier MOAI versions\r\n    local mt = thread.run and thread or getmetatable(thread)\r\n    local patched = mt.run\r\n    mt.run = function(self, f, ...)\r\n      return patched(self,  function(...)\r\n        mobdebug.on()\r\n        return f(...)\r\n      end, ...)\r\n    end\r\n    return thread\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 799,
    "text": "if moconew then return end",
    "type": "statement:if"
  }, {
    "id": 800,
    "text": "moconew = moconew or (MOAICoroutine and MOAICoroutine.new)",
    "type": "statement:assign"
  }, {
    "id": 801,
    "text": "if not moconew then return end",
    "type": "statement:if"
  }, {
    "id": 802,
    "text": "MOAICoroutine.new = function(...)\r\n    local thread = moconew(...)\r\n    -- need to support both thread.run and getmetatable(thread).run, which\r\n    -- was used in earlier MOAI versions\r\n    local mt = thread.run and thread or getmetatable(thread)\r\n    local patched = mt.run\r\n    mt.run = function(self, f, ...)\r\n      return patched(self,  function(...)\r\n        mobdebug.on()\r\n        return f(...)\r\n      end, ...)\r\n    end\r\n    return thread\r\n  end",
    "type": "statement:assign"
  }, {
    "id": 803,
    "text": "local thread = moconew(...)",
    "type": "statement:localassign"
  }, {
    "id": 804,
    "text": "local mt = thread.run and thread or getmetatable(thread)",
    "type": "statement:localassign"
  }, {
    "id": 805,
    "text": "local patched = mt.run",
    "type": "statement:localassign"
  }, {
    "id": 806,
    "text": "mt.run = function(self, f, ...)\r\n      return patched(self,  function(...)\r\n        mobdebug.on()\r\n        return f(...)\r\n      end, ...)\r\n    end",
    "type": "statement:assign"
  }, {
    "id": 807,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 808,
    "text": "function(self, f, ...)\r\n      return patched(self,  function(...)\r\n        mobdebug.on()\r\n        return f(...)\r\n      end, ...)\r\n    end",
    "type": "function"
  }, {
    "id": 809,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 810,
    "text": "function(...)\r\n    local thread = moconew(...)\r\n    -- need to support both thread.run and getmetatable(thread).run, which\r\n    -- was used in earlier MOAI versions\r\n    local mt = thread.run and thread or getmetatable(thread)\r\n    local patched = mt.run\r\n    mt.run = function(self, f, ...)\r\n      return patched(self,  function(...)\r\n        mobdebug.on()\r\n        return f(...)\r\n      end, ...)\r\n    end\r\n    return thread\r\n  end",
    "type": "function"
  }, {
    "id": 811,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 812,
    "text": "function() step_into = true end",
    "type": "function"
  }, {
    "id": 813,
    "text": "function(b) if b then basedir = b end return basedir end",
    "type": "function"
  }, {
    "id": 814,
    "text": "if b then basedir = b end",
    "type": "statement:if"
  }, {
    "id": 815,
    "text": "basedir = b",
    "type": "statement:assign"
  }, {
    "id": 816,
    "text": "function(module)\r\n  local ok, res = pcall(require, module)\r\n  return ok and res or nil\r\nend",
    "type": "function"
  }, {
    "id": 817,
    "text": "local ok, res = pcall(require, module)",
    "type": "statement:localassign"
  }, {
    "id": 818,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 819,
    "text": "function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end",
    "type": "function"
  }, {
    "id": 820,
    "text": "function(a,b)\r\n      -- sort numeric keys first: k[key] is not nil for numerical keys\r\n      return (k[a] ~= nil and 0 or to[type(a)] or 'z')..(tostring(a):gsub(\"%d+\",padnum))\r\n           < (k[b] ~= nil and 0 or to[type(b)] or 'z')..(tostring(b):gsub(\"%d+\",padnum)) end",
    "type": "function"
  }, {
    "id": 821,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 822,
    "text": "function() return mt.__tostring and mt.__tostring(t) end",
    "type": "function"
  }, {
    "id": 823,
    "text": "function(t,k) return t end",
    "type": "function"
  }, {
    "id": 824,
    "text": "function(t,...) error(\"cannot call functions\") end",
    "type": "function"
  }, {
    "id": 825,
    "text": "function(a, opts) return s(a, merge({name = '_', compact = true, sparse = true}, opts)) end",
    "type": "function"
  }, {
    "id": 826,
    "text": "function(a, opts) return s(a, merge({sortkeys = true, comment = true}, opts)) end",
    "type": "function"
  }, {
    "id": 827,
    "text": "function(a, opts) return s(a, merge({indent = '  ', sortkeys = true, comment = true}, opts)) end",
    "type": "function"
  }, {
    "id": 828,
    "text": "function() ---- include Serpent module for serialization\r\nlocal n, v = \"serpent\", 0.285 -- (C) 2012-15 Paul Kulchenko; MIT License\r\nlocal c, d = \"Paul Kulchenko\", \"Lua serializer and pretty printer\"\r\nlocal snum = {[tostring(1/0)]='1/0 --[[math.huge]]',[tostring(-1/0)]='-1/0 --[[-math.huge]]',[tostring(0/0)]='0/0'}\r\nlocal badtype = {thread = true, userdata = true, cdata = true}\r\nlocal getmetatable = debug and debug.getmetatable or getmetatable\r\nlocal keyword, globals, G = {}, {}, (_G or _ENV)\r\nfor _,k in ipairs({'and', 'break', 'do', 'else', 'elseif', 'end', 'false',\r\n  'for', 'function', 'goto', 'if', 'in', 'local', 'nil', 'not', 'or', 'repeat',\r\n  'return', 'then', 'true', 'until', 'while'}) do keyword[k] = true end\r\nfor k,v in pairs(G) do globals[v] = k end -- build func to name mapping\r\nfor _,g in ipairs({'coroutine', 'debug', 'io', 'math', 'string', 'table', 'os'}) do\r\n  for k,v in pairs(type(G[g]) == 'table' and G[g] or {}) do globals[v] = g..'.'..k end end\r\n\r\nlocal function s(t, opts)\r\n  local name, indent, fatal, maxnum = opts.name, opts.indent, opts.fatal, opts.maxnum\r\n  local sparse, custom, huge = opts.sparse, opts.custom, not opts.nohuge\r\n  local space, maxl = (opts.compact and '' or ' '), (opts.maxlevel or math.huge)\r\n  local iname, comm = '_'..(name or ''), opts.comment and (tonumber(opts.comment) or math.huge)\r\n  local numformat = opts.numformat or \"%.17g\"\r\n  local seen, sref, syms, symn = {}, {'local '..iname..'={}'}, {}, 0\r\n  local function gensym(val) return '_'..(tostring(tostring(val)):gsub(\"[^%w]\",\"\"):gsub(\"(%d%w+)\",\r\n    -- tostring(val) is needed because __tostring may return a non-string value\r\n    function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end)) end\r\n  local function safestr(s) return type(s) == \"number\" and tostring(huge and snum[tostring(s)] or numformat:format(s))\r\n    or type(s) ~= \"string\" and tostring(s) -- escape NEWLINE/010 and EOF/026\r\n    or (\"%q\"):format(s):gsub(\"\\010\",\"n\"):gsub(\"\\026\",\"\\\\026\") end\r\n  local function comment(s,l) return comm and (l or 0) < comm and ' --[['..select(2, pcall(tostring, s))..']]' or '' end\r\n  local function globerr(s,l) return globals[s] and globals[s]..comment(s,l) or not fatal\r\n    and safestr(select(2, pcall(tostring, s))) or error(\"Can't serialize \"..tostring(s)) end\r\n  local function safename(path, name) -- generates foo.bar, foo[3], or foo['b a r']\r\n    local n = name == nil and '' or name\r\n    local plain = type(n) == \"string\" and n:match(\"^[%l%u_][%w_]*$\") and not keyword[n]\r\n    local safe = plain and n or '['..safestr(n)..']'\r\n    return (path or '')..(plain and path and '.' or '')..safe, safe end\r\n  local alphanumsort = type(opts.sortkeys) == 'function' and opts.sortkeys or function(k, o, n) -- k=keys, o=originaltable, n=padding\r\n    local maxn, to = tonumber(n) or 12, {number = 'a', string = 'b'}\r\n    local function padnum(d) return (\"%0\"..tostring(maxn)..\"d\"):format(tonumber(d)) end\r\n    table.sort(k, function(a,b)\r\n      -- sort numeric keys first: k[key] is not nil for numerical keys\r\n      return (k[a] ~= nil and 0 or to[type(a)] or 'z')..(tostring(a):gsub(\"%d+\",padnum))\r\n           < (k[b] ~= nil and 0 or to[type(b)] or 'z')..(tostring(b):gsub(\"%d+\",padnum)) end) end\r\n  local function val2str(t, name, indent, insref, path, plainindex, level)\r\n    local ttype, level, mt = type(t), (level or 0), getmetatable(t)\r\n    local spath, sname = safename(path, name)\r\n    local tag = plainindex and\r\n      ((type(name) == \"number\") and '' or name..space..'='..space) or\r\n      (name ~= nil and sname..space..'='..space or '')\r\n    if seen[t] then -- already seen this element\r\n      sref[#sref+1] = spath..space..'='..space..seen[t]\r\n      return tag..'nil'..comment('ref', level) end\r\n    -- protect from those cases where __tostring may fail\r\n    if type(mt) == 'table' and pcall(function() return mt.__tostring and mt.__tostring(t) end)\r\n    and (mt.__serialize or mt.__tostring) then -- knows how to serialize itself\r\n      seen[t] = insref or spath\r\n      if mt.__serialize then t = mt.__serialize(t) else t = tostring(t) end\r\n      ttype = type(t) end -- new value falls through to be serialized\r\n    if ttype == \"table\" then\r\n      if level >= maxl then return tag..'{}'..comment('max', level) end\r\n      seen[t] = insref or spath\r\n      if next(t) == nil then return tag..'{}'..comment(t, level) end -- table empty\r\n      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}\r\n      for key = 1, maxn do o[key] = key end\r\n      if not maxnum or #o < maxnum then\r\n        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables\r\n        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end\r\n      if maxnum and #o > maxnum then o[maxnum+1] = nil end\r\n      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end\r\n      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)\r\n      for n, key in ipairs(o) do\r\n        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse\r\n        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing\r\n        or opts.keyallow and not opts.keyallow[key]\r\n        or opts.keyignore and opts.keyignore[key]\r\n        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types\r\n        or sparse and value == nil then -- skipping nils; do nothing\r\n        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then\r\n          if not seen[key] and not globals[key] then\r\n            sref[#sref+1] = 'placeholder'\r\n            local sname = safename(iname, gensym(key)) -- iname is table for local variables\r\n            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end\r\n          sref[#sref+1] = 'placeholder'\r\n          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'\r\n          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))\r\n        else\r\n          out[#out+1] = val2str(value,key,indent,insref,seen[t],plainindex,level+1)\r\n        end\r\n      end\r\n      local prefix = string.rep(indent or '', level)\r\n      local head = indent and '{\\n'..prefix..indent or '{'\r\n      local body = table.concat(out, ','..(indent and '\\n'..prefix..indent or space))\r\n      local tail = indent and \"\\n\"..prefix..'}' or '}'\r\n      return (custom and custom(tag,head,body,tail) or tag..head..body..tail)..comment(t, level)\r\n    elseif badtype[ttype] then\r\n      seen[t] = insref or spath\r\n      return tag..globerr(t, level)\r\n    elseif ttype == 'function' then\r\n      seen[t] = insref or spath\r\n      local ok, res = pcall(string.dump, t)\r\n      local func = ok and ((opts.nocode and \"function() --[[..skipped..]] end\" or\r\n        \"((loadstring or load)(\"..safestr(res)..\",'@serialized'))\")..comment(t, level))\r\n      return tag..(func or globerr(t, level))\r\n    else return tag..safestr(t) end -- handle all other types\r\n  end\r\n  local sepr = indent and \"\\n\" or \";\"..space\r\n  local body = val2str(t, name, indent) -- this call also populates sref\r\n  local tail = #sref>1 and table.concat(sref, sepr)..sepr or ''\r\n  local warn = opts.comment and #sref>1 and space..\"--[[incomplete output with shared/self-references skipped]]\" or ''\r\n  return not name and body..warn or \"do local \"..body..sepr..tail..\"return \"..name..sepr..\"end\"\r\nend\r\n\r\nlocal function deserialize(data, opts)\r\n  local env = (opts and opts.safe == false) and G\r\n    or setmetatable({}, {\r\n        __index = function(t,k) return t end,\r\n        __call = function(t,...) error(\"cannot call functions\") end\r\n      })\r\n  local f, res = (loadstring or load)('return '..data, nil, nil, env)\r\n  if not f then f, res = (loadstring or load)(data, nil, nil, env) end\r\n  if not f then return f, res end\r\n  if setfenv then setfenv(f, env) end\r\n  return pcall(f)\r\nend\r\n\r\nlocal function merge(a, b) if b then for k,v in pairs(b) do a[k] = v end end; return a; end\r\nreturn { _NAME = n, _COPYRIGHT = c, _DESCRIPTION = d, _VERSION = v, serialize = s,\r\n  load = deserialize,\r\n  dump = function(a, opts) return s(a, merge({name = '_', compact = true, sparse = true}, opts)) end,\r\n  line = function(a, opts) return s(a, merge({sortkeys = true, comment = true}, opts)) end,\r\n  block = function(a, opts) return s(a, merge({indent = '  ', sortkeys = true, comment = true}, opts)) end }\r\nend",
    "type": "function"
  }, {
    "id": 829,
    "text": "local n, v = \"serpent\", 0.285",
    "type": "statement:localassign"
  }, {
    "id": 830,
    "text": "local c, d = \"Paul Kulchenko\", \"Lua serializer and pretty printer\"",
    "type": "statement:localassign"
  }, {
    "id": 831,
    "text": "local snum = {[tostring(1/0)]='1/0 --[[math.huge]]',[tostring(-1/0)]='-1/0 --[[-math.huge]]',[tostring(0/0)]='0/0'}",
    "type": "statement:localassign"
  }, {
    "id": 832,
    "text": "local badtype = {thread = true, userdata = true, cdata = true}",
    "type": "statement:localassign"
  }, {
    "id": 833,
    "text": "local getmetatable = debug and debug.getmetatable or getmetatable",
    "type": "statement:localassign"
  }, {
    "id": 834,
    "text": "local keyword, globals, G = {}, {}, (_G or _ENV)",
    "type": "statement:localassign"
  }, {
    "id": 835,
    "text": "for _,k in ipairs({'and', 'break', 'do', 'else', 'elseif', 'end', 'false',\r\n  'for', 'function', 'goto', 'if', 'in', 'local', 'nil', 'not', 'or', 'repeat',\r\n  'return', 'then', 'true', 'until', 'while'}) do keyword[k] = true end",
    "type": "statement:genericfor"
  }, {
    "id": 836,
    "text": "keyword[k] = true",
    "type": "statement:assign"
  }, {
    "id": 837,
    "text": "for k,v in pairs(G) do globals[v] = k end",
    "type": "statement:genericfor"
  }, {
    "id": 838,
    "text": "globals[v] = k",
    "type": "statement:assign"
  }, {
    "id": 839,
    "text": "for _,g in ipairs({'coroutine', 'debug', 'io', 'math', 'string', 'table', 'os'}) do\r\n  for k,v in pairs(type(G[g]) == 'table' and G[g] or {}) do globals[v] = g..'.'..k end end",
    "type": "statement:genericfor"
  }, {
    "id": 840,
    "text": "for k,v in pairs(type(G[g]) == 'table' and G[g] or {}) do globals[v] = g..'.'..k end",
    "type": "statement:genericfor"
  }, {
    "id": 841,
    "text": "globals[v] = g..'.'..k",
    "type": "statement:assign"
  }, {
    "id": 842,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 843,
    "text": "function()\r\n          -- wrapping into coroutine.wrap protects this function from\r\n          -- being stepped through in the debugger.\r\n          -- don't use vararg (...) as it adds a reference for its values,\r\n          -- which may affect how they are garbage collected\r\n          while true do\r\n            local tbl = {coroutine.yield()}\r\n            if mode == 'c' then iobase.print(unpack(tbl)) end\r\n            for n = 1, #tbl do\r\n              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end\r\n            local file = table.concat(tbl, \"\\t\")..\"\\n\"\r\n            server:send(\"204 Output \" .. stream .. \" \" .. tostring(#file) .. \"\\n\" .. file)\r\n          end\r\n        end",
    "type": "function"
  }, {
    "id": 844,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 845,
    "text": "function(...)\r\n      mobdebug.on()\r\n      return f(...)\r\n    end",
    "type": "function"
  }, {
    "id": 846,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 847,
    "text": "function(...)\r\n        mobdebug.on()\r\n        return f(...)\r\n      end",
    "type": "function"
  }, {
    "id": 848,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 849,
    "text": "",
    "type": "function container"
  }, {
    "id": 850,
    "text": "debug",
    "type": "module"
  }, {
    "id": 851,
    "text": "setlocal",
    "type": "global function"
  }, {
    "id": 852,
    "text": "setupvalue",
    "type": "global function"
  }, {
    "id": 853,
    "text": "getlocal",
    "type": "global function"
  }, {
    "id": 854,
    "text": "getinfo",
    "type": "global function"
  }, {
    "id": 855,
    "text": "getupvalue",
    "type": "global function"
  }, {
    "id": 856,
    "text": "socket",
    "type": "module"
  }, {
    "id": 857,
    "text": "tcp",
    "type": "global function"
  }, {
    "id": 858,
    "text": "sethook",
    "type": "global function"
  }, {
    "id": 859,
    "text": "bind",
    "type": "global function"
  }, {
    "id": 860,
    "text": "string",
    "type": "module"
  }, {
    "id": 861,
    "text": "upper",
    "type": "global function"
  }, {
    "id": 862,
    "text": "getenv",
    "type": "global function"
  }, {
    "id": 863,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 864,
    "text": "tonumber",
    "type": "global function"
  }, {
    "id": 865,
    "text": "rawget",
    "type": "global function"
  }, {
    "id": 866,
    "text": "find",
    "type": "global function"
  }, {
    "id": 867,
    "text": "on",
    "type": "global function"
  }, {
    "id": 868,
    "text": "ipairs",
    "type": "global function"
  }, {
    "id": 869,
    "text": "outputs[stream]",
    "type": "global function"
  }, {
    "id": 870,
    "text": "pcall",
    "type": "global function"
  }, {
    "id": 871,
    "text": "off",
    "type": "global function"
  }, {
    "id": 872,
    "text": "min",
    "type": "global function"
  }, {
    "id": 873,
    "text": "__serialize",
    "type": "global function"
  }, {
    "id": 874,
    "text": "wxGetApp",
    "type": "global function"
  }, {
    "id": 875,
    "text": "find",
    "type": "global function"
  }, {
    "id": 876,
    "text": "coroutine",
    "type": "module"
  }, {
    "id": 877,
    "text": "yield",
    "type": "global function"
  }, {
    "id": 878,
    "text": "custom",
    "type": "global function"
  }, {
    "id": 879,
    "text": "yield",
    "type": "global function"
  }, {
    "id": 880,
    "text": "sub",
    "type": "global function"
  }, {
    "id": 881,
    "text": "table",
    "type": "module"
  }, {
    "id": 882,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 883,
    "text": "next",
    "type": "global function"
  }, {
    "id": 884,
    "text": "linemap",
    "type": "global function"
  }, {
    "id": 885,
    "text": "connect",
    "type": "global function"
  }, {
    "id": 886,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 887,
    "text": "patched",
    "type": "global function"
  }, {
    "id": 888,
    "text": "gsub",
    "type": "global function"
  }, {
    "id": 889,
    "text": "done",
    "type": "global function"
  }, {
    "id": 890,
    "text": "lower",
    "type": "global function"
  }, {
    "id": 891,
    "text": "wx.wxPlatformInfo.Get",
    "type": "global function"
  }, {
    "id": 892,
    "text": "getmetatable",
    "type": "global function"
  }, {
    "id": 893,
    "text": "unpack",
    "type": "global function"
  }, {
    "id": 894,
    "text": "io",
    "type": "module"
  }, {
    "id": 895,
    "text": "write",
    "type": "global function"
  }, {
    "id": 896,
    "text": "read",
    "type": "global function"
  }, {
    "id": 897,
    "text": "loadstring",
    "type": "global function"
  }, {
    "id": 898,
    "text": "running",
    "type": "global function"
  }, {
    "id": 899,
    "text": "type",
    "type": "global function"
  }, {
    "id": 900,
    "text": "dtraceback",
    "type": "global function"
  }, {
    "id": 901,
    "text": "coroyield",
    "type": "global function"
  }, {
    "id": 902,
    "text": "line",
    "type": "global function"
  }, {
    "id": 903,
    "text": "f",
    "type": "global function"
  }, {
    "id": 904,
    "text": "cocreate",
    "type": "global function"
  }, {
    "id": 905,
    "text": "corocreate",
    "type": "global function"
  }, {
    "id": 906,
    "text": "open",
    "type": "global function"
  }, {
    "id": 907,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 908,
    "text": "error",
    "type": "global function"
  }, {
    "id": 909,
    "text": "wxTimer",
    "type": "global function"
  }, {
    "id": 910,
    "text": "set_encoding",
    "type": "global function"
  }, {
    "id": 911,
    "text": "sub",
    "type": "global function"
  }, {
    "id": 912,
    "text": "short_path",
    "type": "global function"
  }, {
    "id": 913,
    "text": "sort",
    "type": "global function"
  }, {
    "id": 914,
    "text": "__tostring",
    "type": "global function"
  }, {
    "id": 915,
    "text": "print",
    "type": "global function"
  }, {
    "id": 916,
    "text": "print",
    "type": "global function"
  }, {
    "id": 917,
    "text": "moconew",
    "type": "global function"
  }, {
    "id": 918,
    "text": "onexit",
    "type": "global function"
  }, {
    "id": 919,
    "text": "cororesume",
    "type": "global function"
  }, {
    "id": 920,
    "text": "rep",
    "type": "global function"
  }, {
    "id": 921,
    "text": "loadstring",
    "type": "global function"
  }, {
    "id": 922,
    "text": "corowrap",
    "type": "global function"
  }, {
    "id": 923,
    "text": "setmetatable",
    "type": "global function"
  }, {
    "id": 924,
    "text": "select",
    "type": "global function"
  }, {
    "id": 925,
    "text": "corostatus",
    "type": "global function"
  }, {
    "id": 926,
    "text": "require",
    "type": "global function"
  }, {
    "id": 927,
    "text": "onscratch",
    "type": "global function"
  }, {
    "id": 928,
    "text": "gsub",
    "type": "global function"
  }, {
    "id": 929,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 930,
    "text": "",
    "type": "variable container"
  }, {
    "id": 931,
    "text": "",
    "type": "require container"
  }, {
    "id": 932,
    "text": "",
    "type": "local variable"
  }, {
    "id": 933,
    "text": "",
    "type": "n/a"
  }, {
    "id": 934,
    "text": "",
    "type": "local variable"
  }, {
    "id": 935,
    "text": "",
    "type": "n/a"
  }, {
    "id": 936,
    "text": "",
    "type": "local variable"
  }, {
    "id": 937,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 938,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 939,
    "text": "",
    "type": "string"
  }, {
    "id": 940,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 941,
    "text": "",
    "type": "string"
  }, {
    "id": 942,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 943,
    "text": "",
    "type": "string"
  }, {
    "id": 944,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 945,
    "text": "",
    "type": "string"
  }, {
    "id": 946,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 947,
    "text": "",
    "type": "number"
  }, {
    "id": 948,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 949,
    "text": "",
    "type": "number"
  }, {
    "id": 950,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 951,
    "text": "",
    "type": "number"
  }, {
    "id": 952,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 953,
    "text": "",
    "type": "number"
  }, {
    "id": 954,
    "text": "",
    "type": "local variable"
  }, {
    "id": 955,
    "text": "",
    "type": "string"
  }, {
    "id": 956,
    "text": "",
    "type": "local variable"
  }, {
    "id": 957,
    "text": "",
    "type": "n/a"
  }, {
    "id": 958,
    "text": "",
    "type": "local variable"
  }, {
    "id": 959,
    "text": "",
    "type": "n/a"
  }, {
    "id": 960,
    "text": "",
    "type": "local variable"
  }, {
    "id": 961,
    "text": "",
    "type": "n/a"
  }, {
    "id": 962,
    "text": "",
    "type": "local variable"
  }, {
    "id": 963,
    "text": "",
    "type": "n/a"
  }, {
    "id": 964,
    "text": "",
    "type": "local variable"
  }, {
    "id": 965,
    "text": "",
    "type": "n/a"
  }, {
    "id": 966,
    "text": "",
    "type": "local variable"
  }, {
    "id": 967,
    "text": "",
    "type": "n/a"
  }, {
    "id": 968,
    "text": "",
    "type": "local variable"
  }, {
    "id": 969,
    "text": "",
    "type": "n/a"
  }, {
    "id": 970,
    "text": "",
    "type": "local variable"
  }, {
    "id": 971,
    "text": "",
    "type": "n/a"
  }, {
    "id": 972,
    "text": "",
    "type": "local variable"
  }, {
    "id": 973,
    "text": "",
    "type": "n/a"
  }, {
    "id": 974,
    "text": "",
    "type": "local variable"
  }, {
    "id": 975,
    "text": "",
    "type": "n/a"
  }, {
    "id": 976,
    "text": "",
    "type": "local variable"
  }, {
    "id": 977,
    "text": "",
    "type": "n/a"
  }, {
    "id": 978,
    "text": "",
    "type": "local variable"
  }, {
    "id": 979,
    "text": "",
    "type": "n/a"
  }, {
    "id": 980,
    "text": "",
    "type": "local variable"
  }, {
    "id": 981,
    "text": "",
    "type": "n/a"
  }, {
    "id": 982,
    "text": "",
    "type": "local variable"
  }, {
    "id": 983,
    "text": "",
    "type": "n/a"
  }, {
    "id": 984,
    "text": "",
    "type": "local variable"
  }, {
    "id": 985,
    "text": "",
    "type": "n/a"
  }, {
    "id": 986,
    "text": "",
    "type": "local variable"
  }, {
    "id": 987,
    "text": "",
    "type": "n/a"
  }, {
    "id": 988,
    "text": "",
    "type": "local variable"
  }, {
    "id": 989,
    "text": "",
    "type": "n/a"
  }, {
    "id": 990,
    "text": "",
    "type": "local variable"
  }, {
    "id": 991,
    "text": "",
    "type": "n/a"
  }, {
    "id": 992,
    "text": "",
    "type": "local variable"
  }, {
    "id": 993,
    "text": "",
    "type": "n/a"
  }, {
    "id": 994,
    "text": "",
    "type": "local variable"
  }, {
    "id": 995,
    "text": "",
    "type": "n/a"
  }, {
    "id": 996,
    "text": "",
    "type": "local variable"
  }, {
    "id": 997,
    "text": "",
    "type": "n/a"
  }, {
    "id": 998,
    "text": "",
    "type": "local variable"
  }, {
    "id": 999,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1000,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1001,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1002,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1003,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1004,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1005,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1006,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1007,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1008,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1009,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 1010,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1011,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 1012,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 1013,
    "text": "",
    "type": "number"
  }, {
    "id": 1014,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 1015,
    "text": "",
    "type": "number"
  }, {
    "id": 1016,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 1017,
    "text": "",
    "type": "number"
  }, {
    "id": 1018,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 1019,
    "text": "",
    "type": "number"
  }, {
    "id": 1020,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1021,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 1022,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1023,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 1024,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1025,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1026,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1027,
    "text": "",
    "type": "number"
  }, {
    "id": 1028,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1029,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1030,
    "text": "",
    "type": "boolean"
  }, {
    "id": 1031,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1032,
    "text": "",
    "type": "number"
  }, {
    "id": 1033,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1034,
    "text": "",
    "type": "boolean"
  }, {
    "id": 1035,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1036,
    "text": "",
    "type": "boolean"
  }, {
    "id": 1037,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1038,
    "text": "",
    "type": "number"
  }, {
    "id": 1039,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1040,
    "text": "",
    "type": "number"
  }, {
    "id": 1041,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1042,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1043,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1044,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 1045,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1046,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 1047,
    "text": "",
    "type": "table assign node"
  }, {
    "id": 1048,
    "text": "",
    "type": "_prefixexp"
  }, {
    "id": 1049,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1050,
    "text": "",
    "type": "string"
  }, {
    "id": 1051,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1052,
    "text": "",
    "type": "string"
  }, {
    "id": 1053,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1054,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1055,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1056,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1057,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1058,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1059,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1060,
    "text": "",
    "type": "local variable"
  }, {
    "id": 1061,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1062,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1063,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1064,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1065,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1066,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1067,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1068,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1069,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1070,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1071,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1072,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1073,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1074,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1075,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1076,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1077,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1078,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1079,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1080,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1081,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1082,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1083,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1084,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1085,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1086,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1087,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1088,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1089,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1090,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1091,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1092,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1093,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1094,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1095,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1096,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1097,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1098,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1099,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1100,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1101,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1102,
    "text": "",
    "type": "global variable"
  }, {
    "id": 1103,
    "text": "",
    "type": "n/a"
  }, {
    "id": 1104,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 1105,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 1106,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 1107,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 1108,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 1109,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 1110,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 1111,
    "text": "",
    "type": "interface container"
  }, {
    "id": 1112,
    "text": "",
    "type": "interface"
  } ]
}