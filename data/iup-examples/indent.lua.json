{
  "_filename": "indent.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/iup-examples/examples/Lua/indent.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "has",
    "to": 3
  }, {
    "from": 3,
    "label": "has",
    "to": 4
  }, {
    "from": 2,
    "label": "has",
    "to": 5
  }, {
    "from": 6,
    "label": "has",
    "to": 7
  }, {
    "from": 6,
    "label": "has",
    "to": 8
  }, {
    "from": 9,
    "label": "has",
    "to": 7
  }, {
    "from": 9,
    "label": "has",
    "to": 10
  }, {
    "from": 11,
    "label": "has",
    "to": 12
  }, {
    "from": 12,
    "label": "has",
    "to": 13
  }, {
    "from": 12,
    "label": "has",
    "to": 14
  }, {
    "from": 12,
    "label": "has",
    "to": 15
  }, {
    "from": 15,
    "label": "has",
    "to": 16
  }, {
    "from": 11,
    "label": "has",
    "to": 7
  }, {
    "from": 11,
    "label": "has",
    "to": 7
  }, {
    "from": 11,
    "label": "has",
    "to": 17
  }, {
    "from": 18,
    "label": "has",
    "to": 13
  }, {
    "from": 18,
    "label": "has",
    "to": 19
  }, {
    "from": 18,
    "label": "has",
    "to": 7
  }, {
    "from": 18,
    "label": "has",
    "to": 20
  }, {
    "from": 20,
    "label": "has",
    "to": 21
  }, {
    "from": 20,
    "label": "has",
    "to": 22
  }, {
    "from": 18,
    "label": "has",
    "to": 7
  }, {
    "from": 18,
    "label": "has",
    "to": 7
  }, {
    "from": 18,
    "label": "has",
    "to": 7
  }, {
    "from": 18,
    "label": "has",
    "to": 23
  }, {
    "from": 24,
    "label": "has",
    "to": 25
  }, {
    "from": 25,
    "label": "has",
    "to": 13
  }, {
    "from": 25,
    "label": "has",
    "to": 14
  }, {
    "from": 25,
    "label": "has",
    "to": 26
  }, {
    "from": 26,
    "label": "has",
    "to": 16
  }, {
    "from": 24,
    "label": "has",
    "to": 7
  }, {
    "from": 24,
    "label": "has",
    "to": 7
  }, {
    "from": 24,
    "label": "has",
    "to": 7
  }, {
    "from": 24,
    "label": "has",
    "to": 27
  }, {
    "from": 28,
    "label": "has",
    "to": 29
  }, {
    "from": 29,
    "label": "has",
    "to": 13
  }, {
    "from": 29,
    "label": "has",
    "to": 14
  }, {
    "from": 29,
    "label": "has",
    "to": 30
  }, {
    "from": 30,
    "label": "has",
    "to": 16
  }, {
    "from": 28,
    "label": "has",
    "to": 7
  }, {
    "from": 28,
    "label": "has",
    "to": 7
  }, {
    "from": 28,
    "label": "has",
    "to": 7
  }, {
    "from": 28,
    "label": "has",
    "to": 7
  }, {
    "from": 28,
    "label": "has",
    "to": 31
  }, {
    "from": 32,
    "label": "has",
    "to": 33
  }, {
    "from": 33,
    "label": "has",
    "to": 13
  }, {
    "from": 33,
    "label": "has",
    "to": 34
  }, {
    "from": 33,
    "label": "has",
    "to": 16
  }, {
    "from": 32,
    "label": "has",
    "to": 7
  }, {
    "from": 32,
    "label": "has",
    "to": 35
  }, {
    "from": 36,
    "label": "has",
    "to": 13
  }, {
    "from": 36,
    "label": "has",
    "to": 37
  }, {
    "from": 37,
    "label": "has",
    "to": 38
  }, {
    "from": 37,
    "label": "has",
    "to": 39
  }, {
    "from": 37,
    "label": "has",
    "to": 40
  }, {
    "from": 40,
    "label": "has",
    "to": 41
  }, {
    "from": 40,
    "label": "has",
    "to": 39
  }, {
    "from": 37,
    "label": "has",
    "to": 42
  }, {
    "from": 36,
    "label": "has",
    "to": 7
  }, {
    "from": 36,
    "label": "has",
    "to": 7
  }, {
    "from": 36,
    "label": "has",
    "to": 7
  }, {
    "from": 36,
    "label": "has",
    "to": 43
  }, {
    "from": 44,
    "label": "has",
    "to": 45
  }, {
    "from": 44,
    "label": "has",
    "to": 46
  }, {
    "from": 46,
    "label": "has",
    "to": 13
  }, {
    "from": 46,
    "label": "has",
    "to": 47
  }, {
    "from": 46,
    "label": "has",
    "to": 48
  }, {
    "from": 48,
    "label": "has",
    "to": 49
  }, {
    "from": 49,
    "label": "has",
    "to": 50
  }, {
    "from": 49,
    "label": "has",
    "to": 51
  }, {
    "from": 48,
    "label": "has",
    "to": 52
  }, {
    "from": 52,
    "label": "has",
    "to": 53
  }, {
    "from": 48,
    "label": "has",
    "to": 51
  }, {
    "from": 46,
    "label": "has",
    "to": 16
  }, {
    "from": 44,
    "label": "has",
    "to": 7
  }, {
    "from": 44,
    "label": "has",
    "to": 7
  }, {
    "from": 44,
    "label": "has",
    "to": 54
  }, {
    "from": 55,
    "label": "has",
    "to": 56
  }, {
    "from": 55,
    "label": "has",
    "to": 57
  }, {
    "from": 57,
    "label": "has",
    "to": 58
  }, {
    "from": 55,
    "label": "has",
    "to": 7
  }, {
    "from": 55,
    "label": "has",
    "to": 13
  }, {
    "from": 55,
    "label": "has",
    "to": 59
  }, {
    "from": 59,
    "label": "has",
    "to": 60
  }, {
    "from": 59,
    "label": "has",
    "to": 61
  }, {
    "from": 59,
    "label": "has",
    "to": 62
  }, {
    "from": 59,
    "label": "has",
    "to": 16
  }, {
    "from": 55,
    "label": "has",
    "to": 7
  }, {
    "from": 55,
    "label": "has",
    "to": 7
  }, {
    "from": 55,
    "label": "has",
    "to": 63
  }, {
    "from": 64,
    "label": "has",
    "to": 65
  }, {
    "from": 64,
    "label": "has",
    "to": 66
  }, {
    "from": 66,
    "label": "has",
    "to": 13
  }, {
    "from": 66,
    "label": "has",
    "to": 47
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 67,
    "label": "has",
    "to": 68
  }, {
    "from": 66,
    "label": "has",
    "to": 69
  }, {
    "from": 69,
    "label": "has",
    "to": 70
  }, {
    "from": 69,
    "label": "has",
    "to": 71
  }, {
    "from": 66,
    "label": "has",
    "to": 16
  }, {
    "from": 64,
    "label": "has",
    "to": 7
  }, {
    "from": 64,
    "label": "has",
    "to": 7
  }, {
    "from": 64,
    "label": "has",
    "to": 72
  }, {
    "from": 73,
    "label": "has",
    "to": 13
  }, {
    "from": 73,
    "label": "has",
    "to": 74
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 75
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 76
  }, {
    "from": 76,
    "label": "has",
    "to": 77
  }, {
    "from": 77,
    "label": "has",
    "to": 16
  }, {
    "from": 77,
    "label": "has",
    "to": 60
  }, {
    "from": 77,
    "label": "has",
    "to": 78
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 79
  }, {
    "from": 73,
    "label": "has",
    "to": 80
  }, {
    "from": 80,
    "label": "has",
    "to": 81
  }, {
    "from": 80,
    "label": "has",
    "to": 82
  }, {
    "from": 82,
    "label": "has",
    "to": 21
  }, {
    "from": 82,
    "label": "has",
    "to": 83
  }, {
    "from": 80,
    "label": "has",
    "to": 84
  }, {
    "from": 80,
    "label": "has",
    "to": 85
  }, {
    "from": 80,
    "label": "has",
    "to": 86
  }, {
    "from": 86,
    "label": "has",
    "to": 56
  }, {
    "from": 86,
    "label": "has",
    "to": 87
  }, {
    "from": 80,
    "label": "has",
    "to": 88
  }, {
    "from": 88,
    "label": "has",
    "to": 21
  }, {
    "from": 88,
    "label": "has",
    "to": 89
  }, {
    "from": 88,
    "label": "has",
    "to": 90
  }, {
    "from": 80,
    "label": "has",
    "to": 91
  }, {
    "from": 91,
    "label": "has",
    "to": 21
  }, {
    "from": 91,
    "label": "has",
    "to": 92
  }, {
    "from": 91,
    "label": "has",
    "to": 93
  }, {
    "from": 93,
    "label": "has",
    "to": 94
  }, {
    "from": 93,
    "label": "has",
    "to": 95
  }, {
    "from": 80,
    "label": "has",
    "to": 96
  }, {
    "from": 96,
    "label": "has",
    "to": 21
  }, {
    "from": 96,
    "label": "has",
    "to": 97
  }, {
    "from": 80,
    "label": "has",
    "to": 98
  }, {
    "from": 98,
    "label": "has",
    "to": 21
  }, {
    "from": 98,
    "label": "has",
    "to": 99
  }, {
    "from": 80,
    "label": "has",
    "to": 100
  }, {
    "from": 100,
    "label": "has",
    "to": 21
  }, {
    "from": 100,
    "label": "has",
    "to": 101
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 7
  }, {
    "from": 73,
    "label": "has",
    "to": 102
  }, {
    "from": 103,
    "label": "has",
    "to": 7
  }, {
    "from": 103,
    "label": "has",
    "to": 104
  }, {
    "from": 105,
    "label": "has",
    "to": 7
  }, {
    "from": 105,
    "label": "has",
    "to": 106
  }, {
    "from": 107,
    "label": "has",
    "to": 108
  }, {
    "from": 107,
    "label": "has",
    "to": 109
  }, {
    "from": 107,
    "label": "has",
    "to": 7
  }, {
    "from": 107,
    "label": "has",
    "to": 110
  }, {
    "from": 107,
    "label": "has",
    "to": 111
  }, {
    "from": 107,
    "label": "has",
    "to": 112
  }, {
    "from": 107,
    "label": "has",
    "to": 113
  }, {
    "from": 107,
    "label": "has",
    "to": 114
  }, {
    "from": 107,
    "label": "has",
    "to": 115
  }, {
    "from": 107,
    "label": "has",
    "to": 116
  }, {
    "from": 107,
    "label": "has",
    "to": 117
  }, {
    "from": 117,
    "label": "has",
    "to": 118
  }, {
    "from": 117,
    "label": "has",
    "to": 119
  }, {
    "from": 117,
    "label": "has",
    "to": 120
  }, {
    "from": 117,
    "label": "has",
    "to": 121
  }, {
    "from": 117,
    "label": "has",
    "to": 122
  }, {
    "from": 122,
    "label": "has",
    "to": 123
  }, {
    "from": 123,
    "label": "has",
    "to": 124
  }, {
    "from": 122,
    "label": "has",
    "to": 125
  }, {
    "from": 122,
    "label": "has",
    "to": 126
  }, {
    "from": 122,
    "label": "has",
    "to": 127
  }, {
    "from": 122,
    "label": "has",
    "to": 125
  }, {
    "from": 122,
    "label": "has",
    "to": 126
  }, {
    "from": 122,
    "label": "has",
    "to": 128
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 122,
    "label": "has",
    "to": 130
  }, {
    "from": 122,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 131,
    "label": "has",
    "to": 133
  }, {
    "from": 133,
    "label": "has",
    "to": 134
  }, {
    "from": 133,
    "label": "has",
    "to": 135
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 136,
    "label": "has",
    "to": 137
  }, {
    "from": 136,
    "label": "has",
    "to": 138
  }, {
    "from": 122,
    "label": "has",
    "to": 139
  }, {
    "from": 139,
    "label": "has",
    "to": 140
  }, {
    "from": 139,
    "label": "has",
    "to": 141
  }, {
    "from": 139,
    "label": "has",
    "to": 142
  }, {
    "from": 139,
    "label": "has",
    "to": 143
  }, {
    "from": 139,
    "label": "has",
    "to": 127
  }, {
    "from": 117,
    "label": "has",
    "to": 144
  }, {
    "from": 107,
    "label": "has",
    "to": 7
  }, {
    "from": 107,
    "label": "has",
    "to": 145
  }, {
    "from": 146,
    "label": "has",
    "to": 147
  }, {
    "from": 146,
    "label": "has",
    "to": 148
  }, {
    "from": 148,
    "label": "has",
    "to": 149
  }, {
    "from": 146,
    "label": "has",
    "to": 150
  }, {
    "from": 150,
    "label": "has",
    "to": 151
  }, {
    "from": 150,
    "label": "has",
    "to": 152
  }, {
    "from": 146,
    "label": "has",
    "to": 153
  }, {
    "from": 146,
    "label": "has",
    "to": 154
  }, {
    "from": 146,
    "label": "has",
    "to": 111
  }, {
    "from": 146,
    "label": "has",
    "to": 155
  }, {
    "from": 146,
    "label": "has",
    "to": 156
  }, {
    "from": 146,
    "label": "has",
    "to": 157
  }, {
    "from": 146,
    "label": "has",
    "to": 110
  }, {
    "from": 146,
    "label": "has",
    "to": 108
  }, {
    "from": 146,
    "label": "has",
    "to": 158
  }, {
    "from": 146,
    "label": "has",
    "to": 159
  }, {
    "from": 146,
    "label": "has",
    "to": 113
  }, {
    "from": 146,
    "label": "has",
    "to": 114
  }, {
    "from": 146,
    "label": "has",
    "to": 115
  }, {
    "from": 146,
    "label": "has",
    "to": 116
  }, {
    "from": 146,
    "label": "has",
    "to": 160
  }, {
    "from": 146,
    "label": "has",
    "to": 161
  }, {
    "from": 146,
    "label": "has",
    "to": 162
  }, {
    "from": 146,
    "label": "has",
    "to": 163
  }, {
    "from": 146,
    "label": "has",
    "to": 164
  }, {
    "from": 164,
    "label": "has",
    "to": 165
  }, {
    "from": 165,
    "label": "has",
    "to": 166
  }, {
    "from": 166,
    "label": "has",
    "to": 167
  }, {
    "from": 166,
    "label": "has",
    "to": 167
  }, {
    "from": 166,
    "label": "has",
    "to": 168
  }, {
    "from": 166,
    "label": "has",
    "to": 169
  }, {
    "from": 169,
    "label": "has",
    "to": 170
  }, {
    "from": 166,
    "label": "has",
    "to": 171
  }, {
    "from": 164,
    "label": "has",
    "to": 118
  }, {
    "from": 164,
    "label": "has",
    "to": 119
  }, {
    "from": 164,
    "label": "has",
    "to": 120
  }, {
    "from": 164,
    "label": "has",
    "to": 172
  }, {
    "from": 172,
    "label": "has",
    "to": 173
  }, {
    "from": 172,
    "label": "has",
    "to": 174
  }, {
    "from": 174,
    "label": "has",
    "to": 175
  }, {
    "from": 172,
    "label": "has",
    "to": 176
  }, {
    "from": 172,
    "label": "has",
    "to": 177
  }, {
    "from": 172,
    "label": "has",
    "to": 178
  }, {
    "from": 172,
    "label": "has",
    "to": 179
  }, {
    "from": 172,
    "label": "has",
    "to": 180
  }, {
    "from": 180,
    "label": "has",
    "to": 181
  }, {
    "from": 180,
    "label": "has",
    "to": 182
  }, {
    "from": 172,
    "label": "has",
    "to": 183
  }, {
    "from": 183,
    "label": "has",
    "to": 184
  }, {
    "from": 184,
    "label": "has",
    "to": 185
  }, {
    "from": 184,
    "label": "has",
    "to": 177
  }, {
    "from": 184,
    "label": "has",
    "to": 186
  }, {
    "from": 184,
    "label": "has",
    "to": 187
  }, {
    "from": 172,
    "label": "has",
    "to": 188
  }, {
    "from": 172,
    "label": "has",
    "to": 177
  }, {
    "from": 172,
    "label": "has",
    "to": 189
  }, {
    "from": 172,
    "label": "has",
    "to": 190
  }, {
    "from": 172,
    "label": "has",
    "to": 191
  }, {
    "from": 172,
    "label": "has",
    "to": 174
  }, {
    "from": 174,
    "label": "has",
    "to": 175
  }, {
    "from": 172,
    "label": "has",
    "to": 155
  }, {
    "from": 172,
    "label": "has",
    "to": 192
  }, {
    "from": 172,
    "label": "has",
    "to": 193
  }, {
    "from": 172,
    "label": "has",
    "to": 194
  }, {
    "from": 172,
    "label": "has",
    "to": 195
  }, {
    "from": 172,
    "label": "has",
    "to": 196
  }, {
    "from": 172,
    "label": "has",
    "to": 197
  }, {
    "from": 172,
    "label": "has",
    "to": 198
  }, {
    "from": 198,
    "label": "has",
    "to": 126
  }, {
    "from": 198,
    "label": "has",
    "to": 199
  }, {
    "from": 198,
    "label": "has",
    "to": 200
  }, {
    "from": 198,
    "label": "has",
    "to": 201
  }, {
    "from": 198,
    "label": "has",
    "to": 202
  }, {
    "from": 172,
    "label": "has",
    "to": 203
  }, {
    "from": 172,
    "label": "has",
    "to": 125
  }, {
    "from": 172,
    "label": "has",
    "to": 126
  }, {
    "from": 172,
    "label": "has",
    "to": 204
  }, {
    "from": 172,
    "label": "has",
    "to": 205
  }, {
    "from": 205,
    "label": "has",
    "to": 206
  }, {
    "from": 205,
    "label": "has",
    "to": 207
  }, {
    "from": 172,
    "label": "has",
    "to": 208
  }, {
    "from": 208,
    "label": "has",
    "to": 209
  }, {
    "from": 209,
    "label": "has",
    "to": 210
  }, {
    "from": 209,
    "label": "has",
    "to": 211
  }, {
    "from": 209,
    "label": "has",
    "to": 212
  }, {
    "from": 209,
    "label": "has",
    "to": 213
  }, {
    "from": 213,
    "label": "has",
    "to": 214
  }, {
    "from": 209,
    "label": "has",
    "to": 215
  }, {
    "from": 209,
    "label": "has",
    "to": 216
  }, {
    "from": 172,
    "label": "has",
    "to": 128
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 172,
    "label": "has",
    "to": 130
  }, {
    "from": 172,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 131,
    "label": "has",
    "to": 133
  }, {
    "from": 133,
    "label": "has",
    "to": 134
  }, {
    "from": 133,
    "label": "has",
    "to": 135
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 136,
    "label": "has",
    "to": 137
  }, {
    "from": 136,
    "label": "has",
    "to": 138
  }, {
    "from": 172,
    "label": "has",
    "to": 217
  }, {
    "from": 217,
    "label": "has",
    "to": 199
  }, {
    "from": 217,
    "label": "has",
    "to": 218
  }, {
    "from": 217,
    "label": "has",
    "to": 199
  }, {
    "from": 217,
    "label": "has",
    "to": 219
  }, {
    "from": 217,
    "label": "has",
    "to": 220
  }, {
    "from": 217,
    "label": "has",
    "to": 199
  }, {
    "from": 217,
    "label": "has",
    "to": 221
  }, {
    "from": 217,
    "label": "has",
    "to": 143
  }, {
    "from": 217,
    "label": "has",
    "to": 199
  }, {
    "from": 217,
    "label": "has",
    "to": 219
  }, {
    "from": 217,
    "label": "has",
    "to": 220
  }, {
    "from": 164,
    "label": "has",
    "to": 144
  }, {
    "from": 146,
    "label": "has",
    "to": 7
  }, {
    "from": 146,
    "label": "has",
    "to": 222
  }, {
    "from": 223,
    "label": "has",
    "to": 224
  }, {
    "from": 223,
    "label": "has",
    "to": 225
  }, {
    "from": 223,
    "label": "has",
    "to": 226
  }, {
    "from": 223,
    "label": "has",
    "to": 227
  }, {
    "from": 223,
    "label": "has",
    "to": 228
  }, {
    "from": 228,
    "label": "has",
    "to": 229
  }, {
    "from": 228,
    "label": "has",
    "to": 230
  }, {
    "from": 230,
    "label": "has",
    "to": 231
  }, {
    "from": 228,
    "label": "has",
    "to": 232
  }, {
    "from": 223,
    "label": "has",
    "to": 233
  }, {
    "from": 223,
    "label": "has",
    "to": 234
  }, {
    "from": 223,
    "label": "has",
    "to": 235
  }, {
    "from": 223,
    "label": "has",
    "to": 236
  }, {
    "from": 237,
    "label": "has",
    "to": 238
  }, {
    "from": 237,
    "label": "has",
    "to": 7
  }, {
    "from": 237,
    "label": "has",
    "to": 224
  }, {
    "from": 237,
    "label": "has",
    "to": 239
  }, {
    "from": 237,
    "label": "has",
    "to": 240
  }, {
    "from": 237,
    "label": "has",
    "to": 227
  }, {
    "from": 237,
    "label": "has",
    "to": 228
  }, {
    "from": 228,
    "label": "has",
    "to": 229
  }, {
    "from": 228,
    "label": "has",
    "to": 230
  }, {
    "from": 230,
    "label": "has",
    "to": 231
  }, {
    "from": 228,
    "label": "has",
    "to": 232
  }, {
    "from": 237,
    "label": "has",
    "to": 233
  }, {
    "from": 237,
    "label": "has",
    "to": 241
  }, {
    "from": 237,
    "label": "has",
    "to": 235
  }, {
    "from": 237,
    "label": "has",
    "to": 242
  }, {
    "from": 243,
    "label": "has",
    "to": 244
  }, {
    "from": 244,
    "label": "has",
    "to": 245
  }, {
    "from": 243,
    "label": "has",
    "to": 246
  }, {
    "from": 246,
    "label": "has",
    "to": 149
  }, {
    "from": 243,
    "label": "has",
    "to": 247
  }, {
    "from": 243,
    "label": "has",
    "to": 248
  }, {
    "from": 243,
    "label": "has",
    "to": 249
  }, {
    "from": 243,
    "label": "has",
    "to": 250
  }, {
    "from": 243,
    "label": "has",
    "to": 251
  }, {
    "from": 251,
    "label": "has",
    "to": 252
  }, {
    "from": 251,
    "label": "has",
    "to": 253
  }, {
    "from": 243,
    "label": "has",
    "to": 254
  }, {
    "from": 254,
    "label": "has",
    "to": 255
  }, {
    "from": 254,
    "label": "has",
    "to": 256
  }, {
    "from": 243,
    "label": "has",
    "to": 257
  }, {
    "from": 258,
    "label": "has",
    "to": 255
  }, {
    "from": 258,
    "label": "has",
    "to": 256
  }, {
    "from": 258,
    "label": "has",
    "to": 259
  }, {
    "from": 260,
    "label": "has",
    "to": 252
  }, {
    "from": 260,
    "label": "has",
    "to": 253
  }, {
    "from": 260,
    "label": "has",
    "to": 261
  }, {
    "from": 146,
    "label": "calls",
    "to": 263
  }, {
    "from": 223,
    "label": "calls",
    "to": 264
  }, {
    "from": 237,
    "label": "calls",
    "to": 264
  }, {
    "from": 73,
    "label": "calls",
    "to": 32
  }, {
    "from": 146,
    "label": "calls",
    "to": 2
  }, {
    "from": 146,
    "label": "calls",
    "to": 2
  }, {
    "from": 146,
    "label": "calls",
    "to": 2
  }, {
    "from": 55,
    "label": "calls",
    "to": 44
  }, {
    "from": 73,
    "label": "calls",
    "to": 44
  }, {
    "from": 107,
    "label": "calls",
    "to": 265
  }, {
    "from": 107,
    "label": "calls",
    "to": 265
  }, {
    "from": 146,
    "label": "calls",
    "to": 265
  }, {
    "from": 146,
    "label": "calls",
    "to": 265
  }, {
    "from": 146,
    "label": "calls",
    "to": 265
  }, {
    "from": 146,
    "label": "calls",
    "to": 265
  }, {
    "from": 223,
    "label": "calls",
    "to": 266
  }, {
    "from": 223,
    "label": "calls",
    "to": 266
  }, {
    "from": 237,
    "label": "calls",
    "to": 266
  }, {
    "from": 237,
    "label": "calls",
    "to": 266
  }, {
    "from": 6,
    "label": "calls",
    "to": 267
  }, {
    "from": 6,
    "label": "calls",
    "to": 267
  }, {
    "from": 9,
    "label": "calls",
    "to": 267
  }, {
    "from": 9,
    "label": "calls",
    "to": 267
  }, {
    "from": 107,
    "label": "calls",
    "to": 267
  }, {
    "from": 107,
    "label": "calls",
    "to": 267
  }, {
    "from": 146,
    "label": "calls",
    "to": 267
  }, {
    "from": 146,
    "label": "calls",
    "to": 267
  }, {
    "from": 146,
    "label": "calls",
    "to": 267
  }, {
    "from": 146,
    "label": "calls",
    "to": 267
  }, {
    "from": 146,
    "label": "calls",
    "to": 267
  }, {
    "from": 28,
    "label": "calls",
    "to": 24
  }, {
    "from": 73,
    "label": "calls",
    "to": 24
  }, {
    "from": 73,
    "label": "calls",
    "to": 55
  }, {
    "from": 146,
    "label": "calls",
    "to": 268
  }, {
    "from": 24,
    "label": "calls",
    "to": 18
  }, {
    "from": 28,
    "label": "calls",
    "to": 18
  }, {
    "from": 107,
    "label": "calls",
    "to": 272
  }, {
    "from": 107,
    "label": "calls",
    "to": 272
  }, {
    "from": 146,
    "label": "calls",
    "to": 272
  }, {
    "from": 55,
    "label": "calls",
    "to": 36
  }, {
    "from": 73,
    "label": "calls",
    "to": 36
  }, {
    "from": 243,
    "label": "calls",
    "to": 271
  }, {
    "from": 103,
    "label": "calls",
    "to": 270
  }, {
    "from": 105,
    "label": "calls",
    "to": 270
  }, {
    "from": 73,
    "label": "calls",
    "to": 28
  }, {
    "from": 18,
    "label": "calls",
    "to": 11
  }, {
    "from": 18,
    "label": "calls",
    "to": 11
  }, {
    "from": 73,
    "label": "calls",
    "to": 64
  }, {
    "from": 73,
    "label": "calls",
    "to": 64
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 262,
    "label": "calls",
    "to": 269
  }, {
    "from": 11,
    "label": "calls",
    "to": 269
  }, {
    "from": 18,
    "label": "calls",
    "to": 269
  }, {
    "from": 18,
    "label": "calls",
    "to": 269
  }, {
    "from": 24,
    "label": "calls",
    "to": 269
  }, {
    "from": 28,
    "label": "calls",
    "to": 269
  }, {
    "from": 32,
    "label": "calls",
    "to": 269
  }, {
    "from": 36,
    "label": "calls",
    "to": 269
  }, {
    "from": 36,
    "label": "calls",
    "to": 269
  }, {
    "from": 36,
    "label": "calls",
    "to": 269
  }, {
    "from": 44,
    "label": "calls",
    "to": 269
  }, {
    "from": 55,
    "label": "calls",
    "to": 269
  }, {
    "from": 55,
    "label": "calls",
    "to": 269
  }, {
    "from": 64,
    "label": "calls",
    "to": 269
  }, {
    "from": 73,
    "label": "calls",
    "to": 269
  }, {
    "from": 73,
    "label": "calls",
    "to": 269
  }, {
    "from": 73,
    "label": "calls",
    "to": 269
  }, {
    "from": 73,
    "label": "calls",
    "to": 269
  }, {
    "from": 73,
    "label": "calls",
    "to": 269
  }, {
    "from": 73,
    "label": "calls",
    "to": 269
  }, {
    "from": 73,
    "label": "calls",
    "to": 269
  }, {
    "from": 73,
    "label": "calls",
    "to": 269
  }, {
    "from": 73,
    "label": "calls",
    "to": 269
  }, {
    "from": 107,
    "label": "calls",
    "to": 73
  }, {
    "from": 146,
    "label": "calls",
    "to": 73
  }, {
    "from": 243,
    "label": "calls",
    "to": 237
  }, {
    "from": 223,
    "label": "calls",
    "to": 146
  }, {
    "from": 237,
    "label": "calls",
    "to": 107
  }, {
    "from": 1,
    "label": "contains",
    "to": 262
  }, {
    "from": 262,
    "label": "declares",
    "to": 2
  }, {
    "from": 262,
    "label": "declares",
    "to": 6
  }, {
    "from": 262,
    "label": "declares",
    "to": 9
  }, {
    "from": 262,
    "label": "declares",
    "to": 11
  }, {
    "from": 262,
    "label": "declares",
    "to": 18
  }, {
    "from": 262,
    "label": "declares",
    "to": 24
  }, {
    "from": 262,
    "label": "declares",
    "to": 28
  }, {
    "from": 262,
    "label": "declares",
    "to": 32
  }, {
    "from": 262,
    "label": "declares",
    "to": 36
  }, {
    "from": 262,
    "label": "declares",
    "to": 44
  }, {
    "from": 262,
    "label": "declares",
    "to": 55
  }, {
    "from": 262,
    "label": "declares",
    "to": 64
  }, {
    "from": 262,
    "label": "declares",
    "to": 73
  }, {
    "from": 262,
    "label": "declares",
    "to": 103
  }, {
    "from": 262,
    "label": "declares",
    "to": 105
  }, {
    "from": 262,
    "label": "declares",
    "to": 107
  }, {
    "from": 262,
    "label": "declares",
    "to": 146
  }, {
    "from": 262,
    "label": "declares",
    "to": 223
  }, {
    "from": 262,
    "label": "declares",
    "to": 237
  }, {
    "from": 262,
    "label": "declares",
    "to": 243
  }, {
    "from": 262,
    "label": "declares",
    "to": 258
  }, {
    "from": 262,
    "label": "declares",
    "to": 260
  }, {
    "from": 1,
    "label": "contains",
    "to": 273
  }, {
    "from": 1,
    "label": "contains",
    "to": 274
  }, {
    "from": 273,
    "label": "initializes",
    "to": 275
  }, {
    "from": 275,
    "label": "assigns",
    "to": 276
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "indent",
    "type": "module"
  }, {
    "id": 2,
    "text": "local function tableclear(t)\r\n        for k in next,t do\r\n            t[k] = nil\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 3,
    "text": "for k in next,t do\r\n            t[k] = nil\r\n        end",
    "type": "statement:genericfor"
  }, {
    "id": 4,
    "text": "t[k] = nil",
    "type": "statement:assign"
  }, {
    "id": 5,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 6,
    "text": "local function stringinsert(s, pos, insertStr)\r\n        return stringsub(s, 1, pos) .. insertStr .. stringsub(s, pos + 1)\r\n    end",
    "type": "function"
  }, {
    "id": 7,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 8,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 9,
    "text": "local function stringdelete(s, pos1, pos2)\r\n        return stringsub(s, 1, pos1 - 1) .. stringsub(s, pos2 + 1)\r\n    end",
    "type": "function"
  }, {
    "id": 10,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 11,
    "text": "local function nextNumberExponentPartInt(text, pos)\r\n        while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n            \r\n            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\t\r\n                pos = pos + 1\r\n            else\r\n                return tokens.TOKEN_NUMBER, pos \r\n            end\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 12,
    "text": "while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n            \r\n            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\t\r\n                pos = pos + 1\r\n            else\r\n                return tokens.TOKEN_NUMBER, pos \r\n            end\r\n        end",
    "type": "statement:while"
  }, {
    "id": 13,
    "text": "local byte = stringbyte(text, pos)",
    "type": "statement:localassign"
  }, {
    "id": 14,
    "text": "if not byte then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end",
    "type": "statement:if"
  }, {
    "id": 15,
    "text": "if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\t\r\n                pos = pos + 1\r\n            else\r\n                return tokens.TOKEN_NUMBER, pos \r\n            end",
    "type": "statement:if"
  }, {
    "id": 16,
    "text": "pos = pos + 1",
    "type": "statement:assign"
  }, {
    "id": 17,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 18,
    "text": "local function nextNumberExponentPart(text, pos)\r\n        local byte = stringbyte(text, pos)\r\n        if not byte then\r\n            return tokens.TOKEN_NUMBER, pos\r\n        end\r\n        \r\n        if byte == bytes.BYTE_MINUS then\r\n            -- handle this case: a = 1.2e-- some comment\r\n            -- i decide to let 1.2e be parsed as a a number\r\n            byte = stringbyte(text, pos + 1)\r\n            if byte == bytes.BYTE_MINUS then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n            return nextNumberExponentPartInt(text, pos + 1)\r\n        end\r\n        \r\n        return nextNumberExponentPartInt(text, pos)\r\n    end",
    "type": "function"
  }, {
    "id": 19,
    "text": "if not byte then\r\n            return tokens.TOKEN_NUMBER, pos\r\n        end",
    "type": "statement:if"
  }, {
    "id": 20,
    "text": "if byte == bytes.BYTE_MINUS then\r\n            -- handle this case: a = 1.2e-- some comment\r\n            -- i decide to let 1.2e be parsed as a a number\r\n            byte = stringbyte(text, pos + 1)\r\n            if byte == bytes.BYTE_MINUS then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n            return nextNumberExponentPartInt(text, pos + 1)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 21,
    "text": "byte = stringbyte(text, pos + 1)",
    "type": "statement:assign"
  }, {
    "id": 22,
    "text": "if byte == bytes.BYTE_MINUS then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end",
    "type": "statement:if"
  }, {
    "id": 23,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 24,
    "text": "local function nextNumberFractionPart(text, pos)\r\n        while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n            \r\n            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\t\r\n                pos = pos + 1\r\n            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then\r\n                return nextNumberExponentPart(text, pos + 1)\r\n            else\r\n                return tokens.TOKEN_NUMBER, pos \r\n            end\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 25,
    "text": "while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n            \r\n            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\t\r\n                pos = pos + 1\r\n            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then\r\n                return nextNumberExponentPart(text, pos + 1)\r\n            else\r\n                return tokens.TOKEN_NUMBER, pos \r\n            end\r\n        end",
    "type": "statement:while"
  }, {
    "id": 26,
    "text": "if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\t\r\n                pos = pos + 1\r\n            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then\r\n                return nextNumberExponentPart(text, pos + 1)\r\n            else\r\n                return tokens.TOKEN_NUMBER, pos \r\n            end",
    "type": "statement:if"
  }, {
    "id": 27,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 28,
    "text": "local function nextNumberIntPart(text, pos)\r\n        while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n            \r\n            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\t\r\n                pos = pos + 1\r\n            elseif byte == bytes.BYTE_PERIOD then\r\n                return nextNumberFractionPart(text, pos + 1)\r\n            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then\r\n                return nextNumberExponentPart(text, pos + 1)\r\n            else\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 29,
    "text": "while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n            \r\n            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\t\r\n                pos = pos + 1\r\n            elseif byte == bytes.BYTE_PERIOD then\r\n                return nextNumberFractionPart(text, pos + 1)\r\n            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then\r\n                return nextNumberExponentPart(text, pos + 1)\r\n            else\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end\r\n        end",
    "type": "statement:while"
  }, {
    "id": 30,
    "text": "if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\t\r\n                pos = pos + 1\r\n            elseif byte == bytes.BYTE_PERIOD then\r\n                return nextNumberFractionPart(text, pos + 1)\r\n            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then\r\n                return nextNumberExponentPart(text, pos + 1)\r\n            else\r\n                return tokens.TOKEN_NUMBER, pos\r\n            end",
    "type": "statement:if"
  }, {
    "id": 31,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 32,
    "text": "local function nextIdentifier(text, pos)\r\n        while true do\r\n            local byte = stringbyte(text, pos)\r\n            \r\n            if not byte or\r\n            linebreakCharacters[byte] or\r\n            whitespaceCharacters[byte] or\r\n            specialCharacters[byte] then\r\n                return tokens.TOKEN_IDENTIFIER, pos\r\n            end\r\n            pos = pos + 1\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 33,
    "text": "while true do\r\n            local byte = stringbyte(text, pos)\r\n            \r\n            if not byte or\r\n            linebreakCharacters[byte] or\r\n            whitespaceCharacters[byte] or\r\n            specialCharacters[byte] then\r\n                return tokens.TOKEN_IDENTIFIER, pos\r\n            end\r\n            pos = pos + 1\r\n        end",
    "type": "statement:while"
  }, {
    "id": 34,
    "text": "if not byte or\r\n            linebreakCharacters[byte] or\r\n            whitespaceCharacters[byte] or\r\n            specialCharacters[byte] then\r\n                return tokens.TOKEN_IDENTIFIER, pos\r\n            end",
    "type": "statement:if"
  }, {
    "id": 35,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 36,
    "text": "local function isBracketStringNext(text, pos)\r\n        local byte = stringbyte(text, pos)\r\n        if byte == bytes.BYTE_LEFTBRACKET then\r\n            local pos2 = pos + 1\r\n            byte = stringbyte(text, pos2)\r\n            while byte == bytes.BYTE_EQUALS do\r\n                pos2 = pos2 + 1\r\n                byte = stringbyte(text, pos2)\r\n            end\r\n            if byte == bytes.BYTE_LEFTBRACKET then\r\n                return true, pos2 + 1, (pos2 - 1) - pos\r\n            else\r\n                return false\r\n            end\r\n        else\r\n            return false\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 37,
    "text": "if byte == bytes.BYTE_LEFTBRACKET then\r\n            local pos2 = pos + 1\r\n            byte = stringbyte(text, pos2)\r\n            while byte == bytes.BYTE_EQUALS do\r\n                pos2 = pos2 + 1\r\n                byte = stringbyte(text, pos2)\r\n            end\r\n            if byte == bytes.BYTE_LEFTBRACKET then\r\n                return true, pos2 + 1, (pos2 - 1) - pos\r\n            else\r\n                return false\r\n            end\r\n        else\r\n            return false\r\n        end",
    "type": "statement:if"
  }, {
    "id": 38,
    "text": "local pos2 = pos + 1",
    "type": "statement:localassign"
  }, {
    "id": 39,
    "text": "byte = stringbyte(text, pos2)",
    "type": "statement:assign"
  }, {
    "id": 40,
    "text": "while byte == bytes.BYTE_EQUALS do\r\n                pos2 = pos2 + 1\r\n                byte = stringbyte(text, pos2)\r\n            end",
    "type": "statement:while"
  }, {
    "id": 41,
    "text": "pos2 = pos2 + 1",
    "type": "statement:assign"
  }, {
    "id": 42,
    "text": "if byte == bytes.BYTE_LEFTBRACKET then\r\n                return true, pos2 + 1, (pos2 - 1) - pos\r\n            else\r\n                return false\r\n            end",
    "type": "statement:if"
  }, {
    "id": 43,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 44,
    "text": "local function nextBracketString(text, pos, equalsCount)\r\n        local state = 0\r\n        while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_STRING, pos\r\n            end\r\n            \r\n            if byte == bytes.BYTE_RIGHTBRACKET then\r\n                if state == 0 then\r\n                    state = 1\r\n                elseif state == equalsCount + 1 then\r\n                    return tokens.TOKEN_STRING, pos + 1\r\n                else\r\n                    state = 0\r\n                end\r\n            elseif byte == bytes.BYTE_EQUALS then\r\n                if state > 0 then\r\n                    state = state + 1\r\n                end\r\n            else\r\n                state = 0\r\n            end\r\n            pos = pos + 1\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 45,
    "text": "local state = 0",
    "type": "statement:localassign"
  }, {
    "id": 46,
    "text": "while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_STRING, pos\r\n            end\r\n            \r\n            if byte == bytes.BYTE_RIGHTBRACKET then\r\n                if state == 0 then\r\n                    state = 1\r\n                elseif state == equalsCount + 1 then\r\n                    return tokens.TOKEN_STRING, pos + 1\r\n                else\r\n                    state = 0\r\n                end\r\n            elseif byte == bytes.BYTE_EQUALS then\r\n                if state > 0 then\r\n                    state = state + 1\r\n                end\r\n            else\r\n                state = 0\r\n            end\r\n            pos = pos + 1\r\n        end",
    "type": "statement:while"
  }, {
    "id": 47,
    "text": "if not byte then\r\n                return tokens.TOKEN_STRING, pos\r\n            end",
    "type": "statement:if"
  }, {
    "id": 48,
    "text": "if byte == bytes.BYTE_RIGHTBRACKET then\r\n                if state == 0 then\r\n                    state = 1\r\n                elseif state == equalsCount + 1 then\r\n                    return tokens.TOKEN_STRING, pos + 1\r\n                else\r\n                    state = 0\r\n                end\r\n            elseif byte == bytes.BYTE_EQUALS then\r\n                if state > 0 then\r\n                    state = state + 1\r\n                end\r\n            else\r\n                state = 0\r\n            end",
    "type": "statement:if"
  }, {
    "id": 49,
    "text": "if state == 0 then\r\n                    state = 1\r\n                elseif state == equalsCount + 1 then\r\n                    return tokens.TOKEN_STRING, pos + 1\r\n                else\r\n                    state = 0\r\n                end",
    "type": "statement:if"
  }, {
    "id": 50,
    "text": "state = 1",
    "type": "statement:assign"
  }, {
    "id": 51,
    "text": "state = 0",
    "type": "statement:assign"
  }, {
    "id": 52,
    "text": "if state > 0 then\r\n                    state = state + 1\r\n                end",
    "type": "statement:if"
  }, {
    "id": 53,
    "text": "state = state + 1",
    "type": "statement:assign"
  }, {
    "id": 54,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 55,
    "text": "local function nextComment(text, pos)\r\n        -- When we get here we have already parsed the \"--\"\r\n        -- Check for long comment\r\n        local isBracketString, nextPos, equalsCount = isBracketStringNext(text, pos)\r\n        if isBracketString then\r\n            local tokenType, nextPos2 = nextBracketString(text, nextPos, equalsCount)\r\n            return tokens.TOKEN_COMMENT_LONG, nextPos2\r\n        end\r\n        \r\n        local byte = stringbyte(text, pos)\r\n        \r\n        -- Short comment, find the first linebreak\r\n        while true do\r\n            byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_COMMENT_SHORT, pos\r\n            end\r\n            if linebreakCharacters[byte] then\r\n                return tokens.TOKEN_COMMENT_SHORT, pos\r\n            end\r\n            pos = pos + 1\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 56,
    "text": "local isBracketString, nextPos, equalsCount = isBracketStringNext(text, pos)",
    "type": "statement:localassign"
  }, {
    "id": 57,
    "text": "if isBracketString then\r\n            local tokenType, nextPos2 = nextBracketString(text, nextPos, equalsCount)\r\n            return tokens.TOKEN_COMMENT_LONG, nextPos2\r\n        end",
    "type": "statement:if"
  }, {
    "id": 58,
    "text": "local tokenType, nextPos2 = nextBracketString(text, nextPos, equalsCount)",
    "type": "statement:localassign"
  }, {
    "id": 59,
    "text": "while true do\r\n            byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_COMMENT_SHORT, pos\r\n            end\r\n            if linebreakCharacters[byte] then\r\n                return tokens.TOKEN_COMMENT_SHORT, pos\r\n            end\r\n            pos = pos + 1\r\n        end",
    "type": "statement:while"
  }, {
    "id": 60,
    "text": "byte = stringbyte(text, pos)",
    "type": "statement:assign"
  }, {
    "id": 61,
    "text": "if not byte then\r\n                return tokens.TOKEN_COMMENT_SHORT, pos\r\n            end",
    "type": "statement:if"
  }, {
    "id": 62,
    "text": "if linebreakCharacters[byte] then\r\n                return tokens.TOKEN_COMMENT_SHORT, pos\r\n            end",
    "type": "statement:if"
  }, {
    "id": 63,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 64,
    "text": "local function nextString(text, pos, character)\r\n        local even = true\r\n        while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_STRING, pos\r\n            end\r\n            \r\n            if byte == character then\r\n                if even then\r\n                    return tokens.TOKEN_STRING, pos + 1\r\n                end\r\n            end\r\n            if byte == bytes.BYTE_BACKSLASH then\r\n                even = not even\r\n            else\r\n                even = true\r\n            end\r\n            \r\n            pos = pos + 1\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 65,
    "text": "local even = true",
    "type": "statement:localassign"
  }, {
    "id": 66,
    "text": "while true do\r\n            local byte = stringbyte(text, pos)\r\n            if not byte then\r\n                return tokens.TOKEN_STRING, pos\r\n            end\r\n            \r\n            if byte == character then\r\n                if even then\r\n                    return tokens.TOKEN_STRING, pos + 1\r\n                end\r\n            end\r\n            if byte == bytes.BYTE_BACKSLASH then\r\n                even = not even\r\n            else\r\n                even = true\r\n            end\r\n            \r\n            pos = pos + 1\r\n        end",
    "type": "statement:while"
  }, {
    "id": 67,
    "text": "if byte == character then\r\n                if even then\r\n                    return tokens.TOKEN_STRING, pos + 1\r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 68,
    "text": "if even then\r\n                    return tokens.TOKEN_STRING, pos + 1\r\n                end",
    "type": "statement:if"
  }, {
    "id": 69,
    "text": "if byte == bytes.BYTE_BACKSLASH then\r\n                even = not even\r\n            else\r\n                even = true\r\n            end",
    "type": "statement:if"
  }, {
    "id": 70,
    "text": "even = not even",
    "type": "statement:assign"
  }, {
    "id": 71,
    "text": "even = true",
    "type": "statement:assign"
  }, {
    "id": 72,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 73,
    "text": "function nextToken(text, pos)\r\n        local byte = stringbyte(text, pos)\r\n        if not byte then\r\n            return nil\r\n        end\r\n        \r\n        if linebreakCharacters[byte] then\r\n            return tokens.TOKEN_LINEBREAK, pos + 1\r\n        end\r\n        \r\n        if whitespaceCharacters[byte] then\r\n            while true do\r\n                pos = pos + 1\r\n                byte = stringbyte(text, pos)\r\n                if not byte or not whitespaceCharacters[byte] then\r\n                    return tokens.TOKEN_WHITESPACE, pos\r\n                end\r\n            end\r\n        end\r\n        \r\n        local token = specialCharacters[byte]\r\n        if token then\r\n            if token ~= -1 then\r\n                return token, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_MINUS then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_MINUS then\r\n                    return nextComment(text, pos + 2)\r\n                end\r\n                return tokens.TOKEN_MINUS, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_SINGLE_QUOTE then\r\n                return nextString(text, pos + 1, bytes.BYTE_SINGLE_QUOTE)\r\n            end\r\n            \r\n            if byte == bytes.BYTE_DOUBLE_QUOTE then\r\n                return nextString(text, pos + 1, bytes.BYTE_DOUBLE_QUOTE)\r\n            end\r\n            \r\n            if byte == bytes.BYTE_LEFTBRACKET then\r\n                local isBracketString, nextPos, equalsCount = isBracketStringNext(text, pos)\r\n                if isBracketString then\r\n                    return nextBracketString(text, nextPos, equalsCount)\r\n                else\r\n                    return tokens.TOKEN_LEFTBRACKET, pos + 1\r\n                end\r\n            end\r\n            \r\n            if byte == bytes.BYTE_EQUALS then\r\n                byte = stringbyte(text, pos + 1)\r\n                if not byte then\r\n                    return tokens.TOKEN_ASSIGNMENT, pos + 1\r\n                end\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_EQUALITY, pos + 2\r\n                end\r\n                return tokens.TOKEN_ASSIGNMENT, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_PERIOD then\r\n                byte = stringbyte(text, pos + 1)\r\n                if not byte then\r\n                    return tokens.TOKEN_PERIOD, pos + 1\r\n                end\r\n                if byte == bytes.BYTE_PERIOD then\r\n                    byte = stringbyte(text, pos + 2)\r\n                    if byte == bytes.BYTE_PERIOD then\r\n                        return tokens.TOKEN_TRIPLEPERIOD, pos + 3\r\n                    end\r\n                    return tokens.TOKEN_DOUBLEPERIOD, pos + 2\r\n                elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\r\n                    return nextNumberFractionPart(text, pos + 2)\r\n                end\r\n                return tokens.TOKEN_PERIOD, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_LESSTHAN then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_LTE, pos + 2\r\n                end\r\n                return tokens.TOKEN_LT, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_GREATERTHAN then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_GTE, pos + 2\r\n                end\r\n                return tokens.TOKEN_GT, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_TILDE then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_NOTEQUAL, pos + 2\r\n                end\r\n                return tokens.TOKEN_TILDE, pos + 1\r\n            end\r\n            \r\n            return tokens.TOKEN_UNKNOWN, pos + 1\r\n        elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\r\n            return nextNumberIntPart(text, pos + 1)\r\n        else\r\n            return nextIdentifier(text, pos + 1)\r\n        end\r\n    end",
    "type": "function"
  }, {
    "id": 74,
    "text": "if not byte then\r\n            return nil\r\n        end",
    "type": "statement:if"
  }, {
    "id": 75,
    "text": "if linebreakCharacters[byte] then\r\n            return tokens.TOKEN_LINEBREAK, pos + 1\r\n        end",
    "type": "statement:if"
  }, {
    "id": 76,
    "text": "if whitespaceCharacters[byte] then\r\n            while true do\r\n                pos = pos + 1\r\n                byte = stringbyte(text, pos)\r\n                if not byte or not whitespaceCharacters[byte] then\r\n                    return tokens.TOKEN_WHITESPACE, pos\r\n                end\r\n            end\r\n        end",
    "type": "statement:if"
  }, {
    "id": 77,
    "text": "while true do\r\n                pos = pos + 1\r\n                byte = stringbyte(text, pos)\r\n                if not byte or not whitespaceCharacters[byte] then\r\n                    return tokens.TOKEN_WHITESPACE, pos\r\n                end\r\n            end",
    "type": "statement:while"
  }, {
    "id": 78,
    "text": "if not byte or not whitespaceCharacters[byte] then\r\n                    return tokens.TOKEN_WHITESPACE, pos\r\n                end",
    "type": "statement:if"
  }, {
    "id": 79,
    "text": "local token = specialCharacters[byte]",
    "type": "statement:localassign"
  }, {
    "id": 80,
    "text": "if token then\r\n            if token ~= -1 then\r\n                return token, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_MINUS then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_MINUS then\r\n                    return nextComment(text, pos + 2)\r\n                end\r\n                return tokens.TOKEN_MINUS, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_SINGLE_QUOTE then\r\n                return nextString(text, pos + 1, bytes.BYTE_SINGLE_QUOTE)\r\n            end\r\n            \r\n            if byte == bytes.BYTE_DOUBLE_QUOTE then\r\n                return nextString(text, pos + 1, bytes.BYTE_DOUBLE_QUOTE)\r\n            end\r\n            \r\n            if byte == bytes.BYTE_LEFTBRACKET then\r\n                local isBracketString, nextPos, equalsCount = isBracketStringNext(text, pos)\r\n                if isBracketString then\r\n                    return nextBracketString(text, nextPos, equalsCount)\r\n                else\r\n                    return tokens.TOKEN_LEFTBRACKET, pos + 1\r\n                end\r\n            end\r\n            \r\n            if byte == bytes.BYTE_EQUALS then\r\n                byte = stringbyte(text, pos + 1)\r\n                if not byte then\r\n                    return tokens.TOKEN_ASSIGNMENT, pos + 1\r\n                end\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_EQUALITY, pos + 2\r\n                end\r\n                return tokens.TOKEN_ASSIGNMENT, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_PERIOD then\r\n                byte = stringbyte(text, pos + 1)\r\n                if not byte then\r\n                    return tokens.TOKEN_PERIOD, pos + 1\r\n                end\r\n                if byte == bytes.BYTE_PERIOD then\r\n                    byte = stringbyte(text, pos + 2)\r\n                    if byte == bytes.BYTE_PERIOD then\r\n                        return tokens.TOKEN_TRIPLEPERIOD, pos + 3\r\n                    end\r\n                    return tokens.TOKEN_DOUBLEPERIOD, pos + 2\r\n                elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\r\n                    return nextNumberFractionPart(text, pos + 2)\r\n                end\r\n                return tokens.TOKEN_PERIOD, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_LESSTHAN then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_LTE, pos + 2\r\n                end\r\n                return tokens.TOKEN_LT, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_GREATERTHAN then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_GTE, pos + 2\r\n                end\r\n                return tokens.TOKEN_GT, pos + 1\r\n            end\r\n            \r\n            if byte == bytes.BYTE_TILDE then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_NOTEQUAL, pos + 2\r\n                end\r\n                return tokens.TOKEN_TILDE, pos + 1\r\n            end\r\n            \r\n            return tokens.TOKEN_UNKNOWN, pos + 1\r\n        elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\r\n            return nextNumberIntPart(text, pos + 1)\r\n        else\r\n            return nextIdentifier(text, pos + 1)\r\n        end",
    "type": "statement:if"
  }, {
    "id": 81,
    "text": "if token ~= -1 then\r\n                return token, pos + 1\r\n            end",
    "type": "statement:if"
  }, {
    "id": 82,
    "text": "if byte == bytes.BYTE_MINUS then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_MINUS then\r\n                    return nextComment(text, pos + 2)\r\n                end\r\n                return tokens.TOKEN_MINUS, pos + 1\r\n            end",
    "type": "statement:if"
  }, {
    "id": 83,
    "text": "if byte == bytes.BYTE_MINUS then\r\n                    return nextComment(text, pos + 2)\r\n                end",
    "type": "statement:if"
  }, {
    "id": 84,
    "text": "if byte == bytes.BYTE_SINGLE_QUOTE then\r\n                return nextString(text, pos + 1, bytes.BYTE_SINGLE_QUOTE)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 85,
    "text": "if byte == bytes.BYTE_DOUBLE_QUOTE then\r\n                return nextString(text, pos + 1, bytes.BYTE_DOUBLE_QUOTE)\r\n            end",
    "type": "statement:if"
  }, {
    "id": 86,
    "text": "if byte == bytes.BYTE_LEFTBRACKET then\r\n                local isBracketString, nextPos, equalsCount = isBracketStringNext(text, pos)\r\n                if isBracketString then\r\n                    return nextBracketString(text, nextPos, equalsCount)\r\n                else\r\n                    return tokens.TOKEN_LEFTBRACKET, pos + 1\r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 87,
    "text": "if isBracketString then\r\n                    return nextBracketString(text, nextPos, equalsCount)\r\n                else\r\n                    return tokens.TOKEN_LEFTBRACKET, pos + 1\r\n                end",
    "type": "statement:if"
  }, {
    "id": 88,
    "text": "if byte == bytes.BYTE_EQUALS then\r\n                byte = stringbyte(text, pos + 1)\r\n                if not byte then\r\n                    return tokens.TOKEN_ASSIGNMENT, pos + 1\r\n                end\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_EQUALITY, pos + 2\r\n                end\r\n                return tokens.TOKEN_ASSIGNMENT, pos + 1\r\n            end",
    "type": "statement:if"
  }, {
    "id": 89,
    "text": "if not byte then\r\n                    return tokens.TOKEN_ASSIGNMENT, pos + 1\r\n                end",
    "type": "statement:if"
  }, {
    "id": 90,
    "text": "if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_EQUALITY, pos + 2\r\n                end",
    "type": "statement:if"
  }, {
    "id": 91,
    "text": "if byte == bytes.BYTE_PERIOD then\r\n                byte = stringbyte(text, pos + 1)\r\n                if not byte then\r\n                    return tokens.TOKEN_PERIOD, pos + 1\r\n                end\r\n                if byte == bytes.BYTE_PERIOD then\r\n                    byte = stringbyte(text, pos + 2)\r\n                    if byte == bytes.BYTE_PERIOD then\r\n                        return tokens.TOKEN_TRIPLEPERIOD, pos + 3\r\n                    end\r\n                    return tokens.TOKEN_DOUBLEPERIOD, pos + 2\r\n                elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\r\n                    return nextNumberFractionPart(text, pos + 2)\r\n                end\r\n                return tokens.TOKEN_PERIOD, pos + 1\r\n            end",
    "type": "statement:if"
  }, {
    "id": 92,
    "text": "if not byte then\r\n                    return tokens.TOKEN_PERIOD, pos + 1\r\n                end",
    "type": "statement:if"
  }, {
    "id": 93,
    "text": "if byte == bytes.BYTE_PERIOD then\r\n                    byte = stringbyte(text, pos + 2)\r\n                    if byte == bytes.BYTE_PERIOD then\r\n                        return tokens.TOKEN_TRIPLEPERIOD, pos + 3\r\n                    end\r\n                    return tokens.TOKEN_DOUBLEPERIOD, pos + 2\r\n                elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then\r\n                    return nextNumberFractionPart(text, pos + 2)\r\n                end",
    "type": "statement:if"
  }, {
    "id": 94,
    "text": "byte = stringbyte(text, pos + 2)",
    "type": "statement:assign"
  }, {
    "id": 95,
    "text": "if byte == bytes.BYTE_PERIOD then\r\n                        return tokens.TOKEN_TRIPLEPERIOD, pos + 3\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 96,
    "text": "if byte == bytes.BYTE_LESSTHAN then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_LTE, pos + 2\r\n                end\r\n                return tokens.TOKEN_LT, pos + 1\r\n            end",
    "type": "statement:if"
  }, {
    "id": 97,
    "text": "if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_LTE, pos + 2\r\n                end",
    "type": "statement:if"
  }, {
    "id": 98,
    "text": "if byte == bytes.BYTE_GREATERTHAN then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_GTE, pos + 2\r\n                end\r\n                return tokens.TOKEN_GT, pos + 1\r\n            end",
    "type": "statement:if"
  }, {
    "id": 99,
    "text": "if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_GTE, pos + 2\r\n                end",
    "type": "statement:if"
  }, {
    "id": 100,
    "text": "if byte == bytes.BYTE_TILDE then\r\n                byte = stringbyte(text, pos + 1)\r\n                if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_NOTEQUAL, pos + 2\r\n                end\r\n                return tokens.TOKEN_TILDE, pos + 1\r\n            end",
    "type": "statement:if"
  }, {
    "id": 101,
    "text": "if byte == bytes.BYTE_EQUALS then\r\n                    return tokens.TOKEN_NOTEQUAL, pos + 2\r\n                end",
    "type": "statement:if"
  }, {
    "id": 102,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 103,
    "text": "local function fillWithTabs(n)\r\n        return stringrep(\"\\t\", n)\r\n    end",
    "type": "function"
  }, {
    "id": 104,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 105,
    "text": "local function fillWithSpaces(a, b)\r\n        return stringrep(\" \", a*b)\r\n    end",
    "type": "function"
  }, {
    "id": 106,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 107,
    "text": "function lib.colorCodeCode(code, colorTable)\r\n        local stopColor = colorTable and colorTable[0]\r\n        if not stopColor then\r\n            return {}, 0\r\n        end\r\n        \r\n        local formatTable = {}\r\n        local totalLen = 0\r\n        \r\n        local numLines = 0\r\n        local prevTokenWasColored = false\r\n        local prevTokenWidth = 0\r\n        \r\n        local pos = 1\r\n        local level = 0\r\n        \r\n        while true do\r\n            prevTokenWasColored = false\r\n            prevTokenWidth = 0\r\n            \r\n            local tokenType, nextPos = nextToken(code, pos)\r\n            \r\n            if not tokenType then\r\n                break\r\n            end\r\n            \r\n            if tokenType == tokens.TOKEN_UNKNOWN then\r\n                -- ignore color codes\r\n                \r\n            elseif tokenType == tokens.TOKEN_LINEBREAK or tokenType == tokens.TOKEN_WHITESPACE then\r\n                if tokenType == tokens.TOKEN_LINEBREAK then\r\n                    numLines = numLines + 1\r\n                end\r\n                local str = stringsub(code, pos, nextPos - 1)\r\n                prevTokenWidth = nextPos - pos\r\n                \r\n                totalLen = totalLen + stringlen(str)\r\n            else\r\n                local str = stringsub(code, pos, nextPos - 1)\r\n                \r\n                prevTokenWidth = nextPos - pos\r\n                \r\n                -- Add coloring\r\n                if keywords[str] then\r\n                    tokenType = tokens.TOKEN_KEYWORD\r\n                end\r\n                \r\n                local color\r\n                if stopColor then\r\n                    color = colorTable[str] or defaultColorTable[str]\r\n                    if not color then\r\n                        color = colorTable[tokenType] or defaultColorTable[tokenType]\r\n                        if not color then\r\n                            if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n                \r\n                if color then\r\n                    table.insert(formatTable, { pos = totalLen, val = color })\r\n                    totalLen = totalLen + (nextPos - pos)\r\n                    table.insert(formatTable, { pos = totalLen, val = stopColor })\r\n                    prevTokenWasColored = true\r\n                else\r\n                    totalLen = totalLen + stringlen(str)\r\n                end\r\n            end\r\n            \r\n            pos = nextPos\r\n        end\r\n        return formatTable, numLines\r\n    end",
    "type": "function"
  }, {
    "id": 108,
    "text": "local stopColor = colorTable and colorTable[0]",
    "type": "statement:localassign"
  }, {
    "id": 109,
    "text": "if not stopColor then\r\n            return {}, 0\r\n        end",
    "type": "statement:if"
  }, {
    "id": 110,
    "text": "local formatTable = {}",
    "type": "statement:localassign"
  }, {
    "id": 111,
    "text": "local totalLen = 0",
    "type": "statement:localassign"
  }, {
    "id": 112,
    "text": "local numLines = 0",
    "type": "statement:localassign"
  }, {
    "id": 113,
    "text": "local prevTokenWasColored = false",
    "type": "statement:localassign"
  }, {
    "id": 114,
    "text": "local prevTokenWidth = 0",
    "type": "statement:localassign"
  }, {
    "id": 115,
    "text": "local pos = 1",
    "type": "statement:localassign"
  }, {
    "id": 116,
    "text": "local level = 0",
    "type": "statement:localassign"
  }, {
    "id": 117,
    "text": "while true do\r\n            prevTokenWasColored = false\r\n            prevTokenWidth = 0\r\n            \r\n            local tokenType, nextPos = nextToken(code, pos)\r\n            \r\n            if not tokenType then\r\n                break\r\n            end\r\n            \r\n            if tokenType == tokens.TOKEN_UNKNOWN then\r\n                -- ignore color codes\r\n                \r\n            elseif tokenType == tokens.TOKEN_LINEBREAK or tokenType == tokens.TOKEN_WHITESPACE then\r\n                if tokenType == tokens.TOKEN_LINEBREAK then\r\n                    numLines = numLines + 1\r\n                end\r\n                local str = stringsub(code, pos, nextPos - 1)\r\n                prevTokenWidth = nextPos - pos\r\n                \r\n                totalLen = totalLen + stringlen(str)\r\n            else\r\n                local str = stringsub(code, pos, nextPos - 1)\r\n                \r\n                prevTokenWidth = nextPos - pos\r\n                \r\n                -- Add coloring\r\n                if keywords[str] then\r\n                    tokenType = tokens.TOKEN_KEYWORD\r\n                end\r\n                \r\n                local color\r\n                if stopColor then\r\n                    color = colorTable[str] or defaultColorTable[str]\r\n                    if not color then\r\n                        color = colorTable[tokenType] or defaultColorTable[tokenType]\r\n                        if not color then\r\n                            if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n                \r\n                if color then\r\n                    table.insert(formatTable, { pos = totalLen, val = color })\r\n                    totalLen = totalLen + (nextPos - pos)\r\n                    table.insert(formatTable, { pos = totalLen, val = stopColor })\r\n                    prevTokenWasColored = true\r\n                else\r\n                    totalLen = totalLen + stringlen(str)\r\n                end\r\n            end\r\n            \r\n            pos = nextPos\r\n        end",
    "type": "statement:while"
  }, {
    "id": 118,
    "text": "prevTokenWasColored = false",
    "type": "statement:assign"
  }, {
    "id": 119,
    "text": "prevTokenWidth = 0",
    "type": "statement:assign"
  }, {
    "id": 120,
    "text": "local tokenType, nextPos = nextToken(code, pos)",
    "type": "statement:localassign"
  }, {
    "id": 121,
    "text": "if not tokenType then\r\n                break\r\n            end",
    "type": "statement:if"
  }, {
    "id": 122,
    "text": "if tokenType == tokens.TOKEN_UNKNOWN then\r\n                -- ignore color codes\r\n                \r\n            elseif tokenType == tokens.TOKEN_LINEBREAK or tokenType == tokens.TOKEN_WHITESPACE then\r\n                if tokenType == tokens.TOKEN_LINEBREAK then\r\n                    numLines = numLines + 1\r\n                end\r\n                local str = stringsub(code, pos, nextPos - 1)\r\n                prevTokenWidth = nextPos - pos\r\n                \r\n                totalLen = totalLen + stringlen(str)\r\n            else\r\n                local str = stringsub(code, pos, nextPos - 1)\r\n                \r\n                prevTokenWidth = nextPos - pos\r\n                \r\n                -- Add coloring\r\n                if keywords[str] then\r\n                    tokenType = tokens.TOKEN_KEYWORD\r\n                end\r\n                \r\n                local color\r\n                if stopColor then\r\n                    color = colorTable[str] or defaultColorTable[str]\r\n                    if not color then\r\n                        color = colorTable[tokenType] or defaultColorTable[tokenType]\r\n                        if not color then\r\n                            if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n                \r\n                if color then\r\n                    table.insert(formatTable, { pos = totalLen, val = color })\r\n                    totalLen = totalLen + (nextPos - pos)\r\n                    table.insert(formatTable, { pos = totalLen, val = stopColor })\r\n                    prevTokenWasColored = true\r\n                else\r\n                    totalLen = totalLen + stringlen(str)\r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 123,
    "text": "if tokenType == tokens.TOKEN_LINEBREAK then\r\n                    numLines = numLines + 1\r\n                end",
    "type": "statement:if"
  }, {
    "id": 124,
    "text": "numLines = numLines + 1",
    "type": "statement:assign"
  }, {
    "id": 125,
    "text": "local str = stringsub(code, pos, nextPos - 1)",
    "type": "statement:localassign"
  }, {
    "id": 126,
    "text": "prevTokenWidth = nextPos - pos",
    "type": "statement:assign"
  }, {
    "id": 127,
    "text": "totalLen = totalLen + stringlen(str)",
    "type": "statement:assign"
  }, {
    "id": 128,
    "text": "if keywords[str] then\r\n                    tokenType = tokens.TOKEN_KEYWORD\r\n                end",
    "type": "statement:if"
  }, {
    "id": 129,
    "text": "tokenType = tokens.TOKEN_KEYWORD",
    "type": "statement:assign"
  }, {
    "id": 130,
    "text": "local color",
    "type": "statement:localassign"
  }, {
    "id": 131,
    "text": "if stopColor then\r\n                    color = colorTable[str] or defaultColorTable[str]\r\n                    if not color then\r\n                        color = colorTable[tokenType] or defaultColorTable[tokenType]\r\n                        if not color then\r\n                            if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end\r\n                        end\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 132,
    "text": "color = colorTable[str] or defaultColorTable[str]",
    "type": "statement:assign"
  }, {
    "id": 133,
    "text": "if not color then\r\n                        color = colorTable[tokenType] or defaultColorTable[tokenType]\r\n                        if not color then\r\n                            if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end\r\n                        end\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 134,
    "text": "color = colorTable[tokenType] or defaultColorTable[tokenType]",
    "type": "statement:assign"
  }, {
    "id": 135,
    "text": "if not color then\r\n                            if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 136,
    "text": "if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end",
    "type": "statement:if"
  }, {
    "id": 137,
    "text": "color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]",
    "type": "statement:assign"
  }, {
    "id": 138,
    "text": "color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]",
    "type": "statement:assign"
  }, {
    "id": 139,
    "text": "if color then\r\n                    table.insert(formatTable, { pos = totalLen, val = color })\r\n                    totalLen = totalLen + (nextPos - pos)\r\n                    table.insert(formatTable, { pos = totalLen, val = stopColor })\r\n                    prevTokenWasColored = true\r\n                else\r\n                    totalLen = totalLen + stringlen(str)\r\n                end",
    "type": "statement:if"
  }, {
    "id": 140,
    "text": "table.insert(formatTable, { pos = totalLen, val = color })",
    "type": "statement:functioncall"
  }, {
    "id": 141,
    "text": "totalLen = totalLen + (nextPos - pos)",
    "type": "statement:assign"
  }, {
    "id": 142,
    "text": "table.insert(formatTable, { pos = totalLen, val = stopColor })",
    "type": "statement:functioncall"
  }, {
    "id": 143,
    "text": "prevTokenWasColored = true",
    "type": "statement:assign"
  }, {
    "id": 144,
    "text": "pos = nextPos",
    "type": "statement:assign"
  }, {
    "id": 145,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 146,
    "text": "function lib.indentCode(code, tabWidth, colorTable, caretPosition)\r\n        local fillFunction\r\n        if tabWidth == nil then\r\n            tabWidth = defaultTabWidth\r\n        end\r\n        if tabWidth then\r\n            fillFunction = fillWithSpaces\r\n        else\r\n            fillFunction = fillWithTabs\r\n        end\r\n        \r\n        tableclear(workingTable)\r\n        local tsize = 0\r\n        local totalLen = 0\r\n        \r\n        tableclear(workingTable2)\r\n        local tsize2 = 0\r\n        local totalLen2 = 0\r\n        \r\n        local formatTable = {}\r\n        \r\n        \r\n        local stopColor = colorTable and colorTable[0]\r\n        \r\n        local newCaretPosition\r\n        local newCaretPositionFinalized = false\r\n        local prevTokenWasColored = false\r\n        local prevTokenWidth = 0\r\n        \r\n        local pos = 1\r\n        local level = 0\r\n        \r\n        local hitNonWhitespace = false\r\n        local hitIndentRight = false\r\n        local preIndent = 0\r\n        local postIndent = 0\r\n        while true do\r\n            if caretPosition and not newCaretPosition and pos >= caretPosition then\r\n                if pos == caretPosition then\r\n                    newCaretPosition = totalLen + totalLen2\r\n                else\r\n                    newCaretPosition = totalLen + totalLen2\r\n                    local diff = pos - caretPosition\r\n                    if diff > prevTokenWidth then\r\n                        diff = prevTokenWidth\r\n                    end\r\n                    newCaretPosition = newCaretPosition - diff\r\n                end\r\n            end\r\n            \r\n            prevTokenWasColored = false\r\n            prevTokenWidth = 0\r\n            \r\n            local tokenType, nextPos = nextToken(code, pos)\r\n            \r\n            if not tokenType or tokenType == tokens.TOKEN_LINEBREAK then\r\n                level = level + preIndent\r\n                if level < 0 then level = 0 end\r\n                \r\n                local s = fillFunction(level, tabWidth)\r\n                \r\n                tsize = tsize + 1\r\n                workingTable[tsize] = s\r\n                totalLen = totalLen + stringlen(s)\r\n                \r\n                if newCaretPosition and not newCaretPositionFinalized then\r\n                    newCaretPosition = newCaretPosition + stringlen(s)\r\n                    newCaretPositionFinalized = true\r\n                end\r\n                \r\n                for k, v in next,workingTable2 do\r\n                    if stringsub(v, 1, 2) == \"|c\" then\r\n                        table.insert(formatTable, { pos = totalLen, val = stringsub(v, 3) })\r\n                    else\r\n                        tsize = tsize + 1\r\n                        workingTable[tsize] = v\r\n                        totalLen = totalLen + stringlen(v)\r\n                    end\r\n                end\r\n                \r\n                if not tokenType then\r\n                    break\r\n                end\r\n                \r\n                tsize = tsize + 1\r\n                workingTable[tsize] = stringsub(code, pos, nextPos - 1)\r\n                totalLen = totalLen + nextPos - pos\r\n                \r\n                level = level + postIndent\r\n                if level < 0 then level = 0 end\r\n                \r\n                tableclear(workingTable2)\r\n                tsize2 = 0\r\n                totalLen2 = 0\r\n                \r\n                hitNonWhitespace = false\r\n                hitIndentRight = false\r\n                preIndent = 0\r\n                postIndent = 0\r\n            elseif tokenType == tokens.TOKEN_WHITESPACE then\r\n                if hitNonWhitespace then\r\n                    prevTokenWidth = nextPos - pos\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    local s = stringsub(code, pos, nextPos - 1)\r\n                    workingTable2[tsize2] = s\r\n                    totalLen2 = totalLen2 + stringlen(s)\r\n                end\r\n            elseif tokenType == tokens.TOKEN_UNKNOWN then\r\n                -- skip these, though they shouldn't be encountered here anyway\r\n            else\r\n                hitNonWhitespace = true\r\n                \r\n                local str = stringsub(code, pos, nextPos - 1)\r\n                \r\n                prevTokenWidth = nextPos - pos\r\n                \r\n                -- See if this is an indent-modifier\r\n                local indentTable\r\n                if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                    indentTable = keywords[str]\r\n                else\r\n                    indentTable = tokenIndentation[tokenType]\r\n                end\r\n                \r\n                if indentTable then\r\n                    if hitIndentRight then\r\n                        postIndent = postIndent + indentTable[1] + indentTable[2]\r\n                    else\r\n                        local pre = indentTable[1]\r\n                        local post = indentTable[2]\r\n                        if post > 0 then\r\n                            hitIndentRight = true\r\n                        end\r\n                        preIndent = preIndent + pre\r\n                        postIndent = postIndent + post\r\n                    end\r\n                end\r\n                \r\n                -- Add coloring\r\n                if keywords[str] then\r\n                    tokenType = tokens.TOKEN_KEYWORD\r\n                end\r\n                \r\n                local color\r\n                if stopColor then\r\n                    color = colorTable[str] or defaultColorTable[str]\r\n                    if not color then\r\n                        color = colorTable[tokenType] or defaultColorTable[tokenType]\r\n                        if not color then\r\n                            if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n                \r\n                if color then\r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = \"|c\" .. color\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = str\r\n                    totalLen2 = totalLen2 + nextPos - pos\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = \"|c\" .. stopColor\r\n                    \r\n                    prevTokenWasColored = true\r\n                else\r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = str\r\n                    totalLen2 = totalLen2 + nextPos - pos\r\n                    \r\n                end\r\n            end\r\n            pos = nextPos\r\n        end\r\n        return table.concat(workingTable), formatTable, newCaretPosition\r\n    end",
    "type": "function"
  }, {
    "id": 147,
    "text": "local fillFunction",
    "type": "statement:localassign"
  }, {
    "id": 148,
    "text": "if tabWidth == nil then\r\n            tabWidth = defaultTabWidth\r\n        end",
    "type": "statement:if"
  }, {
    "id": 149,
    "text": "tabWidth = defaultTabWidth",
    "type": "statement:assign"
  }, {
    "id": 150,
    "text": "if tabWidth then\r\n            fillFunction = fillWithSpaces\r\n        else\r\n            fillFunction = fillWithTabs\r\n        end",
    "type": "statement:if"
  }, {
    "id": 151,
    "text": "fillFunction = fillWithSpaces",
    "type": "statement:assign"
  }, {
    "id": 152,
    "text": "fillFunction = fillWithTabs",
    "type": "statement:assign"
  }, {
    "id": 153,
    "text": "tableclear(workingTable)",
    "type": "statement:functioncall"
  }, {
    "id": 154,
    "text": "local tsize = 0",
    "type": "statement:localassign"
  }, {
    "id": 155,
    "text": "tableclear(workingTable2)",
    "type": "statement:functioncall"
  }, {
    "id": 156,
    "text": "local tsize2 = 0",
    "type": "statement:localassign"
  }, {
    "id": 157,
    "text": "local totalLen2 = 0",
    "type": "statement:localassign"
  }, {
    "id": 158,
    "text": "local newCaretPosition",
    "type": "statement:localassign"
  }, {
    "id": 159,
    "text": "local newCaretPositionFinalized = false",
    "type": "statement:localassign"
  }, {
    "id": 160,
    "text": "local hitNonWhitespace = false",
    "type": "statement:localassign"
  }, {
    "id": 161,
    "text": "local hitIndentRight = false",
    "type": "statement:localassign"
  }, {
    "id": 162,
    "text": "local preIndent = 0",
    "type": "statement:localassign"
  }, {
    "id": 163,
    "text": "local postIndent = 0",
    "type": "statement:localassign"
  }, {
    "id": 164,
    "text": "while true do\r\n            if caretPosition and not newCaretPosition and pos >= caretPosition then\r\n                if pos == caretPosition then\r\n                    newCaretPosition = totalLen + totalLen2\r\n                else\r\n                    newCaretPosition = totalLen + totalLen2\r\n                    local diff = pos - caretPosition\r\n                    if diff > prevTokenWidth then\r\n                        diff = prevTokenWidth\r\n                    end\r\n                    newCaretPosition = newCaretPosition - diff\r\n                end\r\n            end\r\n            \r\n            prevTokenWasColored = false\r\n            prevTokenWidth = 0\r\n            \r\n            local tokenType, nextPos = nextToken(code, pos)\r\n            \r\n            if not tokenType or tokenType == tokens.TOKEN_LINEBREAK then\r\n                level = level + preIndent\r\n                if level < 0 then level = 0 end\r\n                \r\n                local s = fillFunction(level, tabWidth)\r\n                \r\n                tsize = tsize + 1\r\n                workingTable[tsize] = s\r\n                totalLen = totalLen + stringlen(s)\r\n                \r\n                if newCaretPosition and not newCaretPositionFinalized then\r\n                    newCaretPosition = newCaretPosition + stringlen(s)\r\n                    newCaretPositionFinalized = true\r\n                end\r\n                \r\n                for k, v in next,workingTable2 do\r\n                    if stringsub(v, 1, 2) == \"|c\" then\r\n                        table.insert(formatTable, { pos = totalLen, val = stringsub(v, 3) })\r\n                    else\r\n                        tsize = tsize + 1\r\n                        workingTable[tsize] = v\r\n                        totalLen = totalLen + stringlen(v)\r\n                    end\r\n                end\r\n                \r\n                if not tokenType then\r\n                    break\r\n                end\r\n                \r\n                tsize = tsize + 1\r\n                workingTable[tsize] = stringsub(code, pos, nextPos - 1)\r\n                totalLen = totalLen + nextPos - pos\r\n                \r\n                level = level + postIndent\r\n                if level < 0 then level = 0 end\r\n                \r\n                tableclear(workingTable2)\r\n                tsize2 = 0\r\n                totalLen2 = 0\r\n                \r\n                hitNonWhitespace = false\r\n                hitIndentRight = false\r\n                preIndent = 0\r\n                postIndent = 0\r\n            elseif tokenType == tokens.TOKEN_WHITESPACE then\r\n                if hitNonWhitespace then\r\n                    prevTokenWidth = nextPos - pos\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    local s = stringsub(code, pos, nextPos - 1)\r\n                    workingTable2[tsize2] = s\r\n                    totalLen2 = totalLen2 + stringlen(s)\r\n                end\r\n            elseif tokenType == tokens.TOKEN_UNKNOWN then\r\n                -- skip these, though they shouldn't be encountered here anyway\r\n            else\r\n                hitNonWhitespace = true\r\n                \r\n                local str = stringsub(code, pos, nextPos - 1)\r\n                \r\n                prevTokenWidth = nextPos - pos\r\n                \r\n                -- See if this is an indent-modifier\r\n                local indentTable\r\n                if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                    indentTable = keywords[str]\r\n                else\r\n                    indentTable = tokenIndentation[tokenType]\r\n                end\r\n                \r\n                if indentTable then\r\n                    if hitIndentRight then\r\n                        postIndent = postIndent + indentTable[1] + indentTable[2]\r\n                    else\r\n                        local pre = indentTable[1]\r\n                        local post = indentTable[2]\r\n                        if post > 0 then\r\n                            hitIndentRight = true\r\n                        end\r\n                        preIndent = preIndent + pre\r\n                        postIndent = postIndent + post\r\n                    end\r\n                end\r\n                \r\n                -- Add coloring\r\n                if keywords[str] then\r\n                    tokenType = tokens.TOKEN_KEYWORD\r\n                end\r\n                \r\n                local color\r\n                if stopColor then\r\n                    color = colorTable[str] or defaultColorTable[str]\r\n                    if not color then\r\n                        color = colorTable[tokenType] or defaultColorTable[tokenType]\r\n                        if not color then\r\n                            if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n                \r\n                if color then\r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = \"|c\" .. color\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = str\r\n                    totalLen2 = totalLen2 + nextPos - pos\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = \"|c\" .. stopColor\r\n                    \r\n                    prevTokenWasColored = true\r\n                else\r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = str\r\n                    totalLen2 = totalLen2 + nextPos - pos\r\n                    \r\n                end\r\n            end\r\n            pos = nextPos\r\n        end",
    "type": "statement:while"
  }, {
    "id": 165,
    "text": "if caretPosition and not newCaretPosition and pos >= caretPosition then\r\n                if pos == caretPosition then\r\n                    newCaretPosition = totalLen + totalLen2\r\n                else\r\n                    newCaretPosition = totalLen + totalLen2\r\n                    local diff = pos - caretPosition\r\n                    if diff > prevTokenWidth then\r\n                        diff = prevTokenWidth\r\n                    end\r\n                    newCaretPosition = newCaretPosition - diff\r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 166,
    "text": "if pos == caretPosition then\r\n                    newCaretPosition = totalLen + totalLen2\r\n                else\r\n                    newCaretPosition = totalLen + totalLen2\r\n                    local diff = pos - caretPosition\r\n                    if diff > prevTokenWidth then\r\n                        diff = prevTokenWidth\r\n                    end\r\n                    newCaretPosition = newCaretPosition - diff\r\n                end",
    "type": "statement:if"
  }, {
    "id": 167,
    "text": "newCaretPosition = totalLen + totalLen2",
    "type": "statement:assign"
  }, {
    "id": 168,
    "text": "local diff = pos - caretPosition",
    "type": "statement:localassign"
  }, {
    "id": 169,
    "text": "if diff > prevTokenWidth then\r\n                        diff = prevTokenWidth\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 170,
    "text": "diff = prevTokenWidth",
    "type": "statement:assign"
  }, {
    "id": 171,
    "text": "newCaretPosition = newCaretPosition - diff",
    "type": "statement:assign"
  }, {
    "id": 172,
    "text": "if not tokenType or tokenType == tokens.TOKEN_LINEBREAK then\r\n                level = level + preIndent\r\n                if level < 0 then level = 0 end\r\n                \r\n                local s = fillFunction(level, tabWidth)\r\n                \r\n                tsize = tsize + 1\r\n                workingTable[tsize] = s\r\n                totalLen = totalLen + stringlen(s)\r\n                \r\n                if newCaretPosition and not newCaretPositionFinalized then\r\n                    newCaretPosition = newCaretPosition + stringlen(s)\r\n                    newCaretPositionFinalized = true\r\n                end\r\n                \r\n                for k, v in next,workingTable2 do\r\n                    if stringsub(v, 1, 2) == \"|c\" then\r\n                        table.insert(formatTable, { pos = totalLen, val = stringsub(v, 3) })\r\n                    else\r\n                        tsize = tsize + 1\r\n                        workingTable[tsize] = v\r\n                        totalLen = totalLen + stringlen(v)\r\n                    end\r\n                end\r\n                \r\n                if not tokenType then\r\n                    break\r\n                end\r\n                \r\n                tsize = tsize + 1\r\n                workingTable[tsize] = stringsub(code, pos, nextPos - 1)\r\n                totalLen = totalLen + nextPos - pos\r\n                \r\n                level = level + postIndent\r\n                if level < 0 then level = 0 end\r\n                \r\n                tableclear(workingTable2)\r\n                tsize2 = 0\r\n                totalLen2 = 0\r\n                \r\n                hitNonWhitespace = false\r\n                hitIndentRight = false\r\n                preIndent = 0\r\n                postIndent = 0\r\n            elseif tokenType == tokens.TOKEN_WHITESPACE then\r\n                if hitNonWhitespace then\r\n                    prevTokenWidth = nextPos - pos\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    local s = stringsub(code, pos, nextPos - 1)\r\n                    workingTable2[tsize2] = s\r\n                    totalLen2 = totalLen2 + stringlen(s)\r\n                end\r\n            elseif tokenType == tokens.TOKEN_UNKNOWN then\r\n                -- skip these, though they shouldn't be encountered here anyway\r\n            else\r\n                hitNonWhitespace = true\r\n                \r\n                local str = stringsub(code, pos, nextPos - 1)\r\n                \r\n                prevTokenWidth = nextPos - pos\r\n                \r\n                -- See if this is an indent-modifier\r\n                local indentTable\r\n                if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                    indentTable = keywords[str]\r\n                else\r\n                    indentTable = tokenIndentation[tokenType]\r\n                end\r\n                \r\n                if indentTable then\r\n                    if hitIndentRight then\r\n                        postIndent = postIndent + indentTable[1] + indentTable[2]\r\n                    else\r\n                        local pre = indentTable[1]\r\n                        local post = indentTable[2]\r\n                        if post > 0 then\r\n                            hitIndentRight = true\r\n                        end\r\n                        preIndent = preIndent + pre\r\n                        postIndent = postIndent + post\r\n                    end\r\n                end\r\n                \r\n                -- Add coloring\r\n                if keywords[str] then\r\n                    tokenType = tokens.TOKEN_KEYWORD\r\n                end\r\n                \r\n                local color\r\n                if stopColor then\r\n                    color = colorTable[str] or defaultColorTable[str]\r\n                    if not color then\r\n                        color = colorTable[tokenType] or defaultColorTable[tokenType]\r\n                        if not color then\r\n                            if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                                color = colorTable[tokens.TOKEN_IDENTIFIER] or defaultColorTable[tokens.TOKEN_IDENTIFIER]\r\n                            else\r\n                                color = colorTable[tokens.TOKEN_SPECIAL] or defaultColorTable[tokens.TOKEN_SPECIAL]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n                \r\n                if color then\r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = \"|c\" .. color\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = str\r\n                    totalLen2 = totalLen2 + nextPos - pos\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = \"|c\" .. stopColor\r\n                    \r\n                    prevTokenWasColored = true\r\n                else\r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = str\r\n                    totalLen2 = totalLen2 + nextPos - pos\r\n                    \r\n                end\r\n            end",
    "type": "statement:if"
  }, {
    "id": 173,
    "text": "level = level + preIndent",
    "type": "statement:assign"
  }, {
    "id": 174,
    "text": "if level < 0 then level = 0 end",
    "type": "statement:if"
  }, {
    "id": 175,
    "text": "level = 0",
    "type": "statement:assign"
  }, {
    "id": 176,
    "text": "local s = fillFunction(level, tabWidth)",
    "type": "statement:localassign"
  }, {
    "id": 177,
    "text": "tsize = tsize + 1",
    "type": "statement:assign"
  }, {
    "id": 178,
    "text": "workingTable[tsize] = s",
    "type": "statement:assign"
  }, {
    "id": 179,
    "text": "totalLen = totalLen + stringlen(s)",
    "type": "statement:assign"
  }, {
    "id": 180,
    "text": "if newCaretPosition and not newCaretPositionFinalized then\r\n                    newCaretPosition = newCaretPosition + stringlen(s)\r\n                    newCaretPositionFinalized = true\r\n                end",
    "type": "statement:if"
  }, {
    "id": 181,
    "text": "newCaretPosition = newCaretPosition + stringlen(s)",
    "type": "statement:assign"
  }, {
    "id": 182,
    "text": "newCaretPositionFinalized = true",
    "type": "statement:assign"
  }, {
    "id": 183,
    "text": "for k, v in next,workingTable2 do\r\n                    if stringsub(v, 1, 2) == \"|c\" then\r\n                        table.insert(formatTable, { pos = totalLen, val = stringsub(v, 3) })\r\n                    else\r\n                        tsize = tsize + 1\r\n                        workingTable[tsize] = v\r\n                        totalLen = totalLen + stringlen(v)\r\n                    end\r\n                end",
    "type": "statement:genericfor"
  }, {
    "id": 184,
    "text": "if stringsub(v, 1, 2) == \"|c\" then\r\n                        table.insert(formatTable, { pos = totalLen, val = stringsub(v, 3) })\r\n                    else\r\n                        tsize = tsize + 1\r\n                        workingTable[tsize] = v\r\n                        totalLen = totalLen + stringlen(v)\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 185,
    "text": "table.insert(formatTable, { pos = totalLen, val = stringsub(v, 3) })",
    "type": "statement:functioncall"
  }, {
    "id": 186,
    "text": "workingTable[tsize] = v",
    "type": "statement:assign"
  }, {
    "id": 187,
    "text": "totalLen = totalLen + stringlen(v)",
    "type": "statement:assign"
  }, {
    "id": 188,
    "text": "if not tokenType then\r\n                    break\r\n                end",
    "type": "statement:if"
  }, {
    "id": 189,
    "text": "workingTable[tsize] = stringsub(code, pos, nextPos - 1)",
    "type": "statement:assign"
  }, {
    "id": 190,
    "text": "totalLen = totalLen + nextPos - pos",
    "type": "statement:assign"
  }, {
    "id": 191,
    "text": "level = level + postIndent",
    "type": "statement:assign"
  }, {
    "id": 192,
    "text": "tsize2 = 0",
    "type": "statement:assign"
  }, {
    "id": 193,
    "text": "totalLen2 = 0",
    "type": "statement:assign"
  }, {
    "id": 194,
    "text": "hitNonWhitespace = false",
    "type": "statement:assign"
  }, {
    "id": 195,
    "text": "hitIndentRight = false",
    "type": "statement:assign"
  }, {
    "id": 196,
    "text": "preIndent = 0",
    "type": "statement:assign"
  }, {
    "id": 197,
    "text": "postIndent = 0",
    "type": "statement:assign"
  }, {
    "id": 198,
    "text": "if hitNonWhitespace then\r\n                    prevTokenWidth = nextPos - pos\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    local s = stringsub(code, pos, nextPos - 1)\r\n                    workingTable2[tsize2] = s\r\n                    totalLen2 = totalLen2 + stringlen(s)\r\n                end",
    "type": "statement:if"
  }, {
    "id": 199,
    "text": "tsize2 = tsize2 + 1",
    "type": "statement:assign"
  }, {
    "id": 200,
    "text": "local s = stringsub(code, pos, nextPos - 1)",
    "type": "statement:localassign"
  }, {
    "id": 201,
    "text": "workingTable2[tsize2] = s",
    "type": "statement:assign"
  }, {
    "id": 202,
    "text": "totalLen2 = totalLen2 + stringlen(s)",
    "type": "statement:assign"
  }, {
    "id": 203,
    "text": "hitNonWhitespace = true",
    "type": "statement:assign"
  }, {
    "id": 204,
    "text": "local indentTable",
    "type": "statement:localassign"
  }, {
    "id": 205,
    "text": "if tokenType == tokens.TOKEN_IDENTIFIER then\r\n                    indentTable = keywords[str]\r\n                else\r\n                    indentTable = tokenIndentation[tokenType]\r\n                end",
    "type": "statement:if"
  }, {
    "id": 206,
    "text": "indentTable = keywords[str]",
    "type": "statement:assign"
  }, {
    "id": 207,
    "text": "indentTable = tokenIndentation[tokenType]",
    "type": "statement:assign"
  }, {
    "id": 208,
    "text": "if indentTable then\r\n                    if hitIndentRight then\r\n                        postIndent = postIndent + indentTable[1] + indentTable[2]\r\n                    else\r\n                        local pre = indentTable[1]\r\n                        local post = indentTable[2]\r\n                        if post > 0 then\r\n                            hitIndentRight = true\r\n                        end\r\n                        preIndent = preIndent + pre\r\n                        postIndent = postIndent + post\r\n                    end\r\n                end",
    "type": "statement:if"
  }, {
    "id": 209,
    "text": "if hitIndentRight then\r\n                        postIndent = postIndent + indentTable[1] + indentTable[2]\r\n                    else\r\n                        local pre = indentTable[1]\r\n                        local post = indentTable[2]\r\n                        if post > 0 then\r\n                            hitIndentRight = true\r\n                        end\r\n                        preIndent = preIndent + pre\r\n                        postIndent = postIndent + post\r\n                    end",
    "type": "statement:if"
  }, {
    "id": 210,
    "text": "postIndent = postIndent + indentTable[1] + indentTable[2]",
    "type": "statement:assign"
  }, {
    "id": 211,
    "text": "local pre = indentTable[1]",
    "type": "statement:localassign"
  }, {
    "id": 212,
    "text": "local post = indentTable[2]",
    "type": "statement:localassign"
  }, {
    "id": 213,
    "text": "if post > 0 then\r\n                            hitIndentRight = true\r\n                        end",
    "type": "statement:if"
  }, {
    "id": 214,
    "text": "hitIndentRight = true",
    "type": "statement:assign"
  }, {
    "id": 215,
    "text": "preIndent = preIndent + pre",
    "type": "statement:assign"
  }, {
    "id": 216,
    "text": "postIndent = postIndent + post",
    "type": "statement:assign"
  }, {
    "id": 217,
    "text": "if color then\r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = \"|c\" .. color\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = str\r\n                    totalLen2 = totalLen2 + nextPos - pos\r\n                    \r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = \"|c\" .. stopColor\r\n                    \r\n                    prevTokenWasColored = true\r\n                else\r\n                    tsize2 = tsize2 + 1\r\n                    workingTable2[tsize2] = str\r\n                    totalLen2 = totalLen2 + nextPos - pos\r\n                    \r\n                end",
    "type": "statement:if"
  }, {
    "id": 218,
    "text": "workingTable2[tsize2] = \"|c\" .. color",
    "type": "statement:assign"
  }, {
    "id": 219,
    "text": "workingTable2[tsize2] = str",
    "type": "statement:assign"
  }, {
    "id": 220,
    "text": "totalLen2 = totalLen2 + nextPos - pos",
    "type": "statement:assign"
  }, {
    "id": 221,
    "text": "workingTable2[tsize2] = \"|c\" .. stopColor",
    "type": "statement:assign"
  }, {
    "id": 222,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 223,
    "text": "function lib.textboxReindent(textbox)\r\n        textbox.indenting = true\r\n        local prevPos, prevColor, v, newCaretPos, formatTable = 0, \"0\"\r\n        textbox.value, formatTable, newCaret = lib.indentCode(textbox.value, textbox.tabWidth + 0, textbox.colorTable, textbox.caretpos + 0)\r\n        local tags = iup.user { bulk = \"Yes\", cleanout = \"Yes\" }\r\n        for i = 1, #formatTable do\r\n            local v = formatTable[i]\r\n            if prevPos ~= v.pos and prevColor ~= \"0\" then\r\n                iup.Append(tags, iup.user { selectionpos = prevPos .. \":\" .. v.pos, fgcolor = prevColor })\r\n            end\r\n            prevPos, prevColor = v.pos, v.val\r\n        end\r\n        textbox.addformattag = tags\r\n        textbox.caretpos = newCaret\r\n        textbox.indenting = nil\r\n    end",
    "type": "function"
  }, {
    "id": 224,
    "text": "textbox.indenting = true",
    "type": "statement:assign"
  }, {
    "id": 225,
    "text": "local prevPos, prevColor, v, newCaretPos, formatTable = 0, \"0\"",
    "type": "statement:localassign"
  }, {
    "id": 226,
    "text": "textbox.value, formatTable, newCaret = lib.indentCode(textbox.value, textbox.tabWidth + 0, textbox.colorTable, textbox.caretpos + 0)",
    "type": "statement:assign"
  }, {
    "id": 227,
    "text": "local tags = iup.user { bulk = \"Yes\", cleanout = \"Yes\" }",
    "type": "statement:localassign"
  }, {
    "id": 228,
    "text": "for i = 1, #formatTable do\r\n            local v = formatTable[i]\r\n            if prevPos ~= v.pos and prevColor ~= \"0\" then\r\n                iup.Append(tags, iup.user { selectionpos = prevPos .. \":\" .. v.pos, fgcolor = prevColor })\r\n            end\r\n            prevPos, prevColor = v.pos, v.val\r\n        end",
    "type": "statement:numericfor"
  }, {
    "id": 229,
    "text": "local v = formatTable[i]",
    "type": "statement:localassign"
  }, {
    "id": 230,
    "text": "if prevPos ~= v.pos and prevColor ~= \"0\" then\r\n                iup.Append(tags, iup.user { selectionpos = prevPos .. \":\" .. v.pos, fgcolor = prevColor })\r\n            end",
    "type": "statement:if"
  }, {
    "id": 231,
    "text": "iup.Append(tags, iup.user { selectionpos = prevPos .. \":\" .. v.pos, fgcolor = prevColor })",
    "type": "statement:functioncall"
  }, {
    "id": 232,
    "text": "prevPos, prevColor = v.pos, v.val",
    "type": "statement:assign"
  }, {
    "id": 233,
    "text": "textbox.addformattag = tags",
    "type": "statement:assign"
  }, {
    "id": 234,
    "text": "textbox.caretpos = newCaret",
    "type": "statement:assign"
  }, {
    "id": 235,
    "text": "textbox.indenting = nil",
    "type": "statement:assign"
  }, {
    "id": 236,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 237,
    "text": "function lib.textboxRecolor(textbox)\r\n        if textbox.indenting then return end\r\n        textbox.indenting = true\r\n        local prevPos, prevColor, oldCaret, v, formatTable = 0, \"0\", textbox.caretpos\r\n        formatTable = lib.colorCodeCode(textbox.value, textbox.colorTable)\r\n        local tags = iup.user { bulk = \"Yes\", cleanout = \"Yes\" }\r\n        for i = 1, #formatTable do\r\n            local v = formatTable[i]\r\n            if prevPos ~= v.pos and prevColor ~= \"0\" then\r\n                iup.Append(tags, iup.user { selectionpos = prevPos .. \":\" .. v.pos, fgcolor = prevColor })\r\n            end\r\n            prevPos, prevColor = v.pos, v.val\r\n        end\r\n        textbox.addformattag = tags\r\n        textbox.caretpos = oldCaret\r\n        textbox.indenting = nil\r\n    end",
    "type": "function"
  }, {
    "id": 238,
    "text": "if textbox.indenting then return end",
    "type": "statement:if"
  }, {
    "id": 239,
    "text": "local prevPos, prevColor, oldCaret, v, formatTable = 0, \"0\", textbox.caretpos",
    "type": "statement:localassign"
  }, {
    "id": 240,
    "text": "formatTable = lib.colorCodeCode(textbox.value, textbox.colorTable)",
    "type": "statement:assign"
  }, {
    "id": 241,
    "text": "textbox.caretpos = oldCaret",
    "type": "statement:assign"
  }, {
    "id": 242,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 243,
    "text": "function lib.enable(textbox, colorTable, tabWidth)\r\n        if not colorTable then colorTable = defaultColorTable end\r\n        if not tabWidth then tabWidth = defaultTabWidth end\r\n        \r\n        textbox.colorTable = colorTable\r\n        textbox.tabWidth = tabWidth\r\n        textbox.formatting = \"Yes\"\r\n        textbox.multiline = \"Yes\"\r\n        \r\n        textbox.timer = iup.timer \r\n        { \r\n          action_cb = function(timer) \r\n            timer.run = \"No\" \r\n            -- TODO: optimize this to recolor only in the changed lines\r\n            lib.textboxRecolor(textbox) \r\n          end, \r\n          time = 800\r\n        }\r\n \r\n--  AVOID: redefinition of common callbacks\r\n--        textbox.map_cb = function(textbox) \r\n--          lib.textboxRecolor(textbox) \r\n--        end\r\n        \r\n        textbox.valuechanged_cb = function(textbox) \r\n          textbox.timer.run = \"No\" -- stop to start again if already running\r\n          textbox.timer.run = \"Yes\" \r\n        end\r\n          \r\n--  AVOID: redefinition of common callbacks\r\n--        textbox.k_any = function(textbox, key)\r\n--          if key == iup.K_cF then \r\n--            lib.textboxReindent(textbox) \r\n--            return IUP_IGNORE \r\n--          end \r\n--          return IUP_CONTINUE \r\n--        end\r\n    end",
    "type": "function"
  }, {
    "id": 244,
    "text": "if not colorTable then colorTable = defaultColorTable end",
    "type": "statement:if"
  }, {
    "id": 245,
    "text": "colorTable = defaultColorTable",
    "type": "statement:assign"
  }, {
    "id": 246,
    "text": "if not tabWidth then tabWidth = defaultTabWidth end",
    "type": "statement:if"
  }, {
    "id": 247,
    "text": "textbox.colorTable = colorTable",
    "type": "statement:assign"
  }, {
    "id": 248,
    "text": "textbox.tabWidth = tabWidth",
    "type": "statement:assign"
  }, {
    "id": 249,
    "text": "textbox.formatting = \"Yes\"",
    "type": "statement:assign"
  }, {
    "id": 250,
    "text": "textbox.multiline = \"Yes\"",
    "type": "statement:assign"
  }, {
    "id": 251,
    "text": "textbox.timer = iup.timer \r\n        { \r\n          action_cb = function(timer) \r\n            timer.run = \"No\" \r\n            -- TODO: optimize this to recolor only in the changed lines\r\n            lib.textboxRecolor(textbox) \r\n          end, \r\n          time = 800\r\n        }",
    "type": "statement:assign"
  }, {
    "id": 252,
    "text": "timer.run = \"No\"",
    "type": "statement:assign"
  }, {
    "id": 253,
    "text": "lib.textboxRecolor(textbox)",
    "type": "statement:functioncall"
  }, {
    "id": 254,
    "text": "textbox.valuechanged_cb = function(textbox) \r\n          textbox.timer.run = \"No\" -- stop to start again if already running\r\n          textbox.timer.run = \"Yes\" \r\n        end",
    "type": "statement:assign"
  }, {
    "id": 255,
    "text": "textbox.timer.run = \"No\"",
    "type": "statement:assign"
  }, {
    "id": 256,
    "text": "textbox.timer.run = \"Yes\"",
    "type": "statement:assign"
  }, {
    "id": 257,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 258,
    "text": "function(textbox) \r\n          textbox.timer.run = \"No\" -- stop to start again if already running\r\n          textbox.timer.run = \"Yes\" \r\n        end",
    "type": "function"
  }, {
    "id": 259,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 260,
    "text": "function(timer) \r\n            timer.run = \"No\" \r\n            -- TODO: optimize this to recolor only in the changed lines\r\n            lib.textboxRecolor(textbox) \r\n          end",
    "type": "function"
  }, {
    "id": 261,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 262,
    "text": "",
    "type": "function container"
  }, {
    "id": 263,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 264,
    "text": "Append",
    "type": "global function"
  }, {
    "id": 265,
    "text": "stringlen",
    "type": "global function"
  }, {
    "id": 266,
    "text": "user",
    "type": "global function"
  }, {
    "id": 267,
    "text": "stringsub",
    "type": "global function"
  }, {
    "id": 268,
    "text": "fillFunction",
    "type": "global function"
  }, {
    "id": 269,
    "text": "stringbyte",
    "type": "global function"
  }, {
    "id": 270,
    "text": "stringrep",
    "type": "global function"
  }, {
    "id": 271,
    "text": "timer",
    "type": "global function"
  }, {
    "id": 272,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 273,
    "text": "",
    "type": "variable container"
  }, {
    "id": 274,
    "text": "",
    "type": "require container"
  }, {
    "id": 275,
    "text": "",
    "type": "local variable"
  }, {
    "id": 276,
    "text": "",
    "type": "number"
  } ]
}