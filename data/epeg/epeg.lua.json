{
  "_filename": "epeg.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/epeg/epeg.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "has",
    "to": 3
  }, {
    "from": 3,
    "label": "has",
    "to": 4
  }, {
    "from": 2,
    "label": "has",
    "to": 5
  }, {
    "from": 2,
    "label": "has",
    "to": 6
  }, {
    "from": 7,
    "label": "has",
    "to": 8
  }, {
    "from": 7,
    "label": "has",
    "to": 9
  }, {
    "from": 7,
    "label": "has",
    "to": 10
  }, {
    "from": 10,
    "label": "has",
    "to": 11
  }, {
    "from": 7,
    "label": "has",
    "to": 5
  }, {
    "from": 7,
    "label": "has",
    "to": 12
  }, {
    "from": 7,
    "label": "has",
    "to": 13
  }, {
    "from": 7,
    "label": "has",
    "to": 14
  }, {
    "from": 14,
    "label": "has",
    "to": 15
  }, {
    "from": 7,
    "label": "has",
    "to": 5
  }, {
    "from": 7,
    "label": "has",
    "to": 16
  }, {
    "from": 7,
    "label": "has",
    "to": 17
  }, {
    "from": 7,
    "label": "has",
    "to": 18
  }, {
    "from": 7,
    "label": "has",
    "to": 5
  }, {
    "from": 7,
    "label": "has",
    "to": 19
  }, {
    "from": 7,
    "label": "has",
    "to": 20
  }, {
    "from": 7,
    "label": "has",
    "to": 21
  }, {
    "from": 7,
    "label": "has",
    "to": 22
  }, {
    "from": 22,
    "label": "has",
    "to": 23
  }, {
    "from": 23,
    "label": "has",
    "to": 24
  }, {
    "from": 23,
    "label": "has",
    "to": 25
  }, {
    "from": 25,
    "label": "has",
    "to": 26
  }, {
    "from": 25,
    "label": "has",
    "to": 27
  }, {
    "from": 23,
    "label": "has",
    "to": 28
  }, {
    "from": 23,
    "label": "has",
    "to": 29
  }, {
    "from": 7,
    "label": "has",
    "to": 30
  }, {
    "from": 30,
    "label": "has",
    "to": 28
  }, {
    "from": 7,
    "label": "has",
    "to": 5
  }, {
    "from": 7,
    "label": "has",
    "to": 31
  }, {
    "from": 32,
    "label": "has",
    "to": 33
  }, {
    "from": 32,
    "label": "has",
    "to": 34
  }, {
    "from": 32,
    "label": "has",
    "to": 35
  }, {
    "from": 32,
    "label": "has",
    "to": 36
  }, {
    "from": 32,
    "label": "has",
    "to": 37
  }, {
    "from": 32,
    "label": "has",
    "to": 5
  }, {
    "from": 32,
    "label": "has",
    "to": 5
  }, {
    "from": 32,
    "label": "has",
    "to": 38
  }, {
    "from": 39,
    "label": "has",
    "to": 40
  }, {
    "from": 39,
    "label": "has",
    "to": 41
  }, {
    "from": 41,
    "label": "has",
    "to": 42
  }, {
    "from": 41,
    "label": "has",
    "to": 43
  }, {
    "from": 41,
    "label": "has",
    "to": 44
  }, {
    "from": 39,
    "label": "has",
    "to": 5
  }, {
    "from": 39,
    "label": "has",
    "to": 45
  }, {
    "from": 45,
    "label": "has",
    "to": 46
  }, {
    "from": 45,
    "label": "has",
    "to": 47
  }, {
    "from": 39,
    "label": "has",
    "to": 48
  }, {
    "from": 39,
    "label": "has",
    "to": 49
  }, {
    "from": 39,
    "label": "has",
    "to": 5
  }, {
    "from": 39,
    "label": "has",
    "to": 50
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 51,
    "label": "has",
    "to": 53
  }, {
    "from": 51,
    "label": "has",
    "to": 54
  }, {
    "from": 51,
    "label": "has",
    "to": 55
  }, {
    "from": 51,
    "label": "has",
    "to": 56
  }, {
    "from": 51,
    "label": "has",
    "to": 57
  }, {
    "from": 51,
    "label": "has",
    "to": 58
  }, {
    "from": 51,
    "label": "has",
    "to": 5
  }, {
    "from": 51,
    "label": "has",
    "to": 59
  }, {
    "from": 59,
    "label": "has",
    "to": 60
  }, {
    "from": 51,
    "label": "has",
    "to": 61
  }, {
    "from": 61,
    "label": "has",
    "to": 62
  }, {
    "from": 62,
    "label": "has",
    "to": 63
  }, {
    "from": 62,
    "label": "has",
    "to": 64
  }, {
    "from": 64,
    "label": "has",
    "to": 65
  }, {
    "from": 64,
    "label": "has",
    "to": 66
  }, {
    "from": 64,
    "label": "has",
    "to": 67
  }, {
    "from": 64,
    "label": "has",
    "to": 68
  }, {
    "from": 62,
    "label": "has",
    "to": 69
  }, {
    "from": 61,
    "label": "has",
    "to": 70
  }, {
    "from": 61,
    "label": "has",
    "to": 71
  }, {
    "from": 61,
    "label": "has",
    "to": 72
  }, {
    "from": 51,
    "label": "has",
    "to": 5
  }, {
    "from": 51,
    "label": "has",
    "to": 73
  }, {
    "from": 74,
    "label": "has",
    "to": 75
  }, {
    "from": 74,
    "label": "has",
    "to": 76
  }, {
    "from": 74,
    "label": "has",
    "to": 77
  }, {
    "from": 74,
    "label": "has",
    "to": 78
  }, {
    "from": 74,
    "label": "has",
    "to": 79
  }, {
    "from": 74,
    "label": "has",
    "to": 80
  }, {
    "from": 74,
    "label": "has",
    "to": 81
  }, {
    "from": 74,
    "label": "has",
    "to": 82
  }, {
    "from": 82,
    "label": "has",
    "to": 83
  }, {
    "from": 82,
    "label": "has",
    "to": 84
  }, {
    "from": 84,
    "label": "has",
    "to": 85
  }, {
    "from": 82,
    "label": "has",
    "to": 86
  }, {
    "from": 82,
    "label": "has",
    "to": 87
  }, {
    "from": 82,
    "label": "has",
    "to": 88
  }, {
    "from": 82,
    "label": "has",
    "to": 89
  }, {
    "from": 82,
    "label": "has",
    "to": 90
  }, {
    "from": 90,
    "label": "has",
    "to": 91
  }, {
    "from": 91,
    "label": "has",
    "to": 92
  }, {
    "from": 82,
    "label": "has",
    "to": 93
  }, {
    "from": 82,
    "label": "has",
    "to": 94
  }, {
    "from": 82,
    "label": "has",
    "to": 95
  }, {
    "from": 95,
    "label": "has",
    "to": 96
  }, {
    "from": 96,
    "label": "has",
    "to": 97
  }, {
    "from": 82,
    "label": "has",
    "to": 98
  }, {
    "from": 82,
    "label": "has",
    "to": 99
  }, {
    "from": 82,
    "label": "has",
    "to": 100
  }, {
    "from": 82,
    "label": "has",
    "to": 101
  }, {
    "from": 82,
    "label": "has",
    "to": 102
  }, {
    "from": 82,
    "label": "has",
    "to": 100
  }, {
    "from": 82,
    "label": "has",
    "to": 102
  }, {
    "from": 82,
    "label": "has",
    "to": 101
  }, {
    "from": 82,
    "label": "has",
    "to": 103
  }, {
    "from": 103,
    "label": "has",
    "to": 104
  }, {
    "from": 103,
    "label": "has",
    "to": 105
  }, {
    "from": 82,
    "label": "has",
    "to": 106
  }, {
    "from": 82,
    "label": "has",
    "to": 107
  }, {
    "from": 107,
    "label": "has",
    "to": 108
  }, {
    "from": 107,
    "label": "has",
    "to": 109
  }, {
    "from": 107,
    "label": "has",
    "to": 110
  }, {
    "from": 82,
    "label": "has",
    "to": 111
  }, {
    "from": 82,
    "label": "has",
    "to": 112
  }, {
    "from": 82,
    "label": "has",
    "to": 99
  }, {
    "from": 82,
    "label": "has",
    "to": 113
  }, {
    "from": 82,
    "label": "has",
    "to": 107
  }, {
    "from": 107,
    "label": "has",
    "to": 108
  }, {
    "from": 107,
    "label": "has",
    "to": 109
  }, {
    "from": 107,
    "label": "has",
    "to": 110
  }, {
    "from": 82,
    "label": "has",
    "to": 111
  }, {
    "from": 82,
    "label": "has",
    "to": 112
  }, {
    "from": 82,
    "label": "has",
    "to": 113
  }, {
    "from": 82,
    "label": "has",
    "to": 114
  }, {
    "from": 114,
    "label": "has",
    "to": 115
  }, {
    "from": 114,
    "label": "has",
    "to": 105
  }, {
    "from": 82,
    "label": "has",
    "to": 106
  }, {
    "from": 82,
    "label": "has",
    "to": 116
  }, {
    "from": 82,
    "label": "has",
    "to": 117
  }, {
    "from": 82,
    "label": "has",
    "to": 118
  }, {
    "from": 82,
    "label": "has",
    "to": 119
  }, {
    "from": 82,
    "label": "has",
    "to": 120
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 82,
    "label": "has",
    "to": 122
  }, {
    "from": 82,
    "label": "has",
    "to": 123
  }, {
    "from": 82,
    "label": "has",
    "to": 124
  }, {
    "from": 124,
    "label": "has",
    "to": 125
  }, {
    "from": 82,
    "label": "has",
    "to": 126
  }, {
    "from": 126,
    "label": "has",
    "to": 127
  }, {
    "from": 82,
    "label": "has",
    "to": 128
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 82,
    "label": "has",
    "to": 130
  }, {
    "from": 130,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 131,
    "label": "has",
    "to": 133
  }, {
    "from": 130,
    "label": "has",
    "to": 134
  }, {
    "from": 130,
    "label": "has",
    "to": 135
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 130,
    "label": "has",
    "to": 137
  }, {
    "from": 130,
    "label": "has",
    "to": 135
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 130,
    "label": "has",
    "to": 138
  }, {
    "from": 130,
    "label": "has",
    "to": 135
  }, {
    "from": 135,
    "label": "has",
    "to": 136
  }, {
    "from": 130,
    "label": "has",
    "to": 139
  }, {
    "from": 139,
    "label": "has",
    "to": 140
  }, {
    "from": 139,
    "label": "has",
    "to": 141
  }, {
    "from": 139,
    "label": "has",
    "to": 142
  }, {
    "from": 139,
    "label": "has",
    "to": 141
  }, {
    "from": 139,
    "label": "has",
    "to": 143
  }, {
    "from": 139,
    "label": "has",
    "to": 140
  }, {
    "from": 139,
    "label": "has",
    "to": 143
  }, {
    "from": 82,
    "label": "has",
    "to": 144
  }, {
    "from": 144,
    "label": "has",
    "to": 145
  }, {
    "from": 82,
    "label": "has",
    "to": 146
  }, {
    "from": 82,
    "label": "has",
    "to": 147
  }, {
    "from": 147,
    "label": "has",
    "to": 148
  }, {
    "from": 82,
    "label": "has",
    "to": 149
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 150
  }, {
    "from": 150,
    "label": "has",
    "to": 151
  }, {
    "from": 74,
    "label": "has",
    "to": 152
  }, {
    "from": 74,
    "label": "has",
    "to": 153
  }, {
    "from": 74,
    "label": "has",
    "to": 154
  }, {
    "from": 74,
    "label": "has",
    "to": 5
  }, {
    "from": 74,
    "label": "has",
    "to": 155
  }, {
    "from": 156,
    "label": "has",
    "to": 157
  }, {
    "from": 156,
    "label": "has",
    "to": 158
  }, {
    "from": 156,
    "label": "has",
    "to": 159
  }, {
    "from": 160,
    "label": "has",
    "to": 161
  }, {
    "from": 160,
    "label": "has",
    "to": 162
  }, {
    "from": 160,
    "label": "has",
    "to": 163
  }, {
    "from": 160,
    "label": "has",
    "to": 164
  }, {
    "from": 164,
    "label": "has",
    "to": 165
  }, {
    "from": 165,
    "label": "has",
    "to": 166
  }, {
    "from": 160,
    "label": "has",
    "to": 167
  }, {
    "from": 167,
    "label": "has",
    "to": 168
  }, {
    "from": 168,
    "label": "has",
    "to": 169
  }, {
    "from": 169,
    "label": "has",
    "to": 28
  }, {
    "from": 160,
    "label": "has",
    "to": 170
  }, {
    "from": 170,
    "label": "has",
    "to": 171
  }, {
    "from": 160,
    "label": "has",
    "to": 5
  }, {
    "from": 160,
    "label": "has",
    "to": 172
  }, {
    "from": 173,
    "label": "has",
    "to": 174
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 175
  }, {
    "from": 175,
    "label": "has",
    "to": 81
  }, {
    "from": 175,
    "label": "has",
    "to": 176
  }, {
    "from": 176,
    "label": "has",
    "to": 177
  }, {
    "from": 177,
    "label": "has",
    "to": 178
  }, {
    "from": 177,
    "label": "has",
    "to": 179
  }, {
    "from": 176,
    "label": "has",
    "to": 180
  }, {
    "from": 176,
    "label": "has",
    "to": 181
  }, {
    "from": 176,
    "label": "has",
    "to": 182
  }, {
    "from": 175,
    "label": "has",
    "to": 183
  }, {
    "from": 183,
    "label": "has",
    "to": 184
  }, {
    "from": 175,
    "label": "has",
    "to": 185
  }, {
    "from": 185,
    "label": "has",
    "to": 186
  }, {
    "from": 175,
    "label": "has",
    "to": 187
  }, {
    "from": 175,
    "label": "has",
    "to": 187
  }, {
    "from": 175,
    "label": "has",
    "to": 188
  }, {
    "from": 175,
    "label": "has",
    "to": 189
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 5
  }, {
    "from": 173,
    "label": "has",
    "to": 190
  }, {
    "from": 191,
    "label": "has",
    "to": 192
  }, {
    "from": 191,
    "label": "has",
    "to": 193
  }, {
    "from": 193,
    "label": "has",
    "to": 194
  }, {
    "from": 194,
    "label": "has",
    "to": 195
  }, {
    "from": 195,
    "label": "has",
    "to": 196
  }, {
    "from": 195,
    "label": "has",
    "to": 197
  }, {
    "from": 194,
    "label": "has",
    "to": 198
  }, {
    "from": 198,
    "label": "has",
    "to": 199
  }, {
    "from": 198,
    "label": "has",
    "to": 200
  }, {
    "from": 198,
    "label": "has",
    "to": 201
  }, {
    "from": 198,
    "label": "has",
    "to": 202
  }, {
    "from": 202,
    "label": "has",
    "to": 203
  }, {
    "from": 202,
    "label": "has",
    "to": 204
  }, {
    "from": 191,
    "label": "has",
    "to": 205
  }, {
    "from": 206,
    "label": "has",
    "to": 207
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 206,
    "label": "has",
    "to": 5
  }, {
    "from": 206,
    "label": "has",
    "to": 209
  }, {
    "from": 209,
    "label": "has",
    "to": 210
  }, {
    "from": 206,
    "label": "has",
    "to": 192
  }, {
    "from": 206,
    "label": "has",
    "to": 211
  }, {
    "from": 211,
    "label": "has",
    "to": 212
  }, {
    "from": 212,
    "label": "has",
    "to": 213
  }, {
    "from": 206,
    "label": "has",
    "to": 214
  }, {
    "from": 214,
    "label": "has",
    "to": 215
  }, {
    "from": 215,
    "label": "has",
    "to": 216
  }, {
    "from": 215,
    "label": "has",
    "to": 217
  }, {
    "from": 206,
    "label": "has",
    "to": 218
  }, {
    "from": 219,
    "label": "has",
    "to": 220
  }, {
    "from": 220,
    "label": "has",
    "to": 221
  }, {
    "from": 220,
    "label": "has",
    "to": 222
  }, {
    "from": 220,
    "label": "has",
    "to": 223
  }, {
    "from": 219,
    "label": "has",
    "to": 224
  }, {
    "from": 225,
    "label": "has",
    "to": 226
  }, {
    "from": 226,
    "label": "has",
    "to": 227
  }, {
    "from": 227,
    "label": "has",
    "to": 228
  }, {
    "from": 227,
    "label": "has",
    "to": 229
  }, {
    "from": 229,
    "label": "has",
    "to": 230
  }, {
    "from": 226,
    "label": "has",
    "to": 231
  }, {
    "from": 231,
    "label": "has",
    "to": 228
  }, {
    "from": 226,
    "label": "has",
    "to": 232
  }, {
    "from": 226,
    "label": "has",
    "to": 233
  }, {
    "from": 226,
    "label": "has",
    "to": 234
  }, {
    "from": 226,
    "label": "has",
    "to": 235
  }, {
    "from": 226,
    "label": "has",
    "to": 236
  }, {
    "from": 226,
    "label": "has",
    "to": 234
  }, {
    "from": 226,
    "label": "has",
    "to": 235
  }, {
    "from": 226,
    "label": "has",
    "to": 237
  }, {
    "from": 226,
    "label": "has",
    "to": 234
  }, {
    "from": 226,
    "label": "has",
    "to": 235
  }, {
    "from": 226,
    "label": "has",
    "to": 238
  }, {
    "from": 226,
    "label": "has",
    "to": 234
  }, {
    "from": 226,
    "label": "has",
    "to": 235
  }, {
    "from": 226,
    "label": "has",
    "to": 239
  }, {
    "from": 226,
    "label": "has",
    "to": 234
  }, {
    "from": 226,
    "label": "has",
    "to": 240
  }, {
    "from": 226,
    "label": "has",
    "to": 241
  }, {
    "from": 226,
    "label": "has",
    "to": 242
  }, {
    "from": 226,
    "label": "has",
    "to": 243
  }, {
    "from": 226,
    "label": "has",
    "to": 244
  }, {
    "from": 244,
    "label": "has",
    "to": 245
  }, {
    "from": 244,
    "label": "has",
    "to": 246
  }, {
    "from": 244,
    "label": "has",
    "to": 243
  }, {
    "from": 226,
    "label": "has",
    "to": 247
  }, {
    "from": 226,
    "label": "has",
    "to": 242
  }, {
    "from": 226,
    "label": "has",
    "to": 243
  }, {
    "from": 226,
    "label": "has",
    "to": 248
  }, {
    "from": 226,
    "label": "has",
    "to": 249
  }, {
    "from": 226,
    "label": "has",
    "to": 250
  }, {
    "from": 226,
    "label": "has",
    "to": 251
  }, {
    "from": 226,
    "label": "has",
    "to": 252
  }, {
    "from": 226,
    "label": "has",
    "to": 253
  }, {
    "from": 226,
    "label": "has",
    "to": 254
  }, {
    "from": 254,
    "label": "has",
    "to": 255
  }, {
    "from": 226,
    "label": "has",
    "to": 256
  }, {
    "from": 256,
    "label": "has",
    "to": 257
  }, {
    "from": 256,
    "label": "has",
    "to": 258
  }, {
    "from": 256,
    "label": "has",
    "to": 259
  }, {
    "from": 256,
    "label": "has",
    "to": 258
  }, {
    "from": 226,
    "label": "has",
    "to": 260
  }, {
    "from": 260,
    "label": "has",
    "to": 261
  }, {
    "from": 226,
    "label": "has",
    "to": 262
  }, {
    "from": 262,
    "label": "has",
    "to": 263
  }, {
    "from": 226,
    "label": "has",
    "to": 264
  }, {
    "from": 225,
    "label": "has",
    "to": 265
  }, {
    "from": 266,
    "label": "has",
    "to": 267
  }, {
    "from": 266,
    "label": "has",
    "to": 268
  }, {
    "from": 266,
    "label": "has",
    "to": 269
  }, {
    "from": 266,
    "label": "has",
    "to": 270
  }, {
    "from": 266,
    "label": "has",
    "to": 271
  }, {
    "from": 266,
    "label": "has",
    "to": 5
  }, {
    "from": 266,
    "label": "has",
    "to": 272
  }, {
    "from": 273,
    "label": "has",
    "to": 16
  }, {
    "from": 273,
    "label": "has",
    "to": 274
  }, {
    "from": 273,
    "label": "has",
    "to": 5
  }, {
    "from": 273,
    "label": "has",
    "to": 275
  }, {
    "from": 7,
    "label": "calls",
    "to": 277
  }, {
    "from": 7,
    "label": "calls",
    "to": 277
  }, {
    "from": 7,
    "label": "calls",
    "to": 277
  }, {
    "from": 7,
    "label": "calls",
    "to": 277
  }, {
    "from": 51,
    "label": "calls",
    "to": 277
  }, {
    "from": 74,
    "label": "calls",
    "to": 277
  }, {
    "from": 156,
    "label": "calls",
    "to": 277
  }, {
    "from": 160,
    "label": "calls",
    "to": 277
  }, {
    "from": 160,
    "label": "calls",
    "to": 277
  }, {
    "from": 173,
    "label": "calls",
    "to": 277
  }, {
    "from": 173,
    "label": "calls",
    "to": 277
  }, {
    "from": 206,
    "label": "calls",
    "to": 277
  }, {
    "from": 206,
    "label": "calls",
    "to": 277
  }, {
    "from": 219,
    "label": "calls",
    "to": 277
  }, {
    "from": 219,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 225,
    "label": "calls",
    "to": 277
  }, {
    "from": 74,
    "label": "calls",
    "to": 266
  }, {
    "from": 74,
    "label": "calls",
    "to": 266
  }, {
    "from": 32,
    "label": "calls",
    "to": 278
  }, {
    "from": 160,
    "label": "calls",
    "to": 279
  }, {
    "from": 160,
    "label": "calls",
    "to": 279
  }, {
    "from": 191,
    "label": "calls",
    "to": 279
  }, {
    "from": 206,
    "label": "calls",
    "to": 279
  }, {
    "from": 206,
    "label": "calls",
    "to": 279
  }, {
    "from": 219,
    "label": "calls",
    "to": 279
  }, {
    "from": 74,
    "label": "calls",
    "to": 206
  }, {
    "from": 74,
    "label": "calls",
    "to": 206
  }, {
    "from": 74,
    "label": "calls",
    "to": 206
  }, {
    "from": 74,
    "label": "calls",
    "to": 206
  }, {
    "from": 206,
    "label": "calls",
    "to": 206
  }, {
    "from": 7,
    "label": "calls",
    "to": 298
  }, {
    "from": 39,
    "label": "calls",
    "to": 298
  }, {
    "from": 160,
    "label": "calls",
    "to": 173
  }, {
    "from": 173,
    "label": "calls",
    "to": 173
  }, {
    "from": 173,
    "label": "calls",
    "to": 173
  }, {
    "from": 173,
    "label": "calls",
    "to": 173
  }, {
    "from": 173,
    "label": "calls",
    "to": 173
  }, {
    "from": 173,
    "label": "calls",
    "to": 173
  }, {
    "from": 173,
    "label": "calls",
    "to": 173
  }, {
    "from": 173,
    "label": "calls",
    "to": 173
  }, {
    "from": 173,
    "label": "calls",
    "to": 173
  }, {
    "from": 2,
    "label": "calls",
    "to": 282
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 74,
    "label": "calls",
    "to": 74
  }, {
    "from": 51,
    "label": "calls",
    "to": 284
  }, {
    "from": 7,
    "label": "calls",
    "to": 32
  }, {
    "from": 51,
    "label": "calls",
    "to": 286
  }, {
    "from": 51,
    "label": "calls",
    "to": 286
  }, {
    "from": 32,
    "label": "calls",
    "to": 280
  }, {
    "from": 7,
    "label": "calls",
    "to": 160
  }, {
    "from": 7,
    "label": "calls",
    "to": 287
  }, {
    "from": 74,
    "label": "calls",
    "to": 287
  }, {
    "from": 74,
    "label": "calls",
    "to": 287
  }, {
    "from": 74,
    "label": "calls",
    "to": 287
  }, {
    "from": 173,
    "label": "calls",
    "to": 287
  }, {
    "from": 173,
    "label": "calls",
    "to": 287
  }, {
    "from": 225,
    "label": "calls",
    "to": 287
  }, {
    "from": 225,
    "label": "calls",
    "to": 287
  }, {
    "from": 191,
    "label": "calls",
    "to": 273
  }, {
    "from": 74,
    "label": "calls",
    "to": 288
  }, {
    "from": 74,
    "label": "calls",
    "to": 288
  }, {
    "from": 74,
    "label": "calls",
    "to": 288
  }, {
    "from": 74,
    "label": "calls",
    "to": 288
  }, {
    "from": 74,
    "label": "calls",
    "to": 288
  }, {
    "from": 74,
    "label": "calls",
    "to": 288
  }, {
    "from": 206,
    "label": "calls",
    "to": 294
  }, {
    "from": 39,
    "label": "calls",
    "to": 191
  }, {
    "from": 191,
    "label": "calls",
    "to": 191
  }, {
    "from": 191,
    "label": "calls",
    "to": 289
  }, {
    "from": 206,
    "label": "calls",
    "to": 289
  }, {
    "from": 156,
    "label": "calls",
    "to": 283
  }, {
    "from": 32,
    "label": "calls",
    "to": 292
  }, {
    "from": 74,
    "label": "calls",
    "to": 297
  }, {
    "from": 156,
    "label": "calls",
    "to": 297
  }, {
    "from": 156,
    "label": "calls",
    "to": 297
  }, {
    "from": 156,
    "label": "calls",
    "to": 297
  }, {
    "from": 173,
    "label": "calls",
    "to": 297
  }, {
    "from": 191,
    "label": "calls",
    "to": 297
  }, {
    "from": 191,
    "label": "calls",
    "to": 297
  }, {
    "from": 206,
    "label": "calls",
    "to": 297
  }, {
    "from": 206,
    "label": "calls",
    "to": 297
  }, {
    "from": 206,
    "label": "calls",
    "to": 297
  }, {
    "from": 74,
    "label": "calls",
    "to": 281
  }, {
    "from": 7,
    "label": "calls",
    "to": 295
  }, {
    "from": 39,
    "label": "calls",
    "to": 295
  }, {
    "from": 191,
    "label": "calls",
    "to": 295
  }, {
    "from": 191,
    "label": "calls",
    "to": 295
  }, {
    "from": 191,
    "label": "calls",
    "to": 295
  }, {
    "from": 206,
    "label": "calls",
    "to": 295
  }, {
    "from": 206,
    "label": "calls",
    "to": 295
  }, {
    "from": 206,
    "label": "calls",
    "to": 295
  }, {
    "from": 74,
    "label": "calls",
    "to": 296
  }, {
    "from": 266,
    "label": "calls",
    "to": 296
  }, {
    "from": 273,
    "label": "calls",
    "to": 296
  }, {
    "from": 74,
    "label": "calls",
    "to": 293
  }, {
    "from": 219,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 225,
    "label": "calls",
    "to": 225
  }, {
    "from": 1,
    "label": "contains",
    "to": 276
  }, {
    "from": 276,
    "label": "declares",
    "to": 2
  }, {
    "from": 276,
    "label": "declares",
    "to": 7
  }, {
    "from": 276,
    "label": "declares",
    "to": 32
  }, {
    "from": 276,
    "label": "declares",
    "to": 39
  }, {
    "from": 276,
    "label": "declares",
    "to": 51
  }, {
    "from": 276,
    "label": "declares",
    "to": 74
  }, {
    "from": 276,
    "label": "declares",
    "to": 156
  }, {
    "from": 276,
    "label": "declares",
    "to": 160
  }, {
    "from": 276,
    "label": "declares",
    "to": 173
  }, {
    "from": 276,
    "label": "declares",
    "to": 191
  }, {
    "from": 276,
    "label": "declares",
    "to": 206
  }, {
    "from": 276,
    "label": "declares",
    "to": 219
  }, {
    "from": 276,
    "label": "declares",
    "to": 225
  }, {
    "from": 276,
    "label": "declares",
    "to": 266
  }, {
    "from": 276,
    "label": "declares",
    "to": 273
  }, {
    "from": 1,
    "label": "declares",
    "to": 285
  }, {
    "from": 1,
    "label": "declares",
    "to": 290
  }, {
    "from": 1,
    "label": "declares",
    "to": 291
  }, {
    "from": 1,
    "label": "contains",
    "to": 299
  }, {
    "from": 1,
    "label": "contains",
    "to": 300
  }, {
    "from": 299,
    "label": "initializes",
    "to": 301
  }, {
    "from": 301,
    "label": "assigns",
    "to": 302
  }, {
    "from": 299,
    "label": "initializes",
    "to": 303
  }, {
    "from": 303,
    "label": "assigns",
    "to": 304
  }, {
    "from": 299,
    "label": "initializes",
    "to": 305
  }, {
    "from": 305,
    "label": "assigns",
    "to": 306
  }, {
    "from": 299,
    "label": "initializes",
    "to": 307
  }, {
    "from": 307,
    "label": "assigns",
    "to": 308
  }, {
    "from": 299,
    "label": "initializes",
    "to": 309
  }, {
    "from": 309,
    "label": "assigns",
    "to": 310
  }, {
    "from": 1,
    "label": "provides",
    "to": 311
  }, {
    "from": 301,
    "label": "represents",
    "to": 312
  }, {
    "from": 311,
    "label": "provides",
    "to": 312
  }, {
    "from": 303,
    "label": "contains",
    "to": 2
  }, {
    "from": 301,
    "label": "contains",
    "to": 7
  }, {
    "from": 301,
    "label": "contains",
    "to": 32
  }, {
    "from": 301,
    "label": "contains",
    "to": 39
  }, {
    "from": 301,
    "label": "contains",
    "to": 74
  }, {
    "from": 301,
    "label": "contains",
    "to": 160
  }, {
    "from": 301,
    "label": "contains",
    "to": 173
  }, {
    "from": 301,
    "label": "contains",
    "to": 191
  }, {
    "from": 301,
    "label": "contains",
    "to": 206
  }, {
    "from": 301,
    "label": "contains",
    "to": 219
  }, {
    "from": 301,
    "label": "contains",
    "to": 225
  }, {
    "from": 301,
    "label": "contains",
    "to": 266
  }, {
    "from": 301,
    "label": "contains",
    "to": 273
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "epeg",
    "type": "module"
  }, {
    "id": 2,
    "text": "function epeg_proxy.__index(table, key)\r\n\tif epeg[key] == nil then error(\"Called unknown function \"..key..\".\\n\") end\r\n\treturn epeg[key]\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "if epeg[key] == nil then error(\"Called unknown function \"..key..\".\\n\") end",
    "type": "statement:if"
  }, {
    "id": 4,
    "text": "error(\"Called unknown function \"..key..\".\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 5,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 6,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 7,
    "text": "function epeg.read_grammar(filename)\r\n\r\n\tlocal file, input, error\r\n\tfile, error = io.open(filename, 'r')\r\n\r\n\tif file == nil then\r\n\t\tio.write(\"Error: could not open \", filename, \".\\nReason: \", error)\r\n\t\treturn false\r\n\tend\r\n\r\n\tinput = file:read('*a')\r\n\tfile:close()\r\n\r\n\tif input == nil then\r\n\t\tio.write(\"Error: Could not read out of file or file is empty.\")\r\n\t\treturn false\r\n\tend\r\n\r\n\tlocal result\r\n\r\n\t-- Get ast from epeg.\r\n\tresult = epeg.parse_text(epeg.grammar, input)\r\n\r\n\tif not result then return false end\r\n\r\n\t-- Refine ast to grammar.\r\n\tlocal r = result[1].name.string\r\n\tlocal grammar = { [0] = r }\r\n\tlocal ok = grammar\r\n\r\n\tfor i,v in ipairs(result) do\r\n\t\tif grammar[v.name.string] then\r\n\t\t\tio.write(\"Error: Rule \", v.name.string, \" redeclared at \", v.row, \":\", v.column, \".\\n\")\r\n\t\t\tif not type(grammar[v.name.string]) == \"bool\" then\r\n\t\t\t\tio.write(\"Error: Original declaration at \", grammar[v.name.string].row, \":\", grammar[v.name.string].column, \".\\n\")\r\n\t\t\telse\r\n\t\t\t\tgrammar[v.name.string] = false\r\n\t\t\tend\r\n\r\n\t\t\tok = false\r\n\t\telse\r\n\t\t\tgrammar[v.name.string] = v\r\n\t\tend\r\n\tend\r\n\r\n\tif ok and not epeg.check(grammar) then ok = false end\r\n\r\n\treturn ok\r\nend",
    "type": "function"
  }, {
    "id": 8,
    "text": "local file, input, error",
    "type": "statement:localassign"
  }, {
    "id": 9,
    "text": "file, error = io.open(filename, 'r')",
    "type": "statement:assign"
  }, {
    "id": 10,
    "text": "if file == nil then\r\n\t\tio.write(\"Error: could not open \", filename, \".\\nReason: \", error)\r\n\t\treturn false\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 11,
    "text": "io.write(\"Error: could not open \", filename, \".\\nReason: \", error)",
    "type": "statement:functioncall"
  }, {
    "id": 12,
    "text": "input = file:read('*a')",
    "type": "statement:assign"
  }, {
    "id": 13,
    "text": "file:close()",
    "type": "statement:functioncall"
  }, {
    "id": 14,
    "text": "if input == nil then\r\n\t\tio.write(\"Error: Could not read out of file or file is empty.\")\r\n\t\treturn false\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 15,
    "text": "io.write(\"Error: Could not read out of file or file is empty.\")",
    "type": "statement:functioncall"
  }, {
    "id": 16,
    "text": "local result",
    "type": "statement:localassign"
  }, {
    "id": 17,
    "text": "result = epeg.parse_text(epeg.grammar, input)",
    "type": "statement:assign"
  }, {
    "id": 18,
    "text": "if not result then return false end",
    "type": "statement:if"
  }, {
    "id": 19,
    "text": "local r = result[1].name.string",
    "type": "statement:localassign"
  }, {
    "id": 20,
    "text": "local grammar = { [0] = r }",
    "type": "statement:localassign"
  }, {
    "id": 21,
    "text": "local ok = grammar",
    "type": "statement:localassign"
  }, {
    "id": 22,
    "text": "for i,v in ipairs(result) do\r\n\t\tif grammar[v.name.string] then\r\n\t\t\tio.write(\"Error: Rule \", v.name.string, \" redeclared at \", v.row, \":\", v.column, \".\\n\")\r\n\t\t\tif not type(grammar[v.name.string]) == \"bool\" then\r\n\t\t\t\tio.write(\"Error: Original declaration at \", grammar[v.name.string].row, \":\", grammar[v.name.string].column, \".\\n\")\r\n\t\t\telse\r\n\t\t\t\tgrammar[v.name.string] = false\r\n\t\t\tend\r\n\r\n\t\t\tok = false\r\n\t\telse\r\n\t\t\tgrammar[v.name.string] = v\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 23,
    "text": "if grammar[v.name.string] then\r\n\t\t\tio.write(\"Error: Rule \", v.name.string, \" redeclared at \", v.row, \":\", v.column, \".\\n\")\r\n\t\t\tif not type(grammar[v.name.string]) == \"bool\" then\r\n\t\t\t\tio.write(\"Error: Original declaration at \", grammar[v.name.string].row, \":\", grammar[v.name.string].column, \".\\n\")\r\n\t\t\telse\r\n\t\t\t\tgrammar[v.name.string] = false\r\n\t\t\tend\r\n\r\n\t\t\tok = false\r\n\t\telse\r\n\t\t\tgrammar[v.name.string] = v\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 24,
    "text": "io.write(\"Error: Rule \", v.name.string, \" redeclared at \", v.row, \":\", v.column, \".\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 25,
    "text": "if not type(grammar[v.name.string]) == \"bool\" then\r\n\t\t\t\tio.write(\"Error: Original declaration at \", grammar[v.name.string].row, \":\", grammar[v.name.string].column, \".\\n\")\r\n\t\t\telse\r\n\t\t\t\tgrammar[v.name.string] = false\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 26,
    "text": "io.write(\"Error: Original declaration at \", grammar[v.name.string].row, \":\", grammar[v.name.string].column, \".\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 27,
    "text": "grammar[v.name.string] = false",
    "type": "statement:assign"
  }, {
    "id": 28,
    "text": "ok = false",
    "type": "statement:assign"
  }, {
    "id": 29,
    "text": "grammar[v.name.string] = v",
    "type": "statement:assign"
  }, {
    "id": 30,
    "text": "if ok and not epeg.check(grammar) then ok = false end",
    "type": "statement:if"
  }, {
    "id": 31,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 32,
    "text": "function epeg.parse_text(grammar, text)\r\n\tlocal topnode = {\r\n\t\t[\"position\"] = 1,\r\n\t\t[\"column\"] = 0,\r\n\t\t[\"row\"] = 1,\r\n\t\t[\"string\"] = \"\"\r\n\t}\r\n\r\n\tlocal parser = {\r\n\t\t[\"position\"] = 1,\r\n\t\t[\"column\"] = 0,\r\n\t\t[\"row\"] = 1,\r\n\t\t[\"to_parse\"] = text,\r\n\t\t[\"grammar\"] = grammar,\r\n\t\t[\"grabs\"] = 0,\r\n\t\t[\"anchor\"] = {},\r\n\t\t[\"topnode\"] = topnode,\r\n\t}\r\n\r\n\tsetmetatable(parser, epeg_proxy)\r\n\r\n\tparsing = coroutine.create(epeg.run_rule)\r\n\tif not coroutine.resume(parsing, parser, grammar[grammar[0]], topnode) then\r\n\t\treturn false\r\n\tend\r\n\r\n\treturn topnode\r\nend",
    "type": "function"
  }, {
    "id": 33,
    "text": "local topnode = {\r\n\t\t[\"position\"] = 1,\r\n\t\t[\"column\"] = 0,\r\n\t\t[\"row\"] = 1,\r\n\t\t[\"string\"] = \"\"\r\n\t}",
    "type": "statement:localassign"
  }, {
    "id": 34,
    "text": "local parser = {\r\n\t\t[\"position\"] = 1,\r\n\t\t[\"column\"] = 0,\r\n\t\t[\"row\"] = 1,\r\n\t\t[\"to_parse\"] = text,\r\n\t\t[\"grammar\"] = grammar,\r\n\t\t[\"grabs\"] = 0,\r\n\t\t[\"anchor\"] = {},\r\n\t\t[\"topnode\"] = topnode,\r\n\t}",
    "type": "statement:localassign"
  }, {
    "id": 35,
    "text": "setmetatable(parser, epeg_proxy)",
    "type": "statement:functioncall"
  }, {
    "id": 36,
    "text": "parsing = coroutine.create(epeg.run_rule)",
    "type": "statement:assign"
  }, {
    "id": 37,
    "text": "if not coroutine.resume(parsing, parser, grammar[grammar[0]], topnode) then\r\n\t\treturn false\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 38,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 39,
    "text": "function epeg.dump_grammar(grammar, name, filename)\r\n\tlocal file, err\r\n\r\n\tif not filename then\r\n\t\tfile = io.stdout\r\n\telse\r\n\t\tfile, err = io.open(filename, \"w\")\r\n\t\tif not file then return err end\r\n\tend\r\n\r\n\tif type(name) ~= \"string\" then\r\n\t\tfile:write(\"return {\\n\")\r\n\telse\r\n\t\tfile:write(name, \" = {\\n\")\r\n\tend\r\n\r\n\tepeg.dump_table(grammar, file, 1)\r\n\tfile:write(\"}\\n\")\r\n\r\n\treturn true\r\nend",
    "type": "function"
  }, {
    "id": 40,
    "text": "local file, err",
    "type": "statement:localassign"
  }, {
    "id": 41,
    "text": "if not filename then\r\n\t\tfile = io.stdout\r\n\telse\r\n\t\tfile, err = io.open(filename, \"w\")\r\n\t\tif not file then return err end\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 42,
    "text": "file = io.stdout",
    "type": "statement:assign"
  }, {
    "id": 43,
    "text": "file, err = io.open(filename, \"w\")",
    "type": "statement:assign"
  }, {
    "id": 44,
    "text": "if not file then return err end",
    "type": "statement:if"
  }, {
    "id": 45,
    "text": "if type(name) ~= \"string\" then\r\n\t\tfile:write(\"return {\\n\")\r\n\telse\r\n\t\tfile:write(name, \" = {\\n\")\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 46,
    "text": "file:write(\"return {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 47,
    "text": "file:write(name, \" = {\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 48,
    "text": "epeg.dump_table(grammar, file, 1)",
    "type": "statement:functioncall"
  }, {
    "id": 49,
    "text": "file:write(\"}\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 50,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 51,
    "text": "function epeg:read_next(regex, walk, plain)\r\n\tlocal start, length, char, row, column, position, to_parse\r\n\r\n\tposition = self.position\r\n\trow = self.row\r\n\tcolumn = self.column\r\n\tto_parse = self.to_parse\r\n\r\n\tstart, stop = string.find(to_parse, regex, position, plain)\r\n\r\n\tif start == nil then\r\n\t\treturn false\r\n\tend\r\n\r\n\tif start ~= position then\r\n\t\tio.write(\"Note: Regex \", regex,\r\n\t\t\t\t \" does not match against the actual position. (position=\",\r\n\t\t\t\t position,\", row=\", row, \", column=\", column,\r\n\t\t\t\t \")\\n\")\r\n\tend\r\n\r\n\t-- update row/column/position\r\n\tif walk ~= false then\r\n\t\tfor i = position, stop do\r\n\t\t\tchar = string.sub(to_parse, position, position)\r\n\r\n\t\t\tif char == '\\n' then\r\n\t\t\t\trow = row + 1\r\n\t\t\t\tcolumn = 0\r\n\t\t\t-- tabs count as 4 whitespaces\r\n\t\t\telseif char == '\\t' then\r\n\t\t\t\tcolumn = column + 4\r\n\t\t\telse\r\n\t\t\t\tcolumn = column + 1\r\n\t\t\tend\r\n\r\n\t\t\tposition = position + 1\r\n\t\tend\r\n\r\n\t\tself.position = position\r\n\t\tself.row = row\r\n\t\tself.column = column\r\n\tend\r\n\r\n\treturn string.sub(to_parse, start, stop)\r\nend",
    "type": "function"
  }, {
    "id": 52,
    "text": "local start, length, char, row, column, position, to_parse",
    "type": "statement:localassign"
  }, {
    "id": 53,
    "text": "position = self.position",
    "type": "statement:assign"
  }, {
    "id": 54,
    "text": "row = self.row",
    "type": "statement:assign"
  }, {
    "id": 55,
    "text": "column = self.column",
    "type": "statement:assign"
  }, {
    "id": 56,
    "text": "to_parse = self.to_parse",
    "type": "statement:assign"
  }, {
    "id": 57,
    "text": "start, stop = string.find(to_parse, regex, position, plain)",
    "type": "statement:assign"
  }, {
    "id": 58,
    "text": "if start == nil then\r\n\t\treturn false\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 59,
    "text": "if start ~= position then\r\n\t\tio.write(\"Note: Regex \", regex,\r\n\t\t\t\t \" does not match against the actual position. (position=\",\r\n\t\t\t\t position,\", row=\", row, \", column=\", column,\r\n\t\t\t\t \")\\n\")\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 60,
    "text": "io.write(\"Note: Regex \", regex,\r\n\t\t\t\t \" does not match against the actual position. (position=\",\r\n\t\t\t\t position,\", row=\", row, \", column=\", column,\r\n\t\t\t\t \")\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 61,
    "text": "if walk ~= false then\r\n\t\tfor i = position, stop do\r\n\t\t\tchar = string.sub(to_parse, position, position)\r\n\r\n\t\t\tif char == '\\n' then\r\n\t\t\t\trow = row + 1\r\n\t\t\t\tcolumn = 0\r\n\t\t\t-- tabs count as 4 whitespaces\r\n\t\t\telseif char == '\\t' then\r\n\t\t\t\tcolumn = column + 4\r\n\t\t\telse\r\n\t\t\t\tcolumn = column + 1\r\n\t\t\tend\r\n\r\n\t\t\tposition = position + 1\r\n\t\tend\r\n\r\n\t\tself.position = position\r\n\t\tself.row = row\r\n\t\tself.column = column\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 62,
    "text": "for i = position, stop do\r\n\t\t\tchar = string.sub(to_parse, position, position)\r\n\r\n\t\t\tif char == '\\n' then\r\n\t\t\t\trow = row + 1\r\n\t\t\t\tcolumn = 0\r\n\t\t\t-- tabs count as 4 whitespaces\r\n\t\t\telseif char == '\\t' then\r\n\t\t\t\tcolumn = column + 4\r\n\t\t\telse\r\n\t\t\t\tcolumn = column + 1\r\n\t\t\tend\r\n\r\n\t\t\tposition = position + 1\r\n\t\tend",
    "type": "statement:numericfor"
  }, {
    "id": 63,
    "text": "char = string.sub(to_parse, position, position)",
    "type": "statement:assign"
  }, {
    "id": 64,
    "text": "if char == '\\n' then\r\n\t\t\t\trow = row + 1\r\n\t\t\t\tcolumn = 0\r\n\t\t\t-- tabs count as 4 whitespaces\r\n\t\t\telseif char == '\\t' then\r\n\t\t\t\tcolumn = column + 4\r\n\t\t\telse\r\n\t\t\t\tcolumn = column + 1\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 65,
    "text": "row = row + 1",
    "type": "statement:assign"
  }, {
    "id": 66,
    "text": "column = 0",
    "type": "statement:assign"
  }, {
    "id": 67,
    "text": "column = column + 4",
    "type": "statement:assign"
  }, {
    "id": 68,
    "text": "column = column + 1",
    "type": "statement:assign"
  }, {
    "id": 69,
    "text": "position = position + 1",
    "type": "statement:assign"
  }, {
    "id": 70,
    "text": "self.position = position",
    "type": "statement:assign"
  }, {
    "id": 71,
    "text": "self.row = row",
    "type": "statement:assign"
  }, {
    "id": 72,
    "text": "self.column = column",
    "type": "statement:assign"
  }, {
    "id": 73,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 74,
    "text": "function epeg.run_rule(parser, rule, node, parent)\r\n\tlocal position = parser.position\r\n\tlocal row = parser.row\r\n\tlocal column = parser.column\r\n\tlocal string_old_length = #(node.string)\r\n\tlocal string_old = node.string\r\n\r\n\tlocal newnode = {\r\n\t\t[\"position\"] = position,\r\n\t\t[\"column\"] = column,\r\n\t\t[\"row\"] = row,\r\n\t\t[\"string\"] = \"\",\r\n\t\t[\"parent\"] = node\r\n\t}\r\n\r\n\tlocal result = false\r\n\r\n\tif rule.type.string == \"Rule\" then\r\n\t\tresult = epeg.run_rule(parser, rule.rule, node)\r\n\t\treturn result\r\n\r\n\telseif rule.type.string == \"Choice\" then\r\n\t\t-- Only one list out of the selection has to match successfull.\r\n\r\n\t\tfor rulename, subrule in ipairs(rule) do\r\n\t\t\tif epeg.run_rule(parser, subrule, node) then\r\n\t\t\t\treturn true\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\t-- Failed. Resetting the parser gets handled at the end of the function.\r\n\r\n\telseif rule.type.string == \"List\" then\r\n\t\t-- Every pattern in the list needs to succeed. If not, we have to\r\n\t\t-- reset the tree and parser to the state before we went through\r\n\t\t-- the list.\r\n\t\t-- To reset the tree, we use parser.anchor to store a reference to all\r\n\t\t-- newly created child nodes. If the rule fails, we can use this list to\r\n\t\t-- remove the newly added childs from our actual node.\r\n\t\t-- The parser gets reset at the end of the function.\r\n\r\n\t\tlocal oldanchor = parser.anchor\r\n\t\tlocal anchor = {}\r\n\t\tparser.anchor = anchor\r\n\r\n\t\tlocal worked = true\r\n\r\n\t\tfor rulename, subrule in ipairs(rule) do\r\n\t\t\tif not epeg.run_rule(parser, subrule, node) then\r\n\t\t\t\tworked = false\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tparser.anchor = oldanchor\r\n\r\n\t\tif worked then return true end\r\n\r\n\t\t-- the rule failed and we have to remove every created child node from\r\n\t\t-- our node to clean the mess up.\r\n\t\tfor i,v in ipairs(anchor) do\r\n\t\t\tif v ~= -1 then\r\n\t\t\t\tnode[v] = nil\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tanchor = nil\r\n\r\n\telseif rule.type.string == \"RuleName\" then\r\n\t\treturn epeg.run_rule(parser, parser.grammar[rule.name.string], node)\r\n\r\n\telseif rule.type.string == \"AnonymousFixedNode\" then\r\n\t\tnewnode.string = rule.grabs.string\r\n\t\ttable.insert(node, newnode)\r\n\t\ttable.insert(parser.anchor, #node)\r\n\t\tnewnode.pindex = #node\r\n\t\treturn true\r\n\r\n\telseif rule.type.string == \"AnonymousGrabbingNode\" then\r\n\t\ttable.insert(node, newnode)\r\n\t\tnewnode.pindex = #node\r\n\t\ttable.insert(parser.anchor, #node)\r\n\r\n\t\tif not epeg.run_rule(parser, rule.grabs, newnode) then\r\n\t\t\ttable.remove(node)\r\n\t\t\tparser.anchor[#parser.anchor] = -1\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tnewnode.string = epeg.unescape_string(newnode.string)\r\n\r\n\t\treturn true\r\n\r\n\telseif rule.type.string == \"FixedNode\" then\r\n\r\n\t\tif node[rule.name.string] then\r\n\t\t\tepeg.print_table(node)\r\n\t\t\tepeg.print_table(rule)\r\n\t\t\tparser:error(\"Tried to add second node with same name (\"..rule.name.string..\") to parent node.\")\r\n\t\tend\r\n\r\n\t\tnode[rule.name.string] = newnode\r\n\t\tnewnode.pindex = rule.name.string\r\n\t\tnewnode.string = rule.grabs.string\r\n\t\ttable.insert(parser.anchor, rule.name.string)\r\n\t\treturn true\r\n\r\n\telseif rule.type.string == \"GrabbingNode\" then\r\n\t\tif node[rule.name.string] then\r\n\t\t\tepeg.print_table(node)\r\n\t\t\tepeg.print_table(rule)\r\n\t\t\tparser:error(\"Tried to add second node with same name (\"..rule.name.string..\") to parent node.\")\r\n\t\tend\r\n\r\n\t\tnode[rule.name.string] = newnode\r\n\t\tnewnode.pindex = rule.name.string\r\n\t\ttable.insert(parser.anchor, rule.name.string)\r\n\r\n\t\tif not epeg.run_rule(parser, rule.grabs, newnode) then\r\n\t\t\tnode[rule.name.string] = nil\r\n\t\t\tparser.anchor[#parser.anchor] = -1\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tnewnode.string = epeg.unescape_string(newnode.string)\r\n\r\n\t\treturn true\r\n\r\n\telseif rule.type.string == \"CollectInput\" then\r\n\r\n\t\tparser.grabs = parser.grabs + 1\r\n\t\tresult = epeg.run_rule(parser, rule.grabs, node)\r\n\t\tparser.grabs = parser.grabs - 1\r\n\r\n\t\treturn result\r\n\r\n\telseif rule.type.string == \"FunctionCall\" then\r\n\r\n\t\tresult = _G[rule[\"function\"][\"string\"]](parser, node)\r\n\r\n\t\tif parent and parent.type.string == \"Pattern\" and parent.prefix then\r\n\t\t\tif parent.prefix.string == \"!\" then return not result\r\n\t\t\telse return result end\r\n\t\tend\r\n\r\n\t\treturn true\r\n\telseif rule.type.string == \"Pattern\" then\r\n\t\tlocal repetition = \"\"\r\n\t\tlocal prefix = \"\"\r\n\r\n\t\tif rule.errorhandling and rule.errorhandling.type.string == \"Warning\" then\r\n\t\t\tio.write(\"Warning (row=\"..parser.row..\", column=\"..parser.column..\"): \"..rule.errorhandling.message.string)\r\n\t\tend\r\n\r\n\t\tif rule.prefix then prefix = rule.prefix.string end\r\n\r\n\t\tif rule.repetition then repetition = rule.repetition.string end\r\n\r\n\t\t-- First check for simple rules (string, dot and class), because we can\r\n\t\t-- use regular expressions to match them.\r\n\t\tif rule.pattern.type.string == \"String\" then\r\n\t\t\tif not rule.pattern.is_escaped then\r\n\t\t\t\trule.pattern.value.string = string.gsub(rule.pattern.value.string, \"[%$%^%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\")\r\n\t\t\t\trule.pattern.is_escaped = true\r\n\t\t\tend\r\n\r\n\t\t\tresult = parser:read_next(\"^\"..rule.pattern.value.string..repetition)\r\n\t\t\tif parser.grabs ~= 0 and result then node.string = node.string..result end\r\n\r\n\t\telseif rule.pattern.type.string == \"Dot\" then\r\n\t\t\tresult = parser:read_next(\"^\"..\".\"..repetition)\r\n\t\t\tif parser.grabs ~= 0 and result then node.string = node.string..result end\r\n\r\n\t\telseif rule.pattern.type.string == \"Class\" then\r\n\t\t\tresult = parser:read_next(\"^\"..\"[\"..rule.pattern.value.string..\"]\"..repetition)\r\n\t\t\tif parser.grabs ~= 0 and result then node.string = node.string..result end\r\n\r\n\t\telse\r\n\t\t\t-- Otherwise we handle the complex rules:\r\n\r\n\t\t\tif repetition == \"*\" then\r\n\t\t\t\twhile epeg.run_rule(parser, rule.pattern, node, rule) do end\r\n\t\t\t\tresult = true\r\n\t\t\telseif repetition == \"?\" then\r\n\t\t\t\tepeg.run_rule(parser, rule.pattern, node, rule)\r\n\t\t\t\tresult = true\r\n\t\t\telseif repetition == \"+\" then\r\n\t\t\t\tresult = epeg.run_rule(parser, rule.pattern, node, rule)\r\n\r\n\t\t\t\twhile epeg.run_rule(parser, rule.pattern, node, rule) do end\r\n\t\t\telse\r\n\t\t\t\tresult = epeg.run_rule(parser, rule.pattern, node, rule)\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tif rule.prefix and rule.prefix.string == \"!\" then result = not result end\r\n\r\n\t\tif result and not rule.prefix then return true end\r\n\r\n\t\tif not result and rule.errorhandling and rule.errorhandling.type.string == \"Error\" then\r\n\t\t\tparser:error(rule.errorhandling.message.string)\r\n\t\tend\r\n\r\n\telse\r\n\t\tparser:error(\"Epeg construct \"..tostring(rule.type.string)..\" not implemented or unknown.\")\r\n\tend\r\n\r\n\t-- Reset parser to position before we processed the rule.\r\n\t-- (used by !, & and if the rule failed)\r\n\r\n\t-- If the rule failed, we have to reset the grabbed input, too.\r\n\tif parser.grabs ~= 0 and #(node.string) ~= string_old_length and not result then\r\n\t\tnode.string = string_old\r\n\tend\r\n\r\n\tparser.row = row\r\n\tparser.column = column\r\n\tparser.position = position\r\n\r\n\treturn result\r\nend",
    "type": "function"
  }, {
    "id": 75,
    "text": "local position = parser.position",
    "type": "statement:localassign"
  }, {
    "id": 76,
    "text": "local row = parser.row",
    "type": "statement:localassign"
  }, {
    "id": 77,
    "text": "local column = parser.column",
    "type": "statement:localassign"
  }, {
    "id": 78,
    "text": "local string_old_length = #(node.string)",
    "type": "statement:localassign"
  }, {
    "id": 79,
    "text": "local string_old = node.string",
    "type": "statement:localassign"
  }, {
    "id": 80,
    "text": "local newnode = {\r\n\t\t[\"position\"] = position,\r\n\t\t[\"column\"] = column,\r\n\t\t[\"row\"] = row,\r\n\t\t[\"string\"] = \"\",\r\n\t\t[\"parent\"] = node\r\n\t}",
    "type": "statement:localassign"
  }, {
    "id": 81,
    "text": "local result = false",
    "type": "statement:localassign"
  }, {
    "id": 82,
    "text": "if rule.type.string == \"Rule\" then\r\n\t\tresult = epeg.run_rule(parser, rule.rule, node)\r\n\t\treturn result\r\n\r\n\telseif rule.type.string == \"Choice\" then\r\n\t\t-- Only one list out of the selection has to match successfull.\r\n\r\n\t\tfor rulename, subrule in ipairs(rule) do\r\n\t\t\tif epeg.run_rule(parser, subrule, node) then\r\n\t\t\t\treturn true\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\t-- Failed. Resetting the parser gets handled at the end of the function.\r\n\r\n\telseif rule.type.string == \"List\" then\r\n\t\t-- Every pattern in the list needs to succeed. If not, we have to\r\n\t\t-- reset the tree and parser to the state before we went through\r\n\t\t-- the list.\r\n\t\t-- To reset the tree, we use parser.anchor to store a reference to all\r\n\t\t-- newly created child nodes. If the rule fails, we can use this list to\r\n\t\t-- remove the newly added childs from our actual node.\r\n\t\t-- The parser gets reset at the end of the function.\r\n\r\n\t\tlocal oldanchor = parser.anchor\r\n\t\tlocal anchor = {}\r\n\t\tparser.anchor = anchor\r\n\r\n\t\tlocal worked = true\r\n\r\n\t\tfor rulename, subrule in ipairs(rule) do\r\n\t\t\tif not epeg.run_rule(parser, subrule, node) then\r\n\t\t\t\tworked = false\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tparser.anchor = oldanchor\r\n\r\n\t\tif worked then return true end\r\n\r\n\t\t-- the rule failed and we have to remove every created child node from\r\n\t\t-- our node to clean the mess up.\r\n\t\tfor i,v in ipairs(anchor) do\r\n\t\t\tif v ~= -1 then\r\n\t\t\t\tnode[v] = nil\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tanchor = nil\r\n\r\n\telseif rule.type.string == \"RuleName\" then\r\n\t\treturn epeg.run_rule(parser, parser.grammar[rule.name.string], node)\r\n\r\n\telseif rule.type.string == \"AnonymousFixedNode\" then\r\n\t\tnewnode.string = rule.grabs.string\r\n\t\ttable.insert(node, newnode)\r\n\t\ttable.insert(parser.anchor, #node)\r\n\t\tnewnode.pindex = #node\r\n\t\treturn true\r\n\r\n\telseif rule.type.string == \"AnonymousGrabbingNode\" then\r\n\t\ttable.insert(node, newnode)\r\n\t\tnewnode.pindex = #node\r\n\t\ttable.insert(parser.anchor, #node)\r\n\r\n\t\tif not epeg.run_rule(parser, rule.grabs, newnode) then\r\n\t\t\ttable.remove(node)\r\n\t\t\tparser.anchor[#parser.anchor] = -1\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tnewnode.string = epeg.unescape_string(newnode.string)\r\n\r\n\t\treturn true\r\n\r\n\telseif rule.type.string == \"FixedNode\" then\r\n\r\n\t\tif node[rule.name.string] then\r\n\t\t\tepeg.print_table(node)\r\n\t\t\tepeg.print_table(rule)\r\n\t\t\tparser:error(\"Tried to add second node with same name (\"..rule.name.string..\") to parent node.\")\r\n\t\tend\r\n\r\n\t\tnode[rule.name.string] = newnode\r\n\t\tnewnode.pindex = rule.name.string\r\n\t\tnewnode.string = rule.grabs.string\r\n\t\ttable.insert(parser.anchor, rule.name.string)\r\n\t\treturn true\r\n\r\n\telseif rule.type.string == \"GrabbingNode\" then\r\n\t\tif node[rule.name.string] then\r\n\t\t\tepeg.print_table(node)\r\n\t\t\tepeg.print_table(rule)\r\n\t\t\tparser:error(\"Tried to add second node with same name (\"..rule.name.string..\") to parent node.\")\r\n\t\tend\r\n\r\n\t\tnode[rule.name.string] = newnode\r\n\t\tnewnode.pindex = rule.name.string\r\n\t\ttable.insert(parser.anchor, rule.name.string)\r\n\r\n\t\tif not epeg.run_rule(parser, rule.grabs, newnode) then\r\n\t\t\tnode[rule.name.string] = nil\r\n\t\t\tparser.anchor[#parser.anchor] = -1\r\n\t\t\treturn false\r\n\t\tend\r\n\r\n\t\tnewnode.string = epeg.unescape_string(newnode.string)\r\n\r\n\t\treturn true\r\n\r\n\telseif rule.type.string == \"CollectInput\" then\r\n\r\n\t\tparser.grabs = parser.grabs + 1\r\n\t\tresult = epeg.run_rule(parser, rule.grabs, node)\r\n\t\tparser.grabs = parser.grabs - 1\r\n\r\n\t\treturn result\r\n\r\n\telseif rule.type.string == \"FunctionCall\" then\r\n\r\n\t\tresult = _G[rule[\"function\"][\"string\"]](parser, node)\r\n\r\n\t\tif parent and parent.type.string == \"Pattern\" and parent.prefix then\r\n\t\t\tif parent.prefix.string == \"!\" then return not result\r\n\t\t\telse return result end\r\n\t\tend\r\n\r\n\t\treturn true\r\n\telseif rule.type.string == \"Pattern\" then\r\n\t\tlocal repetition = \"\"\r\n\t\tlocal prefix = \"\"\r\n\r\n\t\tif rule.errorhandling and rule.errorhandling.type.string == \"Warning\" then\r\n\t\t\tio.write(\"Warning (row=\"..parser.row..\", column=\"..parser.column..\"): \"..rule.errorhandling.message.string)\r\n\t\tend\r\n\r\n\t\tif rule.prefix then prefix = rule.prefix.string end\r\n\r\n\t\tif rule.repetition then repetition = rule.repetition.string end\r\n\r\n\t\t-- First check for simple rules (string, dot and class), because we can\r\n\t\t-- use regular expressions to match them.\r\n\t\tif rule.pattern.type.string == \"String\" then\r\n\t\t\tif not rule.pattern.is_escaped then\r\n\t\t\t\trule.pattern.value.string = string.gsub(rule.pattern.value.string, \"[%$%^%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\")\r\n\t\t\t\trule.pattern.is_escaped = true\r\n\t\t\tend\r\n\r\n\t\t\tresult = parser:read_next(\"^\"..rule.pattern.value.string..repetition)\r\n\t\t\tif parser.grabs ~= 0 and result then node.string = node.string..result end\r\n\r\n\t\telseif rule.pattern.type.string == \"Dot\" then\r\n\t\t\tresult = parser:read_next(\"^\"..\".\"..repetition)\r\n\t\t\tif parser.grabs ~= 0 and result then node.string = node.string..result end\r\n\r\n\t\telseif rule.pattern.type.string == \"Class\" then\r\n\t\t\tresult = parser:read_next(\"^\"..\"[\"..rule.pattern.value.string..\"]\"..repetition)\r\n\t\t\tif parser.grabs ~= 0 and result then node.string = node.string..result end\r\n\r\n\t\telse\r\n\t\t\t-- Otherwise we handle the complex rules:\r\n\r\n\t\t\tif repetition == \"*\" then\r\n\t\t\t\twhile epeg.run_rule(parser, rule.pattern, node, rule) do end\r\n\t\t\t\tresult = true\r\n\t\t\telseif repetition == \"?\" then\r\n\t\t\t\tepeg.run_rule(parser, rule.pattern, node, rule)\r\n\t\t\t\tresult = true\r\n\t\t\telseif repetition == \"+\" then\r\n\t\t\t\tresult = epeg.run_rule(parser, rule.pattern, node, rule)\r\n\r\n\t\t\t\twhile epeg.run_rule(parser, rule.pattern, node, rule) do end\r\n\t\t\telse\r\n\t\t\t\tresult = epeg.run_rule(parser, rule.pattern, node, rule)\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tif rule.prefix and rule.prefix.string == \"!\" then result = not result end\r\n\r\n\t\tif result and not rule.prefix then return true end\r\n\r\n\t\tif not result and rule.errorhandling and rule.errorhandling.type.string == \"Error\" then\r\n\t\t\tparser:error(rule.errorhandling.message.string)\r\n\t\tend\r\n\r\n\telse\r\n\t\tparser:error(\"Epeg construct \"..tostring(rule.type.string)..\" not implemented or unknown.\")\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 83,
    "text": "result = epeg.run_rule(parser, rule.rule, node)",
    "type": "statement:assign"
  }, {
    "id": 84,
    "text": "for rulename, subrule in ipairs(rule) do\r\n\t\t\tif epeg.run_rule(parser, subrule, node) then\r\n\t\t\t\treturn true\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 85,
    "text": "if epeg.run_rule(parser, subrule, node) then\r\n\t\t\t\treturn true\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 86,
    "text": "local oldanchor = parser.anchor",
    "type": "statement:localassign"
  }, {
    "id": 87,
    "text": "local anchor = {}",
    "type": "statement:localassign"
  }, {
    "id": 88,
    "text": "parser.anchor = anchor",
    "type": "statement:assign"
  }, {
    "id": 89,
    "text": "local worked = true",
    "type": "statement:localassign"
  }, {
    "id": 90,
    "text": "for rulename, subrule in ipairs(rule) do\r\n\t\t\tif not epeg.run_rule(parser, subrule, node) then\r\n\t\t\t\tworked = false\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 91,
    "text": "if not epeg.run_rule(parser, subrule, node) then\r\n\t\t\t\tworked = false\r\n\t\t\t\tbreak\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 92,
    "text": "worked = false",
    "type": "statement:assign"
  }, {
    "id": 93,
    "text": "parser.anchor = oldanchor",
    "type": "statement:assign"
  }, {
    "id": 94,
    "text": "if worked then return true end",
    "type": "statement:if"
  }, {
    "id": 95,
    "text": "for i,v in ipairs(anchor) do\r\n\t\t\tif v ~= -1 then\r\n\t\t\t\tnode[v] = nil\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 96,
    "text": "if v ~= -1 then\r\n\t\t\t\tnode[v] = nil\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 97,
    "text": "node[v] = nil",
    "type": "statement:assign"
  }, {
    "id": 98,
    "text": "anchor = nil",
    "type": "statement:assign"
  }, {
    "id": 99,
    "text": "newnode.string = rule.grabs.string",
    "type": "statement:assign"
  }, {
    "id": 100,
    "text": "table.insert(node, newnode)",
    "type": "statement:functioncall"
  }, {
    "id": 101,
    "text": "table.insert(parser.anchor, #node)",
    "type": "statement:functioncall"
  }, {
    "id": 102,
    "text": "newnode.pindex = #node",
    "type": "statement:assign"
  }, {
    "id": 103,
    "text": "if not epeg.run_rule(parser, rule.grabs, newnode) then\r\n\t\t\ttable.remove(node)\r\n\t\t\tparser.anchor[#parser.anchor] = -1\r\n\t\t\treturn false\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 104,
    "text": "table.remove(node)",
    "type": "statement:functioncall"
  }, {
    "id": 105,
    "text": "parser.anchor[#parser.anchor] = -1",
    "type": "statement:assign"
  }, {
    "id": 106,
    "text": "newnode.string = epeg.unescape_string(newnode.string)",
    "type": "statement:assign"
  }, {
    "id": 107,
    "text": "if node[rule.name.string] then\r\n\t\t\tepeg.print_table(node)\r\n\t\t\tepeg.print_table(rule)\r\n\t\t\tparser:error(\"Tried to add second node with same name (\"..rule.name.string..\") to parent node.\")\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 108,
    "text": "epeg.print_table(node)",
    "type": "statement:functioncall"
  }, {
    "id": 109,
    "text": "epeg.print_table(rule)",
    "type": "statement:functioncall"
  }, {
    "id": 110,
    "text": "parser:error(\"Tried to add second node with same name (\"..rule.name.string..\") to parent node.\")",
    "type": "statement:functioncall"
  }, {
    "id": 111,
    "text": "node[rule.name.string] = newnode",
    "type": "statement:assign"
  }, {
    "id": 112,
    "text": "newnode.pindex = rule.name.string",
    "type": "statement:assign"
  }, {
    "id": 113,
    "text": "table.insert(parser.anchor, rule.name.string)",
    "type": "statement:functioncall"
  }, {
    "id": 114,
    "text": "if not epeg.run_rule(parser, rule.grabs, newnode) then\r\n\t\t\tnode[rule.name.string] = nil\r\n\t\t\tparser.anchor[#parser.anchor] = -1\r\n\t\t\treturn false\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 115,
    "text": "node[rule.name.string] = nil",
    "type": "statement:assign"
  }, {
    "id": 116,
    "text": "parser.grabs = parser.grabs + 1",
    "type": "statement:assign"
  }, {
    "id": 117,
    "text": "result = epeg.run_rule(parser, rule.grabs, node)",
    "type": "statement:assign"
  }, {
    "id": 118,
    "text": "parser.grabs = parser.grabs - 1",
    "type": "statement:assign"
  }, {
    "id": 119,
    "text": "result = _G[rule[\"function\"][\"string\"]](parser, node)",
    "type": "statement:assign"
  }, {
    "id": 120,
    "text": "if parent and parent.type.string == \"Pattern\" and parent.prefix then\r\n\t\t\tif parent.prefix.string == \"!\" then return not result\r\n\t\t\telse return result end\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 121,
    "text": "if parent.prefix.string == \"!\" then return not result\r\n\t\t\telse return result end",
    "type": "statement:if"
  }, {
    "id": 122,
    "text": "local repetition = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 123,
    "text": "local prefix = \"\"",
    "type": "statement:localassign"
  }, {
    "id": 124,
    "text": "if rule.errorhandling and rule.errorhandling.type.string == \"Warning\" then\r\n\t\t\tio.write(\"Warning (row=\"..parser.row..\", column=\"..parser.column..\"): \"..rule.errorhandling.message.string)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 125,
    "text": "io.write(\"Warning (row=\"..parser.row..\", column=\"..parser.column..\"): \"..rule.errorhandling.message.string)",
    "type": "statement:functioncall"
  }, {
    "id": 126,
    "text": "if rule.prefix then prefix = rule.prefix.string end",
    "type": "statement:if"
  }, {
    "id": 127,
    "text": "prefix = rule.prefix.string",
    "type": "statement:assign"
  }, {
    "id": 128,
    "text": "if rule.repetition then repetition = rule.repetition.string end",
    "type": "statement:if"
  }, {
    "id": 129,
    "text": "repetition = rule.repetition.string",
    "type": "statement:assign"
  }, {
    "id": 130,
    "text": "if rule.pattern.type.string == \"String\" then\r\n\t\t\tif not rule.pattern.is_escaped then\r\n\t\t\t\trule.pattern.value.string = string.gsub(rule.pattern.value.string, \"[%$%^%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\")\r\n\t\t\t\trule.pattern.is_escaped = true\r\n\t\t\tend\r\n\r\n\t\t\tresult = parser:read_next(\"^\"..rule.pattern.value.string..repetition)\r\n\t\t\tif parser.grabs ~= 0 and result then node.string = node.string..result end\r\n\r\n\t\telseif rule.pattern.type.string == \"Dot\" then\r\n\t\t\tresult = parser:read_next(\"^\"..\".\"..repetition)\r\n\t\t\tif parser.grabs ~= 0 and result then node.string = node.string..result end\r\n\r\n\t\telseif rule.pattern.type.string == \"Class\" then\r\n\t\t\tresult = parser:read_next(\"^\"..\"[\"..rule.pattern.value.string..\"]\"..repetition)\r\n\t\t\tif parser.grabs ~= 0 and result then node.string = node.string..result end\r\n\r\n\t\telse\r\n\t\t\t-- Otherwise we handle the complex rules:\r\n\r\n\t\t\tif repetition == \"*\" then\r\n\t\t\t\twhile epeg.run_rule(parser, rule.pattern, node, rule) do end\r\n\t\t\t\tresult = true\r\n\t\t\telseif repetition == \"?\" then\r\n\t\t\t\tepeg.run_rule(parser, rule.pattern, node, rule)\r\n\t\t\t\tresult = true\r\n\t\t\telseif repetition == \"+\" then\r\n\t\t\t\tresult = epeg.run_rule(parser, rule.pattern, node, rule)\r\n\r\n\t\t\t\twhile epeg.run_rule(parser, rule.pattern, node, rule) do end\r\n\t\t\telse\r\n\t\t\t\tresult = epeg.run_rule(parser, rule.pattern, node, rule)\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 131,
    "text": "if not rule.pattern.is_escaped then\r\n\t\t\t\trule.pattern.value.string = string.gsub(rule.pattern.value.string, \"[%$%^%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\")\r\n\t\t\t\trule.pattern.is_escaped = true\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 132,
    "text": "rule.pattern.value.string = string.gsub(rule.pattern.value.string, \"[%$%^%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\")",
    "type": "statement:assign"
  }, {
    "id": 133,
    "text": "rule.pattern.is_escaped = true",
    "type": "statement:assign"
  }, {
    "id": 134,
    "text": "result = parser:read_next(\"^\"..rule.pattern.value.string..repetition)",
    "type": "statement:assign"
  }, {
    "id": 135,
    "text": "if parser.grabs ~= 0 and result then node.string = node.string..result end",
    "type": "statement:if"
  }, {
    "id": 136,
    "text": "node.string = node.string..result",
    "type": "statement:assign"
  }, {
    "id": 137,
    "text": "result = parser:read_next(\"^\"..\".\"..repetition)",
    "type": "statement:assign"
  }, {
    "id": 138,
    "text": "result = parser:read_next(\"^\"..\"[\"..rule.pattern.value.string..\"]\"..repetition)",
    "type": "statement:assign"
  }, {
    "id": 139,
    "text": "if repetition == \"*\" then\r\n\t\t\t\twhile epeg.run_rule(parser, rule.pattern, node, rule) do end\r\n\t\t\t\tresult = true\r\n\t\t\telseif repetition == \"?\" then\r\n\t\t\t\tepeg.run_rule(parser, rule.pattern, node, rule)\r\n\t\t\t\tresult = true\r\n\t\t\telseif repetition == \"+\" then\r\n\t\t\t\tresult = epeg.run_rule(parser, rule.pattern, node, rule)\r\n\r\n\t\t\t\twhile epeg.run_rule(parser, rule.pattern, node, rule) do end\r\n\t\t\telse\r\n\t\t\t\tresult = epeg.run_rule(parser, rule.pattern, node, rule)\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 140,
    "text": "while epeg.run_rule(parser, rule.pattern, node, rule) do end",
    "type": "statement:while"
  }, {
    "id": 141,
    "text": "result = true",
    "type": "statement:assign"
  }, {
    "id": 142,
    "text": "epeg.run_rule(parser, rule.pattern, node, rule)",
    "type": "statement:functioncall"
  }, {
    "id": 143,
    "text": "result = epeg.run_rule(parser, rule.pattern, node, rule)",
    "type": "statement:assign"
  }, {
    "id": 144,
    "text": "if rule.prefix and rule.prefix.string == \"!\" then result = not result end",
    "type": "statement:if"
  }, {
    "id": 145,
    "text": "result = not result",
    "type": "statement:assign"
  }, {
    "id": 146,
    "text": "if result and not rule.prefix then return true end",
    "type": "statement:if"
  }, {
    "id": 147,
    "text": "if not result and rule.errorhandling and rule.errorhandling.type.string == \"Error\" then\r\n\t\t\tparser:error(rule.errorhandling.message.string)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 148,
    "text": "parser:error(rule.errorhandling.message.string)",
    "type": "statement:functioncall"
  }, {
    "id": 149,
    "text": "parser:error(\"Epeg construct \"..tostring(rule.type.string)..\" not implemented or unknown.\")",
    "type": "statement:functioncall"
  }, {
    "id": 150,
    "text": "if parser.grabs ~= 0 and #(node.string) ~= string_old_length and not result then\r\n\t\tnode.string = string_old\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 151,
    "text": "node.string = string_old",
    "type": "statement:assign"
  }, {
    "id": 152,
    "text": "parser.row = row",
    "type": "statement:assign"
  }, {
    "id": 153,
    "text": "parser.column = column",
    "type": "statement:assign"
  }, {
    "id": 154,
    "text": "parser.position = position",
    "type": "statement:assign"
  }, {
    "id": 155,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 156,
    "text": "function epeg:error(text)\r\n\tio.write(\"Error (row=\", tostring(self.row),\r\n\t                     \", column=\", tostring(self.column),\r\n\t\t\t\t         \"): \", tostring(text), \".\\n\")\r\n\tyield(false)\r\nend",
    "type": "function"
  }, {
    "id": 157,
    "text": "io.write(\"Error (row=\", tostring(self.row),\r\n\t                     \", column=\", tostring(self.column),\r\n\t\t\t\t         \"): \", tostring(text), \".\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 158,
    "text": "yield(false)",
    "type": "statement:functioncall"
  }, {
    "id": 159,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 160,
    "text": "function epeg.check(grammar)\r\n\tlocal ok = true\r\n\tlocal top = grammar[0]\r\n\r\n\tio.write(\"Checking...\\n\")\r\n\r\n\t-- check against possible infinite left recursion. Algorithm taken from\r\n\t-- peg/leg by Ian Piumarta.\r\n\t-- See: http://piumarta.com/software/peg/ for more information.\r\n\tfor i,v in pairs(grammar) do\r\n\t\tif i ~= 0 then\r\n\t\t\tepeg.consumesInput(v, grammar)\r\n\t\tend\r\n\tend\r\n\r\n\tfor i,v in pairs(grammar) do\r\n\t\tif i ~= 0 then\r\n\t\t\tif v.is_marked_lr then ok = false end\r\n\t\tend\r\n\tend\r\n\r\n\r\n\tif ok then\r\n\t\tio.write(\"... Success\\n\")\r\n\tend\r\n\r\n\treturn ok\r\nend",
    "type": "function"
  }, {
    "id": 161,
    "text": "local ok = true",
    "type": "statement:localassign"
  }, {
    "id": 162,
    "text": "local top = grammar[0]",
    "type": "statement:localassign"
  }, {
    "id": 163,
    "text": "io.write(\"Checking...\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 164,
    "text": "for i,v in pairs(grammar) do\r\n\t\tif i ~= 0 then\r\n\t\t\tepeg.consumesInput(v, grammar)\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 165,
    "text": "if i ~= 0 then\r\n\t\t\tepeg.consumesInput(v, grammar)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 166,
    "text": "epeg.consumesInput(v, grammar)",
    "type": "statement:functioncall"
  }, {
    "id": 167,
    "text": "for i,v in pairs(grammar) do\r\n\t\tif i ~= 0 then\r\n\t\t\tif v.is_marked_lr then ok = false end\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 168,
    "text": "if i ~= 0 then\r\n\t\t\tif v.is_marked_lr then ok = false end\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 169,
    "text": "if v.is_marked_lr then ok = false end",
    "type": "statement:if"
  }, {
    "id": 170,
    "text": "if ok then\r\n\t\tio.write(\"... Success\\n\")\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 171,
    "text": "io.write(\"... Success\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 172,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 173,
    "text": "function epeg.consumesInput(node, grammar)\r\n\tif node == nil then return false end\r\n\r\n\tif node.type.string == \"Rule\" then\r\n\t\tlocal result = false\r\n\r\n\t\tif node.reached ~= nil then\r\n\t\t\tif node.is_marked_lr == nil then\r\n\t\t\t\tio.write(\"Possible endless left recursion in \", node.name.string, \".\\n\")\r\n\t\t\t\tnode.is_marked_lr = true\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tnode.reached = true\r\n\t\t\tresult = epeg.consumesInput(node.rule, grammar)\r\n\t\t\tnode.reached = nil\r\n\t\tend\r\n\r\n\t\treturn result\r\n\telseif node.type.string == \"Choice\" then\r\n\t\tfor i,v in ipairs(node) do\r\n\t\t\tif not epeg.consumesInput(v, grammar) then return false end\r\n\t\tend\r\n\r\n\t\treturn true\r\n\telseif node.type.string == \"List\" then\r\n\t\tfor i,v in ipairs(node) do\r\n\t\t\tif epeg.consumesInput(v, grammar) then return true end\r\n\t\tend\r\n\r\n\t\treturn false\r\n\telseif node.type.string == \"RuleName\" then\r\n\t\treturn epeg.consumesInput(grammar[node.name.string], grammar)\r\n\telseif node.type.string == \"AnonymousFixedNode\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"AnonymousGrabbingNode\" then\r\n\t\treturn epeg.consumesInput(node.grabs, grammar)\r\n\telseif node.type.string == \"FixedNode\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"GrabbingNode\" then\r\n\t\treturn epeg.consumesInput(node.grabs, grammar)\r\n\telseif node.type.string == \"CollectInput\" then\r\n\t\treturn epeg.consumesInput(node.grabs, grammar)\r\n\telseif node.type.string == \"Error\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"Warning\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"Resume\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"FunctionCall\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"EmbeddedCode\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"String\" then\r\n\t\tif node.value.string == \"\" then return false end\r\n\t\treturn true\r\n\telseif node.type.string == \"Class\" then\r\n\t\tif node.value.string == \"\" then return false end\r\n\t\treturn true\r\n\telseif node.type.string == \"Dot\" then\r\n\t\treturn true\r\n\telseif node.type.string == \"Pattern\" then\r\n\t\t-- The pattern does not need to consume input if it uses ? or *.\r\n\t\tif node.repetition and\r\n\t\t   (node.repetition.string == \"*\" or\r\n\t\t    node.repetition.string == \"?\") then\r\n\t\t\treturn false\r\n\t\tend\r\n\t\treturn epeg.consumesInput(node.pattern, grammar)\r\n\telse\r\n\t\tio.write(\"Error: Unknown epeg construct: \", tostring(node.type.string), \".\\n\")\r\n\t\treturn false\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 174,
    "text": "if node == nil then return false end",
    "type": "statement:if"
  }, {
    "id": 175,
    "text": "if node.type.string == \"Rule\" then\r\n\t\tlocal result = false\r\n\r\n\t\tif node.reached ~= nil then\r\n\t\t\tif node.is_marked_lr == nil then\r\n\t\t\t\tio.write(\"Possible endless left recursion in \", node.name.string, \".\\n\")\r\n\t\t\t\tnode.is_marked_lr = true\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tnode.reached = true\r\n\t\t\tresult = epeg.consumesInput(node.rule, grammar)\r\n\t\t\tnode.reached = nil\r\n\t\tend\r\n\r\n\t\treturn result\r\n\telseif node.type.string == \"Choice\" then\r\n\t\tfor i,v in ipairs(node) do\r\n\t\t\tif not epeg.consumesInput(v, grammar) then return false end\r\n\t\tend\r\n\r\n\t\treturn true\r\n\telseif node.type.string == \"List\" then\r\n\t\tfor i,v in ipairs(node) do\r\n\t\t\tif epeg.consumesInput(v, grammar) then return true end\r\n\t\tend\r\n\r\n\t\treturn false\r\n\telseif node.type.string == \"RuleName\" then\r\n\t\treturn epeg.consumesInput(grammar[node.name.string], grammar)\r\n\telseif node.type.string == \"AnonymousFixedNode\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"AnonymousGrabbingNode\" then\r\n\t\treturn epeg.consumesInput(node.grabs, grammar)\r\n\telseif node.type.string == \"FixedNode\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"GrabbingNode\" then\r\n\t\treturn epeg.consumesInput(node.grabs, grammar)\r\n\telseif node.type.string == \"CollectInput\" then\r\n\t\treturn epeg.consumesInput(node.grabs, grammar)\r\n\telseif node.type.string == \"Error\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"Warning\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"Resume\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"FunctionCall\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"EmbeddedCode\" then\r\n\t\treturn false\r\n\telseif node.type.string == \"String\" then\r\n\t\tif node.value.string == \"\" then return false end\r\n\t\treturn true\r\n\telseif node.type.string == \"Class\" then\r\n\t\tif node.value.string == \"\" then return false end\r\n\t\treturn true\r\n\telseif node.type.string == \"Dot\" then\r\n\t\treturn true\r\n\telseif node.type.string == \"Pattern\" then\r\n\t\t-- The pattern does not need to consume input if it uses ? or *.\r\n\t\tif node.repetition and\r\n\t\t   (node.repetition.string == \"*\" or\r\n\t\t    node.repetition.string == \"?\") then\r\n\t\t\treturn false\r\n\t\tend\r\n\t\treturn epeg.consumesInput(node.pattern, grammar)\r\n\telse\r\n\t\tio.write(\"Error: Unknown epeg construct: \", tostring(node.type.string), \".\\n\")\r\n\t\treturn false\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 176,
    "text": "if node.reached ~= nil then\r\n\t\t\tif node.is_marked_lr == nil then\r\n\t\t\t\tio.write(\"Possible endless left recursion in \", node.name.string, \".\\n\")\r\n\t\t\t\tnode.is_marked_lr = true\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tnode.reached = true\r\n\t\t\tresult = epeg.consumesInput(node.rule, grammar)\r\n\t\t\tnode.reached = nil\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 177,
    "text": "if node.is_marked_lr == nil then\r\n\t\t\t\tio.write(\"Possible endless left recursion in \", node.name.string, \".\\n\")\r\n\t\t\t\tnode.is_marked_lr = true\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 178,
    "text": "io.write(\"Possible endless left recursion in \", node.name.string, \".\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 179,
    "text": "node.is_marked_lr = true",
    "type": "statement:assign"
  }, {
    "id": 180,
    "text": "node.reached = true",
    "type": "statement:assign"
  }, {
    "id": 181,
    "text": "result = epeg.consumesInput(node.rule, grammar)",
    "type": "statement:assign"
  }, {
    "id": 182,
    "text": "node.reached = nil",
    "type": "statement:assign"
  }, {
    "id": 183,
    "text": "for i,v in ipairs(node) do\r\n\t\t\tif not epeg.consumesInput(v, grammar) then return false end\r\n\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 184,
    "text": "if not epeg.consumesInput(v, grammar) then return false end",
    "type": "statement:if"
  }, {
    "id": 185,
    "text": "for i,v in ipairs(node) do\r\n\t\t\tif epeg.consumesInput(v, grammar) then return true end\r\n\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 186,
    "text": "if epeg.consumesInput(v, grammar) then return true end",
    "type": "statement:if"
  }, {
    "id": 187,
    "text": "if node.value.string == \"\" then return false end",
    "type": "statement:if"
  }, {
    "id": 188,
    "text": "if node.repetition and\r\n\t\t   (node.repetition.string == \"*\" or\r\n\t\t    node.repetition.string == \"?\") then\r\n\t\t\treturn false\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 189,
    "text": "io.write(\"Error: Unknown epeg construct: \", tostring(node.type.string), \".\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 190,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 191,
    "text": "function epeg.dump_table(table, file, depth)\r\n\tlocal tabs = string.rep(\"\\t\", depth)\r\n\r\n\tfor i,v in pairs(table) do\r\n\t\tif i ~= \"position\" and i ~= \"column\" and i ~= \"row\" and\r\n\t\t   i ~= \"pindex\" and i ~= \"parent\" then\r\n\t\t\tif type(i) == \"string\" then\r\n\t\t\t\tfile:write(tabs, \"[\\\"\", i, \"\\\"] = \")\r\n\t\t\telse\r\n\t\t\t\tfile:write(tabs, \"[\", tostring(i), \"] = \")\r\n\t\t\tend\r\n\r\n\t\t\tif type(v) == \"table\" then\r\n\t\t\t\tfile:write(\"{\\n\")\r\n\t\t\t\t\tepeg.dump_table(v, file, depth + 1)\r\n\t\t\t\tfile:write(tabs, \"},\\n\")\r\n\t\t\telse\r\n\t\t\t\tif type(v) == \"string\" then\r\n\t\t\t\t\tfile:write(\"\\\"\", epeg.escape_string(v), \"\\\",\\n\")\r\n\t\t\t\telse\r\n\t\t\t\t\tfile:write(tostring(v), \",\\n\")\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 192,
    "text": "local tabs = string.rep(\"\\t\", depth)",
    "type": "statement:localassign"
  }, {
    "id": 193,
    "text": "for i,v in pairs(table) do\r\n\t\tif i ~= \"position\" and i ~= \"column\" and i ~= \"row\" and\r\n\t\t   i ~= \"pindex\" and i ~= \"parent\" then\r\n\t\t\tif type(i) == \"string\" then\r\n\t\t\t\tfile:write(tabs, \"[\\\"\", i, \"\\\"] = \")\r\n\t\t\telse\r\n\t\t\t\tfile:write(tabs, \"[\", tostring(i), \"] = \")\r\n\t\t\tend\r\n\r\n\t\t\tif type(v) == \"table\" then\r\n\t\t\t\tfile:write(\"{\\n\")\r\n\t\t\t\t\tepeg.dump_table(v, file, depth + 1)\r\n\t\t\t\tfile:write(tabs, \"},\\n\")\r\n\t\t\telse\r\n\t\t\t\tif type(v) == \"string\" then\r\n\t\t\t\t\tfile:write(\"\\\"\", epeg.escape_string(v), \"\\\",\\n\")\r\n\t\t\t\telse\r\n\t\t\t\t\tfile:write(tostring(v), \",\\n\")\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 194,
    "text": "if i ~= \"position\" and i ~= \"column\" and i ~= \"row\" and\r\n\t\t   i ~= \"pindex\" and i ~= \"parent\" then\r\n\t\t\tif type(i) == \"string\" then\r\n\t\t\t\tfile:write(tabs, \"[\\\"\", i, \"\\\"] = \")\r\n\t\t\telse\r\n\t\t\t\tfile:write(tabs, \"[\", tostring(i), \"] = \")\r\n\t\t\tend\r\n\r\n\t\t\tif type(v) == \"table\" then\r\n\t\t\t\tfile:write(\"{\\n\")\r\n\t\t\t\t\tepeg.dump_table(v, file, depth + 1)\r\n\t\t\t\tfile:write(tabs, \"},\\n\")\r\n\t\t\telse\r\n\t\t\t\tif type(v) == \"string\" then\r\n\t\t\t\t\tfile:write(\"\\\"\", epeg.escape_string(v), \"\\\",\\n\")\r\n\t\t\t\telse\r\n\t\t\t\t\tfile:write(tostring(v), \",\\n\")\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 195,
    "text": "if type(i) == \"string\" then\r\n\t\t\t\tfile:write(tabs, \"[\\\"\", i, \"\\\"] = \")\r\n\t\t\telse\r\n\t\t\t\tfile:write(tabs, \"[\", tostring(i), \"] = \")\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 196,
    "text": "file:write(tabs, \"[\\\"\", i, \"\\\"] = \")",
    "type": "statement:functioncall"
  }, {
    "id": 197,
    "text": "file:write(tabs, \"[\", tostring(i), \"] = \")",
    "type": "statement:functioncall"
  }, {
    "id": 198,
    "text": "if type(v) == \"table\" then\r\n\t\t\t\tfile:write(\"{\\n\")\r\n\t\t\t\t\tepeg.dump_table(v, file, depth + 1)\r\n\t\t\t\tfile:write(tabs, \"},\\n\")\r\n\t\t\telse\r\n\t\t\t\tif type(v) == \"string\" then\r\n\t\t\t\t\tfile:write(\"\\\"\", epeg.escape_string(v), \"\\\",\\n\")\r\n\t\t\t\telse\r\n\t\t\t\t\tfile:write(tostring(v), \",\\n\")\r\n\t\t\t\tend\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 199,
    "text": "file:write(\"{\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 200,
    "text": "epeg.dump_table(v, file, depth + 1)",
    "type": "statement:functioncall"
  }, {
    "id": 201,
    "text": "file:write(tabs, \"},\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 202,
    "text": "if type(v) == \"string\" then\r\n\t\t\t\t\tfile:write(\"\\\"\", epeg.escape_string(v), \"\\\",\\n\")\r\n\t\t\t\telse\r\n\t\t\t\t\tfile:write(tostring(v), \",\\n\")\r\n\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 203,
    "text": "file:write(\"\\\"\", epeg.escape_string(v), \"\\\",\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 204,
    "text": "file:write(tostring(v), \",\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 205,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 206,
    "text": "function epeg.print_table(tab, depth)\r\n\tif not (type(tab) == \"table\") then print (\"failure\"); return end\r\n\tif depth == nil then depth = 0 end\r\n\tlocal tabs = string.rep(\"\\t\", depth)\r\n\r\n\tfor i,v in pairs(tab) do\r\n\t\tif type(v) ~= \"table\" then\r\n\t\t\tio.write(tabs, tostring(i), \": \", tostring(v), \"\\n\")\r\n\t\tend\r\n\tend\r\n\tfor i,v in pairs(tab) do\r\n\t\tif type(v) == \"table\" then\r\n\t\t\tio.write(tabs, tostring(i), \": (table)\\n\")\r\n\t\t\tepeg.print_table(v, depth + 1)\r\n\t\tend\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 207,
    "text": "if not (type(tab) == \"table\") then print (\"failure\"); return end",
    "type": "statement:if"
  }, {
    "id": 208,
    "text": "print (\"failure\")",
    "type": "statement:functioncall"
  }, {
    "id": 209,
    "text": "if depth == nil then depth = 0 end",
    "type": "statement:if"
  }, {
    "id": 210,
    "text": "depth = 0",
    "type": "statement:assign"
  }, {
    "id": 211,
    "text": "for i,v in pairs(tab) do\r\n\t\tif type(v) ~= \"table\" then\r\n\t\t\tio.write(tabs, tostring(i), \": \", tostring(v), \"\\n\")\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 212,
    "text": "if type(v) ~= \"table\" then\r\n\t\t\tio.write(tabs, tostring(i), \": \", tostring(v), \"\\n\")\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 213,
    "text": "io.write(tabs, tostring(i), \": \", tostring(v), \"\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 214,
    "text": "for i,v in pairs(tab) do\r\n\t\tif type(v) == \"table\" then\r\n\t\t\tio.write(tabs, tostring(i), \": (table)\\n\")\r\n\t\t\tepeg.print_table(v, depth + 1)\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 215,
    "text": "if type(v) == \"table\" then\r\n\t\t\tio.write(tabs, tostring(i), \": (table)\\n\")\r\n\t\t\tepeg.print_table(v, depth + 1)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 216,
    "text": "io.write(tabs, tostring(i), \": (table)\\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 217,
    "text": "epeg.print_table(v, depth + 1)",
    "type": "statement:functioncall"
  }, {
    "id": 218,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 219,
    "text": "function epeg.grammar2epeg(grammar)\r\n\tfor i,v in pairs(grammar) do\r\n\t\tio.write(\"\\n\", i, \" <- \")\r\n\t\tepeg.translate_node(v.rule)\r\n\t\tio.write('\\n')\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 220,
    "text": "for i,v in pairs(grammar) do\r\n\t\tio.write(\"\\n\", i, \" <- \")\r\n\t\tepeg.translate_node(v.rule)\r\n\t\tio.write('\\n')\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 221,
    "text": "io.write(\"\\n\", i, \" <- \")",
    "type": "statement:functioncall"
  }, {
    "id": 222,
    "text": "epeg.translate_node(v.rule)",
    "type": "statement:functioncall"
  }, {
    "id": 223,
    "text": "io.write('\\n')",
    "type": "statement:functioncall"
  }, {
    "id": 224,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 225,
    "text": "function epeg.translate_node(node)\r\n\tif node.type.string == \"Choice\" then\r\n\t\tfor i,v in ipairs(node) do\r\n\t\t\tepeg.translate_node(v)\r\n\t\t\tif node.list[i + 1] ~= nil then io.write('/ ') end\r\n\t\tend\r\n\telseif node.type.string == \"List\" then\r\n\t\tfor i,v in ipairs(node) do\r\n\t\t\tepeg.translate_node(v)\r\n\t\tend\r\n\telseif node.type.string == \"RuleName\" then\r\n\t\tio.write(node.name.string, \" \")\r\n\telseif node.type.string == \"AnonymousFixedNode\" then\r\n\t\tio.write(\"<:: \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\">\")\r\n\telseif node.type.string == \"AnonymousGrabbingNode\" then\r\n\t\tio.write(\"<: \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\">\")\r\n\telseif node.type.string == \"FixedNode\" then\r\n\t\tio.write(\"<\", node.name.string, \":: \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\">\")\r\n\telseif node.type.string == \"GrabbingNode\" then\r\n\t\tio.write(\"<\", node.name.string, \": \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\">\")\r\n\telseif node.type.string == \"CollectInput\" then\r\n\t\tio.write(\"< \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\" >\")\r\n\telseif node.type.string == \"Error\" then\r\n\t\tio.write(\" error (\")\r\n\t\tepeg.translate_node(node.message)\r\n\t\tio.write(\") \")\r\n\t\tif node.recover then\r\n\t\t\tio.write(\"recover (\")\r\n\t\t\tepeg.translate_node(node.recover)\r\n\t\t\tio.write(\") \")\r\n\t\tend\r\n\telseif node.type.string == \"Warning\" then\r\n\t\tio.write(\"warning (\")\r\n\t\tepeg.translate_node(node.message)\r\n\t\tio.write(\") \")\r\n\telseif node.type.string == \"Resume\" then\r\n\t\tio.write(\"resume \")\r\n\telseif node.type.string == \"FunctionCall\" then\r\n\t\tio.write(\"{: \", node.name.string, \" } \")\r\n\telseif node.type.string == \"EmbeddedCode\" then\r\n\t\tio.write(\"{\", node.code, \"} \")\r\n\telseif node.type.string == \"String\" then\r\n\t\tio.write(\"\\\"\", node.value.string, \"\\\" \")\r\n\telseif node.type.string == \"Class\" then\r\n\t\tio.write(\"[\", node.value.string, \"] \")\r\n\telseif node.type.string == \"Dot\" then\r\n\t\tio.write(\".\")\r\n\telseif node.type.string == \"Pattern\" then\r\n\t\tif node.prefix then io.write(node.prefix.string) end\r\n\t\tif node.pattern.type.string == \"Choice\" then\r\n\t\t\tio.write(\"(\")\r\n\t\t\tepeg.translate_node(node.pattern)\r\n\t\t\tio.write(\")\")\r\n\t\telse\r\n\t\t\tepeg.translate_node(node.pattern)\r\n\t\tend\r\n\r\n\t\tif node.repetition then\r\n\t\t\tio.write(node.repetition.string)\r\n\t\tend\r\n\r\n\t\tif node.errorhandling then\r\n\t\t\tepeg.translate_node(node.errorhandling)\r\n\t\tend\r\n\telse\r\n\t\tio.write(\"\\n***ERROR***:\", node.type.string, \" \\n\")\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 226,
    "text": "if node.type.string == \"Choice\" then\r\n\t\tfor i,v in ipairs(node) do\r\n\t\t\tepeg.translate_node(v)\r\n\t\t\tif node.list[i + 1] ~= nil then io.write('/ ') end\r\n\t\tend\r\n\telseif node.type.string == \"List\" then\r\n\t\tfor i,v in ipairs(node) do\r\n\t\t\tepeg.translate_node(v)\r\n\t\tend\r\n\telseif node.type.string == \"RuleName\" then\r\n\t\tio.write(node.name.string, \" \")\r\n\telseif node.type.string == \"AnonymousFixedNode\" then\r\n\t\tio.write(\"<:: \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\">\")\r\n\telseif node.type.string == \"AnonymousGrabbingNode\" then\r\n\t\tio.write(\"<: \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\">\")\r\n\telseif node.type.string == \"FixedNode\" then\r\n\t\tio.write(\"<\", node.name.string, \":: \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\">\")\r\n\telseif node.type.string == \"GrabbingNode\" then\r\n\t\tio.write(\"<\", node.name.string, \": \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\">\")\r\n\telseif node.type.string == \"CollectInput\" then\r\n\t\tio.write(\"< \")\r\n\t\tepeg.translate_node(node.grabs)\r\n\t\tio.write(\" >\")\r\n\telseif node.type.string == \"Error\" then\r\n\t\tio.write(\" error (\")\r\n\t\tepeg.translate_node(node.message)\r\n\t\tio.write(\") \")\r\n\t\tif node.recover then\r\n\t\t\tio.write(\"recover (\")\r\n\t\t\tepeg.translate_node(node.recover)\r\n\t\t\tio.write(\") \")\r\n\t\tend\r\n\telseif node.type.string == \"Warning\" then\r\n\t\tio.write(\"warning (\")\r\n\t\tepeg.translate_node(node.message)\r\n\t\tio.write(\") \")\r\n\telseif node.type.string == \"Resume\" then\r\n\t\tio.write(\"resume \")\r\n\telseif node.type.string == \"FunctionCall\" then\r\n\t\tio.write(\"{: \", node.name.string, \" } \")\r\n\telseif node.type.string == \"EmbeddedCode\" then\r\n\t\tio.write(\"{\", node.code, \"} \")\r\n\telseif node.type.string == \"String\" then\r\n\t\tio.write(\"\\\"\", node.value.string, \"\\\" \")\r\n\telseif node.type.string == \"Class\" then\r\n\t\tio.write(\"[\", node.value.string, \"] \")\r\n\telseif node.type.string == \"Dot\" then\r\n\t\tio.write(\".\")\r\n\telseif node.type.string == \"Pattern\" then\r\n\t\tif node.prefix then io.write(node.prefix.string) end\r\n\t\tif node.pattern.type.string == \"Choice\" then\r\n\t\t\tio.write(\"(\")\r\n\t\t\tepeg.translate_node(node.pattern)\r\n\t\t\tio.write(\")\")\r\n\t\telse\r\n\t\t\tepeg.translate_node(node.pattern)\r\n\t\tend\r\n\r\n\t\tif node.repetition then\r\n\t\t\tio.write(node.repetition.string)\r\n\t\tend\r\n\r\n\t\tif node.errorhandling then\r\n\t\t\tepeg.translate_node(node.errorhandling)\r\n\t\tend\r\n\telse\r\n\t\tio.write(\"\\n***ERROR***:\", node.type.string, \" \\n\")\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 227,
    "text": "for i,v in ipairs(node) do\r\n\t\t\tepeg.translate_node(v)\r\n\t\t\tif node.list[i + 1] ~= nil then io.write('/ ') end\r\n\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 228,
    "text": "epeg.translate_node(v)",
    "type": "statement:functioncall"
  }, {
    "id": 229,
    "text": "if node.list[i + 1] ~= nil then io.write('/ ') end",
    "type": "statement:if"
  }, {
    "id": 230,
    "text": "io.write('/ ')",
    "type": "statement:functioncall"
  }, {
    "id": 231,
    "text": "for i,v in ipairs(node) do\r\n\t\t\tepeg.translate_node(v)\r\n\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 232,
    "text": "io.write(node.name.string, \" \")",
    "type": "statement:functioncall"
  }, {
    "id": 233,
    "text": "io.write(\"<:: \")",
    "type": "statement:functioncall"
  }, {
    "id": 234,
    "text": "epeg.translate_node(node.grabs)",
    "type": "statement:functioncall"
  }, {
    "id": 235,
    "text": "io.write(\">\")",
    "type": "statement:functioncall"
  }, {
    "id": 236,
    "text": "io.write(\"<: \")",
    "type": "statement:functioncall"
  }, {
    "id": 237,
    "text": "io.write(\"<\", node.name.string, \":: \")",
    "type": "statement:functioncall"
  }, {
    "id": 238,
    "text": "io.write(\"<\", node.name.string, \": \")",
    "type": "statement:functioncall"
  }, {
    "id": 239,
    "text": "io.write(\"< \")",
    "type": "statement:functioncall"
  }, {
    "id": 240,
    "text": "io.write(\" >\")",
    "type": "statement:functioncall"
  }, {
    "id": 241,
    "text": "io.write(\" error (\")",
    "type": "statement:functioncall"
  }, {
    "id": 242,
    "text": "epeg.translate_node(node.message)",
    "type": "statement:functioncall"
  }, {
    "id": 243,
    "text": "io.write(\") \")",
    "type": "statement:functioncall"
  }, {
    "id": 244,
    "text": "if node.recover then\r\n\t\t\tio.write(\"recover (\")\r\n\t\t\tepeg.translate_node(node.recover)\r\n\t\t\tio.write(\") \")\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 245,
    "text": "io.write(\"recover (\")",
    "type": "statement:functioncall"
  }, {
    "id": 246,
    "text": "epeg.translate_node(node.recover)",
    "type": "statement:functioncall"
  }, {
    "id": 247,
    "text": "io.write(\"warning (\")",
    "type": "statement:functioncall"
  }, {
    "id": 248,
    "text": "io.write(\"resume \")",
    "type": "statement:functioncall"
  }, {
    "id": 249,
    "text": "io.write(\"{: \", node.name.string, \" } \")",
    "type": "statement:functioncall"
  }, {
    "id": 250,
    "text": "io.write(\"{\", node.code, \"} \")",
    "type": "statement:functioncall"
  }, {
    "id": 251,
    "text": "io.write(\"\\\"\", node.value.string, \"\\\" \")",
    "type": "statement:functioncall"
  }, {
    "id": 252,
    "text": "io.write(\"[\", node.value.string, \"] \")",
    "type": "statement:functioncall"
  }, {
    "id": 253,
    "text": "io.write(\".\")",
    "type": "statement:functioncall"
  }, {
    "id": 254,
    "text": "if node.prefix then io.write(node.prefix.string) end",
    "type": "statement:if"
  }, {
    "id": 255,
    "text": "io.write(node.prefix.string)",
    "type": "statement:functioncall"
  }, {
    "id": 256,
    "text": "if node.pattern.type.string == \"Choice\" then\r\n\t\t\tio.write(\"(\")\r\n\t\t\tepeg.translate_node(node.pattern)\r\n\t\t\tio.write(\")\")\r\n\t\telse\r\n\t\t\tepeg.translate_node(node.pattern)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 257,
    "text": "io.write(\"(\")",
    "type": "statement:functioncall"
  }, {
    "id": 258,
    "text": "epeg.translate_node(node.pattern)",
    "type": "statement:functioncall"
  }, {
    "id": 259,
    "text": "io.write(\")\")",
    "type": "statement:functioncall"
  }, {
    "id": 260,
    "text": "if node.repetition then\r\n\t\t\tio.write(node.repetition.string)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 261,
    "text": "io.write(node.repetition.string)",
    "type": "statement:functioncall"
  }, {
    "id": 262,
    "text": "if node.errorhandling then\r\n\t\t\tepeg.translate_node(node.errorhandling)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 263,
    "text": "epeg.translate_node(node.errorhandling)",
    "type": "statement:functioncall"
  }, {
    "id": 264,
    "text": "io.write(\"\\n***ERROR***:\", node.type.string, \" \\n\")",
    "type": "statement:functioncall"
  }, {
    "id": 265,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 266,
    "text": "function epeg.unescape_string(str)\r\n\tlocal result = {}\r\n\tlocal pos = 1\r\n\tlocal oldpos = 1\r\n\tlocal echar, tesc\r\n\r\n\tresult = string.gsub(str, \"\\\\.\", epeg.unesc_table)\r\n\treturn result\r\nend",
    "type": "function"
  }, {
    "id": 267,
    "text": "local result = {}",
    "type": "statement:localassign"
  }, {
    "id": 268,
    "text": "local pos = 1",
    "type": "statement:localassign"
  }, {
    "id": 269,
    "text": "local oldpos = 1",
    "type": "statement:localassign"
  }, {
    "id": 270,
    "text": "local echar, tesc",
    "type": "statement:localassign"
  }, {
    "id": 271,
    "text": "result = string.gsub(str, \"\\\\.\", epeg.unesc_table)",
    "type": "statement:assign"
  }, {
    "id": 272,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 273,
    "text": "function epeg.escape_string(str)\r\n\tlocal result\r\n\tresult = string.gsub(str, \"[]\\\\\\a\\b\\f\\n\\r\\t\\v\\\"\\'[]\", epeg.esc_table)\r\n\treturn result\r\nend",
    "type": "function"
  }, {
    "id": 274,
    "text": "result = string.gsub(str, \"[]\\\\\\a\\b\\f\\n\\r\\t\\v\\\"\\'[]\", epeg.esc_table)",
    "type": "statement:assign"
  }, {
    "id": 275,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 276,
    "text": "",
    "type": "function container"
  }, {
    "id": 277,
    "text": "write",
    "type": "global function"
  }, {
    "id": 278,
    "text": "create",
    "type": "global function"
  }, {
    "id": 279,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 280,
    "text": "resume",
    "type": "global function"
  }, {
    "id": 281,
    "text": "_G[rule[\"function\"][\"string\"]]",
    "type": "global function"
  }, {
    "id": 282,
    "text": "error",
    "type": "global function"
  }, {
    "id": 283,
    "text": "yield",
    "type": "global function"
  }, {
    "id": 284,
    "text": "find",
    "type": "global function"
  }, {
    "id": 285,
    "text": "parse_text",
    "type": "global function"
  }, {
    "id": 286,
    "text": "sub",
    "type": "global function"
  }, {
    "id": 287,
    "text": "ipairs",
    "type": "global function"
  }, {
    "id": 288,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 289,
    "text": "rep",
    "type": "global function"
  }, {
    "id": 290,
    "text": "dump_grammar",
    "type": "global function"
  }, {
    "id": 291,
    "text": "read_grammar",
    "type": "global function"
  }, {
    "id": 292,
    "text": "setmetatable",
    "type": "global function"
  }, {
    "id": 293,
    "text": "remove",
    "type": "global function"
  }, {
    "id": 294,
    "text": "print",
    "type": "global function"
  }, {
    "id": 295,
    "text": "type",
    "type": "global function"
  }, {
    "id": 296,
    "text": "gsub",
    "type": "global function"
  }, {
    "id": 297,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 298,
    "text": "open",
    "type": "global function"
  }, {
    "id": 299,
    "text": "",
    "type": "variable container"
  }, {
    "id": 300,
    "text": "",
    "type": "require container"
  }, {
    "id": 301,
    "text": "",
    "type": "global variable"
  }, {
    "id": 302,
    "text": "",
    "type": "n/a"
  }, {
    "id": 303,
    "text": "",
    "type": "global variable"
  }, {
    "id": 304,
    "text": "",
    "type": "n/a"
  }, {
    "id": 305,
    "text": "",
    "type": "global variable"
  }, {
    "id": 306,
    "text": "",
    "type": "n/a"
  }, {
    "id": 307,
    "text": "",
    "type": "global variable"
  }, {
    "id": 308,
    "text": "",
    "type": "n/a"
  }, {
    "id": 309,
    "text": "",
    "type": "global variable"
  }, {
    "id": 310,
    "text": "",
    "type": "n/a"
  }, {
    "id": 311,
    "text": "",
    "type": "interface container"
  }, {
    "id": 312,
    "text": "",
    "type": "interface"
  } ]
}