{
  "_filename": "utils.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/luametrics/src/metrics/utils.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "calls",
    "to": 38
  }, {
    "from": 2,
    "label": "calls",
    "to": 38
  }, {
    "from": 2,
    "label": "calls",
    "to": 38
  }, {
    "from": 2,
    "label": "calls",
    "to": 38
  }, {
    "from": 2,
    "label": "calls",
    "to": 38
  }, {
    "from": 2,
    "label": "calls",
    "to": 38
  }, {
    "from": 2,
    "label": "calls",
    "to": 38
  }, {
    "from": 3,
    "label": "calls",
    "to": 53
  }, {
    "from": 4,
    "label": "calls",
    "to": 53
  }, {
    "from": 5,
    "label": "calls",
    "to": 53
  }, {
    "from": 5,
    "label": "calls",
    "to": 53
  }, {
    "from": 6,
    "label": "calls",
    "to": 53
  }, {
    "from": 6,
    "label": "calls",
    "to": 53
  }, {
    "from": 7,
    "label": "calls",
    "to": 53
  }, {
    "from": 7,
    "label": "calls",
    "to": 53
  }, {
    "from": 8,
    "label": "calls",
    "to": 53
  }, {
    "from": 8,
    "label": "calls",
    "to": 53
  }, {
    "from": 8,
    "label": "calls",
    "to": 53
  }, {
    "from": 6,
    "label": "calls",
    "to": 38
  }, {
    "from": 6,
    "label": "calls",
    "to": 38
  }, {
    "from": 6,
    "label": "calls",
    "to": 38
  }, {
    "from": 7,
    "label": "calls",
    "to": 38
  }, {
    "from": 7,
    "label": "calls",
    "to": 38
  }, {
    "from": 8,
    "label": "calls",
    "to": 38
  }, {
    "from": 8,
    "label": "calls",
    "to": 38
  }, {
    "from": 5,
    "label": "calls",
    "to": 77
  }, {
    "from": 6,
    "label": "calls",
    "to": 77
  }, {
    "from": 8,
    "label": "calls",
    "to": 77
  }, {
    "from": 5,
    "label": "calls",
    "to": 83
  }, {
    "from": 7,
    "label": "calls",
    "to": 43
  }, {
    "from": 10,
    "label": "calls",
    "to": 49
  }, {
    "from": 9,
    "label": "calls",
    "to": 53
  }, {
    "from": 10,
    "label": "calls",
    "to": 38
  }, {
    "from": 10,
    "label": "calls",
    "to": 38
  }, {
    "from": 9,
    "label": "calls",
    "to": 43
  }, {
    "from": 9,
    "label": "calls",
    "to": 43
  }, {
    "from": 10,
    "label": "calls",
    "to": 43
  }, {
    "from": 11,
    "label": "calls",
    "to": 53
  }, {
    "from": 11,
    "label": "calls",
    "to": 53
  }, {
    "from": 11,
    "label": "calls",
    "to": 38
  }, {
    "from": 11,
    "label": "calls",
    "to": 38
  }, {
    "from": 11,
    "label": "calls",
    "to": 38
  }, {
    "from": 11,
    "label": "calls",
    "to": 38
  }, {
    "from": 12,
    "label": "calls",
    "to": 53
  }, {
    "from": 12,
    "label": "calls",
    "to": 53
  }, {
    "from": 13,
    "label": "calls",
    "to": 77
  }, {
    "from": 13,
    "label": "calls",
    "to": 38
  }, {
    "from": 14,
    "label": "calls",
    "to": 53
  }, {
    "from": 14,
    "label": "calls",
    "to": 77
  }, {
    "from": 14,
    "label": "calls",
    "to": 87
  }, {
    "from": 14,
    "label": "calls",
    "to": 83
  }, {
    "from": 14,
    "label": "calls",
    "to": 38
  }, {
    "from": 14,
    "label": "calls",
    "to": 38
  }, {
    "from": 15,
    "label": "calls",
    "to": 95
  }, {
    "from": 16,
    "label": "calls",
    "to": 38
  }, {
    "from": 16,
    "label": "calls",
    "to": 38
  }, {
    "from": 16,
    "label": "calls",
    "to": 38
  }, {
    "from": 17,
    "label": "calls",
    "to": 38
  }, {
    "from": 17,
    "label": "calls",
    "to": 38
  }, {
    "from": 18,
    "label": "calls",
    "to": 95
  }, {
    "from": 18,
    "label": "calls",
    "to": 95
  }, {
    "from": 1,
    "label": "contains",
    "to": 37
  }, {
    "from": 37,
    "label": "declares",
    "to": 19
  }, {
    "from": 37,
    "label": "declares",
    "to": 20
  }, {
    "from": 37,
    "label": "declares",
    "to": 21
  }, {
    "from": 37,
    "label": "declares",
    "to": 22
  }, {
    "from": 37,
    "label": "declares",
    "to": 23
  }, {
    "from": 37,
    "label": "declares",
    "to": 24
  }, {
    "from": 37,
    "label": "declares",
    "to": 25
  }, {
    "from": 37,
    "label": "declares",
    "to": 26
  }, {
    "from": 37,
    "label": "declares",
    "to": 27
  }, {
    "from": 37,
    "label": "declares",
    "to": 28
  }, {
    "from": 37,
    "label": "declares",
    "to": 29
  }, {
    "from": 37,
    "label": "declares",
    "to": 30
  }, {
    "from": 37,
    "label": "declares",
    "to": 31
  }, {
    "from": 37,
    "label": "declares",
    "to": 32
  }, {
    "from": 37,
    "label": "declares",
    "to": 33
  }, {
    "from": 37,
    "label": "declares",
    "to": 34
  }, {
    "from": 37,
    "label": "declares",
    "to": 35
  }, {
    "from": 37,
    "label": "declares",
    "to": 36
  }, {
    "from": 38,
    "label": "has",
    "to": 39
  }, {
    "from": 39,
    "label": "has",
    "to": 40
  }, {
    "from": 38,
    "label": "has",
    "to": 41
  }, {
    "from": 38,
    "label": "has",
    "to": 41
  }, {
    "from": 38,
    "label": "has",
    "to": 42
  }, {
    "from": 43,
    "label": "has",
    "to": 44
  }, {
    "from": 43,
    "label": "has",
    "to": 45
  }, {
    "from": 45,
    "label": "has",
    "to": 46
  }, {
    "from": 46,
    "label": "has",
    "to": 47
  }, {
    "from": 43,
    "label": "has",
    "to": 41
  }, {
    "from": 43,
    "label": "has",
    "to": 48
  }, {
    "from": 49,
    "label": "has",
    "to": 44
  }, {
    "from": 49,
    "label": "has",
    "to": 50
  }, {
    "from": 50,
    "label": "has",
    "to": 51
  }, {
    "from": 51,
    "label": "has",
    "to": 47
  }, {
    "from": 49,
    "label": "has",
    "to": 41
  }, {
    "from": 49,
    "label": "has",
    "to": 52
  }, {
    "from": 53,
    "label": "has",
    "to": 54
  }, {
    "from": 53,
    "label": "has",
    "to": 41
  }, {
    "from": 53,
    "label": "has",
    "to": 55
  }, {
    "from": 53,
    "label": "has",
    "to": 56
  }, {
    "from": 56,
    "label": "has",
    "to": 57
  }, {
    "from": 53,
    "label": "has",
    "to": 58
  }, {
    "from": 58,
    "label": "has",
    "to": 59
  }, {
    "from": 59,
    "label": "has",
    "to": 60
  }, {
    "from": 60,
    "label": "has",
    "to": 61
  }, {
    "from": 60,
    "label": "has",
    "to": 62
  }, {
    "from": 53,
    "label": "has",
    "to": 41
  }, {
    "from": 53,
    "label": "has",
    "to": 41
  }, {
    "from": 53,
    "label": "has",
    "to": 41
  }, {
    "from": 53,
    "label": "has",
    "to": 63
  }, {
    "from": 64,
    "label": "has",
    "to": 65
  }, {
    "from": 65,
    "label": "has",
    "to": 57
  }, {
    "from": 64,
    "label": "has",
    "to": 66
  }, {
    "from": 64,
    "label": "has",
    "to": 41
  }, {
    "from": 64,
    "label": "has",
    "to": 67
  }, {
    "from": 67,
    "label": "has",
    "to": 68
  }, {
    "from": 68,
    "label": "has",
    "to": 69
  }, {
    "from": 68,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 64,
    "label": "has",
    "to": 41
  }, {
    "from": 64,
    "label": "has",
    "to": 72
  }, {
    "from": 73,
    "label": "has",
    "to": 74
  }, {
    "from": 73,
    "label": "has",
    "to": 41
  }, {
    "from": 73,
    "label": "has",
    "to": 75
  }, {
    "from": 73,
    "label": "has",
    "to": 41
  }, {
    "from": 73,
    "label": "has",
    "to": 76
  }, {
    "from": 77,
    "label": "has",
    "to": 78
  }, {
    "from": 77,
    "label": "has",
    "to": 79
  }, {
    "from": 79,
    "label": "has",
    "to": 80
  }, {
    "from": 80,
    "label": "has",
    "to": 81
  }, {
    "from": 77,
    "label": "has",
    "to": 41
  }, {
    "from": 77,
    "label": "has",
    "to": 82
  }, {
    "from": 83,
    "label": "has",
    "to": 78
  }, {
    "from": 83,
    "label": "has",
    "to": 84
  }, {
    "from": 84,
    "label": "has",
    "to": 85
  }, {
    "from": 85,
    "label": "has",
    "to": 81
  }, {
    "from": 83,
    "label": "has",
    "to": 41
  }, {
    "from": 83,
    "label": "has",
    "to": 86
  }, {
    "from": 87,
    "label": "has",
    "to": 88
  }, {
    "from": 87,
    "label": "has",
    "to": 89
  }, {
    "from": 89,
    "label": "has",
    "to": 90
  }, {
    "from": 90,
    "label": "has",
    "to": 91
  }, {
    "from": 91,
    "label": "has",
    "to": 92
  }, {
    "from": 92,
    "label": "has",
    "to": 93
  }, {
    "from": 87,
    "label": "has",
    "to": 41
  }, {
    "from": 87,
    "label": "has",
    "to": 94
  }, {
    "from": 95,
    "label": "has",
    "to": 96
  }, {
    "from": 95,
    "label": "has",
    "to": 97
  }, {
    "from": 95,
    "label": "has",
    "to": 98
  }, {
    "from": 95,
    "label": "has",
    "to": 99
  }, {
    "from": 95,
    "label": "has",
    "to": 100
  }, {
    "from": 95,
    "label": "has",
    "to": 101
  }, {
    "from": 95,
    "label": "has",
    "to": 102
  }, {
    "from": 95,
    "label": "has",
    "to": 103
  }, {
    "from": 103,
    "label": "has",
    "to": 104
  }, {
    "from": 104,
    "label": "has",
    "to": 105
  }, {
    "from": 104,
    "label": "has",
    "to": 106
  }, {
    "from": 104,
    "label": "has",
    "to": 107
  }, {
    "from": 103,
    "label": "has",
    "to": 108
  }, {
    "from": 103,
    "label": "has",
    "to": 109
  }, {
    "from": 103,
    "label": "has",
    "to": 110
  }, {
    "from": 110,
    "label": "has",
    "to": 111
  }, {
    "from": 110,
    "label": "has",
    "to": 112
  }, {
    "from": 112,
    "label": "has",
    "to": 113
  }, {
    "from": 113,
    "label": "has",
    "to": 114
  }, {
    "from": 114,
    "label": "has",
    "to": 115
  }, {
    "from": 115,
    "label": "has",
    "to": 116
  }, {
    "from": 115,
    "label": "has",
    "to": 117
  }, {
    "from": 114,
    "label": "has",
    "to": 118
  }, {
    "from": 112,
    "label": "has",
    "to": 109
  }, {
    "from": 103,
    "label": "has",
    "to": 119
  }, {
    "from": 95,
    "label": "has",
    "to": 41
  }, {
    "from": 95,
    "label": "has",
    "to": 41
  }, {
    "from": 95,
    "label": "has",
    "to": 120
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 95,
    "label": "has",
    "to": 41
  }, {
    "from": 95,
    "label": "has",
    "to": 122
  }, {
    "from": 123,
    "label": "has",
    "to": 41
  }, {
    "from": 123,
    "label": "has",
    "to": 124
  }, {
    "from": 125,
    "label": "has",
    "to": 126
  }, {
    "from": 125,
    "label": "has",
    "to": 127
  }, {
    "from": 127,
    "label": "has",
    "to": 128
  }, {
    "from": 127,
    "label": "has",
    "to": 129
  }, {
    "from": 127,
    "label": "has",
    "to": 130
  }, {
    "from": 130,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 132,
    "label": "has",
    "to": 133
  }, {
    "from": 125,
    "label": "has",
    "to": 41
  }, {
    "from": 125,
    "label": "has",
    "to": 41
  }, {
    "from": 125,
    "label": "has",
    "to": 134
  }, {
    "from": 64,
    "label": "calls",
    "to": 64
  }, {
    "from": 73,
    "label": "calls",
    "to": 64
  }, {
    "from": 37,
    "label": "calls",
    "to": 136
  }, {
    "from": 95,
    "label": "calls",
    "to": 137
  }, {
    "from": 38,
    "label": "calls",
    "to": 135
  }, {
    "from": 43,
    "label": "calls",
    "to": 135
  }, {
    "from": 49,
    "label": "calls",
    "to": 135
  }, {
    "from": 53,
    "label": "calls",
    "to": 135
  }, {
    "from": 64,
    "label": "calls",
    "to": 135
  }, {
    "from": 77,
    "label": "calls",
    "to": 135
  }, {
    "from": 83,
    "label": "calls",
    "to": 135
  }, {
    "from": 87,
    "label": "calls",
    "to": 135
  }, {
    "from": 87,
    "label": "calls",
    "to": 135
  }, {
    "from": 95,
    "label": "calls",
    "to": 135
  }, {
    "from": 125,
    "label": "calls",
    "to": 135
  }, {
    "from": 125,
    "label": "calls",
    "to": 135
  }, {
    "from": 43,
    "label": "calls",
    "to": 138
  }, {
    "from": 49,
    "label": "calls",
    "to": 138
  }, {
    "from": 64,
    "label": "calls",
    "to": 138
  }, {
    "from": 77,
    "label": "calls",
    "to": 138
  }, {
    "from": 83,
    "label": "calls",
    "to": 138
  }, {
    "from": 53,
    "label": "calls",
    "to": 53
  }, {
    "from": 37,
    "label": "declares",
    "to": 38
  }, {
    "from": 37,
    "label": "declares",
    "to": 43
  }, {
    "from": 37,
    "label": "declares",
    "to": 49
  }, {
    "from": 37,
    "label": "declares",
    "to": 53
  }, {
    "from": 37,
    "label": "declares",
    "to": 64
  }, {
    "from": 37,
    "label": "declares",
    "to": 73
  }, {
    "from": 37,
    "label": "declares",
    "to": 77
  }, {
    "from": 37,
    "label": "declares",
    "to": 83
  }, {
    "from": 37,
    "label": "declares",
    "to": 87
  }, {
    "from": 37,
    "label": "declares",
    "to": 95
  }, {
    "from": 37,
    "label": "declares",
    "to": 123
  }, {
    "from": 37,
    "label": "declares",
    "to": 125
  }, {
    "from": 139,
    "label": "requires",
    "to": 1
  }, {
    "from": 140,
    "label": "requires",
    "to": 1
  }, {
    "from": 141,
    "label": "requires",
    "to": 1
  }, {
    "from": 142,
    "label": "requires",
    "to": 1
  }, {
    "from": 143,
    "label": "requires",
    "to": 1
  }, {
    "from": 144,
    "label": "requires",
    "to": 1
  }, {
    "from": 145,
    "label": "requires",
    "to": 1
  }, {
    "from": 146,
    "label": "requires",
    "to": 1
  }, {
    "from": 147,
    "label": "requires",
    "to": 1
  }, {
    "from": 148,
    "label": "requires",
    "to": 1
  }, {
    "from": 149,
    "label": "requires",
    "to": 1
  }, {
    "from": 150,
    "label": "requires",
    "to": 1
  }, {
    "from": 151,
    "label": "requires",
    "to": 1
  }, {
    "from": 152,
    "label": "requires",
    "to": 1
  }, {
    "from": 153,
    "label": "requires",
    "to": 1
  }, {
    "from": 1,
    "label": "contains",
    "to": 154
  }, {
    "from": 1,
    "label": "contains",
    "to": 155
  }, {
    "from": 1,
    "label": "provides",
    "to": 156
  }, {
    "from": 156,
    "label": "provides",
    "to": 157
  }, {
    "from": 156,
    "label": "provides",
    "to": 158
  }, {
    "from": 156,
    "label": "provides",
    "to": 159
  }, {
    "from": 156,
    "label": "provides",
    "to": 160
  }, {
    "from": 156,
    "label": "provides",
    "to": 161
  }, {
    "from": 156,
    "label": "provides",
    "to": 162
  }, {
    "from": 156,
    "label": "provides",
    "to": 163
  }, {
    "from": 156,
    "label": "provides",
    "to": 164
  }, {
    "from": 156,
    "label": "provides",
    "to": 165
  }, {
    "from": 156,
    "label": "provides",
    "to": 166
  }, {
    "from": 156,
    "label": "provides",
    "to": 167
  }, {
    "from": 156,
    "label": "provides",
    "to": 168
  }, {
    "from": 156,
    "label": "provides",
    "to": 169
  }, {
    "from": 1,
    "label": "contains",
    "to": 170
  }, {
    "from": 1,
    "label": "contains",
    "to": 171
  }, {
    "from": 170,
    "label": "initializes",
    "to": 172
  }, {
    "from": 172,
    "label": "assigns",
    "to": 173
  }, {
    "from": 170,
    "label": "initializes",
    "to": 174
  }, {
    "from": 174,
    "label": "assigns",
    "to": 175
  }, {
    "from": 170,
    "label": "initializes",
    "to": 176
  }, {
    "from": 176,
    "label": "assigns",
    "to": 177
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "utils",
    "type": "module"
  }, {
    "id": 2,
    "text": "",
    "type": "function container"
  }, {
    "id": 3,
    "text": "local function evaluate_require_execs(node, secondary_nodes, nodeName, scopeArray, data) \t\t--- node assign operacie (Name) a data {args} (prefixExp celeho volania)\r\n\r\n\tlocal name\t\t\t-- FULL name of variable assigned to ! ... leftname when searching for functions and variables\r\n\tlocal modulename\t-- FULL name of required module\r\n\r\n\tif (node.tag == 'STRING' ) then -- if node is a STRING node - require function was not part of an assign, defines a new variable\r\n\t\tname = string.sub(node.text, 2 , string.len(node.text) -1) -- delete '' and \"\" \r\n\t\tmodulename = name\r\n\telse\r\n\t\tname = node.text\r\n\t\tif (secondary_nodes) then \r\n\t\t\tfor k,v in pairs (secondary_nodes) do\r\n\t\t\t\tname = name .. v.text\r\n\t\t\tend\r\n\t\tend\r\n\t\tmodulename = utils.searchForTagItem_recursive('STRING', data[1], 5)\r\n\t\tmodulename = string.sub(modulename.text, 2 , string.len(modulename.text) -1)\r\n\tend\r\n\t\r\n\tif (not modulename) then return end -- require does not contain string with its name but only a variable (subject to future dynamic analysis)\r\n\t\r\n\tlocal index\r\n\r\n\t-- evaluate function calls of a referenced module\r\n\tlocal functions = {}\r\n\tif (total_moduleCalls[modulename] == nil) then total_moduleCalls[modulename] = {} end\r\n\tlocal moduleref = total_moduleCalls[modulename]\r\n\t\t\r\n\tfor callName, node in pairs(total_execs_stack) do\r\n\t\tindex = string.find(callName, name)\r\n\t\tif (index == 1) then\r\n\t\t\tlocal rightname = string.sub(callName, index + string.len(name) + 1)\r\n\t\t\tfunctions[rightname] = node\r\n\t\t\tfor _, node in pairs(node) do\r\n\t\t\t\tnode.metrics.module_functionCall = {}\r\n\t\t\t\tnode.metrics.module_functionCall.moduleName = modulename\r\n\t\t\t\tnode.metrics.module_functionCall.functionName = rightname\r\n\t\t\tend\t\t\t\r\n\t\tend\r\n\tend\r\n\t\r\n\tfor key, value in pairs(functions) do\r\n\t\tif (moduleref[key] == nil) then moduleref[key] = 0 end\r\n\t\tmoduleref[key] = moduleref[key] + table.getn(value)\r\n\tend\r\n\t\r\n\t-- evaluate variables of a references module .. the same scope as the beginning of a variable (jedna.dva = require 'aa') - scope of 'jedna'\r\n\tlocal variables = {}\r\n\t\r\n\tfor _ ,var in pairs(scopeArray[nodeName]) do\r\n\t\t-- build name for variable (join parts into one string ( one.two.three ) (var is only a reference to node Name 'one')\r\n\t\tlocal varName = var.text\r\n\t\tif (var.parent.tag == '_PrefixExp') then\r\n\t\t\tnameNode, secondaryNodes = process_PrefixExpChildren(var.parent.data)\r\n\t\t\tfor k,v in pairs(secondaryNodes) do \t\t\t\t\r\n\t\t\t\tvarName = varName .. v.text\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\t-- split name into left.mid.right parts (left+mid = localmodulename)\r\n\t\t\tlocal leftname = var.text\r\n\t\t\ti = 1\r\n\t\t\twhile (leftname ~= name and i<#secondaryNodes + 1) do \r\n\t\t\t\tleftname = leftname .. secondaryNodes[i].text\r\n\t\t\t\ti = i + 1\r\n\t\t\tend\r\n\t\t\tlocal midname\r\n\t\t\tif (i < #secondaryNodes + 1) then \r\n\t\t\t\tmidname = secondaryNodes[i].text\r\n\t\t\tend\r\n\t\t\ti = i + 1\r\n\t\t\tlocal rightname = ''\r\n\t\t\twhile (i<#secondaryNodes + 1) do \r\n\t\t\t\trightname = rightname .. secondaryNodes[i].text\r\n\t\t\t\ti = i + 1\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tif (midname) then\r\n\t\t\t\t-- compare with local variable holding the module\r\n\t\t\t\tmidname = string.sub(midname, 2) -- get rid of the dot in .variable\r\n\t\t\t\tif (variables[midname] == nil) then variables[midname] = {} end\r\n\t\t\t\tif (variables[midname][midname..rightname] == nil) then \r\n\t\t\t\t\tvariables[midname][midname..rightname] = 1 \r\n\t\t\t\telse\r\n\t\t\t\t\tvariables[midname][midname..rightname] = variables[midname][midname..rightname] + 1\r\n\t\t\t\tend\r\n\t\t\t\tvar.metrics.module_reference = {}\r\n\t\t\t\tvar.metrics.module_reference.moduleName = modulename\r\n\t\t\t\tvar.metrics.module_reference.referenceName = midname\r\n\t\t\t\tvar.metrics.module_reference.referenceName_full = midname .. rightname\r\n\t\t\tend\r\n\t\t\t\r\n\t\tend\t\r\n\tend\r\n\t\r\n\ttotal_moduleReferences[modulename] = variables\r\n\t\r\nend",
    "type": "function"
  }, {
    "id": 4,
    "text": "local function checkAndAddFunctionDeclaration(name, expression)\r\n\tif (expression == nil) then \r\n\t\treturn nil\r\n\telse\r\n\t\tlocal fun = utils.searchForTagItem_recursive('Function', expression, 3)\t\r\n\t\tif (fun) then\r\n\t\t\tfun.name = name.text\r\n\t\t\ttable.insert(total_function_def , fun )\r\n\t\t\t\r\n\t\t\treturn fun\r\n\t\telse\r\n\t\t\treturn nil\r\n\t\tend\r\n\tend\r\n\treturn nil\t\r\nend",
    "type": "function"
  }, {
    "id": 5,
    "text": "local function processAssign(node, isLocal)\r\n\r\n\tlocal results = {}\r\n\t\r\n\tlocal nameList = utils.getNamesFromNameList(node.nameList)\r\n\t\r\n\tlocal expList = {}\r\n\tif (node.expList) then expList = utils.getExpsFromExpsList(node.expList) end\r\n\t\r\n\tfor k,v in pairs(nameList) do\r\n\t\t\r\n\t\tlocal functionNode = checkAndAddFunctionDeclaration(v,expList[k])\r\n\t\tlocal secondary_nodes\r\n\t\t\r\n\t\tif (v.tag == 'Var') then -- if normal assign (not local) find the 'Var' node instead of a Name node\r\n\t\t\tv, secondary_nodes = process_PrefixExpChildren(v.data[1].data)\t\t-- v.data[1].data is table of _PrefixExp's children\r\n\t\tend\r\n\t\t\r\n\t\tv.functionNode = functionNode\r\n\t\tif functionNode then functionNode.assignNode = v end\r\n\t\t\r\n\t\t-- check right side of assign for function call\r\n\t\t-- test for 'require' function call\r\n\t\tlocal getPrefixExp = utils.searchForTagItem_recursive('_PrefixExp', expList[k], 3)\r\n\t\tif (getPrefixExp) then\r\n\t\t\tlocal name, results, isFunctionCall, args = process_PrefixExpChildren(getPrefixExp.data)\r\n\t\t\tif (isFunctionCall) then\r\n\t\t\t\tif (name.text == 'require') then \r\n\t\r\n\t\t\t\t\tlocal modulename = utils.searchForTagItem_recursive('STRING', args, 5)\r\n\t\t\t\t\tif (modulename) then\r\n\t\t\t\t\t\tlocal nodeName = string.sub(modulename.text, 2, string.len(modulename.text) -1) -- delete '' and \"\" from beginning and end\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tlocal index = string.find(nodeName, '%.')\r\n\t\t\t\t\t\tif (index) then nodeName = string.sub(nodeName, 0, index - 1) end\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tnewVariable(modulename, nodeName, nil, true) -- set callbacks for node ... evaluate_require_execs is called with node as argument when 'end of scope' happens\r\n\t\t\t\t\t\tnode_callbacks[v] = {}\r\n\t\t\t\t\t\tnode_callbacks[v].sec_nodes = secondary_nodes\r\n\t\t\t\t\t\tnode_callbacks[v].fun = evaluate_require_execs\r\n\t\t\t\t\t\tnode_callbacks[v].call_data = {args}\r\n\t\t\t\t\tend\r\n\t\t\t\t\t\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\t-- create table to be returned\r\n\t\tlocal str = v.text\r\n\t\ttable.insert(results, {str, v, secondary_nodes})\r\n\t\t\r\n\tend\t\r\n\treturn results\r\nend",
    "type": "function"
  }, {
    "id": 6,
    "text": "local function processFunction(node)\r\n\t-- get Block and ParList nodes for function\r\n\tlocal block = utils.searchForTagItem_recursive('Block', node, 2) \r\n\tlocal parlist = utils.searchForTagItem_recursive('ParList', node, 2) \r\n\tnode.metrics.blockdata = block.metrics.blockdata\r\n\t\r\n\t-- treat function as an Assign operation - the name of a function is left side of assign operation\r\n\tif (node.name) then -- funkcie function()... check needed because function() without names are processed together in with Assign operations (later)\r\n\t\tlocal nameBlock, secondaryNames = utils.searchForTagItem('Name', node.data)\r\n\t\t\r\n\t\tif (nameBlock == nil) then\r\n\t\t\tlocal funcname = utils.searchForTagItem('FuncName', node.data)\r\n\t\t\tnameBlock, secondaryNames = process_PrefixExpChildren(funcname.data)\r\n\t\tend\r\n\t\t\r\n\t\tnameBlock.functionNode = node\r\n\t\t\r\n\t\t-- correct setting of isLocal or isGlobal value for function\r\n\t\t\r\n\t\tif (node.tag == 'LocalFunction') then\r\n\t\t\tif (locals_stack[nameBlock.text] ~= nil) then\r\n\t\t\t\ttable.insert(all_locals_stack, {nameBlock.text,locals_stack[nameBlock.text]})\r\n\t\t\t\tendScopeOfVariable(locals_stack, nameBlock.text)\r\n\t\t\t\thighLightVariable(highlight_local, nameBlock.text)\r\n\t\t\tend\r\n\t\t\taddItemToArray(locals_stack, nameBlock.text, nameBlock)\r\n\t\t\taddItemToHighlightArray(highlight_local, nameBlock, secondaryNames)\r\n\t\t\tif (moduleMetrics) then\r\n\t\t\t\ttable.insert(moduleMetrics.variables, nameBlock)\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tnewVariable(nameBlock, nameBlock.text, secondaryNames, false)\r\n\t\tend\r\n\t\tnameNode = nameBlock\t\t\r\n\tend\r\n\t\r\n\t\r\n\t-- body of a function - set function arguments as local variables , and do 'end of scope' (highlight them)\r\n\tif (block ~= nil and parlist ~= nil) then\r\n\t\t-- get table of variables from nameList\r\n\t\t\t\t\t\t\r\n\t\tlocal k,v, names\r\n\t\tlocal nameList = utils.searchForTagItem('NameList', parlist.data)\r\n\t\tif (nameList) then\r\n\t\t\tnames = utils.getNamesFromNameList(nameList)\r\n\t\tend\r\n\t\t\t\t\t\t\t\r\n\t\t-- get table containing remote variables for function (from its block)\r\n\t\tlocal remotes = block.metrics.blockdata.remotes\t\t\r\n\t\tlocal highlight_remotes_block = block.metrics.blockdata.highlight_remote\r\n\t\tif (names ~= nil ) then\r\n\t\t\t-- if remote variable is an argument of a function - call endScopeOfVariable functino that takes care of them (delete them from arrays and highlights them)\r\n\t\t\t-- this variable is a temporary holder\r\n\t\t\tlocal holder = {}\r\n\t\t\t\r\n\t\t\tfor k,v in pairs(names) do\r\n\t\t\t\taddItemToArray(remotes, v.text, v)\r\n\t\t\t\taddItemToHighlightArray(highlight_remotes_block, v, nil)\r\n\t\t\t\t\r\n\t\t\t\t-- number and throw aray\r\n\t\t\t\t\r\n\t\t\t\tholder[v.text] = remotes[v.text]\r\n\t\t\t\t\r\n\t\t\t\tendScopeOfVariable(remotes, v.text)\r\n\t\t\t\thighLightVariable(highlight_remotes_block, v.text)\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tdoRecursion(block.parent)\r\n\t\t\t\r\n\t\t\t-- remotes set earlier are actualy local variables for the block !\r\n\t\t\t-- dane remotes su v skutocnosti lokalne premenne pre dany block !\r\n\t\t\t\r\n\t\t\t-- only for that one block !\r\n\t\t\t\r\n\t\t\tfor k,v in pairs(holder) do\r\n\t\t\t\ttable.insert(block.metrics.blockdata.locals, { k, v })\r\n\t\t\t\ttable.insert(block.metrics.blockdata.locals_total, {k,v} )\r\n\t\t\t\tif (moduleMetrics) then\r\n\t\t\t\t\tfor _, node in pairs(v) do\r\n\t\t\t\t\t\ttable.insert(moduleMetrics.variables, v)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\t\r\n\t\telse\r\n\t\t\tdoRecursion(block.parent)\r\n\t\tend\r\n\telse\t\t\r\n\t\tdoRecursion(block.parent)\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 7,
    "text": "local function process_PrefixExp(node)\r\n\tlocal names = {}\r\n\t\r\n\tlocal name, secondary_names = process_PrefixExpChildren(node.data)\r\n\t\r\n\tlocal args = utils.searchForTagItem('_PrefixExpArgs', node.data)\r\n\tif (args) then \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- IS A FUNCTION CALL\r\n\t\tif (name) then\r\n\t\t\tlocal text = name.text\r\n\t\t\t\r\n\t\t\t-- check if this call is 'module' call - remember the name of this module\r\n\t\t\tif (text == 'module') then \r\n\t\t\t\t-- is package.seeall ?\r\n\t\t\t\t\r\n\t\t\t\tlocal explist = utils.searchForTagItem('ExpList', args.data[1].data)\r\n\t\t\t\tif (explist) then\r\n\t\t\t\t\tlocal exps = utils.searchForTagArray('Exp', explist.data)\r\n\t\t\t\t\tlocal packageSeall = exps[#exps]\r\n\t\t\t\t\r\n\t\t\t\t\tif (not (packageSeall and packageSeall.text == 'package.seeall')) then  \t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\t-- end of scope for all global variables, and highlight them -- TODO whatif package.seeall ?\r\n\t\t\t\t\t\tfor k,v in pairs(remotes_stack) do\r\n\t\t\t\t\t\t\tendScopeOfVariable(remotes_stack, k, true)\t\r\n\t\t\t\t\t\tend\t\t\t\t\t\r\n\t\t\t\t\t\tfor k, v in pairs(highlight_remote) do\r\n\t\t\t\t\t\t\thighLightVariable(highlight_remote, k)\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\r\n\t\t\t\t-- begin collection of module variables\r\n\t\t\t\t\r\n\t\t\t\tlocal modulename = utils.searchForTagItem_recursive('STRING', node, 6)\r\n\t\t\t\r\n\t\t\t\tif (modulename) then \r\n\t\t\t\t\tmodulename = string.sub(modulename.text, 2, string.len(modulename.text) -1 )\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\tmoduleDefinitions[node] = {}\r\n\t\t\t\t\tmoduleDefinitions[node].moduleName = modulename\r\n\t\t\t\t\tmoduleDefinitions[node].references = {\r\n\t\t\t\t\t\tvariables = {},\r\n\t\t\t\t\t\texecs = {}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmoduleMetrics = moduleDefinitions[node].references\t\t\t\t\t\r\n\t\t\t\tend\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\telseif (text == 'require') then -- this is a require call\r\n\t\t\t\t-- make sure it is not a part of an assign\r\n\t\t\t\tlocal helper = node.parent.parent.parent.parent\r\n\t\t\t\tif (helper.tag ~= 'LocalAssign' and helper.tag ~= 'Assign') then \r\n\t\t\t\t\tlocal modulename = utils.searchForTagItem_recursive('STRING', args, 5)\r\n\t\t\t\t\tif (modulename) then\r\n\t\t\t\t\t\t-- require function defines local variable with arguments name\r\n\t\t\t\t\t\tlocal nodeName = string.sub(modulename.text, 2, string.len(modulename.text) -1) -- delete '' and \"\" from beginning and end\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tlocal index = string.find(nodeName, '%.')\r\n\t\t\t\t\t\tif (index) then nodeName = string.sub(nodeName, 0, index - 1) end\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tnewVariable(modulename, nodeName, nil, true)\r\n\t\t\t\t\t\tif (name.text == 'require') then -- set callback arguments for node ... called when 'end of scope' is run - function evaluate_require_execs is called with the node and arguments\r\n\t\t\t\t\t\t\tnode_callbacks[modulename] = {}\r\n\t\t\t\t\t\t\tnode_callbacks[modulename].sec_nodes = nil\r\n\t\t\t\t\t\t\tnode_callbacks[modulename].fun = evaluate_require_execs\r\n\t\t\t\t\t\t\tnode_callbacks[modulename].call_data = {nil}\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\tend\r\n\t\t\t\t\t\r\n\t\t\t\tend\r\n\t\t\t\t\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\t-- build function name from secondary nodes\r\n\t\t\tfor k,v in pairs(secondary_names) do text = text .. v.text end\r\n\t\t\r\n\t\t\taddItemToArray(total_execs_stack, text, node)\r\n\t\t\tif (moduleMetrics) then\r\n\t\t\t\taddItemToArray(moduleMetrics.execs, text, node)\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tif (highlight_local[name.text] == nil) then\r\n\t\t\t\taddItemToHighlightArray(highlight_remote, name, secondary_names)\r\n\t\t\telse\r\n\t\t\t\taddItemToHighlightArray(highlight_local, name, secondary_names)\r\n\t\t\tend\r\n\t\tend\r\n\telse\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- PREMENNA\r\n\t\tif (name ~= nil) then\r\n\t\t\ttable.insert(names, {name.text, name, secondary_names})\r\n\t\tend\r\n\tend\r\n\t\r\n\treturn names\r\nend",
    "type": "function"
  }, {
    "id": 8,
    "text": "",
    "type": "function container"
  }, {
    "id": 9,
    "text": "local function countConditions(expression)\r\n\tif (not expression) then return end\r\n\t\r\n\tlocal simpleExps = utils.searchForTagArray('_SimpleExp', expression.data)\r\n\t\r\n\tlocal binops = utils.searchForTagArray('BinOp', expression.data)\r\n\tlocal count_and_or = 0\r\n\tif (not string.find(expression.text, '^%(')) then count_and_or = 1 end\r\n\t\r\n\tfor _, op in pairs(binops) do\r\n\t\tlocal key = op.data[1].key\r\n\t\tif (key == 'AND' or key == 'OR') then\r\n\t\t\tcount_and_or = count_and_or + 1\r\n\t\tend\r\n\tend\r\n\t\r\n\tfor _, simpleExp in pairs(simpleExps) do\r\n\t\tif (string.find(simpleExp.text, '^%(')) then\r\n\t\t\tlocal current_exp = utils.searchForTagItem_recursive('Exp', simpleExp, 3)\r\n\t\t\tcount_and_or = count_and_or + countConditions(current_exp)\r\n\t\tend\r\n\tend\r\n\treturn count_and_or\r\nend",
    "type": "function"
  }, {
    "id": 10,
    "text": "",
    "type": "function container"
  }, {
    "id": 11,
    "text": "",
    "type": "function container"
  }, {
    "id": 12,
    "text": "",
    "type": "function container"
  }, {
    "id": 13,
    "text": "",
    "type": "function container"
  }, {
    "id": 14,
    "text": "local function do_information_flow(funcAST)\r\n\r\n\tlocal in_counter = 0\r\n\tlocal return_counter = 0\r\n\tlocal block = utils.getBlockFromFunction(funcAST)\r\n\t\r\n\tif (block) then -- should always be true but to be sure\r\n\t\t\r\n\t\tlocal usedNodes = {}\r\n\t\t\r\n\t\t-- get number of expressions in return statement\r\n\t\tlocal lastStat = utils.searchForTagItem('LastStat', block.data[1].data)\r\n\t\tif (lastStat) then\r\n\t\t\tlocal explist = utils.searchForTagItem('ExpList', lastStat.data)\r\n\t\t\tif (explist) then -- moze byt len obycajny return bez argumentov\r\n\t\t\t\tlocal expressions = utils.getExpsFromExpsList(explist)\r\n\t\t\t\treturn_counter = #expressions\t\t\t\r\n\t\t\t\tfor k,v in pairs(expressions) do table.insert(usedNodes, v) end\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\tlocal parListNames = {}\r\n\t\t\r\n\t\t-- search for function's parameters\r\n\t\tlocal parlist = utils.searchForTagItem_recursive('ParList', funcAST, 2)\r\n\t\tif (parlist) then\r\n\t\t\tlocal nameList = parlist.data[1] -- can be a 'symbol' node (...)\r\n\t\t\tif (nameList.tag == 'NameList') then\r\n\t\t\t\tlocal names = utils.getNamesFromNameList(nameList)\r\n\t\t\t\tin_counter = #names\r\n\t\t\t\tfor k,v in pairs(names) do \r\n\t\t\t\t\tparListNames[v.text] = v\r\n\t\t\t\t\ttable.insert(usedNodes, v) \r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\t\r\n\t\tif (funcAST.metrics == nil) then funcAST.metrics = {} end\r\n\t\t\r\n\t\tlocal v_in, v_out = {}, {}\r\n\t\t\r\n\t\t-- count number of read and written remote variables\r\n\t\tfor name, vars in pairs(block.metrics.blockdata.remotes) do\r\n\t\t\tfor _, node in pairs(vars) do\r\n\t\t\t\tlocal used = false\r\n\t\t\t\tif (node.isRead) and parListNames[node.text] == nil then\r\n\t\t\t\t\tif not used then table.insert(v_in, node) used = true end\r\n\t\t\t\t\ttable.insert(usedNodes, node)\r\n\t\t\t\tend\r\n\t\t\t\tif (node.isWritten) and parListNames[node.text] == nil then\r\n\t\t\t\t\tif not used then table.insert(v_out, node) used = true end\r\n\t\t\t\t\ttable.insert(usedNodes, node)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\t-- calculate the metric\r\n\t\tfuncAST.metrics.infoflow = {}\r\n\t\tfuncAST.metrics.infoflow.information_flow = (#v_in * (#v_out + return_counter))^2\r\n\t\tfuncAST.metrics.infoflow.arguments_in =\tin_counter\r\n\t\tfuncAST.metrics.infoflow.arguments_out = return_counter\r\n\t\tfuncAST.metrics.infoflow.interface_complexity = in_counter + return_counter\r\n\t\tfuncAST.metrics.infoflow.used_nodes = usedNodes\t\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 15,
    "text": "local function alterNode(node, block)\r\n\tlocal comment, fullComment = utils.getComment(block)\r\n\tlocal index = string.find(fullComment, '\\n')\r\n\tif (index) then\r\n\t\tnode.metrics.LOC.lines  = node.metrics.LOC.lines - 1\r\n\t\tnode.metrics.LOC.lines_code  = node.metrics.LOC.lines_code - 1\r\n\t\tnode.metrics.LOC.lines_nonempty  = node.metrics.LOC.lines_nonempty - 1\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 16,
    "text": "local function doMetrics(node)\r\n\tlocal children = node.data\r\n\tlocal key, value\r\n\tlocal moduleMetrics = nil\r\n\t\r\n\tlocal LOC = {\r\n\t\tlines = 0\t\t\t\t-- total number of lines\r\n\t\r\n\t\t,lines_nonempty = 0\t\t-- number of non-empty lines ( code or comments )\r\n\t\t,lines_blank = 0\t\t-- number of empty lines \r\n\t\r\n\t\t,lines_code = 0\t\t\t-- number of lines with code ( nonempty without comments ) ( comment can be at the end of line )\r\n\t\t,lines_comment = 0\t\t-- number of comment lines ( inline too )\r\n\t}\r\n\t\r\n\tfor key, value in pairs(children) do\r\n\t\r\n\t\tif (value.tag == 'IGNORED') then\r\n\t\t\t\r\n\t\t\t-- IGNORED means whitespace\r\n\t\t\t-- count number of lines and other measures\r\n\t\t\t\r\n\t\t\tlocal only_newline = false\r\n\t\t\tlocal only_comment = false\r\n\t\t\t\r\n\t\t\tlocal children, key, value = value.data\r\n\t\t\tfor key, value in pairs(children) do\r\n\t\t\t\r\n\t\t\t\tif (value.tag == 'NEWLINE') then \r\n\t\t\t\t\taddCount(LOC, 'lines', 1)\r\n\t\t\t\t\taddCount(moduleMetrics, 'lines', 1)\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (only_newline) then\r\n\t\t\t\t\t\taddCount(LOC, 'lines_blank', 1)\r\n\t\t\t\t\t\taddCount(moduleMetrics, 'lines_blank', 1)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\taddCount(LOC, 'lines_nonempty', 1)\r\n\t\t\t\t\t\taddCount(moduleMetrics, 'lines_nonempty', 1)\r\n\t\t\t\t\t\tif (not only_comment) then\r\n\t\t\t\t\t\t\taddCount(LOC, 'lines_code', 1)\r\n\t\t\t\t\t\t\taddCount(moduleMetrics, 'lines_code', 1)\r\n\t\t\t\t\t\tend\t\r\n\t\t\t\t\tend\t\r\n\t\t\t\t\tonly_newline = true\r\n\t\t\t\tend\r\n\t\t\t\t\r\n\t\t\t\tif (value.tag == 'COMMENT') then\r\n\t\t\t\t\taddCount(LOC, 'lines_comment', 1)\r\n\t\t\t\t\taddCount(moduleMetrics, 'lines_comment', 1)\r\n\t\t\t\t\tif (only_newline) then\r\n\t\t\t\t\t\tonly_comment = true\r\n\t\t\t\t\tend\r\n\t\t\t\t\tonly_newline = false\r\n\t\t\t\t\t\r\n\t\t\t\t\t-- count number of lines in multiline comments\r\n\t\t\t\t\tlocal count = 0\r\n\t\t\t\t\tfor w in string.gmatch(value.text, \"\\n\") do\r\n\t\t\t\t\t\tcount = count + 1\t\t\t\t\t\t\r\n\t\t\t\t\tend\r\n\t\t\t\t\t\r\n\t\t\t\t\taddCount(LOC, 'lines', count)\r\n\t\t\t\t\taddCount(moduleMetrics, 'lines', count)\r\n\t\t\t\t\taddCount(LOC, 'lines_comment', count)\r\n\t\t\t\t\taddCount(moduleMetrics, 'lines_comment', count)\r\n\t\t\t\t\taddCount(LOC, 'lines_nonempty', count) -- BLANK ??\r\n\t\t\t\t\taddCount(moduleMetrics, 'lines_nonempty', count) \r\n\t\t\t\tend\r\n\t\t\t\t\r\n\t\t\tend\t\t\t\r\n\t\t\t\r\n\t\telse \r\n\t\t\t\r\n\t\t\tif (value.tag == 'STRING') then\r\n\t\t\t\tlocal count =0\r\n\t\t\t\tfor w in string.gmatch(value.text, \"\\n\") do\r\n\t\t\t\t\tcount = count + 1\r\n\t\t\t\tend\r\n\t\t\t\taddCount(LOC, 'lines', count)\r\n\t\t\t\taddCount(moduleMetrics, 'lines', count)\r\n\t\t\t\taddCount(LOC, 'lines_code', count)\r\n\t\t\t\taddCount(moduleMetrics, 'lines_code', count)\r\n\t\t\t\taddCount(LOC, 'lines_nonempty', count)\r\n\t\t\t\taddCount(moduleMetrics, 'lines_nonempty', count) \r\n\t\t\tend\r\n\t\t\t\r\n\t\t\t-- TRY MODULE DEFINITION\r\n\r\n\t\t\tonly_newline = false\r\n\t\t\tonly_comment = false\r\n\t\t\r\n\t\t\taddCount(LOC, 'lines', value.metrics.LOC.lines)\r\n\t\t\taddCount(LOC, 'lines_comment', value.metrics.LOC.lines_comment)\r\n\t\t\taddCount(LOC, 'lines_blank', value.metrics.LOC.lines_blank)\r\n\t\t\taddCount(LOC, 'lines_nonempty', value.metrics.LOC.lines_nonempty)\r\n\t\t\taddCount(LOC, 'lines_code', value.metrics.LOC.lines_code)\r\n\t\t\t\r\n\t\t\taddCount(moduleMetrics, 'lines', value.metrics.LOC.lines)\r\n\t\t\taddCount(moduleMetrics, 'lines_comment', value.metrics.LOC.lines_comment)\r\n\t\t\taddCount(moduleMetrics, 'lines_blank', value.metrics.LOC.lines_blank)\r\n\t\t\taddCount(moduleMetrics, 'lines_nonempty', value.metrics.LOC.lines_nonempty)\r\n\t\t\taddCount(moduleMetrics, 'lines_code', value.metrics.LOC.lines_code)\r\n\t\t\t\r\n\t\t\tif (value.tag == 'Stat') then\r\n\t\t\t\tlocal stat = value.data[1]\r\n\t\t\t\tlocal block = utils.searchForTagItem('Block', stat.data)\r\n\t\t\t\tif (block) then\r\n\t\t\t\t\talterNode(stat, block)\r\n\t\t\t\tend\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif (stat.tag == 'FunctionCall') then\r\n\t\t\t\tif (stat.data[1].data[1].text == 'module') then\r\n\t\t\t\t\tlocal exec = stat.data[1]\r\n\t\t\t\t\t\r\n\t\t\t\t\tmoduleDefinitions[exec] = {}\r\n\t\t\t\t\tif (moduleDefinitions[exec].metrics == nil) then moduleDefinitions[exec].metrics = {} end\r\n\t\t\t\t\t\r\n\t\t\t\t\tmoduleDefinitions[exec].LOC = {\r\n\t\t\t\t\t\tlines = 0,\r\n\t\t\t\t\t\tlines_comment = 0,\r\n\t\t\t\t\t\tlines_code = 0,\r\n\t\t\t\t\t\tlines_blank = 0,\r\n\t\t\t\t\t\tlines_nonempty = 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tmoduleMetrics = moduleDefinitions[exec].LOC\r\n\t\t\t\tend\r\n\t\t\t\t\r\n\t\t\tend\r\n\t\t\t\t\r\n\t\t\telseif (value.tag == 'GlobalFunction' or value.tag == 'LocalFunction' or value.tag == 'Function') then\r\n\t\t\t\tlocal funcbody = utils.searchForTagItem('FuncBody', value.data)\r\n\t\t\t\tlocal block = utils.searchForTagItem('Block', funcbody.data)\r\n\t\t\t\tif (block) then\r\n\t\t\t\t\talterNode(value, block)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\t\r\n\tend\r\n\t\r\n\tif (node.metrics == nil) then node.metrics = {} end\r\n\tnode.metrics.LOC \t\t\t\t= LOC\r\nend",
    "type": "function"
  }, {
    "id": 17,
    "text": "local function countStatements(node)\r\n\tlocal children = node.data\r\n\tlocal moduleMetrics = nil\r\n\t\r\n\tlocal statements = {}\r\n\t\r\n\r\n-- doplnil : Peter Kosa  \r\n--counts number of return points in function\r\n\t\tif(node.tag == \"GlobalFunction\" or node.tag ==\"LocalFunction\" or node.tag==\"Function\")then\r\n\t\t\tlocal fbody = utils.searchForTagItem('FuncBody', node.data)\r\n\t\t\tlocal fblock =  utils.searchForTagItem('Block', fbody.data)\r\n\t\t\t\r\n\t\t\tif (not statements[\"return\"]) then statements[\"return\"] = {} end\r\n\t\t\tcountReturnStatements(fblock.data,statements)\r\n\t\tend\r\n----------------------\t\t\r\n\t\r\n\tfor _, child in pairs(children) do\r\n\t\t\r\n\t\tif (child.tag == 'Stat') then\r\n\t\t\tlocal stat = child.data[1]\t\r\n\t\t\tif (not statements[stat.tag]) then statements[stat.tag] = {} end\r\n\t\t\ttable.insert(statements[stat.tag], stat)\r\n\t\t\t\r\n\t\t\tif (moduleMetrics) then \r\n\t\t\t\tif (not moduleMetrics[stat.tag]) then moduleMetrics[stat.tag] = {} end\r\n\t\t\t\ttable.insert(moduleMetrics[stat.tag], stat)\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tif (stat.tag == 'FunctionCall') then\r\n\t\t\t\tif (stat.data[1].data[1].text == 'module') then\r\n\t\t\t\t\tlocal exec = stat.data[1]\r\n\t\t\t\t\t\r\n\t\t\t\t\tmoduleDefinitions[exec] = {}\r\n\t\t\t\t\tif (moduleDefinitions[exec].metrics == nil) then moduleDefinitions[exec].metrics = {} end\r\n\t\t\t\t\t\r\n\t\t\t\t\tmoduleDefinitions[exec].statements = {}\r\n\t\t\t\t\t\r\n\t\t\t\t\tmoduleMetrics = moduleDefinitions[exec].statements\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\t\r\n\t\t\r\n\t\tfor key, stats in pairs(child.metrics.statements) do\r\n\t\t\tif (not statements[key]) then statements[key] = {} end\r\n\t\t\tfor _, stat in pairs(stats) do\r\n\t\t\t\ttable.insert(statements[key], stat)\r\n\t\t\t\tif (moduleMetrics) then \r\n-- modifikoval Peter Kosa,  aby v HTML tabulke : \"Statement usage\" nebolo slovo \"keyword\" ale \"return\"\t\t\t\t\r\n\t\t\t\t\tif(stat.tag == 'keyword' and stat.text == 'return') then\r\n\t\t\t\t\t\tif (not moduleMetrics[\"return\"]) then moduleMetrics[\"return\"] = {} end\r\n\t\t\t\t\t\ttable.insert(moduleMetrics[\"return\"], stat)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tif (not moduleMetrics[stat.tag]) then moduleMetrics[stat.tag] = {} end\r\n\t\t\t\t\t\ttable.insert(moduleMetrics[stat.tag], stat)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\tend\r\n\r\n\tif (node.metrics == nil) then node.metrics = {} end\r\n\tnode.metrics.statements = statements\t\r\nend",
    "type": "function"
  }, {
    "id": 18,
    "text": "",
    "type": "function container"
  }, {
    "id": 19,
    "text": "local function round(num)\r\n\t\r\n\treturn math.floor(num * 100 + 0.5) / 100\r\n\t\r\nend",
    "type": "function"
  }, {
    "id": 20,
    "text": "local function readFile(_sFileName)\r\n\r\n\tlocal f = io.input(_sFileName)\r\n\tlocal sData_ = f:read(\"*a\")\r\n\tf:close()\r\n\treturn sData_\r\n\r\nend",
    "type": "function"
  }, {
    "id": 21,
    "text": "local function replaceSpecials(text)\r\n\r\n\tif text ~= nil then\r\n\t\ttext = text:gsub(lfs.currentdir(), \"\")\r\n\tend\r\n\r\n\tif(text == nil) then\r\n\t\treturn nil;\r\n\tend\r\n\r\n\tif(type(text) ~= \"string\") then\r\n\t\treturn text;\r\n\tend\r\n\r\n\t--replace there characters with their equivalents in HTML\r\n\ttext = text:gsub(\"&\", \"&amp;\");\r\n  \ttext = text:gsub(\"&#\", \"&#38;&#35;\");\r\n\ttext = text:gsub(\"<\", \"&lt;\");\r\n\ttext = text:gsub(\">\", \"&gt;\");\r\n\ttext = text:gsub(\"\\\"\", \"&#34;\");\r\n\ttext = text:gsub(\"'\", \"&#39;\");\r\n\r\n\treturn text;\r\n\r\nend",
    "type": "function"
  }, {
    "id": 22,
    "text": "local function getGraph()\r\n\r\n\treturn readFile('../share/luametrics/highcharts.js')\r\n\r\nend",
    "type": "function"
  }, {
    "id": 23,
    "text": "local function getjQuerryJS()\r\n\r\n\tlocal jquery =  readFile('../share/luametrics/jquery.js')\r\n\r\n\tlocal result = \"<script type='text/javascript'>\" .. jquery .. \"</script>\"\r\n\r\n\treturn result\r\n\r\nend",
    "type": "function"
  }, {
    "id": 24,
    "text": "local function getSmellTable()\r\n\r\n\treturn readFile('../share/luametrics/smellTable.css')\r\n\r\nend",
    "type": "function"
  }, {
    "id": 25,
    "text": "local function getMetricsTable()\r\n\r\n\treturn readFile('../share/luametrics/metricsTable.css')\r\n\r\nend",
    "type": "function"
  }, {
    "id": 26,
    "text": "local function getjQuerryTable()\r\n\r\n\treturn readFile('../share/luametrics/jQueryTable.css')\r\n\r\nend",
    "type": "function"
  }, {
    "id": 27,
    "text": "local function getTabs(id, margin)\r\n\r\n\tlocal result = readFile('../share/luametrics/tabs.css')\r\n\r\n\treturn  \"#tabs\" .. id .. \" { margin-top:\" .. margin .. \"px; }\" .. result\r\n\r\nend",
    "type": "function"
  }, {
    "id": 28,
    "text": "local function addTableCSS(tableClass)\r\n\r\n\tlocal result = \"<style>\"\r\n\r\n\tif(tableClass == \"smell_table\") then\r\n\t\tresult = result .. getSmellTable()\r\n\telseif(tableClass == \"metric_index\") then\r\n\t\tresult = result .. getMetricsTable()\r\n\telseif(tableClass == \"tabs\") then\r\n\t\tresult = result .. getjQuerryTable()\r\n\t\tresult = result .. getTabs(\"\", 50)\r\n\telseif(tableClass == \"tabs2\") then\r\n\t\tresult = result .. getjQuerryTable()\r\n\t\tresult = result .. getTabs(\"2\", 10)\r\n\telseif(tableClass == \"tabs3\") then\r\n\t\tresult = result .. getjQuerryTable()\r\n\t\tresult = result .. getTabs(\"3\", 10)\r\n\tend\r\n\r\n\treturn result .. \"</style>\"\r\n\r\nend",
    "type": "function"
  }, {
    "id": 29,
    "text": "local function createTable(tableClass, collumnNames, style)\r\n\t\r\n\tlocal result = addTableCSS(tableClass) --Add CSS styles from file to template\r\n\tlocal style = style or \"\"\r\n\r\n\t--Create HTML table starting tag with table row starting tag\r\n\tresult = result .. \"<table class='\" .. tableClass .. \"' style='\" .. style .. \"'><tr>\"\r\n\r\n\tfor i = 1, #collumnNames do --Add each collumn to template\r\n\t\tresult = result .. \"<th>\" .. collumnNames[i] .. \"</th>\"\r\n\tend\r\n\r\n\tresult = result .. \"</tr>\" --Close table row tag\r\n\r\n\treturn result\r\n\r\nend",
    "type": "function"
  }, {
    "id": 30,
    "text": "local function closeTable()\r\n\treturn \"</table>\"\r\nend",
    "type": "function"
  }, {
    "id": 31,
    "text": "local function addTableRow(collumns, withLink, color)\r\n\r\n\tlocal result = \"<tr>\" --Starting HTML tag of the row\r\n\tlocal start = 1\r\n\tlocal bg = color or \"WHITE\" --Default color of data collumns\r\n\r\n\tif(withLink) then --If link to the file will be provided in first collumn\r\n\t\tresult = result .. \"<td class='file'>\" .. \r\n\t\t\t\"<img src='../fileIcon.jpg' title='\" .. collumns[1] .. \"' />\" ..\r\n\t\t\t\"</td>\"\r\n\t\tstart = 2\r\n\tend\r\n\r\n\tresult = result .. \"<td class='name' nowrap>\" .. collumns[start] .. \"</td>\" --Name of the data in the row\r\n\r\n\tfor i = start + 1, #collumns do --For each data entry create new collumn in table, with background set\r\n\t\tresult = result .. \"<td class='value' bgcolor='\" .. bg .. \"'><center>\" .. collumns[i] .. \"</center></td>\" \r\n\tend\r\n\r\n\tresult = result .. \"</tr>\" --Close HTML tag of the row\r\n\r\n\treturn result\r\n\r\nend",
    "type": "function"
  }, {
    "id": 32,
    "text": "local function createBarGraph(title, subtitle, height, xAxis, yAxis, seriesName, seriesData, green, orange, withScript)\r\n\t\r\n\tlocal result = \"\"\r\n\tlocal div = \"bar_graph_\" .. math.random(2, 955) --Random graph ID to prevent errors when more graphs will be on one site\r\n\tlocal graphHeight = height * 20\r\n\r\n\t--Create box where graph will be rendered\r\n\tresult = result .. \"<div id='\" .. div .. \"' style='width: 800px; height: \" .. graphHeight .. \"px; min-height: 400px; margin: 0 auto'></div><script>\"\r\n\r\n\tif(withScript or withScript == nil) then --Include JavaScript script from file\r\n\t\tresult = result .. getGraph()\r\n\tend\r\n\r\n\t--Create graph object in JavaScript\r\n\tresult = result .. \"Highcharts.chart('\" .. div .. \"', { chart: { type: 'bar' }, \" ..\r\n\t\t\"title: { text: '\" .. title .. \"' }, subtitle: { text: '\" .. subtitle .. \"' }, \" ..\r\n\t\t\"xAxis: { categories: [ \" .. xAxis .. \" ], title: { text: null } }, \" ..\r\n\t\t\"yAxis: { min: 0, title: { text: '\" .. yAxis .. \"', align: 'high' }, labels: { overflow: 'justify' } }, \" ..\r\n\t\t\"plotOptions: { bar: { dataLabels: { enabled: true } } }, \" ..\r\n\t\t\"legend: { layout: 'vertical', align: 'right', verticalAlign: 'top', x: -40, y: 80, floating: true, borderWidth: 1, backgroundColor: '#FFFFFF', shadow: true }, \" ..\r\n\t\t\"credits: { enabled: true }, \" ..\r\n\t\t\"series: [\"\r\n\r\n\t\tfor i = 1, #seriesName do --Add series to object with color borders of data values\r\n\r\n\t\t\tresult = result .. \"{ name: '\" .. seriesName[i] .. \"', data: [\" .. seriesData[i] .. \"],\" ..\r\n\t\t\t\t\"zones: [{ value: \" .. green .. \", color: 'green'}, \" ..\r\n\t\t\t\t\t\"{ value: \" .. orange .. \", color: 'orange'}, \" ..\r\n\t\t\t\t\t\"{ color: 'red' }]},\"\r\n\r\n\t\tend\r\n\r\n\t\tresult = result .. \"]});</script>\" -- Close JavaScript object and HTML script tag\r\n\r\n\t\treturn result\r\n\r\nend",
    "type": "function"
  }, {
    "id": 33,
    "text": "local function createPieGraph(title, data, withScript)\r\n \r\n\tlocal result = \"\"\r\n\tlocal div = \"pie_graph_\" .. math.random(2, 955)\t--Random graph ID to prevent errors when more graphs will be on one site\r\n\r\n\t--Create box where graph will be rendered\r\n\tresult = result .. \"<div style='margin: 20px;' id='\" .. div .. \"'></div><script>\"\r\n\r\n\tif(withScript or withScript == nil) then --Include JavaScript script from file\r\n\t\tresult = result .. getGraph()\r\n\tend\r\n\r\n\t--Create graph object in JavaScript with specified data and closing HTML script tag\r\n\tresult = result .. \"Highcharts.chart('\" .. div .. \"', {\" ..\r\n        \"chart: { plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false, type: 'pie' },\" ..\r\n        \"title: { text: '\" .. title .. \"' },\" ..\r\n        \"tooltip: { formatter: function() { return '<b>' + this.point.name + '</b>: ' + this.y + ' lines'; } },\" ..\r\n        \"plotOptions: { pie: { allowPointSelect: true, cursor: 'pointer',\" ..\r\n            \"dataLabels: { enabled: true }, showInLegend: true } },\" ..\r\n        \"series: [{ type: 'pie', name: 'Lines', colorByPoint: true,\" ..\r\n\t\t\t\"data: [\" .. data .. \"]}]});</script>\"\r\n\r\n\treturn result\r\n\r\nend",
    "type": "function"
  }, {
    "id": 34,
    "text": "local function getSortedTable(definitions)\r\n\r\n\tlocal letterTable = {}\r\n\tlocal sortedTable = {}\r\n\r\n\tfor _, fun in ipairs(definitions) do --Loop throung functions\r\n\r\n\t\tlocal firstLetter = string.char(string.byte(fun.name)) --Get first letter\r\n\r\n\t\tif(firstLetter ~= \"#\") then\r\n\r\n\t\t\tif (letterTable[firstLetter] == nil) then letterTable[firstLetter] = {} end --If subtable does not exist create one\r\n\t\t\ttable.insert(letterTable[firstLetter], fun) --Add function name to table under starting letter\r\n\r\n\t\tend\r\n\tend\r\n\t\r\n\tfor key in pairs(letterTable) do table.insert(sortedTable, key) end --Add starting letters to letterTable\r\n\ttable.sort(sortedTable)\r\n\r\n\treturn sortedTable, letterTable\r\n\r\nend",
    "type": "function"
  }, {
    "id": 35,
    "text": "local function drawFunctionTree(node, filepath)\r\n\r\n\tlocal result = \"\"\r\n\r\n\tfor _ ,fun in pairs(node.metrics.functiontree) do --Loop throung function trees under project\r\n\r\n\t\tresult = result .. \"<li>\"\r\n\t\t\t\r\n\t\tif (#fun.metrics.functiontree > 0) then --If file contains functions create header with filename\r\n\t\t\tresult = result .. \"<a href='#' class='toggler' onclick='return menu_toggle(this);'>[+]</a>\"\r\n\t\tend\r\n\r\n\t\t--Add functions with links to documentation contained in file\r\n\t\tresult = result .. fun.fcntype .. \"<a href='#|type=fileLink|to=\" .. filepath .. \"|from=functionlist/index.html|#\" .. \"#\" ..\r\n\t\t\t\tfun.name .. \"'>\" .. fun.name .. \"</a><ul style='list-style-type: none;'>\" ..\r\n\t\t\t\tdrawFunctionTree(fun, filepath, fileLink) .. \"</ul></li>\" --Trying to go one level deeper (submodule in module)\r\n\r\n\tend\r\n\r\n\treturn result\r\n\r\nend",
    "type": "function"
  }, {
    "id": 36,
    "text": "local function drawParentTree(parents, prefix)\r\n\r\n\tif(not prefix) then prefix = \"\" end\r\n\r\n\tlocal result = \"\"\r\n\tlocal endTags = \"\"\r\n\r\n\tif(#parents == 0) then\r\n\t\treturn \"\"\r\n\tend\r\n\r\n\tresult = result .. \"<ul class='menulist' style='list-style-type: none;'><li><a href='#' class='toggler' onclick='return parent_toggle(this);'>[+]</a> \" \r\n\t\t\t.. prefix .. \" \" .. parents[#parents] .. \" is nested in:\"\r\n\tendTags = \"</li></ul>\" .. endTags\r\n\r\n\tfor _ ,p in pairs(parents) do --Loop throung parents trees under project\r\n\t\tresult = result .. \"<ul style='list-style-type: none; display:none;'><li> \"\r\n\t\tif(p ~= parents[#parents]) then\r\n\t\t\tresult = result .. \"<a href='#' class='toggler' onclick='return parent_toggle(this);'>[+]</a> \"\r\n\t\tend\r\n\t\tresult = result .. prefix .. \" \" .. p\r\n\t\tendTags = \"</li></ul>\" .. endTags\r\n\tend\r\n\r\n\tresult = result .. endTags\r\n\r\n\treturn result\r\n\r\nend",
    "type": "function"
  }, {
    "id": 37,
    "text": "",
    "type": "function container"
  }, {
    "id": 38,
    "text": "function searchForTagItem(tagname, data)\r\n\tfor j,l in pairs(data) do\r\n\t\tif (l.tag == tagname) then\r\n\t\t\treturn l\t\r\n\t\tend\r\n\tend\r\n\treturn nil\r\nend",
    "type": "function"
  }, {
    "id": 39,
    "text": "for j,l in pairs(data) do\r\n\t\tif (l.tag == tagname) then\r\n\t\t\treturn l\t\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 40,
    "text": "if (l.tag == tagname) then\r\n\t\t\treturn l\t\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 41,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 42,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 43,
    "text": "function searchForTagArray(tagname, data)\r\n\tlocal nodes = {}\r\n\tfor j,l in pairs(data) do\r\n\t\tif (l.tag == tagname) then\r\n\t\t\ttable.insert(nodes, l)\t\r\n\t\tend\r\n\tend\r\n\treturn nodes\r\nend",
    "type": "function"
  }, {
    "id": 44,
    "text": "local nodes = {}",
    "type": "statement:localassign"
  }, {
    "id": 45,
    "text": "for j,l in pairs(data) do\r\n\t\tif (l.tag == tagname) then\r\n\t\t\ttable.insert(nodes, l)\t\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 46,
    "text": "if (l.tag == tagname) then\r\n\t\t\ttable.insert(nodes, l)\t\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 47,
    "text": "table.insert(nodes, l)",
    "type": "statement:functioncall"
  }, {
    "id": 48,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 49,
    "text": "function searchForTagArray_key(key, data)\r\n\tlocal nodes = {}\r\n\tfor j,l in pairs(data) do\r\n\t\tif (l.key == key) then\r\n\t\t\ttable.insert(nodes, l)\t\r\n\t\tend\r\n\tend\r\n\treturn nodes\r\nend",
    "type": "function"
  }, {
    "id": 50,
    "text": "for j,l in pairs(data) do\r\n\t\tif (l.key == key) then\r\n\t\t\ttable.insert(nodes, l)\t\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 51,
    "text": "if (l.key == key) then\r\n\t\t\ttable.insert(nodes, l)\t\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 52,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 53,
    "text": "function searchForTagItem_recursive(tagname, node, maxdepth)\r\n\tif (node == nil) then return nil end\r\n\tlocal j,l\r\n\tif (maxdepth ~= nil) then maxdepth = maxdepth -1 end\r\n\tfor j,l in pairs(node.data) do\r\n\t\tif (l.tag == tagname) then\r\n\t\t\treturn l\r\n\t\telseif (l.data ~= nil) then\r\n\t\t\tif (maxdepth == nil or maxdepth > 0) then\r\n\t\t\t\tlocal tmp = searchForTagItem_recursive(tagname, l, maxdepth)\r\n\t\t\t\tif (tmp ~= nil) then return tmp end\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\treturn nil\r\nend",
    "type": "function"
  }, {
    "id": 54,
    "text": "if (node == nil) then return nil end",
    "type": "statement:if"
  }, {
    "id": 55,
    "text": "local j,l",
    "type": "statement:localassign"
  }, {
    "id": 56,
    "text": "if (maxdepth ~= nil) then maxdepth = maxdepth -1 end",
    "type": "statement:if"
  }, {
    "id": 57,
    "text": "maxdepth = maxdepth -1",
    "type": "statement:assign"
  }, {
    "id": 58,
    "text": "for j,l in pairs(node.data) do\r\n\t\tif (l.tag == tagname) then\r\n\t\t\treturn l\r\n\t\telseif (l.data ~= nil) then\r\n\t\t\tif (maxdepth == nil or maxdepth > 0) then\r\n\t\t\t\tlocal tmp = searchForTagItem_recursive(tagname, l, maxdepth)\r\n\t\t\t\tif (tmp ~= nil) then return tmp end\r\n\t\t\tend\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 59,
    "text": "if (l.tag == tagname) then\r\n\t\t\treturn l\r\n\t\telseif (l.data ~= nil) then\r\n\t\t\tif (maxdepth == nil or maxdepth > 0) then\r\n\t\t\t\tlocal tmp = searchForTagItem_recursive(tagname, l, maxdepth)\r\n\t\t\t\tif (tmp ~= nil) then return tmp end\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 60,
    "text": "if (maxdepth == nil or maxdepth > 0) then\r\n\t\t\t\tlocal tmp = searchForTagItem_recursive(tagname, l, maxdepth)\r\n\t\t\t\tif (tmp ~= nil) then return tmp end\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 61,
    "text": "local tmp = searchForTagItem_recursive(tagname, l, maxdepth)",
    "type": "statement:localassign"
  }, {
    "id": 62,
    "text": "if (tmp ~= nil) then return tmp end",
    "type": "statement:if"
  }, {
    "id": 63,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 64,
    "text": "local function searchForTagArray_recursive_helper(tagname, node, maxdepth, tbl) \t\r\n\tif (maxdepth ~= nil) then \r\n    maxdepth = maxdepth -1 \r\n  end\r\n  \r\n  if (node.data == nil) then\r\n    return tbl\r\n  end\r\n    \r\n  for j,l in pairs(node.data) do\r\n      if (l.tag == tagname) then\r\n        table.insert(tbl or {}, l)\r\n      elseif (l.data ~= nil) then\r\n        if (maxdepth == nil or maxdepth > 0) then\r\n          tbl = searchForTagArray_recursive_helper(tagname, l, maxdepth, tbl)      \r\n        end\r\n      end    \r\n  end\r\n  return tbl\r\nend",
    "type": "function"
  }, {
    "id": 65,
    "text": "if (maxdepth ~= nil) then \r\n    maxdepth = maxdepth -1 \r\n  end",
    "type": "statement:if"
  }, {
    "id": 66,
    "text": "if (node.data == nil) then\r\n    return tbl\r\n  end",
    "type": "statement:if"
  }, {
    "id": 67,
    "text": "for j,l in pairs(node.data) do\r\n      if (l.tag == tagname) then\r\n        table.insert(tbl or {}, l)\r\n      elseif (l.data ~= nil) then\r\n        if (maxdepth == nil or maxdepth > 0) then\r\n          tbl = searchForTagArray_recursive_helper(tagname, l, maxdepth, tbl)      \r\n        end\r\n      end    \r\n  end",
    "type": "statement:genericfor"
  }, {
    "id": 68,
    "text": "if (l.tag == tagname) then\r\n        table.insert(tbl or {}, l)\r\n      elseif (l.data ~= nil) then\r\n        if (maxdepth == nil or maxdepth > 0) then\r\n          tbl = searchForTagArray_recursive_helper(tagname, l, maxdepth, tbl)      \r\n        end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 69,
    "text": "table.insert(tbl or {}, l)",
    "type": "statement:functioncall"
  }, {
    "id": 70,
    "text": "if (maxdepth == nil or maxdepth > 0) then\r\n          tbl = searchForTagArray_recursive_helper(tagname, l, maxdepth, tbl)      \r\n        end",
    "type": "statement:if"
  }, {
    "id": 71,
    "text": "tbl = searchForTagArray_recursive_helper(tagname, l, maxdepth, tbl)",
    "type": "statement:assign"
  }, {
    "id": 72,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 73,
    "text": "function searchForTagArray_recursive(tagname, node, maxdepth)\r\n\tif (node == nil) then \r\n    return nil \r\n  end\r\n   \r\n  local tbl = searchForTagArray_recursive_helper(tagname, node, maxdepth, {})\r\n    \r\n  return tbl;\r\nend",
    "type": "function"
  }, {
    "id": 74,
    "text": "if (node == nil) then \r\n    return nil \r\n  end",
    "type": "statement:if"
  }, {
    "id": 75,
    "text": "local tbl = searchForTagArray_recursive_helper(tagname, node, maxdepth, {})",
    "type": "statement:localassign"
  }, {
    "id": 76,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 77,
    "text": "function getNamesFromNameList(nameList)\r\n\tlocal names = {}\r\n\tfor i,j in pairs(nameList.data) do\r\n\t\tif (j.tag == 'Name' or j.tag == 'Var') then\r\n\t\t\ttable.insert(names, j)\r\n\t\tend\r\n\tend\r\n\treturn names\r\nend",
    "type": "function"
  }, {
    "id": 78,
    "text": "local names = {}",
    "type": "statement:localassign"
  }, {
    "id": 79,
    "text": "for i,j in pairs(nameList.data) do\r\n\t\tif (j.tag == 'Name' or j.tag == 'Var') then\r\n\t\t\ttable.insert(names, j)\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 80,
    "text": "if (j.tag == 'Name' or j.tag == 'Var') then\r\n\t\t\ttable.insert(names, j)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 81,
    "text": "table.insert(names, j)",
    "type": "statement:functioncall"
  }, {
    "id": 82,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 83,
    "text": "function getExpsFromExpsList(expList)\r\n\tlocal names = {}\r\n\tfor i,j in pairs(expList.data) do\r\n\t\tif (j.tag == 'Exp') then\r\n\t\t\ttable.insert(names, j)\r\n\t\tend\r\n\tend\r\n\treturn names\r\nend",
    "type": "function"
  }, {
    "id": 84,
    "text": "for i,j in pairs(expList.data) do\r\n\t\tif (j.tag == 'Exp') then\r\n\t\t\ttable.insert(names, j)\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 85,
    "text": "if (j.tag == 'Exp') then\r\n\t\t\ttable.insert(names, j)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 86,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 87,
    "text": "function getBlockFromFunction(func)\r\n\tlocal block = nil\r\n\tfor k, v in pairs(func.data) do\r\n\t\tif (v.tag == 'FuncBody') then\r\n\t\t\tfor i,j in pairs(v.data) do\r\n\t\t\t\tif (j.tag == 'Block') then\r\n\t\t\t\t\tblock = j\t\r\n\t\t\t\t\tbreak\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tbreak\r\n\t\tend\r\n\tend\t\t\r\n\treturn block\r\nend",
    "type": "function"
  }, {
    "id": 88,
    "text": "local block = nil",
    "type": "statement:localassign"
  }, {
    "id": 89,
    "text": "for k, v in pairs(func.data) do\r\n\t\tif (v.tag == 'FuncBody') then\r\n\t\t\tfor i,j in pairs(v.data) do\r\n\t\t\t\tif (j.tag == 'Block') then\r\n\t\t\t\t\tblock = j\t\r\n\t\t\t\t\tbreak\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tbreak\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 90,
    "text": "if (v.tag == 'FuncBody') then\r\n\t\t\tfor i,j in pairs(v.data) do\r\n\t\t\t\tif (j.tag == 'Block') then\r\n\t\t\t\t\tblock = j\t\r\n\t\t\t\t\tbreak\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tbreak\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 91,
    "text": "for i,j in pairs(v.data) do\r\n\t\t\t\tif (j.tag == 'Block') then\r\n\t\t\t\t\tblock = j\t\r\n\t\t\t\t\tbreak\r\n\t\t\t\tend\r\n\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 92,
    "text": "if (j.tag == 'Block') then\r\n\t\t\t\t\tblock = j\t\r\n\t\t\t\t\tbreak\r\n\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 93,
    "text": "block = j",
    "type": "statement:assign"
  }, {
    "id": 94,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 95,
    "text": "function getComment(node)\r\n\t\r\n\tlocal comment = ''\r\n\tlocal fullIGNORED = ''\r\n\tlocal ignore\r\n\tlocal order = node.order\r\n\tlocal currNode = node\r\n\tlocal comment_table = {}\r\n\tlocal numberOfLines = 0\r\n\t\r\n\twhile (true) do\r\n\t\twhile (order == 1 or order == 0) do\r\n\t\t\tcurrNode = currNode.parent\r\n\t\t\tif (currNode == nil) then return nil end\r\n\t\t\torder = currNode.order\t\t\t\r\n\t\tend\t\r\n\r\n\t\tif (currNode.tag == 'STARTPOINT') then return nil end\r\n\t\r\n\t\torder = order - 1\r\n\r\n\t\twhile (order ~= 0) do\r\n\t\t\tignore = currNode.parent.data[order]\r\n\t\t\tif (ignore.tag == 'IGNORED') then\r\n\t\t\t\tfor k,v in pairs(ignore.data) do\r\n\t\t\t\t\tif (type(v) == 'table') then\r\n\t\t\t\t\t\tif (v.tag == 'COMMENT') then\r\n\t\t\t\t\t\t\tcomment = comment .. v.text .. '\\n'\r\n\t\t\t\t\t\t\tnumberOfLines = numberOfLines + 1\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\tfullIGNORED = fullIGNORED .. v.text\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\torder = order - 1\r\n\t\t\telse\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\tif (order ~= 0) then\r\n\t\t\tbreak\r\n\t\tend\t\r\n\t\t\t\r\n\tend\r\n\t\r\n\tif (comment == '') then comment = nil end\r\n\treturn comment, fullIGNORED,numberOfLines\r\nend",
    "type": "function"
  }, {
    "id": 96,
    "text": "local comment = ''",
    "type": "statement:localassign"
  }, {
    "id": 97,
    "text": "local fullIGNORED = ''",
    "type": "statement:localassign"
  }, {
    "id": 98,
    "text": "local ignore",
    "type": "statement:localassign"
  }, {
    "id": 99,
    "text": "local order = node.order",
    "type": "statement:localassign"
  }, {
    "id": 100,
    "text": "local currNode = node",
    "type": "statement:localassign"
  }, {
    "id": 101,
    "text": "local comment_table = {}",
    "type": "statement:localassign"
  }, {
    "id": 102,
    "text": "local numberOfLines = 0",
    "type": "statement:localassign"
  }, {
    "id": 103,
    "text": "while (true) do\r\n\t\twhile (order == 1 or order == 0) do\r\n\t\t\tcurrNode = currNode.parent\r\n\t\t\tif (currNode == nil) then return nil end\r\n\t\t\torder = currNode.order\t\t\t\r\n\t\tend\t\r\n\r\n\t\tif (currNode.tag == 'STARTPOINT') then return nil end\r\n\t\r\n\t\torder = order - 1\r\n\r\n\t\twhile (order ~= 0) do\r\n\t\t\tignore = currNode.parent.data[order]\r\n\t\t\tif (ignore.tag == 'IGNORED') then\r\n\t\t\t\tfor k,v in pairs(ignore.data) do\r\n\t\t\t\t\tif (type(v) == 'table') then\r\n\t\t\t\t\t\tif (v.tag == 'COMMENT') then\r\n\t\t\t\t\t\t\tcomment = comment .. v.text .. '\\n'\r\n\t\t\t\t\t\t\tnumberOfLines = numberOfLines + 1\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\tfullIGNORED = fullIGNORED .. v.text\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\torder = order - 1\r\n\t\t\telse\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\tif (order ~= 0) then\r\n\t\t\tbreak\r\n\t\tend\t\r\n\t\t\t\r\n\tend",
    "type": "statement:while"
  }, {
    "id": 104,
    "text": "while (order == 1 or order == 0) do\r\n\t\t\tcurrNode = currNode.parent\r\n\t\t\tif (currNode == nil) then return nil end\r\n\t\t\torder = currNode.order\t\t\t\r\n\t\tend",
    "type": "statement:while"
  }, {
    "id": 105,
    "text": "currNode = currNode.parent",
    "type": "statement:assign"
  }, {
    "id": 106,
    "text": "if (currNode == nil) then return nil end",
    "type": "statement:if"
  }, {
    "id": 107,
    "text": "order = currNode.order",
    "type": "statement:assign"
  }, {
    "id": 108,
    "text": "if (currNode.tag == 'STARTPOINT') then return nil end",
    "type": "statement:if"
  }, {
    "id": 109,
    "text": "order = order - 1",
    "type": "statement:assign"
  }, {
    "id": 110,
    "text": "while (order ~= 0) do\r\n\t\t\tignore = currNode.parent.data[order]\r\n\t\t\tif (ignore.tag == 'IGNORED') then\r\n\t\t\t\tfor k,v in pairs(ignore.data) do\r\n\t\t\t\t\tif (type(v) == 'table') then\r\n\t\t\t\t\t\tif (v.tag == 'COMMENT') then\r\n\t\t\t\t\t\t\tcomment = comment .. v.text .. '\\n'\r\n\t\t\t\t\t\t\tnumberOfLines = numberOfLines + 1\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\tfullIGNORED = fullIGNORED .. v.text\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\torder = order - 1\r\n\t\t\telse\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:while"
  }, {
    "id": 111,
    "text": "ignore = currNode.parent.data[order]",
    "type": "statement:assign"
  }, {
    "id": 112,
    "text": "if (ignore.tag == 'IGNORED') then\r\n\t\t\t\tfor k,v in pairs(ignore.data) do\r\n\t\t\t\t\tif (type(v) == 'table') then\r\n\t\t\t\t\t\tif (v.tag == 'COMMENT') then\r\n\t\t\t\t\t\t\tcomment = comment .. v.text .. '\\n'\r\n\t\t\t\t\t\t\tnumberOfLines = numberOfLines + 1\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\tfullIGNORED = fullIGNORED .. v.text\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\torder = order - 1\r\n\t\t\telse\r\n\t\t\t\tbreak\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 113,
    "text": "for k,v in pairs(ignore.data) do\r\n\t\t\t\t\tif (type(v) == 'table') then\r\n\t\t\t\t\t\tif (v.tag == 'COMMENT') then\r\n\t\t\t\t\t\t\tcomment = comment .. v.text .. '\\n'\r\n\t\t\t\t\t\t\tnumberOfLines = numberOfLines + 1\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\tfullIGNORED = fullIGNORED .. v.text\r\n\t\t\t\t\tend\r\n\t\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 114,
    "text": "if (type(v) == 'table') then\r\n\t\t\t\t\t\tif (v.tag == 'COMMENT') then\r\n\t\t\t\t\t\t\tcomment = comment .. v.text .. '\\n'\r\n\t\t\t\t\t\t\tnumberOfLines = numberOfLines + 1\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\tfullIGNORED = fullIGNORED .. v.text\r\n\t\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 115,
    "text": "if (v.tag == 'COMMENT') then\r\n\t\t\t\t\t\t\tcomment = comment .. v.text .. '\\n'\r\n\t\t\t\t\t\t\tnumberOfLines = numberOfLines + 1\r\n\t\t\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 116,
    "text": "comment = comment .. v.text .. '\\n'",
    "type": "statement:assign"
  }, {
    "id": 117,
    "text": "numberOfLines = numberOfLines + 1",
    "type": "statement:assign"
  }, {
    "id": 118,
    "text": "fullIGNORED = fullIGNORED .. v.text",
    "type": "statement:assign"
  }, {
    "id": 119,
    "text": "if (order ~= 0) then\r\n\t\t\tbreak\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 120,
    "text": "if (comment == '') then comment = nil end",
    "type": "statement:if"
  }, {
    "id": 121,
    "text": "comment = nil",
    "type": "statement:assign"
  }, {
    "id": 122,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 123,
    "text": "function compare_functions_by_name(function1, function2)\r\n\treturn function1.name<function2.name\t\r\nend",
    "type": "function"
  }, {
    "id": 124,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 125,
    "text": "function getVariableCommonPoint(node, name)\r\n--\tprint ('looking for', node.nodeid, name)\r\n\tlocal parent = node.parent\r\n\t\r\n\twhile true do \r\n\t\tif parent == nill or parent.parent == nil then return node end\r\n\t\tparent = parent.parent \r\n\t\t\r\n\t\tif parent.tag == 'Block' then\r\n\t\t\tfor localname, occurences in pairs(parent.metrics.blockdata.locals) do\r\n--\t\t\t\tprint ('', occurences[1])\r\n\t\t\t\tif occurences[1] == name then\r\n--\t\t\t\t\tprint ('', 'found', occurences[2][1], occurences[2][1].nodeid, occurences[2][1].text)\r\n\t\t\t\t\tfor k,v in pairs(occurences[2][1]) do\r\n--\t\t\t\t\t\tprint ('','',k,v)\r\n\t\t\t\t\tend\r\n\t\t\t\t\treturn occurences[2][1]\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\t\r\nend",
    "type": "function"
  }, {
    "id": 126,
    "text": "local parent = node.parent",
    "type": "statement:localassign"
  }, {
    "id": 127,
    "text": "while true do \r\n\t\tif parent == nill or parent.parent == nil then return node end\r\n\t\tparent = parent.parent \r\n\t\t\r\n\t\tif parent.tag == 'Block' then\r\n\t\t\tfor localname, occurences in pairs(parent.metrics.blockdata.locals) do\r\n--\t\t\t\tprint ('', occurences[1])\r\n\t\t\t\tif occurences[1] == name then\r\n--\t\t\t\t\tprint ('', 'found', occurences[2][1], occurences[2][1].nodeid, occurences[2][1].text)\r\n\t\t\t\t\tfor k,v in pairs(occurences[2][1]) do\r\n--\t\t\t\t\t\tprint ('','',k,v)\r\n\t\t\t\t\tend\r\n\t\t\t\t\treturn occurences[2][1]\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend",
    "type": "statement:while"
  }, {
    "id": 128,
    "text": "if parent == nill or parent.parent == nil then return node end",
    "type": "statement:if"
  }, {
    "id": 129,
    "text": "parent = parent.parent",
    "type": "statement:assign"
  }, {
    "id": 130,
    "text": "if parent.tag == 'Block' then\r\n\t\t\tfor localname, occurences in pairs(parent.metrics.blockdata.locals) do\r\n--\t\t\t\tprint ('', occurences[1])\r\n\t\t\t\tif occurences[1] == name then\r\n--\t\t\t\t\tprint ('', 'found', occurences[2][1], occurences[2][1].nodeid, occurences[2][1].text)\r\n\t\t\t\t\tfor k,v in pairs(occurences[2][1]) do\r\n--\t\t\t\t\t\tprint ('','',k,v)\r\n\t\t\t\t\tend\r\n\t\t\t\t\treturn occurences[2][1]\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 131,
    "text": "for localname, occurences in pairs(parent.metrics.blockdata.locals) do\r\n--\t\t\t\tprint ('', occurences[1])\r\n\t\t\t\tif occurences[1] == name then\r\n--\t\t\t\t\tprint ('', 'found', occurences[2][1], occurences[2][1].nodeid, occurences[2][1].text)\r\n\t\t\t\t\tfor k,v in pairs(occurences[2][1]) do\r\n--\t\t\t\t\t\tprint ('','',k,v)\r\n\t\t\t\t\tend\r\n\t\t\t\t\treturn occurences[2][1]\r\n\t\t\t\tend\r\n\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 132,
    "text": "if occurences[1] == name then\r\n--\t\t\t\t\tprint ('', 'found', occurences[2][1], occurences[2][1].nodeid, occurences[2][1].text)\r\n\t\t\t\t\tfor k,v in pairs(occurences[2][1]) do\r\n--\t\t\t\t\t\tprint ('','',k,v)\r\n\t\t\t\t\tend\r\n\t\t\t\t\treturn occurences[2][1]\r\n\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 133,
    "text": "for k,v in pairs(occurences[2][1]) do\r\n--\t\t\t\t\t\tprint ('','',k,v)\r\n\t\t\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 134,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 135,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 136,
    "text": "module",
    "type": "global function"
  }, {
    "id": 137,
    "text": "type",
    "type": "global function"
  }, {
    "id": 138,
    "text": "insert",
    "type": "global function"
  }, {
    "id": 139,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 140,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 141,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 142,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 143,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 144,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 145,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 146,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 147,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 148,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 149,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 150,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 151,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 152,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 153,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 154,
    "text": "",
    "type": "variable container"
  }, {
    "id": 155,
    "text": "",
    "type": "require container"
  }, {
    "id": 156,
    "text": "",
    "type": "interface container"
  }, {
    "id": 157,
    "text": "",
    "type": "interface"
  }, {
    "id": 158,
    "text": "",
    "type": "interface"
  }, {
    "id": 159,
    "text": "",
    "type": "interface"
  }, {
    "id": 160,
    "text": "",
    "type": "interface"
  }, {
    "id": 161,
    "text": "",
    "type": "interface"
  }, {
    "id": 162,
    "text": "",
    "type": "interface"
  }, {
    "id": 163,
    "text": "",
    "type": "interface"
  }, {
    "id": 164,
    "text": "",
    "type": "interface"
  }, {
    "id": 165,
    "text": "",
    "type": "interface"
  }, {
    "id": 166,
    "text": "",
    "type": "interface"
  }, {
    "id": 167,
    "text": "",
    "type": "interface"
  }, {
    "id": 168,
    "text": "",
    "type": "interface"
  }, {
    "id": 169,
    "text": "",
    "type": "interface"
  }, {
    "id": 170,
    "text": "",
    "type": "variable container"
  }, {
    "id": 171,
    "text": "",
    "type": "require container"
  }, {
    "id": 172,
    "text": "",
    "type": "local variable"
  }, {
    "id": 173,
    "text": "",
    "type": "n/a"
  }, {
    "id": 174,
    "text": "",
    "type": "local variable"
  }, {
    "id": 175,
    "text": "",
    "type": "n/a"
  }, {
    "id": 176,
    "text": "",
    "type": "local variable"
  }, {
    "id": 177,
    "text": "",
    "type": "n/a"
  } ]
}