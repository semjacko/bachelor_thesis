{
  "_filename": "serialize.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": true,
  "_path": "modules/lua-apr/test/serialize.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 1,
    "label": "contains",
    "to": 9
  }, {
    "from": 9,
    "label": "declares",
    "to": 2
  }, {
    "from": 9,
    "label": "declares",
    "to": 3
  }, {
    "from": 9,
    "label": "declares",
    "to": 4
  }, {
    "from": 9,
    "label": "declares",
    "to": 5
  }, {
    "from": 9,
    "label": "declares",
    "to": 6
  }, {
    "from": 9,
    "label": "declares",
    "to": 7
  }, {
    "from": 9,
    "label": "declares",
    "to": 8
  }, {
    "from": 10,
    "label": "has",
    "to": 11
  }, {
    "from": 10,
    "label": "has",
    "to": 12
  }, {
    "from": 10,
    "label": "has",
    "to": 13
  }, {
    "from": 10,
    "label": "has",
    "to": 14
  }, {
    "from": 10,
    "label": "has",
    "to": 15
  }, {
    "from": 10,
    "label": "has",
    "to": 16
  }, {
    "from": 10,
    "label": "has",
    "to": 17
  }, {
    "from": 10,
    "label": "has",
    "to": 18
  }, {
    "from": 10,
    "label": "has",
    "to": 19
  }, {
    "from": 10,
    "label": "has",
    "to": 20
  }, {
    "from": 10,
    "label": "has",
    "to": 21
  }, {
    "from": 10,
    "label": "has",
    "to": 22
  }, {
    "from": 10,
    "label": "has",
    "to": 23
  }, {
    "from": 10,
    "label": "has",
    "to": 24
  }, {
    "from": 10,
    "label": "has",
    "to": 25
  }, {
    "from": 10,
    "label": "has",
    "to": 26
  }, {
    "from": 10,
    "label": "has",
    "to": 27
  }, {
    "from": 10,
    "label": "has",
    "to": 28
  }, {
    "from": 10,
    "label": "has",
    "to": 29
  }, {
    "from": 10,
    "label": "has",
    "to": 30
  }, {
    "from": 10,
    "label": "has",
    "to": 31
  }, {
    "from": 10,
    "label": "has",
    "to": 32
  }, {
    "from": 32,
    "label": "has",
    "to": 33
  }, {
    "from": 10,
    "label": "has",
    "to": 34
  }, {
    "from": 10,
    "label": "has",
    "to": 35
  }, {
    "from": 35,
    "label": "has",
    "to": 33
  }, {
    "from": 10,
    "label": "has",
    "to": 36
  }, {
    "from": 10,
    "label": "has",
    "to": 37
  }, {
    "from": 37,
    "label": "has",
    "to": 33
  }, {
    "from": 10,
    "label": "has",
    "to": 38
  }, {
    "from": 10,
    "label": "has",
    "to": 39
  }, {
    "from": 10,
    "label": "has",
    "to": 40
  }, {
    "from": 40,
    "label": "has",
    "to": 33
  }, {
    "from": 10,
    "label": "has",
    "to": 41
  }, {
    "from": 10,
    "label": "has",
    "to": 42
  }, {
    "from": 10,
    "label": "has",
    "to": 43
  }, {
    "from": 10,
    "label": "has",
    "to": 44
  }, {
    "from": 10,
    "label": "has",
    "to": 45
  }, {
    "from": 46,
    "label": "has",
    "to": 33
  }, {
    "from": 46,
    "label": "has",
    "to": 47
  }, {
    "from": 48,
    "label": "has",
    "to": 33
  }, {
    "from": 48,
    "label": "has",
    "to": 49
  }, {
    "from": 50,
    "label": "has",
    "to": 51
  }, {
    "from": 50,
    "label": "has",
    "to": 33
  }, {
    "from": 50,
    "label": "has",
    "to": 52
  }, {
    "from": 50,
    "label": "has",
    "to": 53
  }, {
    "from": 50,
    "label": "has",
    "to": 33
  }, {
    "from": 50,
    "label": "has",
    "to": 54
  }, {
    "from": 50,
    "label": "has",
    "to": 33
  }, {
    "from": 50,
    "label": "has",
    "to": 55
  }, {
    "from": 50,
    "label": "has",
    "to": 33
  }, {
    "from": 50,
    "label": "has",
    "to": 56
  }, {
    "from": 56,
    "label": "has",
    "to": 57
  }, {
    "from": 50,
    "label": "has",
    "to": 33
  }, {
    "from": 50,
    "label": "has",
    "to": 58
  }, {
    "from": 58,
    "label": "has",
    "to": 59
  }, {
    "from": 50,
    "label": "has",
    "to": 33
  }, {
    "from": 50,
    "label": "has",
    "to": 33
  }, {
    "from": 50,
    "label": "has",
    "to": 60
  }, {
    "from": 61,
    "label": "has",
    "to": 33
  }, {
    "from": 62,
    "label": "has",
    "to": 33
  }, {
    "from": 63,
    "label": "has",
    "to": 33
  }, {
    "from": 64,
    "label": "has",
    "to": 33
  }, {
    "from": 9,
    "label": "calls",
    "to": 69
  }, {
    "from": 9,
    "label": "calls",
    "to": 69
  }, {
    "from": 10,
    "label": "calls",
    "to": 66
  }, {
    "from": 10,
    "label": "calls",
    "to": 66
  }, {
    "from": 48,
    "label": "calls",
    "to": 66
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 10,
    "label": "calls",
    "to": 68
  }, {
    "from": 50,
    "label": "calls",
    "to": 72
  }, {
    "from": 50,
    "label": "calls",
    "to": 72
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 48
  }, {
    "from": 10,
    "label": "calls",
    "to": 65
  }, {
    "from": 10,
    "label": "calls",
    "to": 65
  }, {
    "from": 48,
    "label": "calls",
    "to": 65
  }, {
    "from": 9,
    "label": "calls",
    "to": 75
  }, {
    "from": 48,
    "label": "calls",
    "to": 50
  }, {
    "from": 50,
    "label": "calls",
    "to": 50
  }, {
    "from": 50,
    "label": "calls",
    "to": 50
  }, {
    "from": 50,
    "label": "calls",
    "to": 50
  }, {
    "from": 50,
    "label": "calls",
    "to": 73
  }, {
    "from": 50,
    "label": "calls",
    "to": 73
  }, {
    "from": 46,
    "label": "calls",
    "to": 74
  }, {
    "from": 50,
    "label": "calls",
    "to": 71
  }, {
    "from": 9,
    "label": "calls",
    "to": 10
  }, {
    "from": 10,
    "label": "calls",
    "to": 67
  }, {
    "from": 50,
    "label": "calls",
    "to": 70
  }, {
    "from": 48,
    "label": "calls",
    "to": 46
  }, {
    "from": 48,
    "label": "calls",
    "to": 46
  }, {
    "from": 50,
    "label": "calls",
    "to": 46
  }, {
    "from": 50,
    "label": "calls",
    "to": 46
  }, {
    "from": 9,
    "label": "declares",
    "to": 10
  }, {
    "from": 9,
    "label": "declares",
    "to": 46
  }, {
    "from": 9,
    "label": "declares",
    "to": 48
  }, {
    "from": 9,
    "label": "declares",
    "to": 50
  }, {
    "from": 9,
    "label": "declares",
    "to": 61
  }, {
    "from": 9,
    "label": "declares",
    "to": 62
  }, {
    "from": 9,
    "label": "declares",
    "to": 63
  }, {
    "from": 9,
    "label": "declares",
    "to": 64
  }, {
    "from": 1,
    "label": "contains",
    "to": 76
  }, {
    "from": 1,
    "label": "contains",
    "to": 77
  }, {
    "from": 76,
    "label": "initializes",
    "to": 78
  }, {
    "from": 77,
    "label": "initializes",
    "to": 79
  }, {
    "from": 1,
    "label": "provides",
    "to": 80
  }, {
    "from": 80,
    "label": "provides",
    "to": 81
  }, {
    "from": 1,
    "label": "contains",
    "to": 82
  }, {
    "from": 1,
    "label": "contains",
    "to": 83
  }, {
    "from": 82,
    "label": "initializes",
    "to": 84
  }, {
    "from": 84,
    "label": "assigns",
    "to": 85
  }, {
    "from": 82,
    "label": "initializes",
    "to": 86
  }, {
    "from": 32,
    "label": "hasArgument",
    "to": 61
  }, {
    "from": 35,
    "label": "hasArgument",
    "to": 62
  }, {
    "from": 37,
    "label": "hasArgument",
    "to": 63
  }, {
    "from": 40,
    "label": "hasArgument",
    "to": 64
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "serialize",
    "type": "module"
  }, {
    "id": 2,
    "text": "local function serialize(x)\r\n\r\n  local gensym_max = 0  -- index of the gensym() symbol generator\r\n  local seen_once = {} -- element->true set of elements seen exactly once in the table\r\n  local multiple = {} -- element->varname set of elements seen more than once\r\n  local nested = {} -- transient, set of elements currently being traversed\r\n  local nest_points = {}\r\n  local nest_patches = {}\r\n\r\n  -- Generate fresh indexes to store new sub-tables:\r\n  local function gensym()\r\n    gensym_max = gensym_max + 1\r\n    return gensym_max\r\n  end\r\n\r\n  -----------------------------------------------------------------------------\r\n  -- `nest_points' are places where a (recursive) table appears within\r\n  -- itself, directly or not.  for instance, all of these chunks\r\n  -- create nest points in table `x':\r\n  --\r\n  -- \"x = {}; x[x] = 1\"\r\n  -- \"x = {}; x[1] = x\"\r\n  -- \"x = {}; x[1] = { y = { x } }\".\r\n  --\r\n  -- To handle those, two tables are created by `mark_nest_point()':\r\n  --\r\n  -- * `nest_points[parent]' associates all keys and values in table\r\n  --   parent which create a nest_point with boolean `true'\r\n  --\r\n  -- * `nest_patches' contains a list of `{ parent, key, value }'\r\n  --   tuples creating a nest point. They're all dumped after all the\r\n  --   other table operations have been performed.\r\n  --\r\n  -- `mark_nest_point(p, k, v)' fills tables `nest_points' and\r\n  -- `nest_patches' with information required to remember that\r\n  -- key/value `(k,v)' creates a nest point in parent table `p'.\r\n  -- It also marks `p' as occurring multiple times, since several\r\n  -- references to it will be required in order to patch the nest\r\n  -- points.\r\n  -----------------------------------------------------------------------------\r\n  local function mark_nest_point(parent, k, v)\r\n    local nk, nv = nested[k], nested[v]\r\n    assert(not nk or seen_once[k] or multiple[k])\r\n    assert(not nv or seen_once[v] or multiple[v])\r\n    local parent_np = nest_points[parent]\r\n    if not parent_np then\r\n      parent_np = {}\r\n      nest_points[parent] = parent_np\r\n    end\r\n    if nk then parent_np[k] = true end\r\n    if nv then parent_np[v] = true end\r\n    table.insert(nest_patches, { parent, k, v })\r\n    seen_once[parent] = nil\r\n    multiple[parent] = true\r\n  end\r\n\r\n  -----------------------------------------------------------------------------\r\n  -- 1st pass, list the tables and functions which appear more than once in `x'\r\n  -----------------------------------------------------------------------------\r\n  local function mark_multiple_occurrences(x)\r\n    local t = type(x)\r\n    if no_identity[t] then\r\n      return\r\n    elseif seen_once[x] then\r\n      seen_once[x] = nil\r\n      multiple[x] = true\r\n    elseif not multiple[x] then\r\n      seen_once[x] = true\r\n    end\r\n    if t == 'table' then\r\n      nested[x] = true\r\n      for k, v in pairs(x) do\r\n        if nested[k] or nested[v] then\r\n          mark_nest_point(x, k, v)\r\n        else\r\n          mark_multiple_occurrences(k)\r\n          mark_multiple_occurrences(v)\r\n        end\r\n      end\r\n      nested[x] = nil\r\n    elseif t == 'function' then\r\n      for i = 1, math.huge do\r\n        local n, v = debug.getupvalue(x, i)\r\n        if n then mark_multiple_occurrences(v) else break end\r\n      end\r\n    end\r\n  end\r\n\r\n  local dumped = {} -- multiply occurring values already dumped in localdefs\r\n  local localdefs = {} -- already dumped local definitions as source code lines\r\n\r\n  -- mutually recursive functions:\r\n  local dump_val, dump_or_ref_val\r\n\r\n  ------------------------------------------------------------------------------\r\n  -- if `x' occurs multiple times, dump the local var rather than the\r\n  -- value. If it's the first time it's dumped, also dump the content\r\n  -- in localdefs.\r\n  ------------------------------------------------------------------------------\r\n  function dump_or_ref_val(x)\r\n    if nested[x] then\r\n      -- placeholder for recursive reference\r\n      return 'false'\r\n    elseif not multiple[x] then\r\n      -- value referenced only once, dump directly\r\n      return dump_val(x)\r\n    else\r\n      local var = dumped[x]\r\n      if var then\r\n        -- already referenced\r\n        return '_[' .. var .. ']'\r\n      else\r\n        -- first occutrence, create and register reference\r\n        local val = dump_val(x)\r\n        var = gensym()\r\n        table.insert(localdefs, '_[' .. var .. '] = ' .. val)\r\n        dumped[x] = var\r\n        return '_[' .. var .. ']'\r\n      end\r\n    end\r\n  end\r\n\r\n  -----------------------------------------------------------------------------\r\n  -- 2nd pass, dump the object; subparts occurring multiple times are dumped\r\n  -- in local variables, which can then be referenced multiple times;\r\n  -- care is taken to dump local vars in an order which respect dependencies.\r\n  -----------------------------------------------------------------------------\r\n  function dump_val(x)\r\n    local t = type(x)\r\n    if x == nil then\r\n      return 'nil'\r\n    elseif t == 'number' then\r\n      return x == math.huge and 'math.huge' or string.format('%.16f', x)\r\n    elseif t == 'string' then\r\n      return string.format('%q', x)\r\n    elseif t == 'boolean' then\r\n      return x and 'true' or 'false'\r\n    elseif t == 'function' then\r\n      local body = string.format(\"loadstring(%q, '@serialized')\", string.dump(x))\r\n      if not debug.getupvalue(x, 1) then return body end\r\n      local acc = {}\r\n      -- FIXME This doesn't actually need an anonymous function, I'm just lazy.\r\n      table.insert(acc, '(function()')\r\n      table.insert(acc, 'local f = ' .. body)\r\n      for i = 1, math.huge do\r\n        local n, v = debug.getupvalue(x, i)\r\n        if not n then break end\r\n        table.insert(acc, string.format('debug.setupvalue(f, %i, %s)', i, dump_or_ref_val(v)))\r\n      end\r\n      table.insert(acc, 'return f')\r\n      table.insert(acc, 'end)()')\r\n      return table.concat(acc, '\\n')\r\n    elseif t == 'table' then\r\n      local acc = {}\r\n      local idx_dumped = {}\r\n      local np = nest_points[x]\r\n      for i, v in ipairs(x) do\r\n        if np and np[v] then\r\n          table.insert(acc, 'false') -- placeholder\r\n        else\r\n          table.insert(acc, dump_or_ref_val(v))\r\n        end\r\n        idx_dumped[i] = true\r\n      end\r\n      for k, v in pairs(x) do\r\n        if np and (np[k] or np[v]) then\r\n          --check_multiple(k); check_multiple(v) -- force dumps in localdefs\r\n        elseif not idx_dumped[k] then\r\n          table.insert(acc, '[' .. dump_or_ref_val(k) .. '] = ' .. dump_or_ref_val(v))\r\n        end\r\n      end\r\n      return '{ ' .. table.concat(acc, ', ') .. ' }'\r\n    elseif t == 'userdata' then\r\n      local apr = require 'apr'\r\n      return string.format(\"require('apr').deref(%q)\", apr.ref(x))\r\n    else\r\n      error(\"Can't serialize data of type \" .. t)\r\n    end\r\n  end\r\n\r\n  -- Patch the recursive table entries:\r\n  local function dump_nest_patches()\r\n    for _, entry in ipairs(nest_patches) do\r\n      local p, k, v = unpack(entry)\r\n      assert(multiple[p])\r\n      table.insert(localdefs, dump_or_ref_val(p)\r\n          .. '[' .. dump_or_ref_val(k) .. '] = '\r\n          .. dump_or_ref_val(v) .. ' -- rec')\r\n    end\r\n  end\r\n\r\n  mark_multiple_occurrences(x)\r\n  local toplevel = dump_or_ref_val(x)\r\n  dump_nest_patches()\r\n\r\n  if next(localdefs) then\r\n    -- Dump local vars containing shared or recursive parts,\r\n    -- then the main table using them.\r\n    return 'local _={}\\n' ..\r\n      table.concat(localdefs, '\\n') ..\r\n      '\\nreturn ' .. toplevel\r\n  else\r\n    -- No shared part, straightforward dump:\r\n    return 'return ' .. toplevel\r\n  end\r\n\r\nend",
    "type": "function"
  }, {
    "id": 3,
    "text": "local function gensym()\r\n    gensym_max = gensym_max + 1\r\n    return gensym_max\r\n  end",
    "type": "function"
  }, {
    "id": 4,
    "text": "local function mark_nest_point(parent, k, v)\r\n    local nk, nv = nested[k], nested[v]\r\n    assert(not nk or seen_once[k] or multiple[k])\r\n    assert(not nv or seen_once[v] or multiple[v])\r\n    local parent_np = nest_points[parent]\r\n    if not parent_np then\r\n      parent_np = {}\r\n      nest_points[parent] = parent_np\r\n    end\r\n    if nk then parent_np[k] = true end\r\n    if nv then parent_np[v] = true end\r\n    table.insert(nest_patches, { parent, k, v })\r\n    seen_once[parent] = nil\r\n    multiple[parent] = true\r\n  end",
    "type": "function"
  }, {
    "id": 5,
    "text": "local function mark_multiple_occurrences(x)\r\n    local t = type(x)\r\n    if no_identity[t] then\r\n      return\r\n    elseif seen_once[x] then\r\n      seen_once[x] = nil\r\n      multiple[x] = true\r\n    elseif not multiple[x] then\r\n      seen_once[x] = true\r\n    end\r\n    if t == 'table' then\r\n      nested[x] = true\r\n      for k, v in pairs(x) do\r\n        if nested[k] or nested[v] then\r\n          mark_nest_point(x, k, v)\r\n        else\r\n          mark_multiple_occurrences(k)\r\n          mark_multiple_occurrences(v)\r\n        end\r\n      end\r\n      nested[x] = nil\r\n    elseif t == 'function' then\r\n      for i = 1, math.huge do\r\n        local n, v = debug.getupvalue(x, i)\r\n        if n then mark_multiple_occurrences(v) else break end\r\n      end\r\n    end\r\n  end",
    "type": "function"
  }, {
    "id": 6,
    "text": "function dump_or_ref_val(x)\r\n    if nested[x] then\r\n      -- placeholder for recursive reference\r\n      return 'false'\r\n    elseif not multiple[x] then\r\n      -- value referenced only once, dump directly\r\n      return dump_val(x)\r\n    else\r\n      local var = dumped[x]\r\n      if var then\r\n        -- already referenced\r\n        return '_[' .. var .. ']'\r\n      else\r\n        -- first occutrence, create and register reference\r\n        local val = dump_val(x)\r\n        var = gensym()\r\n        table.insert(localdefs, '_[' .. var .. '] = ' .. val)\r\n        dumped[x] = var\r\n        return '_[' .. var .. ']'\r\n      end\r\n    end\r\n  end",
    "type": "function"
  }, {
    "id": 7,
    "text": "function dump_val(x)\r\n    local t = type(x)\r\n    if x == nil then\r\n      return 'nil'\r\n    elseif t == 'number' then\r\n      return x == math.huge and 'math.huge' or string.format('%.16f', x)\r\n    elseif t == 'string' then\r\n      return string.format('%q', x)\r\n    elseif t == 'boolean' then\r\n      return x and 'true' or 'false'\r\n    elseif t == 'function' then\r\n      local body = string.format(\"loadstring(%q, '@serialized')\", string.dump(x))\r\n      if not debug.getupvalue(x, 1) then return body end\r\n      local acc = {}\r\n      -- FIXME This doesn't actually need an anonymous function, I'm just lazy.\r\n      table.insert(acc, '(function()')\r\n      table.insert(acc, 'local f = ' .. body)\r\n      for i = 1, math.huge do\r\n        local n, v = debug.getupvalue(x, i)\r\n        if not n then break end\r\n        table.insert(acc, string.format('debug.setupvalue(f, %i, %s)', i, dump_or_ref_val(v)))\r\n      end\r\n      table.insert(acc, 'return f')\r\n      table.insert(acc, 'end)()')\r\n      return table.concat(acc, '\\n')\r\n    elseif t == 'table' then\r\n      local acc = {}\r\n      local idx_dumped = {}\r\n      local np = nest_points[x]\r\n      for i, v in ipairs(x) do\r\n        if np and np[v] then\r\n          table.insert(acc, 'false') -- placeholder\r\n        else\r\n          table.insert(acc, dump_or_ref_val(v))\r\n        end\r\n        idx_dumped[i] = true\r\n      end\r\n      for k, v in pairs(x) do\r\n        if np and (np[k] or np[v]) then\r\n          --check_multiple(k); check_multiple(v) -- force dumps in localdefs\r\n        elseif not idx_dumped[k] then\r\n          table.insert(acc, '[' .. dump_or_ref_val(k) .. '] = ' .. dump_or_ref_val(v))\r\n        end\r\n      end\r\n      return '{ ' .. table.concat(acc, ', ') .. ' }'\r\n    elseif t == 'userdata' then\r\n      local apr = require 'apr'\r\n      return string.format(\"require('apr').deref(%q)\", apr.ref(x))\r\n    else\r\n      error(\"Can't serialize data of type \" .. t)\r\n    end\r\n  end",
    "type": "function"
  }, {
    "id": 8,
    "text": "local function dump_nest_patches()\r\n    for _, entry in ipairs(nest_patches) do\r\n      local p, k, v = unpack(entry)\r\n      assert(multiple[p])\r\n      table.insert(localdefs, dump_or_ref_val(p)\r\n          .. '[' .. dump_or_ref_val(k) .. '] = '\r\n          .. dump_or_ref_val(v) .. ' -- rec')\r\n    end\r\n  end",
    "type": "function"
  }, {
    "id": 9,
    "text": "",
    "type": "function container"
  }, {
    "id": 10,
    "text": "function main()\r\n\r\n  -- Test single, scalar values. {{{1\r\n  assert(roundtrip(nil), \"Failed to serialize nil value\")\r\n  assert(roundtrip(true), \"Failed to serialize true value\")\r\n  assert(roundtrip(false), \"Failed to serialize false value\")\r\n  assert(roundtrip(0), \"Failed to serialize number value (0)\")\r\n  assert(roundtrip(1), \"Failed to serialize number value (1)\")\r\n  assert(roundtrip(-1), \"Failed to serialize number value (-1)\")\r\n  assert(roundtrip(math.pi), \"Failed to serialize number value (math.pi)\")\r\n  assert(roundtrip(math.huge), \"Failed to serialize number value (math.huge)\")\r\n  assert(roundtrip(''), \"Failed to serialize empty string\")\r\n  assert(roundtrip('simple'), \"Failed to serialize simple string ('simple')\")\r\n  assert(roundtrip('foo\\nbar\\rbaz\\0qux'), \"Failed to serialize complex string ('foo\\\\nbar\\\\rbaz\\\\0qux')\")\r\n\r\n  -- Test multiple scalar values (a tuple). {{{1\r\n  assert(roundtrip(true, false, nil, 13), \"Failed to serialize tuple with nil value\")\r\n\r\n  -- Test tables (empty, list, dictionary, nested). {{{1\r\n  assert(roundtrip({}), \"Failed to serialize empty table\")\r\n  assert(roundtrip({1, 2, 3, 4, 5}), \"Failed to serialize list like table ({1, 2, 3, 4, 5})\")\r\n  assert(roundtrip({pi=math.pi}), \"Failed to serialize table ({pi=3.14})\")\r\n  assert(roundtrip({nested={42}}), \"Failed to serialize nested table ({nested={42}})\")\r\n\r\n  -- Test tables with cycles. {{{1\r\n  local a, b = {}, {}; a.b, b.a = b, a\r\n  local chunk = apr.serialize(a, b)\r\n  local a2, b2 = apr.unserialize(chunk)\r\n  assert(a2.b == b2 and b2.a == a2)\r\n\r\n  -- Test simple Lua function. {{{1\r\n  assert(roundtrip(function() return 42 end), \"Failed to serialize simple function (return 42)\")\r\n\r\n  -- Test Lua function with scalar upvalue. {{{1\r\n  local simple_upvalue = 42\r\n  assert(roundtrip(function() return simple_upvalue end), \"Failed to serialize function with scalar upvalue\")\r\n\r\n  -- Test Lua function with multiple upvalues. {{{1\r\n  local a, b, c, d = 1, 9, 8, 6\r\n  assert(roundtrip(function() return a, b, c, d end), \"Failed to serialize function with multiple upvalues\")\r\n\r\n  -- Test Lua function with complex upvalues. {{{1\r\n  local nested = {1, 2, 3, 4, 5}\r\n  local complex_upvalue = {pi=math.pi, string=name_of_upvalue, nested=nested}\r\n  assert(roundtrip(function() return nested, complex_upvalue end), \"Failed to serialize function with complex upvalues\")\r\n\r\n  -- Test Lua/APR userdata. {{{1\r\n  local object = apr.pipe_open_stdin()\r\n  local data = apr.serialize(object)\r\n  local result = apr.unserialize(data)\r\n  assert(object == result, \"Failed to preserve userdata identity!\")\r\n\r\nend",
    "type": "function"
  }, {
    "id": 11,
    "text": "assert(roundtrip(nil), \"Failed to serialize nil value\")",
    "type": "statement:functioncall"
  }, {
    "id": 12,
    "text": "assert(roundtrip(true), \"Failed to serialize true value\")",
    "type": "statement:functioncall"
  }, {
    "id": 13,
    "text": "assert(roundtrip(false), \"Failed to serialize false value\")",
    "type": "statement:functioncall"
  }, {
    "id": 14,
    "text": "assert(roundtrip(0), \"Failed to serialize number value (0)\")",
    "type": "statement:functioncall"
  }, {
    "id": 15,
    "text": "assert(roundtrip(1), \"Failed to serialize number value (1)\")",
    "type": "statement:functioncall"
  }, {
    "id": 16,
    "text": "assert(roundtrip(-1), \"Failed to serialize number value (-1)\")",
    "type": "statement:functioncall"
  }, {
    "id": 17,
    "text": "assert(roundtrip(math.pi), \"Failed to serialize number value (math.pi)\")",
    "type": "statement:functioncall"
  }, {
    "id": 18,
    "text": "assert(roundtrip(math.huge), \"Failed to serialize number value (math.huge)\")",
    "type": "statement:functioncall"
  }, {
    "id": 19,
    "text": "assert(roundtrip(''), \"Failed to serialize empty string\")",
    "type": "statement:functioncall"
  }, {
    "id": 20,
    "text": "assert(roundtrip('simple'), \"Failed to serialize simple string ('simple')\")",
    "type": "statement:functioncall"
  }, {
    "id": 21,
    "text": "assert(roundtrip('foo\\nbar\\rbaz\\0qux'), \"Failed to serialize complex string ('foo\\\\nbar\\\\rbaz\\\\0qux')\")",
    "type": "statement:functioncall"
  }, {
    "id": 22,
    "text": "assert(roundtrip(true, false, nil, 13), \"Failed to serialize tuple with nil value\")",
    "type": "statement:functioncall"
  }, {
    "id": 23,
    "text": "assert(roundtrip({}), \"Failed to serialize empty table\")",
    "type": "statement:functioncall"
  }, {
    "id": 24,
    "text": "assert(roundtrip({1, 2, 3, 4, 5}), \"Failed to serialize list like table ({1, 2, 3, 4, 5})\")",
    "type": "statement:functioncall"
  }, {
    "id": 25,
    "text": "assert(roundtrip({pi=math.pi}), \"Failed to serialize table ({pi=3.14})\")",
    "type": "statement:functioncall"
  }, {
    "id": 26,
    "text": "assert(roundtrip({nested={42}}), \"Failed to serialize nested table ({nested={42}})\")",
    "type": "statement:functioncall"
  }, {
    "id": 27,
    "text": "local a, b = {}, {}",
    "type": "statement:localassign"
  }, {
    "id": 28,
    "text": "a.b, b.a = b, a",
    "type": "statement:assign"
  }, {
    "id": 29,
    "text": "local chunk = apr.serialize(a, b)",
    "type": "statement:localassign"
  }, {
    "id": 30,
    "text": "local a2, b2 = apr.unserialize(chunk)",
    "type": "statement:localassign"
  }, {
    "id": 31,
    "text": "assert(a2.b == b2 and b2.a == a2)",
    "type": "statement:functioncall"
  }, {
    "id": 32,
    "text": "assert(roundtrip(function() return 42 end), \"Failed to serialize simple function (return 42)\")",
    "type": "statement:functioncall"
  }, {
    "id": 33,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 34,
    "text": "local simple_upvalue = 42",
    "type": "statement:localassign"
  }, {
    "id": 35,
    "text": "assert(roundtrip(function() return simple_upvalue end), \"Failed to serialize function with scalar upvalue\")",
    "type": "statement:functioncall"
  }, {
    "id": 36,
    "text": "local a, b, c, d = 1, 9, 8, 6",
    "type": "statement:localassign"
  }, {
    "id": 37,
    "text": "assert(roundtrip(function() return a, b, c, d end), \"Failed to serialize function with multiple upvalues\")",
    "type": "statement:functioncall"
  }, {
    "id": 38,
    "text": "local nested = {1, 2, 3, 4, 5}",
    "type": "statement:localassign"
  }, {
    "id": 39,
    "text": "local complex_upvalue = {pi=math.pi, string=name_of_upvalue, nested=nested}",
    "type": "statement:localassign"
  }, {
    "id": 40,
    "text": "assert(roundtrip(function() return nested, complex_upvalue end), \"Failed to serialize function with complex upvalues\")",
    "type": "statement:functioncall"
  }, {
    "id": 41,
    "text": "local object = apr.pipe_open_stdin()",
    "type": "statement:localassign"
  }, {
    "id": 42,
    "text": "local data = apr.serialize(object)",
    "type": "statement:localassign"
  }, {
    "id": 43,
    "text": "local result = apr.unserialize(data)",
    "type": "statement:localassign"
  }, {
    "id": 44,
    "text": "assert(object == result, \"Failed to preserve userdata identity!\")",
    "type": "statement:functioncall"
  }, {
    "id": 45,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 46,
    "text": "function pack(...)\r\n  return { n = select('#', ...), ... }\r\nend",
    "type": "function"
  }, {
    "id": 47,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 48,
    "text": "function roundtrip(...)\r\n  return deepequals(pack(...), pack(apr.unserialize(apr.serialize(...))))\r\nend",
    "type": "function"
  }, {
    "id": 49,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 50,
    "text": "function deepequals(a, b)\r\n  if a == b then return true end\r\n  local at, bt = type(a), type(b)\r\n  if at ~= bt then return false end\r\n  if at == 'function' then\r\n    -- Compare functions based on return values.\r\n    return deepequals(pack(a()), pack(b()))\r\n  end\r\n  if at ~= 'table' then\r\n    -- Everything except functions and tables can be compared literally.\r\n    return a == b\r\n  end\r\n  -- Compare the two tables by iterating the keys of both tables.\r\n  for k, v in pairs(a) do\r\n    if not deepequals(v, b[k]) then\r\n      return false\r\n    end\r\n  end\r\n  for k, v in pairs(b) do\r\n    if not deepequals(v, a[k]) then\r\n      return false\r\n    end\r\n  end\r\n  return true\r\nend",
    "type": "function"
  }, {
    "id": 51,
    "text": "if a == b then return true end",
    "type": "statement:if"
  }, {
    "id": 52,
    "text": "local at, bt = type(a), type(b)",
    "type": "statement:localassign"
  }, {
    "id": 53,
    "text": "if at ~= bt then return false end",
    "type": "statement:if"
  }, {
    "id": 54,
    "text": "if at == 'function' then\r\n    -- Compare functions based on return values.\r\n    return deepequals(pack(a()), pack(b()))\r\n  end",
    "type": "statement:if"
  }, {
    "id": 55,
    "text": "if at ~= 'table' then\r\n    -- Everything except functions and tables can be compared literally.\r\n    return a == b\r\n  end",
    "type": "statement:if"
  }, {
    "id": 56,
    "text": "for k, v in pairs(a) do\r\n    if not deepequals(v, b[k]) then\r\n      return false\r\n    end\r\n  end",
    "type": "statement:genericfor"
  }, {
    "id": 57,
    "text": "if not deepequals(v, b[k]) then\r\n      return false\r\n    end",
    "type": "statement:if"
  }, {
    "id": 58,
    "text": "for k, v in pairs(b) do\r\n    if not deepequals(v, a[k]) then\r\n      return false\r\n    end\r\n  end",
    "type": "statement:genericfor"
  }, {
    "id": 59,
    "text": "if not deepequals(v, a[k]) then\r\n      return false\r\n    end",
    "type": "statement:if"
  }, {
    "id": 60,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 61,
    "text": "function() return 42 end",
    "type": "function"
  }, {
    "id": 62,
    "text": "function() return simple_upvalue end",
    "type": "function"
  }, {
    "id": 63,
    "text": "function() return a, b, c, d end",
    "type": "function"
  }, {
    "id": 64,
    "text": "function() return nested, complex_upvalue end",
    "type": "function"
  }, {
    "id": 65,
    "text": "serialize",
    "type": "global function"
  }, {
    "id": 66,
    "text": "unserialize",
    "type": "global function"
  }, {
    "id": 67,
    "text": "pipe_open_stdin",
    "type": "global function"
  }, {
    "id": 68,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 69,
    "text": "pcall",
    "type": "global function"
  }, {
    "id": 70,
    "text": "a",
    "type": "global function"
  }, {
    "id": 71,
    "text": "b",
    "type": "global function"
  }, {
    "id": 72,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 73,
    "text": "type",
    "type": "global function"
  }, {
    "id": 74,
    "text": "select",
    "type": "global function"
  }, {
    "id": 75,
    "text": "require",
    "type": "global function"
  }, {
    "id": 76,
    "text": "",
    "type": "variable container"
  }, {
    "id": 77,
    "text": "",
    "type": "require container"
  }, {
    "id": 78,
    "text": "",
    "type": "local variable"
  }, {
    "id": 79,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 80,
    "text": "",
    "type": "interface container"
  }, {
    "id": 81,
    "text": "",
    "type": "interface"
  }, {
    "id": 82,
    "text": "",
    "type": "variable container"
  }, {
    "id": 83,
    "text": "",
    "type": "require container"
  }, {
    "id": 84,
    "text": "",
    "type": "local variable"
  }, {
    "id": 85,
    "text": "",
    "type": "n/a"
  }, {
    "id": 86,
    "text": "",
    "type": "local variable"
  } ]
}