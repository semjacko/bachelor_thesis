{
  "_filename": "lanes.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/lanes/src/lanes.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 1
  }, {
    "from": 2,
    "label": "has",
    "to": 3
  }, {
    "from": 2,
    "label": "has",
    "to": 4
  }, {
    "from": 5,
    "label": "has",
    "to": 6
  }, {
    "from": 5,
    "label": "has",
    "to": 3
  }, {
    "from": 5,
    "label": "has",
    "to": 7
  }, {
    "from": 5,
    "label": "has",
    "to": 8
  }, {
    "from": 8,
    "label": "has",
    "to": 9
  }, {
    "from": 5,
    "label": "has",
    "to": 10
  }, {
    "from": 10,
    "label": "has",
    "to": 11
  }, {
    "from": 10,
    "label": "has",
    "to": 12
  }, {
    "from": 10,
    "label": "has",
    "to": 13
  }, {
    "from": 13,
    "label": "has",
    "to": 14
  }, {
    "from": 13,
    "label": "has",
    "to": 15
  }, {
    "from": 10,
    "label": "has",
    "to": 16
  }, {
    "from": 16,
    "label": "has",
    "to": 17
  }, {
    "from": 10,
    "label": "has",
    "to": 18
  }, {
    "from": 5,
    "label": "has",
    "to": 3
  }, {
    "from": 5,
    "label": "has",
    "to": 19
  }, {
    "from": 20,
    "label": "has",
    "to": 21
  }, {
    "from": 20,
    "label": "has",
    "to": 22
  }, {
    "from": 23,
    "label": "has",
    "to": 24
  }, {
    "from": 23,
    "label": "has",
    "to": 3
  }, {
    "from": 23,
    "label": "has",
    "to": 25
  }, {
    "from": 23,
    "label": "has",
    "to": 26
  }, {
    "from": 26,
    "label": "has",
    "to": 27
  }, {
    "from": 23,
    "label": "has",
    "to": 28
  }, {
    "from": 23,
    "label": "has",
    "to": 29
  }, {
    "from": 30,
    "label": "has",
    "to": 31
  }, {
    "from": 30,
    "label": "has",
    "to": 32
  }, {
    "from": 33,
    "label": "has",
    "to": 34
  }, {
    "from": 33,
    "label": "has",
    "to": 35
  }, {
    "from": 33,
    "label": "has",
    "to": 36
  }, {
    "from": 33,
    "label": "has",
    "to": 37
  }, {
    "from": 37,
    "label": "has",
    "to": 38
  }, {
    "from": 33,
    "label": "has",
    "to": 39
  }, {
    "from": 39,
    "label": "has",
    "to": 40
  }, {
    "from": 39,
    "label": "has",
    "to": 41
  }, {
    "from": 39,
    "label": "has",
    "to": 42
  }, {
    "from": 42,
    "label": "has",
    "to": 43
  }, {
    "from": 42,
    "label": "has",
    "to": 44
  }, {
    "from": 44,
    "label": "has",
    "to": 45
  }, {
    "from": 42,
    "label": "has",
    "to": 46
  }, {
    "from": 33,
    "label": "has",
    "to": 47
  }, {
    "from": 33,
    "label": "has",
    "to": 48
  }, {
    "from": 33,
    "label": "has",
    "to": 49
  }, {
    "from": 49,
    "label": "has",
    "to": 50
  }, {
    "from": 33,
    "label": "has",
    "to": 51
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 51,
    "label": "has",
    "to": 53
  }, {
    "from": 53,
    "label": "has",
    "to": 54
  }, {
    "from": 54,
    "label": "has",
    "to": 55
  }, {
    "from": 54,
    "label": "has",
    "to": 56
  }, {
    "from": 54,
    "label": "has",
    "to": 57
  }, {
    "from": 57,
    "label": "has",
    "to": 58
  }, {
    "from": 33,
    "label": "has",
    "to": 59
  }, {
    "from": 59,
    "label": "has",
    "to": 60
  }, {
    "from": 59,
    "label": "has",
    "to": 61
  }, {
    "from": 61,
    "label": "has",
    "to": 62
  }, {
    "from": 61,
    "label": "has",
    "to": 63
  }, {
    "from": 33,
    "label": "has",
    "to": 64
  }, {
    "from": 33,
    "label": "has",
    "to": 3
  }, {
    "from": 33,
    "label": "has",
    "to": 3
  }, {
    "from": 33,
    "label": "has",
    "to": 65
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 68,
    "label": "has",
    "to": 69
  }, {
    "from": 68,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 70,
    "label": "has",
    "to": 72
  }, {
    "from": 72,
    "label": "has",
    "to": 73
  }, {
    "from": 73,
    "label": "has",
    "to": 74
  }, {
    "from": 68,
    "label": "has",
    "to": 3
  }, {
    "from": 68,
    "label": "has",
    "to": 75
  }, {
    "from": 76,
    "label": "has",
    "to": 77
  }, {
    "from": 76,
    "label": "has",
    "to": 78
  }, {
    "from": 76,
    "label": "has",
    "to": 79
  }, {
    "from": 76,
    "label": "has",
    "to": 80
  }, {
    "from": 76,
    "label": "has",
    "to": 81
  }, {
    "from": 76,
    "label": "has",
    "to": 82
  }, {
    "from": 82,
    "label": "has",
    "to": 83
  }, {
    "from": 82,
    "label": "has",
    "to": 84
  }, {
    "from": 76,
    "label": "has",
    "to": 85
  }, {
    "from": 85,
    "label": "has",
    "to": 86
  }, {
    "from": 85,
    "label": "has",
    "to": 87
  }, {
    "from": 85,
    "label": "has",
    "to": 88
  }, {
    "from": 88,
    "label": "has",
    "to": 89
  }, {
    "from": 89,
    "label": "has",
    "to": 90
  }, {
    "from": 85,
    "label": "has",
    "to": 91
  }, {
    "from": 91,
    "label": "has",
    "to": 92
  }, {
    "from": 85,
    "label": "has",
    "to": 93
  }, {
    "from": 85,
    "label": "has",
    "to": 94
  }, {
    "from": 94,
    "label": "has",
    "to": 95
  }, {
    "from": 94,
    "label": "has",
    "to": 96
  }, {
    "from": 85,
    "label": "has",
    "to": 97
  }, {
    "from": 85,
    "label": "has",
    "to": 98
  }, {
    "from": 76,
    "label": "has",
    "to": 99
  }, {
    "from": 100,
    "label": "has",
    "to": 101
  }, {
    "from": 100,
    "label": "has",
    "to": 102
  }, {
    "from": 100,
    "label": "has",
    "to": 103
  }, {
    "from": 103,
    "label": "has",
    "to": 104
  }, {
    "from": 104,
    "label": "has",
    "to": 105
  }, {
    "from": 105,
    "label": "has",
    "to": 106
  }, {
    "from": 105,
    "label": "has",
    "to": 107
  }, {
    "from": 105,
    "label": "has",
    "to": 108
  }, {
    "from": 108,
    "label": "has",
    "to": 109
  }, {
    "from": 108,
    "label": "has",
    "to": 110
  }, {
    "from": 108,
    "label": "has",
    "to": 111
  }, {
    "from": 108,
    "label": "has",
    "to": 112
  }, {
    "from": 112,
    "label": "has",
    "to": 86
  }, {
    "from": 112,
    "label": "has",
    "to": 113
  }, {
    "from": 112,
    "label": "has",
    "to": 114
  }, {
    "from": 114,
    "label": "has",
    "to": 115
  }, {
    "from": 112,
    "label": "has",
    "to": 116
  }, {
    "from": 105,
    "label": "has",
    "to": 117
  }, {
    "from": 117,
    "label": "has",
    "to": 118
  }, {
    "from": 100,
    "label": "has",
    "to": 3
  }, {
    "from": 100,
    "label": "has",
    "to": 119
  }, {
    "from": 120,
    "label": "has",
    "to": 121
  }, {
    "from": 120,
    "label": "has",
    "to": 122
  }, {
    "from": 120,
    "label": "has",
    "to": 123
  }, {
    "from": 120,
    "label": "has",
    "to": 124
  }, {
    "from": 124,
    "label": "has",
    "to": 69
  }, {
    "from": 124,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 70,
    "label": "has",
    "to": 72
  }, {
    "from": 72,
    "label": "has",
    "to": 73
  }, {
    "from": 73,
    "label": "has",
    "to": 74
  }, {
    "from": 124,
    "label": "has",
    "to": 3
  }, {
    "from": 120,
    "label": "has",
    "to": 125
  }, {
    "from": 125,
    "label": "has",
    "to": 77
  }, {
    "from": 125,
    "label": "has",
    "to": 78
  }, {
    "from": 125,
    "label": "has",
    "to": 79
  }, {
    "from": 125,
    "label": "has",
    "to": 80
  }, {
    "from": 125,
    "label": "has",
    "to": 81
  }, {
    "from": 125,
    "label": "has",
    "to": 82
  }, {
    "from": 82,
    "label": "has",
    "to": 83
  }, {
    "from": 82,
    "label": "has",
    "to": 84
  }, {
    "from": 125,
    "label": "has",
    "to": 85
  }, {
    "from": 85,
    "label": "has",
    "to": 86
  }, {
    "from": 85,
    "label": "has",
    "to": 87
  }, {
    "from": 85,
    "label": "has",
    "to": 88
  }, {
    "from": 88,
    "label": "has",
    "to": 89
  }, {
    "from": 89,
    "label": "has",
    "to": 90
  }, {
    "from": 85,
    "label": "has",
    "to": 91
  }, {
    "from": 91,
    "label": "has",
    "to": 92
  }, {
    "from": 85,
    "label": "has",
    "to": 93
  }, {
    "from": 85,
    "label": "has",
    "to": 94
  }, {
    "from": 94,
    "label": "has",
    "to": 95
  }, {
    "from": 94,
    "label": "has",
    "to": 96
  }, {
    "from": 85,
    "label": "has",
    "to": 97
  }, {
    "from": 85,
    "label": "has",
    "to": 98
  }, {
    "from": 120,
    "label": "has",
    "to": 126
  }, {
    "from": 126,
    "label": "has",
    "to": 101
  }, {
    "from": 126,
    "label": "has",
    "to": 102
  }, {
    "from": 126,
    "label": "has",
    "to": 103
  }, {
    "from": 103,
    "label": "has",
    "to": 104
  }, {
    "from": 104,
    "label": "has",
    "to": 105
  }, {
    "from": 105,
    "label": "has",
    "to": 106
  }, {
    "from": 105,
    "label": "has",
    "to": 107
  }, {
    "from": 105,
    "label": "has",
    "to": 108
  }, {
    "from": 108,
    "label": "has",
    "to": 109
  }, {
    "from": 108,
    "label": "has",
    "to": 110
  }, {
    "from": 108,
    "label": "has",
    "to": 111
  }, {
    "from": 108,
    "label": "has",
    "to": 112
  }, {
    "from": 112,
    "label": "has",
    "to": 86
  }, {
    "from": 112,
    "label": "has",
    "to": 113
  }, {
    "from": 112,
    "label": "has",
    "to": 114
  }, {
    "from": 114,
    "label": "has",
    "to": 115
  }, {
    "from": 112,
    "label": "has",
    "to": 116
  }, {
    "from": 105,
    "label": "has",
    "to": 117
  }, {
    "from": 117,
    "label": "has",
    "to": 118
  }, {
    "from": 126,
    "label": "has",
    "to": 3
  }, {
    "from": 120,
    "label": "has",
    "to": 127
  }, {
    "from": 120,
    "label": "has",
    "to": 128
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 129,
    "label": "has",
    "to": 130
  }, {
    "from": 120,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 131,
    "label": "has",
    "to": 133
  }, {
    "from": 131,
    "label": "has",
    "to": 134
  }, {
    "from": 134,
    "label": "has",
    "to": 135
  }, {
    "from": 134,
    "label": "has",
    "to": 136
  }, {
    "from": 136,
    "label": "has",
    "to": 137
  }, {
    "from": 131,
    "label": "has",
    "to": 138
  }, {
    "from": 131,
    "label": "has",
    "to": 139
  }, {
    "from": 139,
    "label": "has",
    "to": 140
  }, {
    "from": 139,
    "label": "has",
    "to": 141
  }, {
    "from": 139,
    "label": "has",
    "to": 142
  }, {
    "from": 139,
    "label": "has",
    "to": 143
  }, {
    "from": 139,
    "label": "has",
    "to": 144
  }, {
    "from": 144,
    "label": "has",
    "to": 145
  }, {
    "from": 144,
    "label": "has",
    "to": 146
  }, {
    "from": 120,
    "label": "has",
    "to": 147
  }, {
    "from": 148,
    "label": "has",
    "to": 149
  }, {
    "from": 149,
    "label": "has",
    "to": 150
  }, {
    "from": 148,
    "label": "has",
    "to": 151
  }, {
    "from": 151,
    "label": "has",
    "to": 152
  }, {
    "from": 151,
    "label": "has",
    "to": 153
  }, {
    "from": 153,
    "label": "has",
    "to": 154
  }, {
    "from": 151,
    "label": "has",
    "to": 155
  }, {
    "from": 148,
    "label": "has",
    "to": 3
  }, {
    "from": 148,
    "label": "has",
    "to": 156
  }, {
    "from": 148,
    "label": "has",
    "to": 157
  }, {
    "from": 148,
    "label": "has",
    "to": 158
  }, {
    "from": 159,
    "label": "has",
    "to": 160
  }, {
    "from": 159,
    "label": "has",
    "to": 161
  }, {
    "from": 159,
    "label": "has",
    "to": 3
  }, {
    "from": 159,
    "label": "has",
    "to": 162
  }, {
    "from": 163,
    "label": "has",
    "to": 164
  }, {
    "from": 163,
    "label": "has",
    "to": 3
  }, {
    "from": 163,
    "label": "has",
    "to": 165
  }, {
    "from": 166,
    "label": "has",
    "to": 167
  }, {
    "from": 166,
    "label": "has",
    "to": 168
  }, {
    "from": 166,
    "label": "has",
    "to": 3
  }, {
    "from": 166,
    "label": "has",
    "to": 3
  }, {
    "from": 166,
    "label": "has",
    "to": 169
  }, {
    "from": 166,
    "label": "has",
    "to": 170
  }, {
    "from": 170,
    "label": "has",
    "to": 171
  }, {
    "from": 166,
    "label": "has",
    "to": 3
  }, {
    "from": 166,
    "label": "has",
    "to": 3
  }, {
    "from": 166,
    "label": "has",
    "to": 169
  }, {
    "from": 166,
    "label": "has",
    "to": 172
  }, {
    "from": 172,
    "label": "has",
    "to": 173
  }, {
    "from": 166,
    "label": "has",
    "to": 3
  }, {
    "from": 166,
    "label": "has",
    "to": 3
  }, {
    "from": 166,
    "label": "has",
    "to": 174
  }, {
    "from": 175,
    "label": "has",
    "to": 176
  }, {
    "from": 175,
    "label": "has",
    "to": 3
  }, {
    "from": 175,
    "label": "has",
    "to": 3
  }, {
    "from": 175,
    "label": "has",
    "to": 177
  }, {
    "from": 175,
    "label": "has",
    "to": 3
  }, {
    "from": 175,
    "label": "has",
    "to": 178
  }, {
    "from": 175,
    "label": "has",
    "to": 179
  }, {
    "from": 179,
    "label": "has",
    "to": 180
  }, {
    "from": 179,
    "label": "has",
    "to": 181
  }, {
    "from": 181,
    "label": "has",
    "to": 182
  }, {
    "from": 175,
    "label": "has",
    "to": 3
  }, {
    "from": 175,
    "label": "has",
    "to": 183
  }, {
    "from": 184,
    "label": "has",
    "to": 185
  }, {
    "from": 186,
    "label": "has",
    "to": 187
  }, {
    "from": 187,
    "label": "has",
    "to": 188
  }, {
    "from": 186,
    "label": "has",
    "to": 189
  }, {
    "from": 186,
    "label": "has",
    "to": 190
  }, {
    "from": 186,
    "label": "has",
    "to": 191
  }, {
    "from": 186,
    "label": "has",
    "to": 192
  }, {
    "from": 186,
    "label": "has",
    "to": 193
  }, {
    "from": 186,
    "label": "has",
    "to": 194
  }, {
    "from": 186,
    "label": "has",
    "to": 195
  }, {
    "from": 186,
    "label": "has",
    "to": 196
  }, {
    "from": 186,
    "label": "has",
    "to": 197
  }, {
    "from": 186,
    "label": "has",
    "to": 198
  }, {
    "from": 198,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 199
  }, {
    "from": 199,
    "label": "has",
    "to": 3
  }, {
    "from": 199,
    "label": "has",
    "to": 3
  }, {
    "from": 199,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 200
  }, {
    "from": 200,
    "label": "has",
    "to": 6
  }, {
    "from": 200,
    "label": "has",
    "to": 3
  }, {
    "from": 200,
    "label": "has",
    "to": 7
  }, {
    "from": 200,
    "label": "has",
    "to": 8
  }, {
    "from": 8,
    "label": "has",
    "to": 9
  }, {
    "from": 200,
    "label": "has",
    "to": 10
  }, {
    "from": 10,
    "label": "has",
    "to": 11
  }, {
    "from": 10,
    "label": "has",
    "to": 12
  }, {
    "from": 10,
    "label": "has",
    "to": 13
  }, {
    "from": 13,
    "label": "has",
    "to": 14
  }, {
    "from": 13,
    "label": "has",
    "to": 15
  }, {
    "from": 10,
    "label": "has",
    "to": 16
  }, {
    "from": 16,
    "label": "has",
    "to": 17
  }, {
    "from": 10,
    "label": "has",
    "to": 18
  }, {
    "from": 200,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 201
  }, {
    "from": 186,
    "label": "has",
    "to": 202
  }, {
    "from": 186,
    "label": "has",
    "to": 203
  }, {
    "from": 186,
    "label": "has",
    "to": 204
  }, {
    "from": 186,
    "label": "has",
    "to": 20
  }, {
    "from": 20,
    "label": "has",
    "to": 21
  }, {
    "from": 186,
    "label": "has",
    "to": 23
  }, {
    "from": 23,
    "label": "has",
    "to": 24
  }, {
    "from": 23,
    "label": "has",
    "to": 3
  }, {
    "from": 23,
    "label": "has",
    "to": 25
  }, {
    "from": 23,
    "label": "has",
    "to": 26
  }, {
    "from": 26,
    "label": "has",
    "to": 27
  }, {
    "from": 23,
    "label": "has",
    "to": 28
  }, {
    "from": 186,
    "label": "has",
    "to": 205
  }, {
    "from": 186,
    "label": "has",
    "to": 206
  }, {
    "from": 206,
    "label": "has",
    "to": 31
  }, {
    "from": 186,
    "label": "has",
    "to": 207
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 207,
    "label": "has",
    "to": 3
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 207,
    "label": "has",
    "to": 3
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 207,
    "label": "has",
    "to": 3
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 207,
    "label": "has",
    "to": 3
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 207,
    "label": "has",
    "to": 3
  }, {
    "from": 207,
    "label": "has",
    "to": 208
  }, {
    "from": 207,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 209
  }, {
    "from": 209,
    "label": "has",
    "to": 34
  }, {
    "from": 209,
    "label": "has",
    "to": 35
  }, {
    "from": 209,
    "label": "has",
    "to": 36
  }, {
    "from": 209,
    "label": "has",
    "to": 37
  }, {
    "from": 37,
    "label": "has",
    "to": 38
  }, {
    "from": 209,
    "label": "has",
    "to": 39
  }, {
    "from": 39,
    "label": "has",
    "to": 40
  }, {
    "from": 39,
    "label": "has",
    "to": 41
  }, {
    "from": 39,
    "label": "has",
    "to": 42
  }, {
    "from": 42,
    "label": "has",
    "to": 43
  }, {
    "from": 42,
    "label": "has",
    "to": 44
  }, {
    "from": 44,
    "label": "has",
    "to": 45
  }, {
    "from": 42,
    "label": "has",
    "to": 46
  }, {
    "from": 209,
    "label": "has",
    "to": 47
  }, {
    "from": 209,
    "label": "has",
    "to": 48
  }, {
    "from": 209,
    "label": "has",
    "to": 49
  }, {
    "from": 49,
    "label": "has",
    "to": 50
  }, {
    "from": 209,
    "label": "has",
    "to": 51
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 51,
    "label": "has",
    "to": 53
  }, {
    "from": 53,
    "label": "has",
    "to": 54
  }, {
    "from": 54,
    "label": "has",
    "to": 55
  }, {
    "from": 54,
    "label": "has",
    "to": 56
  }, {
    "from": 54,
    "label": "has",
    "to": 57
  }, {
    "from": 57,
    "label": "has",
    "to": 58
  }, {
    "from": 209,
    "label": "has",
    "to": 59
  }, {
    "from": 59,
    "label": "has",
    "to": 60
  }, {
    "from": 59,
    "label": "has",
    "to": 61
  }, {
    "from": 61,
    "label": "has",
    "to": 62
  }, {
    "from": 61,
    "label": "has",
    "to": 63
  }, {
    "from": 209,
    "label": "has",
    "to": 64
  }, {
    "from": 209,
    "label": "has",
    "to": 3
  }, {
    "from": 209,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 210
  }, {
    "from": 210,
    "label": "has",
    "to": 67
  }, {
    "from": 186,
    "label": "has",
    "to": 211
  }, {
    "from": 186,
    "label": "has",
    "to": 212
  }, {
    "from": 186,
    "label": "has",
    "to": 213
  }, {
    "from": 213,
    "label": "has",
    "to": 214
  }, {
    "from": 213,
    "label": "has",
    "to": 215
  }, {
    "from": 213,
    "label": "has",
    "to": 216
  }, {
    "from": 213,
    "label": "has",
    "to": 217
  }, {
    "from": 213,
    "label": "has",
    "to": 218
  }, {
    "from": 213,
    "label": "has",
    "to": 219
  }, {
    "from": 213,
    "label": "has",
    "to": 220
  }, {
    "from": 220,
    "label": "has",
    "to": 221
  }, {
    "from": 220,
    "label": "has",
    "to": 222
  }, {
    "from": 220,
    "label": "has",
    "to": 223
  }, {
    "from": 223,
    "label": "has",
    "to": 121
  }, {
    "from": 223,
    "label": "has",
    "to": 122
  }, {
    "from": 223,
    "label": "has",
    "to": 123
  }, {
    "from": 223,
    "label": "has",
    "to": 124
  }, {
    "from": 124,
    "label": "has",
    "to": 69
  }, {
    "from": 124,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 71
  }, {
    "from": 70,
    "label": "has",
    "to": 72
  }, {
    "from": 72,
    "label": "has",
    "to": 73
  }, {
    "from": 73,
    "label": "has",
    "to": 74
  }, {
    "from": 124,
    "label": "has",
    "to": 3
  }, {
    "from": 223,
    "label": "has",
    "to": 125
  }, {
    "from": 125,
    "label": "has",
    "to": 77
  }, {
    "from": 125,
    "label": "has",
    "to": 78
  }, {
    "from": 125,
    "label": "has",
    "to": 79
  }, {
    "from": 125,
    "label": "has",
    "to": 80
  }, {
    "from": 125,
    "label": "has",
    "to": 81
  }, {
    "from": 125,
    "label": "has",
    "to": 82
  }, {
    "from": 82,
    "label": "has",
    "to": 83
  }, {
    "from": 82,
    "label": "has",
    "to": 84
  }, {
    "from": 125,
    "label": "has",
    "to": 85
  }, {
    "from": 85,
    "label": "has",
    "to": 86
  }, {
    "from": 85,
    "label": "has",
    "to": 87
  }, {
    "from": 85,
    "label": "has",
    "to": 88
  }, {
    "from": 88,
    "label": "has",
    "to": 89
  }, {
    "from": 89,
    "label": "has",
    "to": 90
  }, {
    "from": 85,
    "label": "has",
    "to": 91
  }, {
    "from": 91,
    "label": "has",
    "to": 92
  }, {
    "from": 85,
    "label": "has",
    "to": 93
  }, {
    "from": 85,
    "label": "has",
    "to": 94
  }, {
    "from": 94,
    "label": "has",
    "to": 95
  }, {
    "from": 94,
    "label": "has",
    "to": 96
  }, {
    "from": 85,
    "label": "has",
    "to": 97
  }, {
    "from": 85,
    "label": "has",
    "to": 98
  }, {
    "from": 223,
    "label": "has",
    "to": 126
  }, {
    "from": 126,
    "label": "has",
    "to": 101
  }, {
    "from": 126,
    "label": "has",
    "to": 102
  }, {
    "from": 126,
    "label": "has",
    "to": 103
  }, {
    "from": 103,
    "label": "has",
    "to": 104
  }, {
    "from": 104,
    "label": "has",
    "to": 105
  }, {
    "from": 105,
    "label": "has",
    "to": 106
  }, {
    "from": 105,
    "label": "has",
    "to": 107
  }, {
    "from": 105,
    "label": "has",
    "to": 108
  }, {
    "from": 108,
    "label": "has",
    "to": 109
  }, {
    "from": 108,
    "label": "has",
    "to": 110
  }, {
    "from": 108,
    "label": "has",
    "to": 111
  }, {
    "from": 108,
    "label": "has",
    "to": 112
  }, {
    "from": 112,
    "label": "has",
    "to": 86
  }, {
    "from": 112,
    "label": "has",
    "to": 113
  }, {
    "from": 112,
    "label": "has",
    "to": 114
  }, {
    "from": 114,
    "label": "has",
    "to": 115
  }, {
    "from": 112,
    "label": "has",
    "to": 116
  }, {
    "from": 105,
    "label": "has",
    "to": 117
  }, {
    "from": 117,
    "label": "has",
    "to": 118
  }, {
    "from": 126,
    "label": "has",
    "to": 3
  }, {
    "from": 223,
    "label": "has",
    "to": 127
  }, {
    "from": 223,
    "label": "has",
    "to": 128
  }, {
    "from": 128,
    "label": "has",
    "to": 129
  }, {
    "from": 129,
    "label": "has",
    "to": 130
  }, {
    "from": 223,
    "label": "has",
    "to": 131
  }, {
    "from": 131,
    "label": "has",
    "to": 132
  }, {
    "from": 131,
    "label": "has",
    "to": 133
  }, {
    "from": 131,
    "label": "has",
    "to": 134
  }, {
    "from": 134,
    "label": "has",
    "to": 135
  }, {
    "from": 134,
    "label": "has",
    "to": 136
  }, {
    "from": 136,
    "label": "has",
    "to": 137
  }, {
    "from": 131,
    "label": "has",
    "to": 138
  }, {
    "from": 131,
    "label": "has",
    "to": 139
  }, {
    "from": 139,
    "label": "has",
    "to": 140
  }, {
    "from": 139,
    "label": "has",
    "to": 141
  }, {
    "from": 139,
    "label": "has",
    "to": 142
  }, {
    "from": 139,
    "label": "has",
    "to": 143
  }, {
    "from": 139,
    "label": "has",
    "to": 144
  }, {
    "from": 144,
    "label": "has",
    "to": 145
  }, {
    "from": 144,
    "label": "has",
    "to": 146
  }, {
    "from": 220,
    "label": "has",
    "to": 224
  }, {
    "from": 213,
    "label": "has",
    "to": 225
  }, {
    "from": 225,
    "label": "has",
    "to": 149
  }, {
    "from": 149,
    "label": "has",
    "to": 150
  }, {
    "from": 225,
    "label": "has",
    "to": 151
  }, {
    "from": 151,
    "label": "has",
    "to": 152
  }, {
    "from": 151,
    "label": "has",
    "to": 153
  }, {
    "from": 153,
    "label": "has",
    "to": 154
  }, {
    "from": 151,
    "label": "has",
    "to": 155
  }, {
    "from": 225,
    "label": "has",
    "to": 3
  }, {
    "from": 225,
    "label": "has",
    "to": 156
  }, {
    "from": 225,
    "label": "has",
    "to": 157
  }, {
    "from": 213,
    "label": "has",
    "to": 226
  }, {
    "from": 226,
    "label": "has",
    "to": 160
  }, {
    "from": 226,
    "label": "has",
    "to": 161
  }, {
    "from": 226,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 227
  }, {
    "from": 186,
    "label": "has",
    "to": 163
  }, {
    "from": 163,
    "label": "has",
    "to": 164
  }, {
    "from": 163,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 228
  }, {
    "from": 228,
    "label": "has",
    "to": 167
  }, {
    "from": 228,
    "label": "has",
    "to": 168
  }, {
    "from": 228,
    "label": "has",
    "to": 3
  }, {
    "from": 228,
    "label": "has",
    "to": 3
  }, {
    "from": 228,
    "label": "has",
    "to": 169
  }, {
    "from": 228,
    "label": "has",
    "to": 170
  }, {
    "from": 170,
    "label": "has",
    "to": 171
  }, {
    "from": 228,
    "label": "has",
    "to": 3
  }, {
    "from": 228,
    "label": "has",
    "to": 3
  }, {
    "from": 228,
    "label": "has",
    "to": 169
  }, {
    "from": 228,
    "label": "has",
    "to": 172
  }, {
    "from": 172,
    "label": "has",
    "to": 173
  }, {
    "from": 228,
    "label": "has",
    "to": 3
  }, {
    "from": 228,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 229
  }, {
    "from": 229,
    "label": "has",
    "to": 176
  }, {
    "from": 229,
    "label": "has",
    "to": 3
  }, {
    "from": 229,
    "label": "has",
    "to": 3
  }, {
    "from": 229,
    "label": "has",
    "to": 177
  }, {
    "from": 229,
    "label": "has",
    "to": 3
  }, {
    "from": 229,
    "label": "has",
    "to": 178
  }, {
    "from": 229,
    "label": "has",
    "to": 179
  }, {
    "from": 179,
    "label": "has",
    "to": 180
  }, {
    "from": 179,
    "label": "has",
    "to": 181
  }, {
    "from": 181,
    "label": "has",
    "to": 182
  }, {
    "from": 229,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 230
  }, {
    "from": 186,
    "label": "has",
    "to": 231
  }, {
    "from": 186,
    "label": "has",
    "to": 232
  }, {
    "from": 186,
    "label": "has",
    "to": 233
  }, {
    "from": 186,
    "label": "has",
    "to": 234
  }, {
    "from": 186,
    "label": "has",
    "to": 235
  }, {
    "from": 186,
    "label": "has",
    "to": 236
  }, {
    "from": 236,
    "label": "has",
    "to": 185
  }, {
    "from": 186,
    "label": "has",
    "to": 237
  }, {
    "from": 186,
    "label": "has",
    "to": 238
  }, {
    "from": 186,
    "label": "has",
    "to": 239
  }, {
    "from": 186,
    "label": "has",
    "to": 240
  }, {
    "from": 186,
    "label": "has",
    "to": 241
  }, {
    "from": 186,
    "label": "has",
    "to": 242
  }, {
    "from": 186,
    "label": "has",
    "to": 243
  }, {
    "from": 186,
    "label": "has",
    "to": 244
  }, {
    "from": 186,
    "label": "has",
    "to": 3
  }, {
    "from": 186,
    "label": "has",
    "to": 245
  }, {
    "from": 246,
    "label": "has",
    "to": 3
  }, {
    "from": 246,
    "label": "has",
    "to": 247
  }, {
    "from": 248,
    "label": "has",
    "to": 3
  }, {
    "from": 248,
    "label": "has",
    "to": 249
  }, {
    "from": 250,
    "label": "has",
    "to": 3
  }, {
    "from": 250,
    "label": "has",
    "to": 251
  }, {
    "from": 252,
    "label": "has",
    "to": 208
  }, {
    "from": 252,
    "label": "has",
    "to": 3
  }, {
    "from": 252,
    "label": "has",
    "to": 253
  }, {
    "from": 254,
    "label": "has",
    "to": 208
  }, {
    "from": 254,
    "label": "has",
    "to": 3
  }, {
    "from": 254,
    "label": "has",
    "to": 255
  }, {
    "from": 256,
    "label": "has",
    "to": 208
  }, {
    "from": 256,
    "label": "has",
    "to": 3
  }, {
    "from": 256,
    "label": "has",
    "to": 257
  }, {
    "from": 258,
    "label": "has",
    "to": 208
  }, {
    "from": 258,
    "label": "has",
    "to": 3
  }, {
    "from": 258,
    "label": "has",
    "to": 259
  }, {
    "from": 260,
    "label": "has",
    "to": 208
  }, {
    "from": 260,
    "label": "has",
    "to": 3
  }, {
    "from": 260,
    "label": "has",
    "to": 261
  }, {
    "from": 262,
    "label": "has",
    "to": 208
  }, {
    "from": 262,
    "label": "has",
    "to": 3
  }, {
    "from": 262,
    "label": "has",
    "to": 263
  }, {
    "from": 264,
    "label": "has",
    "to": 3
  }, {
    "from": 264,
    "label": "has",
    "to": 265
  }, {
    "from": 266,
    "label": "has",
    "to": 129
  }, {
    "from": 129,
    "label": "has",
    "to": 130
  }, {
    "from": 266,
    "label": "has",
    "to": 267
  }, {
    "from": 268,
    "label": "has",
    "to": 169
  }, {
    "from": 268,
    "label": "has",
    "to": 170
  }, {
    "from": 170,
    "label": "has",
    "to": 171
  }, {
    "from": 268,
    "label": "has",
    "to": 3
  }, {
    "from": 268,
    "label": "has",
    "to": 3
  }, {
    "from": 268,
    "label": "has",
    "to": 269
  }, {
    "from": 270,
    "label": "has",
    "to": 169
  }, {
    "from": 270,
    "label": "has",
    "to": 172
  }, {
    "from": 172,
    "label": "has",
    "to": 173
  }, {
    "from": 270,
    "label": "has",
    "to": 3
  }, {
    "from": 270,
    "label": "has",
    "to": 3
  }, {
    "from": 270,
    "label": "has",
    "to": 271
  }, {
    "from": 272,
    "label": "has",
    "to": 177
  }, {
    "from": 272,
    "label": "has",
    "to": 3
  }, {
    "from": 272,
    "label": "has",
    "to": 178
  }, {
    "from": 272,
    "label": "has",
    "to": 179
  }, {
    "from": 179,
    "label": "has",
    "to": 180
  }, {
    "from": 179,
    "label": "has",
    "to": 181
  }, {
    "from": 181,
    "label": "has",
    "to": 182
  }, {
    "from": 272,
    "label": "has",
    "to": 3
  }, {
    "from": 272,
    "label": "has",
    "to": 273
  }, {
    "from": 274,
    "label": "calls",
    "to": 100
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 309
  }, {
    "from": 274,
    "label": "calls",
    "to": 315
  }, {
    "from": 23,
    "label": "calls",
    "to": 315
  }, {
    "from": 274,
    "label": "calls",
    "to": 315
  }, {
    "from": 274,
    "label": "calls",
    "to": 315
  }, {
    "from": 274,
    "label": "calls",
    "to": 315
  }, {
    "from": 274,
    "label": "calls",
    "to": 315
  }, {
    "from": 274,
    "label": "calls",
    "to": 315
  }, {
    "from": 274,
    "label": "calls",
    "to": 315
  }, {
    "from": 274,
    "label": "calls",
    "to": 315
  }, {
    "from": 274,
    "label": "calls",
    "to": 325
  }, {
    "from": 23,
    "label": "calls",
    "to": 325
  }, {
    "from": 274,
    "label": "calls",
    "to": 325
  }, {
    "from": 274,
    "label": "calls",
    "to": 325
  }, {
    "from": 274,
    "label": "calls",
    "to": 325
  }, {
    "from": 274,
    "label": "calls",
    "to": 325
  }, {
    "from": 274,
    "label": "calls",
    "to": 325
  }, {
    "from": 274,
    "label": "calls",
    "to": 325
  }, {
    "from": 274,
    "label": "calls",
    "to": 68
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 316
  }, {
    "from": 274,
    "label": "calls",
    "to": 76
  }, {
    "from": 274,
    "label": "calls",
    "to": 313
  }, {
    "from": 274,
    "label": "calls",
    "to": 310
  }, {
    "from": 274,
    "label": "calls",
    "to": 312
  }, {
    "from": 274,
    "label": "calls",
    "to": 317
  }, {
    "from": 274,
    "label": "calls",
    "to": 305
  }, {
    "from": 274,
    "label": "calls",
    "to": 311
  }, {
    "from": 274,
    "label": "calls",
    "to": 319
  }, {
    "from": 274,
    "label": "calls",
    "to": 319
  }, {
    "from": 274,
    "label": "calls",
    "to": 320
  }, {
    "from": 274,
    "label": "calls",
    "to": 321
  }, {
    "from": 274,
    "label": "calls",
    "to": 321
  }, {
    "from": 274,
    "label": "calls",
    "to": 321
  }, {
    "from": 274,
    "label": "calls",
    "to": 321
  }, {
    "from": 23,
    "label": "calls",
    "to": 20
  }, {
    "from": 274,
    "label": "calls",
    "to": 20
  }, {
    "from": 274,
    "label": "calls",
    "to": 303
  }, {
    "from": 274,
    "label": "calls",
    "to": 303
  }, {
    "from": 274,
    "label": "calls",
    "to": 323
  }, {
    "from": 274,
    "label": "calls",
    "to": 323
  }, {
    "from": 274,
    "label": "calls",
    "to": 323
  }, {
    "from": 163,
    "label": "calls",
    "to": 163
  }, {
    "from": 274,
    "label": "calls",
    "to": 163
  }, {
    "from": 274,
    "label": "calls",
    "to": 318
  }, {
    "from": 274,
    "label": "calls",
    "to": 322
  }, {
    "from": 274,
    "label": "calls",
    "to": 308
  }, {
    "from": 274,
    "label": "calls",
    "to": 186
  }, {
    "from": 274,
    "label": "calls",
    "to": 33
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 314
  }, {
    "from": 274,
    "label": "calls",
    "to": 324
  }, {
    "from": 274,
    "label": "calls",
    "to": 324
  }, {
    "from": 274,
    "label": "calls",
    "to": 5
  }, {
    "from": 274,
    "label": "calls",
    "to": 30
  }, {
    "from": 274,
    "label": "calls",
    "to": 30
  }, {
    "from": 274,
    "label": "calls",
    "to": 30
  }, {
    "from": 274,
    "label": "calls",
    "to": 30
  }, {
    "from": 274,
    "label": "calls",
    "to": 30
  }, {
    "from": 274,
    "label": "calls",
    "to": 30
  }, {
    "from": 1,
    "label": "contains",
    "to": 274
  }, {
    "from": 274,
    "label": "declares",
    "to": 2
  }, {
    "from": 274,
    "label": "declares",
    "to": 5
  }, {
    "from": 274,
    "label": "declares",
    "to": 20
  }, {
    "from": 274,
    "label": "declares",
    "to": 23
  }, {
    "from": 274,
    "label": "declares",
    "to": 30
  }, {
    "from": 274,
    "label": "declares",
    "to": 33
  }, {
    "from": 274,
    "label": "declares",
    "to": 66
  }, {
    "from": 274,
    "label": "declares",
    "to": 68
  }, {
    "from": 274,
    "label": "declares",
    "to": 76
  }, {
    "from": 274,
    "label": "declares",
    "to": 100
  }, {
    "from": 274,
    "label": "declares",
    "to": 120
  }, {
    "from": 274,
    "label": "declares",
    "to": 148
  }, {
    "from": 274,
    "label": "declares",
    "to": 159
  }, {
    "from": 274,
    "label": "declares",
    "to": 163
  }, {
    "from": 274,
    "label": "declares",
    "to": 166
  }, {
    "from": 274,
    "label": "declares",
    "to": 175
  }, {
    "from": 274,
    "label": "declares",
    "to": 184
  }, {
    "from": 274,
    "label": "declares",
    "to": 186
  }, {
    "from": 274,
    "label": "declares",
    "to": 246
  }, {
    "from": 274,
    "label": "declares",
    "to": 248
  }, {
    "from": 274,
    "label": "declares",
    "to": 250
  }, {
    "from": 274,
    "label": "declares",
    "to": 252
  }, {
    "from": 274,
    "label": "declares",
    "to": 254
  }, {
    "from": 274,
    "label": "declares",
    "to": 256
  }, {
    "from": 274,
    "label": "declares",
    "to": 258
  }, {
    "from": 274,
    "label": "declares",
    "to": 260
  }, {
    "from": 274,
    "label": "declares",
    "to": 262
  }, {
    "from": 274,
    "label": "declares",
    "to": 264
  }, {
    "from": 274,
    "label": "declares",
    "to": 266
  }, {
    "from": 274,
    "label": "declares",
    "to": 268
  }, {
    "from": 274,
    "label": "declares",
    "to": 270
  }, {
    "from": 274,
    "label": "declares",
    "to": 272
  }, {
    "from": 275,
    "label": "calls",
    "to": 33
  }, {
    "from": 276,
    "label": "calls",
    "to": 33
  }, {
    "from": 276,
    "label": "calls",
    "to": 33
  }, {
    "from": 277,
    "label": "calls",
    "to": 175
  }, {
    "from": 278,
    "label": "calls",
    "to": 33
  }, {
    "from": 278,
    "label": "calls",
    "to": 33
  }, {
    "from": 278,
    "label": "calls",
    "to": 33
  }, {
    "from": 279,
    "label": "calls",
    "to": 33
  }, {
    "from": 279,
    "label": "calls",
    "to": 33
  }, {
    "from": 279,
    "label": "calls",
    "to": 33
  }, {
    "from": 279,
    "label": "calls",
    "to": 33
  }, {
    "from": 279,
    "label": "calls",
    "to": 166
  }, {
    "from": 279,
    "label": "calls",
    "to": 166
  }, {
    "from": 279,
    "label": "calls",
    "to": 175
  }, {
    "from": 279,
    "label": "calls",
    "to": 175
  }, {
    "from": 280,
    "label": "calls",
    "to": 33
  }, {
    "from": 280,
    "label": "calls",
    "to": 33
  }, {
    "from": 280,
    "label": "calls",
    "to": 33
  }, {
    "from": 281,
    "label": "calls",
    "to": 33
  }, {
    "from": 282,
    "label": "calls",
    "to": 33
  }, {
    "from": 283,
    "label": "calls",
    "to": 33
  }, {
    "from": 284,
    "label": "calls",
    "to": 175
  }, {
    "from": 285,
    "label": "calls",
    "to": 33
  }, {
    "from": 286,
    "label": "calls",
    "to": 33
  }, {
    "from": 287,
    "label": "calls",
    "to": 33
  }, {
    "from": 288,
    "label": "calls",
    "to": 33
  }, {
    "from": 289,
    "label": "calls",
    "to": 33
  }, {
    "from": 290,
    "label": "calls",
    "to": 33
  }, {
    "from": 291,
    "label": "calls",
    "to": 33
  }, {
    "from": 292,
    "label": "calls",
    "to": 33
  }, {
    "from": 292,
    "label": "calls",
    "to": 33
  }, {
    "from": 293,
    "label": "calls",
    "to": 33
  }, {
    "from": 294,
    "label": "calls",
    "to": 33
  }, {
    "from": 294,
    "label": "calls",
    "to": 33
  }, {
    "from": 294,
    "label": "calls",
    "to": 33
  }, {
    "from": 294,
    "label": "calls",
    "to": 33
  }, {
    "from": 295,
    "label": "calls",
    "to": 33
  }, {
    "from": 295,
    "label": "calls",
    "to": 33
  }, {
    "from": 296,
    "label": "calls",
    "to": 33
  }, {
    "from": 296,
    "label": "calls",
    "to": 33
  }, {
    "from": 297,
    "label": "calls",
    "to": 33
  }, {
    "from": 298,
    "label": "calls",
    "to": 33
  }, {
    "from": 299,
    "label": "calls",
    "to": 33
  }, {
    "from": 300,
    "label": "calls",
    "to": 33
  }, {
    "from": 301,
    "label": "calls",
    "to": 33
  }, {
    "from": 302,
    "label": "calls",
    "to": 66
  }, {
    "from": 302,
    "label": "calls",
    "to": 66
  }, {
    "from": 302,
    "label": "calls",
    "to": 66
  }, {
    "from": 302,
    "label": "calls",
    "to": 66
  }, {
    "from": 302,
    "label": "calls",
    "to": 159
  }, {
    "from": 1,
    "label": "declares",
    "to": 304
  }, {
    "from": 1,
    "label": "declares",
    "to": 306
  }, {
    "from": 1,
    "label": "declares",
    "to": 307
  }, {
    "from": 1,
    "label": "contains",
    "to": 326
  }, {
    "from": 1,
    "label": "contains",
    "to": 327
  }, {
    "from": 326,
    "label": "initializes",
    "to": 328
  }, {
    "from": 328,
    "label": "assigns",
    "to": 329
  }, {
    "from": 326,
    "label": "initializes",
    "to": 330
  }, {
    "from": 330,
    "label": "assigns",
    "to": 331
  }, {
    "from": 327,
    "label": "initializes",
    "to": 332
  }, {
    "from": 332,
    "label": "requires",
    "to": 333
  }, {
    "from": 1,
    "label": "provides",
    "to": 334
  }, {
    "from": 328,
    "label": "represents",
    "to": 335
  }, {
    "from": 334,
    "label": "provides",
    "to": 335
  }, {
    "from": 336,
    "label": "requires",
    "to": 1
  }, {
    "from": 337,
    "label": "requires",
    "to": 1
  }, {
    "from": 338,
    "label": "requires",
    "to": 1
  }, {
    "from": 339,
    "label": "requires",
    "to": 1
  }, {
    "from": 340,
    "label": "requires",
    "to": 1
  }, {
    "from": 341,
    "label": "requires",
    "to": 1
  }, {
    "from": 342,
    "label": "requires",
    "to": 1
  }, {
    "from": 343,
    "label": "requires",
    "to": 1
  }, {
    "from": 344,
    "label": "requires",
    "to": 1
  }, {
    "from": 345,
    "label": "requires",
    "to": 1
  }, {
    "from": 346,
    "label": "requires",
    "to": 1
  }, {
    "from": 347,
    "label": "requires",
    "to": 1
  }, {
    "from": 348,
    "label": "requires",
    "to": 1
  }, {
    "from": 349,
    "label": "requires",
    "to": 1
  }, {
    "from": 350,
    "label": "requires",
    "to": 1
  }, {
    "from": 351,
    "label": "requires",
    "to": 1
  }, {
    "from": 352,
    "label": "requires",
    "to": 1
  }, {
    "from": 353,
    "label": "requires",
    "to": 1
  }, {
    "from": 354,
    "label": "requires",
    "to": 1
  }, {
    "from": 355,
    "label": "requires",
    "to": 1
  }, {
    "from": 356,
    "label": "requires",
    "to": 1
  }, {
    "from": 357,
    "label": "requires",
    "to": 1
  }, {
    "from": 358,
    "label": "requires",
    "to": 1
  }, {
    "from": 359,
    "label": "requires",
    "to": 1
  }, {
    "from": 360,
    "label": "requires",
    "to": 1
  }, {
    "from": 361,
    "label": "requires",
    "to": 1
  }, {
    "from": 362,
    "label": "requires",
    "to": 1
  }, {
    "from": 363,
    "label": "requires",
    "to": 1
  }, {
    "from": 328,
    "label": "contains",
    "to": 184
  }, {
    "from": 328,
    "label": "contains",
    "to": 186
  }, {
    "from": 128,
    "label": "hasArgument",
    "to": 266
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "lanes",
    "type": "module"
  }, {
    "id": 2,
    "text": "function( val_)\r\n\t\t-- non-'boolean-false' should be 'boolean-true' or nil\r\n\t\treturn val_ and (val_ == true) or true\r\n\tend",
    "type": "function"
  }, {
    "id": 3,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 4,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 5,
    "text": "function( settings_)\r\n\t\tif not settings_ then\r\n\t\t\treturn default_params\r\n\t\tend\r\n\t\t-- make a copy of the table to leave the provided one unchanged, *and* to help ensure it won't change behind our back\r\n\t\tlocal settings = {}\r\n\t\tif type( settings_) ~= \"table\" then\r\n\t\t\terror \"Bad parameter #1 to lanes.configure(), should be a table\"\r\n\t\tend\r\n\t\t-- any setting not present in the provided parameters takes the default value\r\n\t\tfor key, checker in pairs( param_checkers) do\r\n\t\t\tlocal my_param = settings_[key]\r\n\t\t\tlocal param\r\n\t\t\tif my_param ~= nil then\r\n\t\t\t\tparam = my_param\r\n\t\t\telse\r\n\t\t\t\tparam = default_params[key]\r\n\t\t\tend\r\n\t\t\tif not checker( param) then\r\n\t\t\t\terror( \"Bad \" .. key .. \": \" .. tostring( param), 2)\r\n\t\t\tend\r\n\t\t\tsettings[key] = param\r\n\t\tend\r\n\t\treturn settings\r\n\tend",
    "type": "function"
  }, {
    "id": 6,
    "text": "if not settings_ then\r\n\t\t\treturn default_params\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 7,
    "text": "local settings = {}",
    "type": "statement:localassign"
  }, {
    "id": 8,
    "text": "if type( settings_) ~= \"table\" then\r\n\t\t\terror \"Bad parameter #1 to lanes.configure(), should be a table\"\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 9,
    "text": "error \"Bad parameter #1 to lanes.configure(), should be a table\"",
    "type": "statement:functioncall"
  }, {
    "id": 10,
    "text": "for key, checker in pairs( param_checkers) do\r\n\t\t\tlocal my_param = settings_[key]\r\n\t\t\tlocal param\r\n\t\t\tif my_param ~= nil then\r\n\t\t\t\tparam = my_param\r\n\t\t\telse\r\n\t\t\t\tparam = default_params[key]\r\n\t\t\tend\r\n\t\t\tif not checker( param) then\r\n\t\t\t\terror( \"Bad \" .. key .. \": \" .. tostring( param), 2)\r\n\t\t\tend\r\n\t\t\tsettings[key] = param\r\n\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 11,
    "text": "local my_param = settings_[key]",
    "type": "statement:localassign"
  }, {
    "id": 12,
    "text": "local param",
    "type": "statement:localassign"
  }, {
    "id": 13,
    "text": "if my_param ~= nil then\r\n\t\t\t\tparam = my_param\r\n\t\t\telse\r\n\t\t\t\tparam = default_params[key]\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 14,
    "text": "param = my_param",
    "type": "statement:assign"
  }, {
    "id": 15,
    "text": "param = default_params[key]",
    "type": "statement:assign"
  }, {
    "id": 16,
    "text": "if not checker( param) then\r\n\t\t\t\terror( \"Bad \" .. key .. \": \" .. tostring( param), 2)\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 17,
    "text": "error( \"Bad \" .. key .. \": \" .. tostring( param), 2)",
    "type": "statement:functioncall"
  }, {
    "id": 18,
    "text": "settings[key] = param",
    "type": "statement:assign"
  }, {
    "id": 19,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 20,
    "text": "local function WR(str)\r\n    io.stderr:write( str..\"\\n\" )\r\nend",
    "type": "function"
  }, {
    "id": 21,
    "text": "io.stderr:write( str..\"\\n\" )",
    "type": "statement:functioncall"
  }, {
    "id": 22,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 23,
    "text": "local function DUMP( tbl )\r\n    if not tbl then return end\r\n    local str=\"\"\r\n    for k,v in pairs(tbl) do\r\n        str= str..k..\"=\"..tostring(v)..\"\\n\"\r\n    end\r\n    WR(str)\r\nend",
    "type": "function"
  }, {
    "id": 24,
    "text": "if not tbl then return end",
    "type": "statement:if"
  }, {
    "id": 25,
    "text": "local str=\"\"",
    "type": "statement:localassign"
  }, {
    "id": 26,
    "text": "for k,v in pairs(tbl) do\r\n        str= str..k..\"=\"..tostring(v)..\"\\n\"\r\n    end",
    "type": "statement:genericfor"
  }, {
    "id": 27,
    "text": "str= str..k..\"=\"..tostring(v)..\"\\n\"",
    "type": "statement:assign"
  }, {
    "id": 28,
    "text": "WR(str)",
    "type": "statement:functioncall"
  }, {
    "id": 29,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 30,
    "text": "function( name_, tv_, v_)\r\n\terror( \"Bad '\" .. name_ .. \"' option: \" .. tv_ .. \" \" .. string_format( \"%q\", tostring( v_)), 4)\r\nend",
    "type": "function"
  }, {
    "id": 31,
    "text": "error( \"Bad '\" .. name_ .. \"' option: \" .. tv_ .. \" \" .. string_format( \"%q\", tostring( v_)), 4)",
    "type": "statement:functioncall"
  }, {
    "id": 32,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 33,
    "text": "function( ...)\r\n\t-- aggregrate all strings together, separated by \",\" as well as tables\r\n\t-- the strings are a list of libraries to open\r\n\t-- the tables contain the lane options\r\n\tlocal opt = {}\r\n\tlocal libs = nil\r\n\r\n\tlocal n = select( '#', ...)\r\n\r\n\t-- we need at least a function\r\n\tif n == 0 then\r\n\t\terror( \"No parameters!\", 2)\r\n\tend\r\n\r\n\t-- all arguments but the last must be nil, strings, or tables\r\n\tfor i = 1, n - 1 do\r\n\t\tlocal v = select( i, ...)\r\n\t\tlocal tv = type( v)\r\n\t\tif tv == \"string\" then\r\n\t\t\tlibs = libs and libs .. \",\" .. v or v\r\n\t\telseif tv == \"table\" then\r\n\t\t\tfor k, vv in pairs( v) do\r\n\t\t\t\topt[k]= vv\r\n\t\t\tend\r\n\t\telseif v == nil then\r\n\t\t\t-- skip\r\n\t\telse\r\n\t\t\terror( \"Bad parameter \" .. i .. \": \" .. tv .. \" \" .. string_format( \"%q\", tostring( v)), 2)\r\n\t\tend\r\n\tend\r\n\r\n\t-- the last argument should be a function or a string\r\n\tlocal func = select( n, ...)\r\n\tlocal functype = type( func)\r\n\tif functype ~= \"function\" and functype ~= \"string\" then\r\n\t\terror( \"Last parameter not function or string: \" .. functype .. \" \" .. string_format( \"%q\", tostring( func)), 2)\r\n\tend\r\n\r\n\t-- check that the caller only provides reserved library names, and those only once\r\n\t-- \"*\" is a special case that doesn't require individual checking\r\n\tif libs and libs ~= \"*\" then\r\n\t\tlocal found = {}\r\n\t\tfor s in string_gmatch(libs, \"[%a%d.]+\") do\r\n\t\t\tif not valid_libs[s] then\r\n\t\t\t\terror( \"Bad library name: \" .. s, 2)\r\n\t\t\telse\r\n\t\t\t\tfound[s] = (found[s] or 0) + 1\r\n\t\t\t\tif found[s] > 1 then\r\n\t\t\t\t\terror( \"libs specification contains '\" .. s .. \"' more than once\", 2)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\t-- validate that each option is known and properly valued\r\n\tfor k, v in pairs( opt) do\r\n\t\tlocal validator = opt_validators[k]\r\n\t\tif not validator then\r\n\t\t\terror( (type( k) == \"number\" and \"Unkeyed option: \" .. type( v) .. \" \" .. string_format( \"%q\", tostring( v)) or \"Bad '\" .. tostring( k) .. \"' option\"), 2)\r\n\t\telse\r\n\t\t\topt[k] = validator( v)\r\n\t\tend\r\n\tend\r\n\r\n\tlocal cancelstep, priority, globals, package, required, gc_cb = opt.cancelstep, opt.priority, opt.globals, opt.package or package, opt.required, opt.gc_cb\r\n\treturn function( ...)\r\n\t\t-- must pass functions args last else they will be truncated to the first one\r\n\t\treturn core_lane_new( func, libs, cancelstep, priority, globals, package, required, gc_cb, ...)\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 34,
    "text": "local opt = {}",
    "type": "statement:localassign"
  }, {
    "id": 35,
    "text": "local libs = nil",
    "type": "statement:localassign"
  }, {
    "id": 36,
    "text": "local n = select( '#', ...)",
    "type": "statement:localassign"
  }, {
    "id": 37,
    "text": "if n == 0 then\r\n\t\terror( \"No parameters!\", 2)\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 38,
    "text": "error( \"No parameters!\", 2)",
    "type": "statement:functioncall"
  }, {
    "id": 39,
    "text": "for i = 1, n - 1 do\r\n\t\tlocal v = select( i, ...)\r\n\t\tlocal tv = type( v)\r\n\t\tif tv == \"string\" then\r\n\t\t\tlibs = libs and libs .. \",\" .. v or v\r\n\t\telseif tv == \"table\" then\r\n\t\t\tfor k, vv in pairs( v) do\r\n\t\t\t\topt[k]= vv\r\n\t\t\tend\r\n\t\telseif v == nil then\r\n\t\t\t-- skip\r\n\t\telse\r\n\t\t\terror( \"Bad parameter \" .. i .. \": \" .. tv .. \" \" .. string_format( \"%q\", tostring( v)), 2)\r\n\t\tend\r\n\tend",
    "type": "statement:numericfor"
  }, {
    "id": 40,
    "text": "local v = select( i, ...)",
    "type": "statement:localassign"
  }, {
    "id": 41,
    "text": "local tv = type( v)",
    "type": "statement:localassign"
  }, {
    "id": 42,
    "text": "if tv == \"string\" then\r\n\t\t\tlibs = libs and libs .. \",\" .. v or v\r\n\t\telseif tv == \"table\" then\r\n\t\t\tfor k, vv in pairs( v) do\r\n\t\t\t\topt[k]= vv\r\n\t\t\tend\r\n\t\telseif v == nil then\r\n\t\t\t-- skip\r\n\t\telse\r\n\t\t\terror( \"Bad parameter \" .. i .. \": \" .. tv .. \" \" .. string_format( \"%q\", tostring( v)), 2)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 43,
    "text": "libs = libs and libs .. \",\" .. v or v",
    "type": "statement:assign"
  }, {
    "id": 44,
    "text": "for k, vv in pairs( v) do\r\n\t\t\t\topt[k]= vv\r\n\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 45,
    "text": "opt[k]= vv",
    "type": "statement:assign"
  }, {
    "id": 46,
    "text": "error( \"Bad parameter \" .. i .. \": \" .. tv .. \" \" .. string_format( \"%q\", tostring( v)), 2)",
    "type": "statement:functioncall"
  }, {
    "id": 47,
    "text": "local func = select( n, ...)",
    "type": "statement:localassign"
  }, {
    "id": 48,
    "text": "local functype = type( func)",
    "type": "statement:localassign"
  }, {
    "id": 49,
    "text": "if functype ~= \"function\" and functype ~= \"string\" then\r\n\t\terror( \"Last parameter not function or string: \" .. functype .. \" \" .. string_format( \"%q\", tostring( func)), 2)\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 50,
    "text": "error( \"Last parameter not function or string: \" .. functype .. \" \" .. string_format( \"%q\", tostring( func)), 2)",
    "type": "statement:functioncall"
  }, {
    "id": 51,
    "text": "if libs and libs ~= \"*\" then\r\n\t\tlocal found = {}\r\n\t\tfor s in string_gmatch(libs, \"[%a%d.]+\") do\r\n\t\t\tif not valid_libs[s] then\r\n\t\t\t\terror( \"Bad library name: \" .. s, 2)\r\n\t\t\telse\r\n\t\t\t\tfound[s] = (found[s] or 0) + 1\r\n\t\t\t\tif found[s] > 1 then\r\n\t\t\t\t\terror( \"libs specification contains '\" .. s .. \"' more than once\", 2)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 52,
    "text": "local found = {}",
    "type": "statement:localassign"
  }, {
    "id": 53,
    "text": "for s in string_gmatch(libs, \"[%a%d.]+\") do\r\n\t\t\tif not valid_libs[s] then\r\n\t\t\t\terror( \"Bad library name: \" .. s, 2)\r\n\t\t\telse\r\n\t\t\t\tfound[s] = (found[s] or 0) + 1\r\n\t\t\t\tif found[s] > 1 then\r\n\t\t\t\t\terror( \"libs specification contains '\" .. s .. \"' more than once\", 2)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 54,
    "text": "if not valid_libs[s] then\r\n\t\t\t\terror( \"Bad library name: \" .. s, 2)\r\n\t\t\telse\r\n\t\t\t\tfound[s] = (found[s] or 0) + 1\r\n\t\t\t\tif found[s] > 1 then\r\n\t\t\t\t\terror( \"libs specification contains '\" .. s .. \"' more than once\", 2)\r\n\t\t\t\tend\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 55,
    "text": "error( \"Bad library name: \" .. s, 2)",
    "type": "statement:functioncall"
  }, {
    "id": 56,
    "text": "found[s] = (found[s] or 0) + 1",
    "type": "statement:assign"
  }, {
    "id": 57,
    "text": "if found[s] > 1 then\r\n\t\t\t\t\terror( \"libs specification contains '\" .. s .. \"' more than once\", 2)\r\n\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 58,
    "text": "error( \"libs specification contains '\" .. s .. \"' more than once\", 2)",
    "type": "statement:functioncall"
  }, {
    "id": 59,
    "text": "for k, v in pairs( opt) do\r\n\t\tlocal validator = opt_validators[k]\r\n\t\tif not validator then\r\n\t\t\terror( (type( k) == \"number\" and \"Unkeyed option: \" .. type( v) .. \" \" .. string_format( \"%q\", tostring( v)) or \"Bad '\" .. tostring( k) .. \"' option\"), 2)\r\n\t\telse\r\n\t\t\topt[k] = validator( v)\r\n\t\tend\r\n\tend",
    "type": "statement:genericfor"
  }, {
    "id": 60,
    "text": "local validator = opt_validators[k]",
    "type": "statement:localassign"
  }, {
    "id": 61,
    "text": "if not validator then\r\n\t\t\terror( (type( k) == \"number\" and \"Unkeyed option: \" .. type( v) .. \" \" .. string_format( \"%q\", tostring( v)) or \"Bad '\" .. tostring( k) .. \"' option\"), 2)\r\n\t\telse\r\n\t\t\topt[k] = validator( v)\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 62,
    "text": "error( (type( k) == \"number\" and \"Unkeyed option: \" .. type( v) .. \" \" .. string_format( \"%q\", tostring( v)) or \"Bad '\" .. tostring( k) .. \"' option\"), 2)",
    "type": "statement:functioncall"
  }, {
    "id": 63,
    "text": "opt[k] = validator( v)",
    "type": "statement:assign"
  }, {
    "id": 64,
    "text": "local cancelstep, priority, globals, package, required, gc_cb = opt.cancelstep, opt.priority, opt.globals, opt.package or package, opt.required, opt.gc_cb",
    "type": "statement:localassign"
  }, {
    "id": 65,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 66,
    "text": "function() error \"timers are not active\" end",
    "type": "function"
  }, {
    "id": 67,
    "text": "error \"timers are not active\"",
    "type": "statement:functioncall"
  }, {
    "id": 68,
    "text": "function()\r\n\t\t\tlocal r = {}\r\n\t\t\tfor deep, t in pairs( collection) do\r\n\t\t\t\t-- WR( tostring( deep))\r\n\t\t\t\tlocal l = t[deep]\r\n\t\t\t\tfor key, timer_data in pairs( t) do\r\n\t\t\t\t\tif key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn r\r\n\t\tend",
    "type": "function"
  }, {
    "id": 69,
    "text": "local r = {}",
    "type": "statement:localassign"
  }, {
    "id": 70,
    "text": "for deep, t in pairs( collection) do\r\n\t\t\t\t-- WR( tostring( deep))\r\n\t\t\t\tlocal l = t[deep]\r\n\t\t\t\tfor key, timer_data in pairs( t) do\r\n\t\t\t\t\tif key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 71,
    "text": "local l = t[deep]",
    "type": "statement:localassign"
  }, {
    "id": 72,
    "text": "for key, timer_data in pairs( t) do\r\n\t\t\t\t\tif key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend\r\n\t\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 73,
    "text": "if key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 74,
    "text": "table_insert( r, {l, key, timer_data})",
    "type": "statement:functioncall"
  }, {
    "id": 75,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 76,
    "text": "function( linda, key, wakeup_at, period)\r\n\t\t\tassert( wakeup_at == nil or wakeup_at > 0.0)\r\n\t\t\tassert( period == nil or period > 0.0)\r\n\r\n\t\t\tlocal linda_deep = linda:deep()\r\n\t\t\tassert( linda_deep)\r\n\r\n\t\t\t-- Find or make a lookup for this timer\r\n\t\t\t--\r\n\t\t\tlocal t1 = collection[linda_deep]\r\n\t\t\tif not t1 then\r\n\t\t\t\tt1 = { [linda_deep] = linda}     -- proxy to use the Linda\r\n\t\t\t\tcollection[linda_deep] = t1\r\n\t\t\tend\r\n\t\t\r\n\t\t\tif wakeup_at == nil then\r\n\t\t\t\t-- Clear the timer\r\n\t\t\t\t--\r\n\t\t\t\tt1[key]= nil\r\n\r\n\t\t\t\t-- Remove empty tables from collection; speeds timer checks and\r\n\t\t\t\t-- lets our 'safety reference' proxy be gc:ed as well.\r\n\t\t\t\t--\r\n\t\t\t\tlocal empty = true\r\n\t\t\t\tfor k, _ in pairs( t1) do\r\n\t\t\t\t\tif k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif empty then\r\n\t\t\t\t\tcollection[linda_deep] = nil\r\n\t\t\t\tend\r\n\r\n\t\t\t\t-- Note: any unread timer value is left at 'linda[key]' intensionally;\r\n\t\t\t\t--       clearing a timer just stops it.\r\n\t\t\telse\r\n\t\t\t\t-- New timer or changing the timings\r\n\t\t\t\t--\r\n\t\t\t\tlocal t2 = t1[key]\r\n\t\t\t\tif not t2 then\r\n\t\t\t\t\tt2= {}\r\n\t\t\t\t\tt1[key]= t2\r\n\t\t\t\tend\r\n\t\t\r\n\t\t\t\tt2[1] = wakeup_at\r\n\t\t\t\tt2[2] = period   -- can be 'nil'\r\n\t\t\tend\r\n\t\tend",
    "type": "function"
  }, {
    "id": 77,
    "text": "assert( wakeup_at == nil or wakeup_at > 0.0)",
    "type": "statement:functioncall"
  }, {
    "id": 78,
    "text": "assert( period == nil or period > 0.0)",
    "type": "statement:functioncall"
  }, {
    "id": 79,
    "text": "local linda_deep = linda:deep()",
    "type": "statement:localassign"
  }, {
    "id": 80,
    "text": "assert( linda_deep)",
    "type": "statement:functioncall"
  }, {
    "id": 81,
    "text": "local t1 = collection[linda_deep]",
    "type": "statement:localassign"
  }, {
    "id": 82,
    "text": "if not t1 then\r\n\t\t\t\tt1 = { [linda_deep] = linda}     -- proxy to use the Linda\r\n\t\t\t\tcollection[linda_deep] = t1\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 83,
    "text": "t1 = { [linda_deep] = linda}",
    "type": "statement:assign"
  }, {
    "id": 84,
    "text": "collection[linda_deep] = t1",
    "type": "statement:assign"
  }, {
    "id": 85,
    "text": "if wakeup_at == nil then\r\n\t\t\t\t-- Clear the timer\r\n\t\t\t\t--\r\n\t\t\t\tt1[key]= nil\r\n\r\n\t\t\t\t-- Remove empty tables from collection; speeds timer checks and\r\n\t\t\t\t-- lets our 'safety reference' proxy be gc:ed as well.\r\n\t\t\t\t--\r\n\t\t\t\tlocal empty = true\r\n\t\t\t\tfor k, _ in pairs( t1) do\r\n\t\t\t\t\tif k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif empty then\r\n\t\t\t\t\tcollection[linda_deep] = nil\r\n\t\t\t\tend\r\n\r\n\t\t\t\t-- Note: any unread timer value is left at 'linda[key]' intensionally;\r\n\t\t\t\t--       clearing a timer just stops it.\r\n\t\t\telse\r\n\t\t\t\t-- New timer or changing the timings\r\n\t\t\t\t--\r\n\t\t\t\tlocal t2 = t1[key]\r\n\t\t\t\tif not t2 then\r\n\t\t\t\t\tt2= {}\r\n\t\t\t\t\tt1[key]= t2\r\n\t\t\t\tend\r\n\t\t\r\n\t\t\t\tt2[1] = wakeup_at\r\n\t\t\t\tt2[2] = period   -- can be 'nil'\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 86,
    "text": "t1[key]= nil",
    "type": "statement:assign"
  }, {
    "id": 87,
    "text": "local empty = true",
    "type": "statement:localassign"
  }, {
    "id": 88,
    "text": "for k, _ in pairs( t1) do\r\n\t\t\t\t\tif k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 89,
    "text": "if k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 90,
    "text": "empty = false",
    "type": "statement:assign"
  }, {
    "id": 91,
    "text": "if empty then\r\n\t\t\t\t\tcollection[linda_deep] = nil\r\n\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 92,
    "text": "collection[linda_deep] = nil",
    "type": "statement:assign"
  }, {
    "id": 93,
    "text": "local t2 = t1[key]",
    "type": "statement:localassign"
  }, {
    "id": 94,
    "text": "if not t2 then\r\n\t\t\t\t\tt2= {}\r\n\t\t\t\t\tt1[key]= t2\r\n\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 95,
    "text": "t2= {}",
    "type": "statement:assign"
  }, {
    "id": 96,
    "text": "t1[key]= t2",
    "type": "statement:assign"
  }, {
    "id": 97,
    "text": "t2[1] = wakeup_at",
    "type": "statement:assign"
  }, {
    "id": 98,
    "text": "t2[2] = period",
    "type": "statement:assign"
  }, {
    "id": 99,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 100,
    "text": "function()\r\n\t\t\tlocal now = now_secs()\r\n\t\t\tlocal next_wakeup\r\n\r\n\t\t\tfor linda_deep,t1 in pairs(collection) do\r\n\t\t\t\tfor key,t2 in pairs(t1) do\r\n\t\t\t\t\t--\r\n\t\t\t\t\tif key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend\r\n\t\t\t\tend -- t2 loop\r\n\t\t\tend -- t1 loop\r\n\r\n\t\t\treturn next_wakeup  -- may be 'nil'\r\n\t\tend",
    "type": "function"
  }, {
    "id": 101,
    "text": "local now = now_secs()",
    "type": "statement:localassign"
  }, {
    "id": 102,
    "text": "local next_wakeup",
    "type": "statement:localassign"
  }, {
    "id": 103,
    "text": "for linda_deep,t1 in pairs(collection) do\r\n\t\t\t\tfor key,t2 in pairs(t1) do\r\n\t\t\t\t\t--\r\n\t\t\t\t\tif key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend\r\n\t\t\t\tend -- t2 loop\r\n\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 104,
    "text": "for key,t2 in pairs(t1) do\r\n\t\t\t\t\t--\r\n\t\t\t\t\tif key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend\r\n\t\t\t\tend",
    "type": "statement:genericfor"
  }, {
    "id": 105,
    "text": "if key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 106,
    "text": "local wakeup_at= t2[1]",
    "type": "statement:localassign"
  }, {
    "id": 107,
    "text": "local period= t2[2]",
    "type": "statement:localassign"
  }, {
    "id": 108,
    "text": "if wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 109,
    "text": "local linda= t1[linda_deep]",
    "type": "statement:localassign"
  }, {
    "id": 110,
    "text": "assert(linda)",
    "type": "statement:functioncall"
  }, {
    "id": 111,
    "text": "linda:set( key, now )",
    "type": "statement:functioncall"
  }, {
    "id": 112,
    "text": "if not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 113,
    "text": "wakeup_at= nil",
    "type": "statement:assign"
  }, {
    "id": 114,
    "text": "repeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now",
    "type": "statement:repeat"
  }, {
    "id": 115,
    "text": "wakeup_at= wakeup_at+period",
    "type": "statement:assign"
  }, {
    "id": 116,
    "text": "t2[1]= wakeup_at",
    "type": "statement:assign"
  }, {
    "id": 117,
    "text": "if wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 118,
    "text": "next_wakeup= wakeup_at",
    "type": "statement:assign"
  }, {
    "id": 119,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 120,
    "text": "function()\r\n\t\tset_debug_threadname( \"LanesTimer\")\r\n\t\t--\r\n\t\t-- { [deep_linda_lightuserdata]= { [deep_linda_lightuserdata]=linda_h, \r\n\t\t--                                 [key]= { wakeup_secs [,period_secs] } [, ...] },\r\n\t\t-- }\r\n\t\t--\r\n\t\t-- Collection of all running timers, indexed with linda's & key.\r\n\t\t--\r\n\t\t-- Note that we need to use the deep lightuserdata identifiers, instead\r\n\t\t-- of 'linda_h' themselves as table indices. Otherwise, we'd get multiple\r\n\t\t-- entries for the same timer.\r\n\t\t--\r\n\t\t-- The 'hidden' reference to Linda proxy is used in 'check_timers()' but\r\n\t\t-- also important to keep the Linda alive, even if all outside world threw\r\n\t\t-- away pointers to it (which would ruin uniqueness of the deep pointer).\r\n\t\t-- Now we're safe.\r\n\t\t--\r\n\t\tlocal collection = {}\r\n\t\tlocal table_insert = assert( table.insert)\r\n\r\n\t\tlocal get_timers = function()\r\n\t\t\tlocal r = {}\r\n\t\t\tfor deep, t in pairs( collection) do\r\n\t\t\t\t-- WR( tostring( deep))\r\n\t\t\t\tlocal l = t[deep]\r\n\t\t\t\tfor key, timer_data in pairs( t) do\r\n\t\t\t\t\tif key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn r\r\n\t\tend -- get_timers()\r\n\r\n\t\t--\r\n\t\t-- set_timer( linda_h, key [,wakeup_at_secs [,period_secs]] )\r\n\t\t--\r\n\t\tlocal set_timer = function( linda, key, wakeup_at, period)\r\n\t\t\tassert( wakeup_at == nil or wakeup_at > 0.0)\r\n\t\t\tassert( period == nil or period > 0.0)\r\n\r\n\t\t\tlocal linda_deep = linda:deep()\r\n\t\t\tassert( linda_deep)\r\n\r\n\t\t\t-- Find or make a lookup for this timer\r\n\t\t\t--\r\n\t\t\tlocal t1 = collection[linda_deep]\r\n\t\t\tif not t1 then\r\n\t\t\t\tt1 = { [linda_deep] = linda}     -- proxy to use the Linda\r\n\t\t\t\tcollection[linda_deep] = t1\r\n\t\t\tend\r\n\t\t\r\n\t\t\tif wakeup_at == nil then\r\n\t\t\t\t-- Clear the timer\r\n\t\t\t\t--\r\n\t\t\t\tt1[key]= nil\r\n\r\n\t\t\t\t-- Remove empty tables from collection; speeds timer checks and\r\n\t\t\t\t-- lets our 'safety reference' proxy be gc:ed as well.\r\n\t\t\t\t--\r\n\t\t\t\tlocal empty = true\r\n\t\t\t\tfor k, _ in pairs( t1) do\r\n\t\t\t\t\tif k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif empty then\r\n\t\t\t\t\tcollection[linda_deep] = nil\r\n\t\t\t\tend\r\n\r\n\t\t\t\t-- Note: any unread timer value is left at 'linda[key]' intensionally;\r\n\t\t\t\t--       clearing a timer just stops it.\r\n\t\t\telse\r\n\t\t\t\t-- New timer or changing the timings\r\n\t\t\t\t--\r\n\t\t\t\tlocal t2 = t1[key]\r\n\t\t\t\tif not t2 then\r\n\t\t\t\t\tt2= {}\r\n\t\t\t\t\tt1[key]= t2\r\n\t\t\t\tend\r\n\t\t\r\n\t\t\t\tt2[1] = wakeup_at\r\n\t\t\t\tt2[2] = period   -- can be 'nil'\r\n\t\t\tend\r\n\t\tend -- set_timer()\r\n\r\n\t\t-----\r\n\t\t-- [next_wakeup_at]= check_timers()\r\n\t\t-- Check timers, and wake up the ones expired (if any)\r\n\t\t-- Returns the closest upcoming (remaining) wakeup time (or 'nil' if none).\r\n\t\tlocal check_timers = function()\r\n\t\t\tlocal now = now_secs()\r\n\t\t\tlocal next_wakeup\r\n\r\n\t\t\tfor linda_deep,t1 in pairs(collection) do\r\n\t\t\t\tfor key,t2 in pairs(t1) do\r\n\t\t\t\t\t--\r\n\t\t\t\t\tif key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend\r\n\t\t\t\tend -- t2 loop\r\n\t\t\tend -- t1 loop\r\n\r\n\t\t\treturn next_wakeup  -- may be 'nil'\r\n\t\tend -- check_timers()\r\n\r\n\t\tlocal timer_gateway_batched = timer_gateway.batched\r\n\t\tset_finalizer( function( err, stk)\r\n\t\t\tif err and type( err) ~= \"userdata\" then\r\n\t\t\t\tWR( \"LanesTimer error: \"..tostring(err))\r\n\t\t\t--elseif type( err) == \"userdata\" then\r\n\t\t\t--\tWR( \"LanesTimer after cancel\" )\r\n\t\t\t--else\r\n\t\t\t--\tWR(\"LanesTimer finalized\")\r\n\t\t\tend\r\n\t\tend)\r\n\t\twhile true do\r\n\t\t\tlocal next_wakeup = check_timers()\r\n\r\n\t\t\t-- Sleep until next timer to wake up, or a set/clear command\r\n\t\t\t--\r\n\t\t\tlocal secs\r\n\t\t\tif next_wakeup then\r\n\t\t\t\tsecs =  next_wakeup - now_secs()\r\n\t\t\t\tif secs < 0 then secs = 0 end\r\n\t\t\tend\r\n\t\t\tlocal key, what = timer_gateway:receive( secs, TGW_KEY, TGW_QUERY)\r\n\r\n\t\t\tif key == TGW_KEY then\r\n\t\t\t\tassert( getmetatable( what) == \"Linda\") -- 'what' should be a linda on which the client sets a timer\r\n\t\t\t\tlocal _, key, wakeup_at, period = timer_gateway:receive( 0, timer_gateway_batched, TGW_KEY, 3)\r\n\t\t\t\tassert( key)\r\n\t\t\t\tset_timer( what, key, wakeup_at, period and period > 0 and period or nil)\r\n\t\t\telseif key == TGW_QUERY then\r\n\t\t\t\tif what == \"get_timers\" then\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, get_timers())\r\n\t\t\t\telse\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, \"unknown query \" .. what)\r\n\t\t\t\tend\r\n\t\t\t--elseif secs == nil then -- got no value while block-waiting?\r\n\t\t\t--\tWR( \"timer lane: no linda, aborted?\")\r\n\t\t\tend\r\n\t\tend\r\n\tend",
    "type": "function"
  }, {
    "id": 121,
    "text": "set_debug_threadname( \"LanesTimer\")",
    "type": "statement:functioncall"
  }, {
    "id": 122,
    "text": "local collection = {}",
    "type": "statement:localassign"
  }, {
    "id": 123,
    "text": "local table_insert = assert( table.insert)",
    "type": "statement:localassign"
  }, {
    "id": 124,
    "text": "local get_timers = function()\r\n\t\t\tlocal r = {}\r\n\t\t\tfor deep, t in pairs( collection) do\r\n\t\t\t\t-- WR( tostring( deep))\r\n\t\t\t\tlocal l = t[deep]\r\n\t\t\t\tfor key, timer_data in pairs( t) do\r\n\t\t\t\t\tif key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn r\r\n\t\tend",
    "type": "statement:localassign"
  }, {
    "id": 125,
    "text": "local set_timer = function( linda, key, wakeup_at, period)\r\n\t\t\tassert( wakeup_at == nil or wakeup_at > 0.0)\r\n\t\t\tassert( period == nil or period > 0.0)\r\n\r\n\t\t\tlocal linda_deep = linda:deep()\r\n\t\t\tassert( linda_deep)\r\n\r\n\t\t\t-- Find or make a lookup for this timer\r\n\t\t\t--\r\n\t\t\tlocal t1 = collection[linda_deep]\r\n\t\t\tif not t1 then\r\n\t\t\t\tt1 = { [linda_deep] = linda}     -- proxy to use the Linda\r\n\t\t\t\tcollection[linda_deep] = t1\r\n\t\t\tend\r\n\t\t\r\n\t\t\tif wakeup_at == nil then\r\n\t\t\t\t-- Clear the timer\r\n\t\t\t\t--\r\n\t\t\t\tt1[key]= nil\r\n\r\n\t\t\t\t-- Remove empty tables from collection; speeds timer checks and\r\n\t\t\t\t-- lets our 'safety reference' proxy be gc:ed as well.\r\n\t\t\t\t--\r\n\t\t\t\tlocal empty = true\r\n\t\t\t\tfor k, _ in pairs( t1) do\r\n\t\t\t\t\tif k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif empty then\r\n\t\t\t\t\tcollection[linda_deep] = nil\r\n\t\t\t\tend\r\n\r\n\t\t\t\t-- Note: any unread timer value is left at 'linda[key]' intensionally;\r\n\t\t\t\t--       clearing a timer just stops it.\r\n\t\t\telse\r\n\t\t\t\t-- New timer or changing the timings\r\n\t\t\t\t--\r\n\t\t\t\tlocal t2 = t1[key]\r\n\t\t\t\tif not t2 then\r\n\t\t\t\t\tt2= {}\r\n\t\t\t\t\tt1[key]= t2\r\n\t\t\t\tend\r\n\t\t\r\n\t\t\t\tt2[1] = wakeup_at\r\n\t\t\t\tt2[2] = period   -- can be 'nil'\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:localassign"
  }, {
    "id": 126,
    "text": "local check_timers = function()\r\n\t\t\tlocal now = now_secs()\r\n\t\t\tlocal next_wakeup\r\n\r\n\t\t\tfor linda_deep,t1 in pairs(collection) do\r\n\t\t\t\tfor key,t2 in pairs(t1) do\r\n\t\t\t\t\t--\r\n\t\t\t\t\tif key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend\r\n\t\t\t\tend -- t2 loop\r\n\t\t\tend -- t1 loop\r\n\r\n\t\t\treturn next_wakeup  -- may be 'nil'\r\n\t\tend",
    "type": "statement:localassign"
  }, {
    "id": 127,
    "text": "local timer_gateway_batched = timer_gateway.batched",
    "type": "statement:localassign"
  }, {
    "id": 128,
    "text": "set_finalizer( function( err, stk)\r\n\t\t\tif err and type( err) ~= \"userdata\" then\r\n\t\t\t\tWR( \"LanesTimer error: \"..tostring(err))\r\n\t\t\t--elseif type( err) == \"userdata\" then\r\n\t\t\t--\tWR( \"LanesTimer after cancel\" )\r\n\t\t\t--else\r\n\t\t\t--\tWR(\"LanesTimer finalized\")\r\n\t\t\tend\r\n\t\tend)",
    "type": "statement:functioncall"
  }, {
    "id": 129,
    "text": "if err and type( err) ~= \"userdata\" then\r\n\t\t\t\tWR( \"LanesTimer error: \"..tostring(err))\r\n\t\t\t--elseif type( err) == \"userdata\" then\r\n\t\t\t--\tWR( \"LanesTimer after cancel\" )\r\n\t\t\t--else\r\n\t\t\t--\tWR(\"LanesTimer finalized\")\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 130,
    "text": "WR( \"LanesTimer error: \"..tostring(err))",
    "type": "statement:functioncall"
  }, {
    "id": 131,
    "text": "while true do\r\n\t\t\tlocal next_wakeup = check_timers()\r\n\r\n\t\t\t-- Sleep until next timer to wake up, or a set/clear command\r\n\t\t\t--\r\n\t\t\tlocal secs\r\n\t\t\tif next_wakeup then\r\n\t\t\t\tsecs =  next_wakeup - now_secs()\r\n\t\t\t\tif secs < 0 then secs = 0 end\r\n\t\t\tend\r\n\t\t\tlocal key, what = timer_gateway:receive( secs, TGW_KEY, TGW_QUERY)\r\n\r\n\t\t\tif key == TGW_KEY then\r\n\t\t\t\tassert( getmetatable( what) == \"Linda\") -- 'what' should be a linda on which the client sets a timer\r\n\t\t\t\tlocal _, key, wakeup_at, period = timer_gateway:receive( 0, timer_gateway_batched, TGW_KEY, 3)\r\n\t\t\t\tassert( key)\r\n\t\t\t\tset_timer( what, key, wakeup_at, period and period > 0 and period or nil)\r\n\t\t\telseif key == TGW_QUERY then\r\n\t\t\t\tif what == \"get_timers\" then\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, get_timers())\r\n\t\t\t\telse\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, \"unknown query \" .. what)\r\n\t\t\t\tend\r\n\t\t\t--elseif secs == nil then -- got no value while block-waiting?\r\n\t\t\t--\tWR( \"timer lane: no linda, aborted?\")\r\n\t\t\tend\r\n\t\tend",
    "type": "statement:while"
  }, {
    "id": 132,
    "text": "local next_wakeup = check_timers()",
    "type": "statement:localassign"
  }, {
    "id": 133,
    "text": "local secs",
    "type": "statement:localassign"
  }, {
    "id": 134,
    "text": "if next_wakeup then\r\n\t\t\t\tsecs =  next_wakeup - now_secs()\r\n\t\t\t\tif secs < 0 then secs = 0 end\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 135,
    "text": "secs =  next_wakeup - now_secs()",
    "type": "statement:assign"
  }, {
    "id": 136,
    "text": "if secs < 0 then secs = 0 end",
    "type": "statement:if"
  }, {
    "id": 137,
    "text": "secs = 0",
    "type": "statement:assign"
  }, {
    "id": 138,
    "text": "local key, what = timer_gateway:receive( secs, TGW_KEY, TGW_QUERY)",
    "type": "statement:localassign"
  }, {
    "id": 139,
    "text": "if key == TGW_KEY then\r\n\t\t\t\tassert( getmetatable( what) == \"Linda\") -- 'what' should be a linda on which the client sets a timer\r\n\t\t\t\tlocal _, key, wakeup_at, period = timer_gateway:receive( 0, timer_gateway_batched, TGW_KEY, 3)\r\n\t\t\t\tassert( key)\r\n\t\t\t\tset_timer( what, key, wakeup_at, period and period > 0 and period or nil)\r\n\t\t\telseif key == TGW_QUERY then\r\n\t\t\t\tif what == \"get_timers\" then\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, get_timers())\r\n\t\t\t\telse\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, \"unknown query \" .. what)\r\n\t\t\t\tend\r\n\t\t\t--elseif secs == nil then -- got no value while block-waiting?\r\n\t\t\t--\tWR( \"timer lane: no linda, aborted?\")\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 140,
    "text": "assert( getmetatable( what) == \"Linda\")",
    "type": "statement:functioncall"
  }, {
    "id": 141,
    "text": "local _, key, wakeup_at, period = timer_gateway:receive( 0, timer_gateway_batched, TGW_KEY, 3)",
    "type": "statement:localassign"
  }, {
    "id": 142,
    "text": "assert( key)",
    "type": "statement:functioncall"
  }, {
    "id": 143,
    "text": "set_timer( what, key, wakeup_at, period and period > 0 and period or nil)",
    "type": "statement:functioncall"
  }, {
    "id": 144,
    "text": "if what == \"get_timers\" then\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, get_timers())\r\n\t\t\t\telse\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, \"unknown query \" .. what)\r\n\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 145,
    "text": "timer_gateway:send( TGW_REPLY, get_timers())",
    "type": "statement:functioncall"
  }, {
    "id": 146,
    "text": "timer_gateway:send( TGW_REPLY, \"unknown query \" .. what)",
    "type": "statement:functioncall"
  }, {
    "id": 147,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 148,
    "text": "function( linda, key, a, period )\r\n    if getmetatable( linda) ~= \"Linda\" then\r\n        error \"expecting a Linda\"\r\n    end\r\n    if a == 0.0 then\r\n        -- Caller expects to get current time stamp in Linda, on return\r\n        -- (like the timer had expired instantly); it would be good to set this\r\n        -- as late as possible (to give most current time) but also we want it\r\n        -- to precede any possible timers that might start striking.\r\n        --\r\n        linda:set( key, core.now_secs())\r\n\r\n        if not period or period==0.0 then\r\n            timer_gateway:send( TGW_KEY, linda, key, nil, nil )   -- clear the timer\r\n            return  -- nothing more to do\r\n        end\r\n        a= period\r\n    end\r\n\r\n    local wakeup_at= type(a)==\"table\" and core.wakeup_conv(a)    -- given point of time\r\n                                       or (a and core.now_secs()+a or nil)\r\n    -- queue to timer\r\n    --\r\n    timer_gateway:send( TGW_KEY, linda, key, wakeup_at, period )\r\nend",
    "type": "function"
  }, {
    "id": 149,
    "text": "if getmetatable( linda) ~= \"Linda\" then\r\n        error \"expecting a Linda\"\r\n    end",
    "type": "statement:if"
  }, {
    "id": 150,
    "text": "error \"expecting a Linda\"",
    "type": "statement:functioncall"
  }, {
    "id": 151,
    "text": "if a == 0.0 then\r\n        -- Caller expects to get current time stamp in Linda, on return\r\n        -- (like the timer had expired instantly); it would be good to set this\r\n        -- as late as possible (to give most current time) but also we want it\r\n        -- to precede any possible timers that might start striking.\r\n        --\r\n        linda:set( key, core.now_secs())\r\n\r\n        if not period or period==0.0 then\r\n            timer_gateway:send( TGW_KEY, linda, key, nil, nil )   -- clear the timer\r\n            return  -- nothing more to do\r\n        end\r\n        a= period\r\n    end",
    "type": "statement:if"
  }, {
    "id": 152,
    "text": "linda:set( key, core.now_secs())",
    "type": "statement:functioncall"
  }, {
    "id": 153,
    "text": "if not period or period==0.0 then\r\n            timer_gateway:send( TGW_KEY, linda, key, nil, nil )   -- clear the timer\r\n            return  -- nothing more to do\r\n        end",
    "type": "statement:if"
  }, {
    "id": 154,
    "text": "timer_gateway:send( TGW_KEY, linda, key, nil, nil )",
    "type": "statement:functioncall"
  }, {
    "id": 155,
    "text": "a= period",
    "type": "statement:assign"
  }, {
    "id": 156,
    "text": "local wakeup_at= type(a)==\"table\" and core.wakeup_conv(a)    -- given point of time\r\n                                       or (a and core.now_secs()+a or nil)",
    "type": "statement:localassign"
  }, {
    "id": 157,
    "text": "timer_gateway:send( TGW_KEY, linda, key, wakeup_at, period )",
    "type": "statement:functioncall"
  }, {
    "id": 158,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 159,
    "text": "function()\r\n\ttimer_gateway:send( TGW_QUERY, \"get_timers\")\r\n\tlocal _, r = timer_gateway:receive( TGW_REPLY)\r\n\treturn r\r\nend",
    "type": "function"
  }, {
    "id": 160,
    "text": "timer_gateway:send( TGW_QUERY, \"get_timers\")",
    "type": "statement:functioncall"
  }, {
    "id": 161,
    "text": "local _, r = timer_gateway:receive( TGW_REPLY)",
    "type": "statement:localassign"
  }, {
    "id": 162,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 163,
    "text": "local function trues( n)\r\n\tif n > 0 then\r\n\t\treturn true, trues( n - 1)\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 164,
    "text": "if n > 0 then\r\n\t\treturn true, trues( n - 1)\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 165,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 166,
    "text": "function( linda, key, N)\r\n\t-- clear existing data and set the limit\r\n\tN = N or 1\r\n\tif linda:set( key) == cancel_error or linda:limit( key, N) == cancel_error then\r\n\t\treturn cancel_error\r\n\tend\r\n\r\n\t-- use an optimized version for case N == 1\r\n\treturn (N == 1) and\r\n\tfunction( M, mode_)\r\n\t\tlocal timeout = (mode_ == \"try\") and 0 or nil\r\n\t\tif M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, true)    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, key)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend\r\n\tend\r\n\tor\r\n\tfunction( M, mode_)\r\n\t\tlocal timeout = (mode_ == \"try\") and 0 or nil\r\n\t\tif M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, trues(M))    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, linda.batched, key, -M)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend\r\n\tend\r\nend",
    "type": "function"
  }, {
    "id": 167,
    "text": "N = N or 1",
    "type": "statement:assign"
  }, {
    "id": 168,
    "text": "if linda:set( key) == cancel_error or linda:limit( key, N) == cancel_error then\r\n\t\treturn cancel_error\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 169,
    "text": "local timeout = (mode_ == \"try\") and 0 or nil",
    "type": "statement:localassign"
  }, {
    "id": 170,
    "text": "if M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, true)    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, key)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 171,
    "text": "local k = linda:receive( nil, key)",
    "type": "statement:localassign"
  }, {
    "id": 172,
    "text": "if M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, trues(M))    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, linda.batched, key, -M)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 173,
    "text": "local k = linda:receive( nil, linda.batched, key, -M)",
    "type": "statement:localassign"
  }, {
    "id": 174,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 175,
    "text": "function( linda, key, initial_val)\r\n\t\t-- clears existing data (also queue). the slot may contain the stored value, and an additional boolean value\r\n\t\tif linda:limit( key, 2) == cancel_error or linda:set( key, initial_val or 0.0) == cancel_error then\r\n\t\t\treturn cancel_error\r\n\t\tend\r\n\r\n\t\treturn function( diff)\r\n\t\t\t-- 'nil' allows 'key' to be numeric\r\n\t\t\t-- suspends until our 'true' is in\r\n\t\t\tif linda:send( nil, key, true) == cancel_error then\r\n\t\t\t\treturn cancel_error\r\n\t\t\tend\r\n\t\t\tlocal val = linda:get( key)\r\n\t\t\tif val ~= cancel_error then\r\n\t\t\t\tval = val + (diff or 1.0)\r\n\t\t\t\t-- set() releases the lock by emptying queue\r\n\t\t\t\tif linda:set( key, val) == cancel_error then\r\n\t\t\t\t\tval = cancel_error\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn val\r\n\t\tend\r\n\tend",
    "type": "function"
  }, {
    "id": 176,
    "text": "if linda:limit( key, 2) == cancel_error or linda:set( key, initial_val or 0.0) == cancel_error then\r\n\t\t\treturn cancel_error\r\n\t\tend",
    "type": "statement:if"
  }, {
    "id": 177,
    "text": "if linda:send( nil, key, true) == cancel_error then\r\n\t\t\t\treturn cancel_error\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 178,
    "text": "local val = linda:get( key)",
    "type": "statement:localassign"
  }, {
    "id": 179,
    "text": "if val ~= cancel_error then\r\n\t\t\t\tval = val + (diff or 1.0)\r\n\t\t\t\t-- set() releases the lock by emptying queue\r\n\t\t\t\tif linda:set( key, val) == cancel_error then\r\n\t\t\t\t\tval = cancel_error\r\n\t\t\t\tend\r\n\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 180,
    "text": "val = val + (diff or 1.0)",
    "type": "statement:assign"
  }, {
    "id": 181,
    "text": "if linda:set( key, val) == cancel_error then\r\n\t\t\t\t\tval = cancel_error\r\n\t\t\t\tend",
    "type": "statement:if"
  }, {
    "id": 182,
    "text": "val = cancel_error",
    "type": "statement:assign"
  }, {
    "id": 183,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 184,
    "text": "function() error \"lane tracking is not available\" end",
    "type": "function"
  }, {
    "id": 185,
    "text": "error \"lane tracking is not available\"",
    "type": "statement:functioncall"
  }, {
    "id": 186,
    "text": "function( settings_)\r\n\r\n\t-- This check is for sublanes requiring Lanes\r\n\t--\r\n\t-- TBD: We could also have the C level expose 'string.gmatch' for us. But this is simpler.\r\n\t--\r\n\tif not string then\r\n\t\terror( \"To use 'lanes', you will also need to have 'string' available.\", 2)\r\n\tend\r\n\r\n\t-- \r\n\t-- Cache globals for code that might run under sandboxing\r\n\t--\r\n\tlocal assert = assert( assert)\r\n\tlocal string_gmatch = assert( string.gmatch)\r\n\tlocal string_format = assert( string.format)\r\n\tlocal select = assert( select)\r\n\tlocal type = assert( type)\r\n\tlocal pairs = assert( pairs)\r\n\tlocal tostring = assert( tostring)\r\n\tlocal error = assert( error)\r\n\r\n\tlocal default_params =\r\n\t{\r\n\t\tnb_keepers = 1,\r\n\t\ton_state_create = nil,\r\n\t\tshutdown_timeout = 0.25,\r\n\t\twith_timers = true,\r\n\t\ttrack_lanes = false,\r\n\t\tdemote_full_userdata = nil,\r\n\t\tverbose_errors = false,\r\n\t\t-- LuaJIT provides a thread-unsafe allocator by default, so we need to protect it when used in parallel lanes\r\n\t\tprotect_allocator = (jit and jit.version) and true or false\r\n\t}\r\n\tlocal boolean_param_checker = function( val_)\r\n\t\t-- non-'boolean-false' should be 'boolean-true' or nil\r\n\t\treturn val_ and (val_ == true) or true\r\n\tend\r\n\tlocal param_checkers =\r\n\t{\r\n\t\tnb_keepers = function( val_)\r\n\t\t\t-- nb_keepers should be a number > 0\r\n\t\t\treturn type( val_) == \"number\" and val_ > 0\r\n\t\tend,\r\n\t\twith_timers = boolean_param_checker,\r\n\t\tprotect_allocator = boolean_param_checker,\r\n\t\ton_state_create = function( val_)\r\n\t\t\t-- on_state_create may be nil or a function\r\n\t\t\treturn val_ and type( val_) == \"function\" or true\r\n\t\tend,\r\n\t\tshutdown_timeout = function( val_)\r\n\t\t\t-- shutdown_timeout should be a number >= 0\r\n\t\t\treturn type( val_) == \"number\" and val_ >= 0\r\n\t\tend,\r\n\t\ttrack_lanes = boolean_param_checker,\r\n\t\tdemote_full_userdata = boolean_param_checker,\r\n\t\tverbose_errors = boolean_param_checker\r\n\t}\r\n\r\n\tlocal params_checker = function( settings_)\r\n\t\tif not settings_ then\r\n\t\t\treturn default_params\r\n\t\tend\r\n\t\t-- make a copy of the table to leave the provided one unchanged, *and* to help ensure it won't change behind our back\r\n\t\tlocal settings = {}\r\n\t\tif type( settings_) ~= \"table\" then\r\n\t\t\terror \"Bad parameter #1 to lanes.configure(), should be a table\"\r\n\t\tend\r\n\t\t-- any setting not present in the provided parameters takes the default value\r\n\t\tfor key, checker in pairs( param_checkers) do\r\n\t\t\tlocal my_param = settings_[key]\r\n\t\t\tlocal param\r\n\t\t\tif my_param ~= nil then\r\n\t\t\t\tparam = my_param\r\n\t\t\telse\r\n\t\t\t\tparam = default_params[key]\r\n\t\t\tend\r\n\t\t\tif not checker( param) then\r\n\t\t\t\terror( \"Bad \" .. key .. \": \" .. tostring( param), 2)\r\n\t\t\tend\r\n\t\t\tsettings[key] = param\r\n\t\tend\r\n\t\treturn settings\r\n\tend\r\n\tlocal settings = core.configure and core.configure( params_checker( settings_)) or core.settings\r\n\tlocal core_lane_new = assert( core.lane_new)\r\n\tlocal max_prio = assert( core.max_prio)\r\n\r\nlanes.ABOUT =\r\n{\r\n\tauthor= \"Asko Kauppi <akauppi@gmail.com>, Benoit Germain <bnt.germain@gmail.com>\",\r\n\tdescription= \"Running multiple Lua states in parallel\",\r\n\tlicense= \"MIT/X11\",\r\n\tcopyright= \"Copyright (c) 2007-10, Asko Kauppi; (c) 2011-13, Benoit Germain\",\r\n\tversion = assert( core.version)\r\n}\r\n\r\n\r\n-- Making copies of necessary system libs will pass them on as upvalues;\r\n-- only the first state doing \"require 'lanes'\" will need to have 'string'\r\n-- and 'table' visible.\r\n--\r\nlocal function WR(str)\r\n    io.stderr:write( str..\"\\n\" )\r\nend\r\n\r\nlocal function DUMP( tbl )\r\n    if not tbl then return end\r\n    local str=\"\"\r\n    for k,v in pairs(tbl) do\r\n        str= str..k..\"=\"..tostring(v)..\"\\n\"\r\n    end\r\n    WR(str)\r\nend\r\n\r\n\r\n---=== Laning ===---\r\n\r\n-- lane_h[1..n]: lane results, same as via 'lane_h:join()'\r\n-- lane_h[0]:    can be read to make sure a thread has finished (always gives 'true')\r\n-- lane_h[-1]:   error message, without propagating the error\r\n--\r\n--      Reading a Lane result (or [0]) propagates a possible error in the lane\r\n--      (and execution does not return). Cancelled lanes give 'nil' values.\r\n--\r\n-- lane_h.state: \"pending\"/\"running\"/\"waiting\"/\"done\"/\"error\"/\"cancelled\"\r\n--\r\n-- Note: Would be great to be able to have '__ipairs' metamethod, that gets\r\n--      called by 'ipairs()' function to custom iterate objects. We'd use it\r\n--      for making sure a lane has ended (results are available); not requiring\r\n--      the user to precede a loop by explicit 'h[0]' or 'h:join()'.\r\n--\r\n--      Or, even better, 'ipairs()' should start valuing '__index' instead\r\n--      of using raw reads that bypass it.\r\n--\r\n-----\r\n-- lanes.gen( [libs_str|opt_tbl [, ...],] lane_func ) ( [...] ) -> h\r\n--\r\n-- 'libs': nil:     no libraries available (default)\r\n--         \"\":      only base library ('assert', 'print', 'unpack' etc.)\r\n--         \"math,os\": math + os + base libraries (named ones + base)\r\n--         \"*\":     all standard libraries available\r\n--\r\n-- 'opt': .priority:  int (-3..+3) smaller is lower priority (0 = default)\r\n--\r\n--\t      .cancelstep: bool | uint\r\n--            false: cancellation check only at pending Linda operations\r\n--                   (send/receive) so no runtime performance penalty (default)\r\n--            true:  adequate cancellation check (same as 100)\r\n--            >0:    cancellation check every x Lua lines (small number= faster\r\n--                   reaction but more performance overhead)\r\n--\r\n--        .globals:  table of globals to set for a new thread (passed by value)\r\n--\r\n--        .required: table of packages to require\r\n--\r\n--        .gc_cb:    function called when the lane handle is collected\r\n--\r\n--        ... (more options may be introduced later) ...\r\n--\r\n-- Calling with a function parameter ('lane_func') ends the string/table\r\n-- modifiers, and prepares a lane generator.\r\n\r\nlocal valid_libs =\r\n{\r\n\t[\"package\"] = true,\r\n\t[\"table\"] = true,\r\n\t[\"io\"] = true,\r\n\t[\"os\"] = true,\r\n\t[\"string\"] = true,\r\n\t[\"math\"] = true,\r\n\t[\"debug\"] = true,\r\n\t[\"bit32\"] = true, -- Lua 5.2 only, ignored silently under 5.1\r\n\t--\r\n\t[\"base\"] = true,\r\n\t[\"coroutine\"] = true, -- part of \"base\" in Lua 5.1\r\n\t[\"lanes.core\"] = true\r\n}\r\n\r\nlocal raise_option_error = function( name_, tv_, v_)\r\n\terror( \"Bad '\" .. name_ .. \"' option: \" .. tv_ .. \" \" .. string_format( \"%q\", tostring( v_)), 4)\r\nend\r\n\r\nlocal opt_validators =\r\n{\r\n\tpriority = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"number\") and v_ or raise_option_error( \"priority\", tv, v_)\r\n\tend,\r\n\tcancelstep = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"number\") and v_ or (v_ == true) and 100 or (v_ == false) and 0 or raise_option_error( \"cancelstep\", tv, v_)\r\n\tend,\r\n\tglobals = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"table\") and v_ or raise_option_error( \"globals\", tv, v_)\r\n\tend,\r\n\tpackage = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"table\") and v_ or raise_option_error( \"package\", tv, v_)\r\n\tend,\r\n\trequired = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"table\") and v_ or raise_option_error( \"required\", tv, v_)\r\n\tend,\r\n\tgc_cb = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"function\") and v_ or raise_option_error( \"gc_cb\", tv, v_)\r\n\tend\r\n}\r\n\r\n-- PUBLIC LANES API\r\n-- receives a sequence of strings and tables, plus a function\r\nlocal gen = function( ...)\r\n\t-- aggregrate all strings together, separated by \",\" as well as tables\r\n\t-- the strings are a list of libraries to open\r\n\t-- the tables contain the lane options\r\n\tlocal opt = {}\r\n\tlocal libs = nil\r\n\r\n\tlocal n = select( '#', ...)\r\n\r\n\t-- we need at least a function\r\n\tif n == 0 then\r\n\t\terror( \"No parameters!\", 2)\r\n\tend\r\n\r\n\t-- all arguments but the last must be nil, strings, or tables\r\n\tfor i = 1, n - 1 do\r\n\t\tlocal v = select( i, ...)\r\n\t\tlocal tv = type( v)\r\n\t\tif tv == \"string\" then\r\n\t\t\tlibs = libs and libs .. \",\" .. v or v\r\n\t\telseif tv == \"table\" then\r\n\t\t\tfor k, vv in pairs( v) do\r\n\t\t\t\topt[k]= vv\r\n\t\t\tend\r\n\t\telseif v == nil then\r\n\t\t\t-- skip\r\n\t\telse\r\n\t\t\terror( \"Bad parameter \" .. i .. \": \" .. tv .. \" \" .. string_format( \"%q\", tostring( v)), 2)\r\n\t\tend\r\n\tend\r\n\r\n\t-- the last argument should be a function or a string\r\n\tlocal func = select( n, ...)\r\n\tlocal functype = type( func)\r\n\tif functype ~= \"function\" and functype ~= \"string\" then\r\n\t\terror( \"Last parameter not function or string: \" .. functype .. \" \" .. string_format( \"%q\", tostring( func)), 2)\r\n\tend\r\n\r\n\t-- check that the caller only provides reserved library names, and those only once\r\n\t-- \"*\" is a special case that doesn't require individual checking\r\n\tif libs and libs ~= \"*\" then\r\n\t\tlocal found = {}\r\n\t\tfor s in string_gmatch(libs, \"[%a%d.]+\") do\r\n\t\t\tif not valid_libs[s] then\r\n\t\t\t\terror( \"Bad library name: \" .. s, 2)\r\n\t\t\telse\r\n\t\t\t\tfound[s] = (found[s] or 0) + 1\r\n\t\t\t\tif found[s] > 1 then\r\n\t\t\t\t\terror( \"libs specification contains '\" .. s .. \"' more than once\", 2)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\t-- validate that each option is known and properly valued\r\n\tfor k, v in pairs( opt) do\r\n\t\tlocal validator = opt_validators[k]\r\n\t\tif not validator then\r\n\t\t\terror( (type( k) == \"number\" and \"Unkeyed option: \" .. type( v) .. \" \" .. string_format( \"%q\", tostring( v)) or \"Bad '\" .. tostring( k) .. \"' option\"), 2)\r\n\t\telse\r\n\t\t\topt[k] = validator( v)\r\n\t\tend\r\n\tend\r\n\r\n\tlocal cancelstep, priority, globals, package, required, gc_cb = opt.cancelstep, opt.priority, opt.globals, opt.package or package, opt.required, opt.gc_cb\r\n\treturn function( ...)\r\n\t\t-- must pass functions args last else they will be truncated to the first one\r\n\t\treturn core_lane_new( func, libs, cancelstep, priority, globals, package, required, gc_cb, ...)\r\n\tend\r\nend -- gen()\r\n\r\n---=== Timers ===---\r\n\r\n-- PUBLIC LANES API\r\nlocal timer = function() error \"timers are not active\" end\r\nlocal timer_lane = nil\r\nlocal timers = timer\r\n\r\nif settings.with_timers ~= false then\r\n\r\nlocal timer_gateway = assert( core.timer_gateway)\r\n--\r\n-- On first 'require \"lanes\"', a timer lane is spawned that will maintain\r\n-- timer tables and sleep in between the timer events. All interaction with\r\n-- the timer lane happens via a 'timer_gateway' Linda, which is common to\r\n-- all that 'require \"lanes\"'.\r\n-- \r\n-- Linda protocol to timer lane:\r\n--\r\n--  TGW_KEY: linda_h, key, [wakeup_at_secs], [repeat_secs]\r\n--\r\nlocal TGW_KEY= \"(timer control)\"    -- the key does not matter, a 'weird' key may help debugging\r\nlocal TGW_QUERY, TGW_REPLY = \"(timer query)\", \"(timer reply)\"\r\nlocal first_time_key= \"first time\"\r\n\r\nlocal first_time= timer_gateway:get(first_time_key) == nil\r\ntimer_gateway:set(first_time_key,true)\r\n\r\n--\r\n-- Timer lane; initialize only on the first 'require \"lanes\"' instance (which naturally\r\n-- has 'table' always declared)\r\n--\r\nif first_time then\r\n\r\n\tlocal now_secs = core.now_secs\r\n\tassert( type( now_secs) == \"function\")\r\n\t-----\r\n\t-- Snore loop (run as a lane on the background)\r\n\t--\r\n\t-- High priority, to get trustworthy timings.\r\n\t--\r\n\t-- We let the timer lane be a \"free running\" thread; no handle to it\r\n\t-- remains.\r\n\t--\r\n\tlocal timer_body = function()\r\n\t\tset_debug_threadname( \"LanesTimer\")\r\n\t\t--\r\n\t\t-- { [deep_linda_lightuserdata]= { [deep_linda_lightuserdata]=linda_h, \r\n\t\t--                                 [key]= { wakeup_secs [,period_secs] } [, ...] },\r\n\t\t-- }\r\n\t\t--\r\n\t\t-- Collection of all running timers, indexed with linda's & key.\r\n\t\t--\r\n\t\t-- Note that we need to use the deep lightuserdata identifiers, instead\r\n\t\t-- of 'linda_h' themselves as table indices. Otherwise, we'd get multiple\r\n\t\t-- entries for the same timer.\r\n\t\t--\r\n\t\t-- The 'hidden' reference to Linda proxy is used in 'check_timers()' but\r\n\t\t-- also important to keep the Linda alive, even if all outside world threw\r\n\t\t-- away pointers to it (which would ruin uniqueness of the deep pointer).\r\n\t\t-- Now we're safe.\r\n\t\t--\r\n\t\tlocal collection = {}\r\n\t\tlocal table_insert = assert( table.insert)\r\n\r\n\t\tlocal get_timers = function()\r\n\t\t\tlocal r = {}\r\n\t\t\tfor deep, t in pairs( collection) do\r\n\t\t\t\t-- WR( tostring( deep))\r\n\t\t\t\tlocal l = t[deep]\r\n\t\t\t\tfor key, timer_data in pairs( t) do\r\n\t\t\t\t\tif key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn r\r\n\t\tend -- get_timers()\r\n\r\n\t\t--\r\n\t\t-- set_timer( linda_h, key [,wakeup_at_secs [,period_secs]] )\r\n\t\t--\r\n\t\tlocal set_timer = function( linda, key, wakeup_at, period)\r\n\t\t\tassert( wakeup_at == nil or wakeup_at > 0.0)\r\n\t\t\tassert( period == nil or period > 0.0)\r\n\r\n\t\t\tlocal linda_deep = linda:deep()\r\n\t\t\tassert( linda_deep)\r\n\r\n\t\t\t-- Find or make a lookup for this timer\r\n\t\t\t--\r\n\t\t\tlocal t1 = collection[linda_deep]\r\n\t\t\tif not t1 then\r\n\t\t\t\tt1 = { [linda_deep] = linda}     -- proxy to use the Linda\r\n\t\t\t\tcollection[linda_deep] = t1\r\n\t\t\tend\r\n\t\t\r\n\t\t\tif wakeup_at == nil then\r\n\t\t\t\t-- Clear the timer\r\n\t\t\t\t--\r\n\t\t\t\tt1[key]= nil\r\n\r\n\t\t\t\t-- Remove empty tables from collection; speeds timer checks and\r\n\t\t\t\t-- lets our 'safety reference' proxy be gc:ed as well.\r\n\t\t\t\t--\r\n\t\t\t\tlocal empty = true\r\n\t\t\t\tfor k, _ in pairs( t1) do\r\n\t\t\t\t\tif k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif empty then\r\n\t\t\t\t\tcollection[linda_deep] = nil\r\n\t\t\t\tend\r\n\r\n\t\t\t\t-- Note: any unread timer value is left at 'linda[key]' intensionally;\r\n\t\t\t\t--       clearing a timer just stops it.\r\n\t\t\telse\r\n\t\t\t\t-- New timer or changing the timings\r\n\t\t\t\t--\r\n\t\t\t\tlocal t2 = t1[key]\r\n\t\t\t\tif not t2 then\r\n\t\t\t\t\tt2= {}\r\n\t\t\t\t\tt1[key]= t2\r\n\t\t\t\tend\r\n\t\t\r\n\t\t\t\tt2[1] = wakeup_at\r\n\t\t\t\tt2[2] = period   -- can be 'nil'\r\n\t\t\tend\r\n\t\tend -- set_timer()\r\n\r\n\t\t-----\r\n\t\t-- [next_wakeup_at]= check_timers()\r\n\t\t-- Check timers, and wake up the ones expired (if any)\r\n\t\t-- Returns the closest upcoming (remaining) wakeup time (or 'nil' if none).\r\n\t\tlocal check_timers = function()\r\n\t\t\tlocal now = now_secs()\r\n\t\t\tlocal next_wakeup\r\n\r\n\t\t\tfor linda_deep,t1 in pairs(collection) do\r\n\t\t\t\tfor key,t2 in pairs(t1) do\r\n\t\t\t\t\t--\r\n\t\t\t\t\tif key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend\r\n\t\t\t\tend -- t2 loop\r\n\t\t\tend -- t1 loop\r\n\r\n\t\t\treturn next_wakeup  -- may be 'nil'\r\n\t\tend -- check_timers()\r\n\r\n\t\tlocal timer_gateway_batched = timer_gateway.batched\r\n\t\tset_finalizer( function( err, stk)\r\n\t\t\tif err and type( err) ~= \"userdata\" then\r\n\t\t\t\tWR( \"LanesTimer error: \"..tostring(err))\r\n\t\t\t--elseif type( err) == \"userdata\" then\r\n\t\t\t--\tWR( \"LanesTimer after cancel\" )\r\n\t\t\t--else\r\n\t\t\t--\tWR(\"LanesTimer finalized\")\r\n\t\t\tend\r\n\t\tend)\r\n\t\twhile true do\r\n\t\t\tlocal next_wakeup = check_timers()\r\n\r\n\t\t\t-- Sleep until next timer to wake up, or a set/clear command\r\n\t\t\t--\r\n\t\t\tlocal secs\r\n\t\t\tif next_wakeup then\r\n\t\t\t\tsecs =  next_wakeup - now_secs()\r\n\t\t\t\tif secs < 0 then secs = 0 end\r\n\t\t\tend\r\n\t\t\tlocal key, what = timer_gateway:receive( secs, TGW_KEY, TGW_QUERY)\r\n\r\n\t\t\tif key == TGW_KEY then\r\n\t\t\t\tassert( getmetatable( what) == \"Linda\") -- 'what' should be a linda on which the client sets a timer\r\n\t\t\t\tlocal _, key, wakeup_at, period = timer_gateway:receive( 0, timer_gateway_batched, TGW_KEY, 3)\r\n\t\t\t\tassert( key)\r\n\t\t\t\tset_timer( what, key, wakeup_at, period and period > 0 and period or nil)\r\n\t\t\telseif key == TGW_QUERY then\r\n\t\t\t\tif what == \"get_timers\" then\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, get_timers())\r\n\t\t\t\telse\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, \"unknown query \" .. what)\r\n\t\t\t\tend\r\n\t\t\t--elseif secs == nil then -- got no value while block-waiting?\r\n\t\t\t--\tWR( \"timer lane: no linda, aborted?\")\r\n\t\t\tend\r\n\t\tend\r\n\tend -- timer_body()\r\n\ttimer_lane = gen( \"*\", { package= {}, priority = max_prio}, timer_body)() -- \"*\" instead of \"io,package\" for LuaJIT compatibility...\r\nend -- first_time\r\n\r\n-----\r\n-- = timer( linda_h, key_val, date_tbl|first_secs [,period_secs] )\r\n--\r\n-- PUBLIC LANES API\r\ntimer = function( linda, key, a, period )\r\n    if getmetatable( linda) ~= \"Linda\" then\r\n        error \"expecting a Linda\"\r\n    end\r\n    if a == 0.0 then\r\n        -- Caller expects to get current time stamp in Linda, on return\r\n        -- (like the timer had expired instantly); it would be good to set this\r\n        -- as late as possible (to give most current time) but also we want it\r\n        -- to precede any possible timers that might start striking.\r\n        --\r\n        linda:set( key, core.now_secs())\r\n\r\n        if not period or period==0.0 then\r\n            timer_gateway:send( TGW_KEY, linda, key, nil, nil )   -- clear the timer\r\n            return  -- nothing more to do\r\n        end\r\n        a= period\r\n    end\r\n\r\n    local wakeup_at= type(a)==\"table\" and core.wakeup_conv(a)    -- given point of time\r\n                                       or (a and core.now_secs()+a or nil)\r\n    -- queue to timer\r\n    --\r\n    timer_gateway:send( TGW_KEY, linda, key, wakeup_at, period )\r\nend\r\n\r\n-----\r\n-- {[{linda, slot, when, period}[,...]]} = timers()\r\n--\r\n-- PUBLIC LANES API\r\ntimers = function()\r\n\ttimer_gateway:send( TGW_QUERY, \"get_timers\")\r\n\tlocal _, r = timer_gateway:receive( TGW_REPLY)\r\n\treturn r\r\nend\r\n\r\nend -- settings.with_timers\r\n\r\n-- avoid pulling the whole core module as upvalue when cancel_error is enough\r\nlocal cancel_error = assert( core.cancel_error)\r\n\r\n---=== Lock & atomic generators ===---\r\n\r\n-- These functions are just surface sugar, but make solutions easier to read.\r\n-- Not many applications should even need explicit locks or atomic counters.\r\n\r\n--\r\n-- [true [, ...]= trues(uint)\r\n--\r\nlocal function trues( n)\r\n\tif n > 0 then\r\n\t\treturn true, trues( n - 1)\r\n\tend\r\nend\r\n\r\n--\r\n-- lock_f = lanes.genlock( linda_h, key [,N_uint=1] )\r\n--\r\n-- = lock_f( +M )   -- acquire M\r\n--      ...locked...\r\n-- = lock_f( -M )   -- release M\r\n--\r\n-- Returns an access function that allows 'N' simultaneous entries between\r\n-- acquire (+M) and release (-M). For binary locks, use M==1.\r\n--\r\n-- PUBLIC LANES API\r\nlocal genlock = function( linda, key, N)\r\n\t-- clear existing data and set the limit\r\n\tN = N or 1\r\n\tif linda:set( key) == cancel_error or linda:limit( key, N) == cancel_error then\r\n\t\treturn cancel_error\r\n\tend\r\n\r\n\t-- use an optimized version for case N == 1\r\n\treturn (N == 1) and\r\n\tfunction( M, mode_)\r\n\t\tlocal timeout = (mode_ == \"try\") and 0 or nil\r\n\t\tif M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, true)    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, key)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend\r\n\tend\r\n\tor\r\n\tfunction( M, mode_)\r\n\t\tlocal timeout = (mode_ == \"try\") and 0 or nil\r\n\t\tif M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, trues(M))    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, linda.batched, key, -M)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend\r\n\tend\r\nend\r\n\r\n\r\n\t--\r\n\t-- atomic_f = lanes.genatomic( linda_h, key [,initial_num=0.0])\r\n\t--\r\n\t-- int|cancel_error = atomic_f( [diff_num = 1.0])\r\n\t--\r\n\t-- Returns an access function that allows atomic increment/decrement of the\r\n\t-- number in 'key'.\r\n\t--\r\n\t-- PUBLIC LANES API\r\n\tlocal genatomic = function( linda, key, initial_val)\r\n\t\t-- clears existing data (also queue). the slot may contain the stored value, and an additional boolean value\r\n\t\tif linda:limit( key, 2) == cancel_error or linda:set( key, initial_val or 0.0) == cancel_error then\r\n\t\t\treturn cancel_error\r\n\t\tend\r\n\r\n\t\treturn function( diff)\r\n\t\t\t-- 'nil' allows 'key' to be numeric\r\n\t\t\t-- suspends until our 'true' is in\r\n\t\t\tif linda:send( nil, key, true) == cancel_error then\r\n\t\t\t\treturn cancel_error\r\n\t\t\tend\r\n\t\t\tlocal val = linda:get( key)\r\n\t\t\tif val ~= cancel_error then\r\n\t\t\t\tval = val + (diff or 1.0)\r\n\t\t\t\t-- set() releases the lock by emptying queue\r\n\t\t\t\tif linda:set( key, val) == cancel_error then\r\n\t\t\t\t\tval = cancel_error\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn val\r\n\t\tend\r\n\tend\r\n\r\n\t-- activate full interface\r\n\tlanes.require = core.require\r\n\tlanes.gen = gen\r\n\tlanes.linda = core.linda\r\n\tlanes.cancel_error = core.cancel_error\r\n\tlanes.nameof = core.nameof\r\n\tlanes.set_singlethreaded = core.set_singlethreaded\r\n\tlanes.threads = core.threads or function() error \"lane tracking is not available\" end -- core.threads isn't registered if settings.track_lanes is false\r\n\tlanes.set_thread_priority = core.set_thread_priority\r\n\tlanes.timer = timer\r\n\tlanes.timer_lane = timer_lane\r\n\tlanes.timers = timers\r\n\tlanes.genlock = genlock\r\n\tlanes.now_secs = core.now_secs\r\n\tlanes.genatomic = genatomic\r\n\tlanes.configure = nil -- no need to call configure() ever again\r\n\treturn lanes\r\nend",
    "type": "function"
  }, {
    "id": 187,
    "text": "if not string then\r\n\t\terror( \"To use 'lanes', you will also need to have 'string' available.\", 2)\r\n\tend",
    "type": "statement:if"
  }, {
    "id": 188,
    "text": "error( \"To use 'lanes', you will also need to have 'string' available.\", 2)",
    "type": "statement:functioncall"
  }, {
    "id": 189,
    "text": "local assert = assert( assert)",
    "type": "statement:localassign"
  }, {
    "id": 190,
    "text": "local string_gmatch = assert( string.gmatch)",
    "type": "statement:localassign"
  }, {
    "id": 191,
    "text": "local string_format = assert( string.format)",
    "type": "statement:localassign"
  }, {
    "id": 192,
    "text": "local select = assert( select)",
    "type": "statement:localassign"
  }, {
    "id": 193,
    "text": "local type = assert( type)",
    "type": "statement:localassign"
  }, {
    "id": 194,
    "text": "local pairs = assert( pairs)",
    "type": "statement:localassign"
  }, {
    "id": 195,
    "text": "local tostring = assert( tostring)",
    "type": "statement:localassign"
  }, {
    "id": 196,
    "text": "local error = assert( error)",
    "type": "statement:localassign"
  }, {
    "id": 197,
    "text": "local default_params =\r\n\t{\r\n\t\tnb_keepers = 1,\r\n\t\ton_state_create = nil,\r\n\t\tshutdown_timeout = 0.25,\r\n\t\twith_timers = true,\r\n\t\ttrack_lanes = false,\r\n\t\tdemote_full_userdata = nil,\r\n\t\tverbose_errors = false,\r\n\t\t-- LuaJIT provides a thread-unsafe allocator by default, so we need to protect it when used in parallel lanes\r\n\t\tprotect_allocator = (jit and jit.version) and true or false\r\n\t}",
    "type": "statement:localassign"
  }, {
    "id": 198,
    "text": "local boolean_param_checker = function( val_)\r\n\t\t-- non-'boolean-false' should be 'boolean-true' or nil\r\n\t\treturn val_ and (val_ == true) or true\r\n\tend",
    "type": "statement:localassign"
  }, {
    "id": 199,
    "text": "local param_checkers =\r\n\t{\r\n\t\tnb_keepers = function( val_)\r\n\t\t\t-- nb_keepers should be a number > 0\r\n\t\t\treturn type( val_) == \"number\" and val_ > 0\r\n\t\tend,\r\n\t\twith_timers = boolean_param_checker,\r\n\t\tprotect_allocator = boolean_param_checker,\r\n\t\ton_state_create = function( val_)\r\n\t\t\t-- on_state_create may be nil or a function\r\n\t\t\treturn val_ and type( val_) == \"function\" or true\r\n\t\tend,\r\n\t\tshutdown_timeout = function( val_)\r\n\t\t\t-- shutdown_timeout should be a number >= 0\r\n\t\t\treturn type( val_) == \"number\" and val_ >= 0\r\n\t\tend,\r\n\t\ttrack_lanes = boolean_param_checker,\r\n\t\tdemote_full_userdata = boolean_param_checker,\r\n\t\tverbose_errors = boolean_param_checker\r\n\t}",
    "type": "statement:localassign"
  }, {
    "id": 200,
    "text": "local params_checker = function( settings_)\r\n\t\tif not settings_ then\r\n\t\t\treturn default_params\r\n\t\tend\r\n\t\t-- make a copy of the table to leave the provided one unchanged, *and* to help ensure it won't change behind our back\r\n\t\tlocal settings = {}\r\n\t\tif type( settings_) ~= \"table\" then\r\n\t\t\terror \"Bad parameter #1 to lanes.configure(), should be a table\"\r\n\t\tend\r\n\t\t-- any setting not present in the provided parameters takes the default value\r\n\t\tfor key, checker in pairs( param_checkers) do\r\n\t\t\tlocal my_param = settings_[key]\r\n\t\t\tlocal param\r\n\t\t\tif my_param ~= nil then\r\n\t\t\t\tparam = my_param\r\n\t\t\telse\r\n\t\t\t\tparam = default_params[key]\r\n\t\t\tend\r\n\t\t\tif not checker( param) then\r\n\t\t\t\terror( \"Bad \" .. key .. \": \" .. tostring( param), 2)\r\n\t\t\tend\r\n\t\t\tsettings[key] = param\r\n\t\tend\r\n\t\treturn settings\r\n\tend",
    "type": "statement:localassign"
  }, {
    "id": 201,
    "text": "local settings = core.configure and core.configure( params_checker( settings_)) or core.settings",
    "type": "statement:localassign"
  }, {
    "id": 202,
    "text": "local core_lane_new = assert( core.lane_new)",
    "type": "statement:localassign"
  }, {
    "id": 203,
    "text": "local max_prio = assert( core.max_prio)",
    "type": "statement:localassign"
  }, {
    "id": 204,
    "text": "lanes.ABOUT =\r\n{\r\n\tauthor= \"Asko Kauppi <akauppi@gmail.com>, Benoit Germain <bnt.germain@gmail.com>\",\r\n\tdescription= \"Running multiple Lua states in parallel\",\r\n\tlicense= \"MIT/X11\",\r\n\tcopyright= \"Copyright (c) 2007-10, Asko Kauppi; (c) 2011-13, Benoit Germain\",\r\n\tversion = assert( core.version)\r\n}",
    "type": "statement:assign"
  }, {
    "id": 205,
    "text": "local valid_libs =\r\n{\r\n\t[\"package\"] = true,\r\n\t[\"table\"] = true,\r\n\t[\"io\"] = true,\r\n\t[\"os\"] = true,\r\n\t[\"string\"] = true,\r\n\t[\"math\"] = true,\r\n\t[\"debug\"] = true,\r\n\t[\"bit32\"] = true, -- Lua 5.2 only, ignored silently under 5.1\r\n\t--\r\n\t[\"base\"] = true,\r\n\t[\"coroutine\"] = true, -- part of \"base\" in Lua 5.1\r\n\t[\"lanes.core\"] = true\r\n}",
    "type": "statement:localassign"
  }, {
    "id": 206,
    "text": "local raise_option_error = function( name_, tv_, v_)\r\n\terror( \"Bad '\" .. name_ .. \"' option: \" .. tv_ .. \" \" .. string_format( \"%q\", tostring( v_)), 4)\r\nend",
    "type": "statement:localassign"
  }, {
    "id": 207,
    "text": "local opt_validators =\r\n{\r\n\tpriority = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"number\") and v_ or raise_option_error( \"priority\", tv, v_)\r\n\tend,\r\n\tcancelstep = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"number\") and v_ or (v_ == true) and 100 or (v_ == false) and 0 or raise_option_error( \"cancelstep\", tv, v_)\r\n\tend,\r\n\tglobals = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"table\") and v_ or raise_option_error( \"globals\", tv, v_)\r\n\tend,\r\n\tpackage = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"table\") and v_ or raise_option_error( \"package\", tv, v_)\r\n\tend,\r\n\trequired = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"table\") and v_ or raise_option_error( \"required\", tv, v_)\r\n\tend,\r\n\tgc_cb = function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"function\") and v_ or raise_option_error( \"gc_cb\", tv, v_)\r\n\tend\r\n}",
    "type": "statement:localassign"
  }, {
    "id": 208,
    "text": "local tv = type( v_)",
    "type": "statement:localassign"
  }, {
    "id": 209,
    "text": "local gen = function( ...)\r\n\t-- aggregrate all strings together, separated by \",\" as well as tables\r\n\t-- the strings are a list of libraries to open\r\n\t-- the tables contain the lane options\r\n\tlocal opt = {}\r\n\tlocal libs = nil\r\n\r\n\tlocal n = select( '#', ...)\r\n\r\n\t-- we need at least a function\r\n\tif n == 0 then\r\n\t\terror( \"No parameters!\", 2)\r\n\tend\r\n\r\n\t-- all arguments but the last must be nil, strings, or tables\r\n\tfor i = 1, n - 1 do\r\n\t\tlocal v = select( i, ...)\r\n\t\tlocal tv = type( v)\r\n\t\tif tv == \"string\" then\r\n\t\t\tlibs = libs and libs .. \",\" .. v or v\r\n\t\telseif tv == \"table\" then\r\n\t\t\tfor k, vv in pairs( v) do\r\n\t\t\t\topt[k]= vv\r\n\t\t\tend\r\n\t\telseif v == nil then\r\n\t\t\t-- skip\r\n\t\telse\r\n\t\t\terror( \"Bad parameter \" .. i .. \": \" .. tv .. \" \" .. string_format( \"%q\", tostring( v)), 2)\r\n\t\tend\r\n\tend\r\n\r\n\t-- the last argument should be a function or a string\r\n\tlocal func = select( n, ...)\r\n\tlocal functype = type( func)\r\n\tif functype ~= \"function\" and functype ~= \"string\" then\r\n\t\terror( \"Last parameter not function or string: \" .. functype .. \" \" .. string_format( \"%q\", tostring( func)), 2)\r\n\tend\r\n\r\n\t-- check that the caller only provides reserved library names, and those only once\r\n\t-- \"*\" is a special case that doesn't require individual checking\r\n\tif libs and libs ~= \"*\" then\r\n\t\tlocal found = {}\r\n\t\tfor s in string_gmatch(libs, \"[%a%d.]+\") do\r\n\t\t\tif not valid_libs[s] then\r\n\t\t\t\terror( \"Bad library name: \" .. s, 2)\r\n\t\t\telse\r\n\t\t\t\tfound[s] = (found[s] or 0) + 1\r\n\t\t\t\tif found[s] > 1 then\r\n\t\t\t\t\terror( \"libs specification contains '\" .. s .. \"' more than once\", 2)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\t-- validate that each option is known and properly valued\r\n\tfor k, v in pairs( opt) do\r\n\t\tlocal validator = opt_validators[k]\r\n\t\tif not validator then\r\n\t\t\terror( (type( k) == \"number\" and \"Unkeyed option: \" .. type( v) .. \" \" .. string_format( \"%q\", tostring( v)) or \"Bad '\" .. tostring( k) .. \"' option\"), 2)\r\n\t\telse\r\n\t\t\topt[k] = validator( v)\r\n\t\tend\r\n\tend\r\n\r\n\tlocal cancelstep, priority, globals, package, required, gc_cb = opt.cancelstep, opt.priority, opt.globals, opt.package or package, opt.required, opt.gc_cb\r\n\treturn function( ...)\r\n\t\t-- must pass functions args last else they will be truncated to the first one\r\n\t\treturn core_lane_new( func, libs, cancelstep, priority, globals, package, required, gc_cb, ...)\r\n\tend\r\nend",
    "type": "statement:localassign"
  }, {
    "id": 210,
    "text": "local timer = function() error \"timers are not active\" end",
    "type": "statement:localassign"
  }, {
    "id": 211,
    "text": "local timer_lane = nil",
    "type": "statement:localassign"
  }, {
    "id": 212,
    "text": "local timers = timer",
    "type": "statement:localassign"
  }, {
    "id": 213,
    "text": "if settings.with_timers ~= false then\r\n\r\nlocal timer_gateway = assert( core.timer_gateway)\r\n--\r\n-- On first 'require \"lanes\"', a timer lane is spawned that will maintain\r\n-- timer tables and sleep in between the timer events. All interaction with\r\n-- the timer lane happens via a 'timer_gateway' Linda, which is common to\r\n-- all that 'require \"lanes\"'.\r\n-- \r\n-- Linda protocol to timer lane:\r\n--\r\n--  TGW_KEY: linda_h, key, [wakeup_at_secs], [repeat_secs]\r\n--\r\nlocal TGW_KEY= \"(timer control)\"    -- the key does not matter, a 'weird' key may help debugging\r\nlocal TGW_QUERY, TGW_REPLY = \"(timer query)\", \"(timer reply)\"\r\nlocal first_time_key= \"first time\"\r\n\r\nlocal first_time= timer_gateway:get(first_time_key) == nil\r\ntimer_gateway:set(first_time_key,true)\r\n\r\n--\r\n-- Timer lane; initialize only on the first 'require \"lanes\"' instance (which naturally\r\n-- has 'table' always declared)\r\n--\r\nif first_time then\r\n\r\n\tlocal now_secs = core.now_secs\r\n\tassert( type( now_secs) == \"function\")\r\n\t-----\r\n\t-- Snore loop (run as a lane on the background)\r\n\t--\r\n\t-- High priority, to get trustworthy timings.\r\n\t--\r\n\t-- We let the timer lane be a \"free running\" thread; no handle to it\r\n\t-- remains.\r\n\t--\r\n\tlocal timer_body = function()\r\n\t\tset_debug_threadname( \"LanesTimer\")\r\n\t\t--\r\n\t\t-- { [deep_linda_lightuserdata]= { [deep_linda_lightuserdata]=linda_h, \r\n\t\t--                                 [key]= { wakeup_secs [,period_secs] } [, ...] },\r\n\t\t-- }\r\n\t\t--\r\n\t\t-- Collection of all running timers, indexed with linda's & key.\r\n\t\t--\r\n\t\t-- Note that we need to use the deep lightuserdata identifiers, instead\r\n\t\t-- of 'linda_h' themselves as table indices. Otherwise, we'd get multiple\r\n\t\t-- entries for the same timer.\r\n\t\t--\r\n\t\t-- The 'hidden' reference to Linda proxy is used in 'check_timers()' but\r\n\t\t-- also important to keep the Linda alive, even if all outside world threw\r\n\t\t-- away pointers to it (which would ruin uniqueness of the deep pointer).\r\n\t\t-- Now we're safe.\r\n\t\t--\r\n\t\tlocal collection = {}\r\n\t\tlocal table_insert = assert( table.insert)\r\n\r\n\t\tlocal get_timers = function()\r\n\t\t\tlocal r = {}\r\n\t\t\tfor deep, t in pairs( collection) do\r\n\t\t\t\t-- WR( tostring( deep))\r\n\t\t\t\tlocal l = t[deep]\r\n\t\t\t\tfor key, timer_data in pairs( t) do\r\n\t\t\t\t\tif key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn r\r\n\t\tend -- get_timers()\r\n\r\n\t\t--\r\n\t\t-- set_timer( linda_h, key [,wakeup_at_secs [,period_secs]] )\r\n\t\t--\r\n\t\tlocal set_timer = function( linda, key, wakeup_at, period)\r\n\t\t\tassert( wakeup_at == nil or wakeup_at > 0.0)\r\n\t\t\tassert( period == nil or period > 0.0)\r\n\r\n\t\t\tlocal linda_deep = linda:deep()\r\n\t\t\tassert( linda_deep)\r\n\r\n\t\t\t-- Find or make a lookup for this timer\r\n\t\t\t--\r\n\t\t\tlocal t1 = collection[linda_deep]\r\n\t\t\tif not t1 then\r\n\t\t\t\tt1 = { [linda_deep] = linda}     -- proxy to use the Linda\r\n\t\t\t\tcollection[linda_deep] = t1\r\n\t\t\tend\r\n\t\t\r\n\t\t\tif wakeup_at == nil then\r\n\t\t\t\t-- Clear the timer\r\n\t\t\t\t--\r\n\t\t\t\tt1[key]= nil\r\n\r\n\t\t\t\t-- Remove empty tables from collection; speeds timer checks and\r\n\t\t\t\t-- lets our 'safety reference' proxy be gc:ed as well.\r\n\t\t\t\t--\r\n\t\t\t\tlocal empty = true\r\n\t\t\t\tfor k, _ in pairs( t1) do\r\n\t\t\t\t\tif k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif empty then\r\n\t\t\t\t\tcollection[linda_deep] = nil\r\n\t\t\t\tend\r\n\r\n\t\t\t\t-- Note: any unread timer value is left at 'linda[key]' intensionally;\r\n\t\t\t\t--       clearing a timer just stops it.\r\n\t\t\telse\r\n\t\t\t\t-- New timer or changing the timings\r\n\t\t\t\t--\r\n\t\t\t\tlocal t2 = t1[key]\r\n\t\t\t\tif not t2 then\r\n\t\t\t\t\tt2= {}\r\n\t\t\t\t\tt1[key]= t2\r\n\t\t\t\tend\r\n\t\t\r\n\t\t\t\tt2[1] = wakeup_at\r\n\t\t\t\tt2[2] = period   -- can be 'nil'\r\n\t\t\tend\r\n\t\tend -- set_timer()\r\n\r\n\t\t-----\r\n\t\t-- [next_wakeup_at]= check_timers()\r\n\t\t-- Check timers, and wake up the ones expired (if any)\r\n\t\t-- Returns the closest upcoming (remaining) wakeup time (or 'nil' if none).\r\n\t\tlocal check_timers = function()\r\n\t\t\tlocal now = now_secs()\r\n\t\t\tlocal next_wakeup\r\n\r\n\t\t\tfor linda_deep,t1 in pairs(collection) do\r\n\t\t\t\tfor key,t2 in pairs(t1) do\r\n\t\t\t\t\t--\r\n\t\t\t\t\tif key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend\r\n\t\t\t\tend -- t2 loop\r\n\t\t\tend -- t1 loop\r\n\r\n\t\t\treturn next_wakeup  -- may be 'nil'\r\n\t\tend -- check_timers()\r\n\r\n\t\tlocal timer_gateway_batched = timer_gateway.batched\r\n\t\tset_finalizer( function( err, stk)\r\n\t\t\tif err and type( err) ~= \"userdata\" then\r\n\t\t\t\tWR( \"LanesTimer error: \"..tostring(err))\r\n\t\t\t--elseif type( err) == \"userdata\" then\r\n\t\t\t--\tWR( \"LanesTimer after cancel\" )\r\n\t\t\t--else\r\n\t\t\t--\tWR(\"LanesTimer finalized\")\r\n\t\t\tend\r\n\t\tend)\r\n\t\twhile true do\r\n\t\t\tlocal next_wakeup = check_timers()\r\n\r\n\t\t\t-- Sleep until next timer to wake up, or a set/clear command\r\n\t\t\t--\r\n\t\t\tlocal secs\r\n\t\t\tif next_wakeup then\r\n\t\t\t\tsecs =  next_wakeup - now_secs()\r\n\t\t\t\tif secs < 0 then secs = 0 end\r\n\t\t\tend\r\n\t\t\tlocal key, what = timer_gateway:receive( secs, TGW_KEY, TGW_QUERY)\r\n\r\n\t\t\tif key == TGW_KEY then\r\n\t\t\t\tassert( getmetatable( what) == \"Linda\") -- 'what' should be a linda on which the client sets a timer\r\n\t\t\t\tlocal _, key, wakeup_at, period = timer_gateway:receive( 0, timer_gateway_batched, TGW_KEY, 3)\r\n\t\t\t\tassert( key)\r\n\t\t\t\tset_timer( what, key, wakeup_at, period and period > 0 and period or nil)\r\n\t\t\telseif key == TGW_QUERY then\r\n\t\t\t\tif what == \"get_timers\" then\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, get_timers())\r\n\t\t\t\telse\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, \"unknown query \" .. what)\r\n\t\t\t\tend\r\n\t\t\t--elseif secs == nil then -- got no value while block-waiting?\r\n\t\t\t--\tWR( \"timer lane: no linda, aborted?\")\r\n\t\t\tend\r\n\t\tend\r\n\tend -- timer_body()\r\n\ttimer_lane = gen( \"*\", { package= {}, priority = max_prio}, timer_body)() -- \"*\" instead of \"io,package\" for LuaJIT compatibility...\r\nend -- first_time\r\n\r\n-----\r\n-- = timer( linda_h, key_val, date_tbl|first_secs [,period_secs] )\r\n--\r\n-- PUBLIC LANES API\r\ntimer = function( linda, key, a, period )\r\n    if getmetatable( linda) ~= \"Linda\" then\r\n        error \"expecting a Linda\"\r\n    end\r\n    if a == 0.0 then\r\n        -- Caller expects to get current time stamp in Linda, on return\r\n        -- (like the timer had expired instantly); it would be good to set this\r\n        -- as late as possible (to give most current time) but also we want it\r\n        -- to precede any possible timers that might start striking.\r\n        --\r\n        linda:set( key, core.now_secs())\r\n\r\n        if not period or period==0.0 then\r\n            timer_gateway:send( TGW_KEY, linda, key, nil, nil )   -- clear the timer\r\n            return  -- nothing more to do\r\n        end\r\n        a= period\r\n    end\r\n\r\n    local wakeup_at= type(a)==\"table\" and core.wakeup_conv(a)    -- given point of time\r\n                                       or (a and core.now_secs()+a or nil)\r\n    -- queue to timer\r\n    --\r\n    timer_gateway:send( TGW_KEY, linda, key, wakeup_at, period )\r\nend\r\n\r\n-----\r\n-- {[{linda, slot, when, period}[,...]]} = timers()\r\n--\r\n-- PUBLIC LANES API\r\ntimers = function()\r\n\ttimer_gateway:send( TGW_QUERY, \"get_timers\")\r\n\tlocal _, r = timer_gateway:receive( TGW_REPLY)\r\n\treturn r\r\nend\r\n\r\nend",
    "type": "statement:if"
  }, {
    "id": 214,
    "text": "local timer_gateway = assert( core.timer_gateway)",
    "type": "statement:localassign"
  }, {
    "id": 215,
    "text": "local TGW_KEY= \"(timer control)\"",
    "type": "statement:localassign"
  }, {
    "id": 216,
    "text": "local TGW_QUERY, TGW_REPLY = \"(timer query)\", \"(timer reply)\"",
    "type": "statement:localassign"
  }, {
    "id": 217,
    "text": "local first_time_key= \"first time\"",
    "type": "statement:localassign"
  }, {
    "id": 218,
    "text": "local first_time= timer_gateway:get(first_time_key) == nil",
    "type": "statement:localassign"
  }, {
    "id": 219,
    "text": "timer_gateway:set(first_time_key,true)",
    "type": "statement:functioncall"
  }, {
    "id": 220,
    "text": "if first_time then\r\n\r\n\tlocal now_secs = core.now_secs\r\n\tassert( type( now_secs) == \"function\")\r\n\t-----\r\n\t-- Snore loop (run as a lane on the background)\r\n\t--\r\n\t-- High priority, to get trustworthy timings.\r\n\t--\r\n\t-- We let the timer lane be a \"free running\" thread; no handle to it\r\n\t-- remains.\r\n\t--\r\n\tlocal timer_body = function()\r\n\t\tset_debug_threadname( \"LanesTimer\")\r\n\t\t--\r\n\t\t-- { [deep_linda_lightuserdata]= { [deep_linda_lightuserdata]=linda_h, \r\n\t\t--                                 [key]= { wakeup_secs [,period_secs] } [, ...] },\r\n\t\t-- }\r\n\t\t--\r\n\t\t-- Collection of all running timers, indexed with linda's & key.\r\n\t\t--\r\n\t\t-- Note that we need to use the deep lightuserdata identifiers, instead\r\n\t\t-- of 'linda_h' themselves as table indices. Otherwise, we'd get multiple\r\n\t\t-- entries for the same timer.\r\n\t\t--\r\n\t\t-- The 'hidden' reference to Linda proxy is used in 'check_timers()' but\r\n\t\t-- also important to keep the Linda alive, even if all outside world threw\r\n\t\t-- away pointers to it (which would ruin uniqueness of the deep pointer).\r\n\t\t-- Now we're safe.\r\n\t\t--\r\n\t\tlocal collection = {}\r\n\t\tlocal table_insert = assert( table.insert)\r\n\r\n\t\tlocal get_timers = function()\r\n\t\t\tlocal r = {}\r\n\t\t\tfor deep, t in pairs( collection) do\r\n\t\t\t\t-- WR( tostring( deep))\r\n\t\t\t\tlocal l = t[deep]\r\n\t\t\t\tfor key, timer_data in pairs( t) do\r\n\t\t\t\t\tif key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn r\r\n\t\tend -- get_timers()\r\n\r\n\t\t--\r\n\t\t-- set_timer( linda_h, key [,wakeup_at_secs [,period_secs]] )\r\n\t\t--\r\n\t\tlocal set_timer = function( linda, key, wakeup_at, period)\r\n\t\t\tassert( wakeup_at == nil or wakeup_at > 0.0)\r\n\t\t\tassert( period == nil or period > 0.0)\r\n\r\n\t\t\tlocal linda_deep = linda:deep()\r\n\t\t\tassert( linda_deep)\r\n\r\n\t\t\t-- Find or make a lookup for this timer\r\n\t\t\t--\r\n\t\t\tlocal t1 = collection[linda_deep]\r\n\t\t\tif not t1 then\r\n\t\t\t\tt1 = { [linda_deep] = linda}     -- proxy to use the Linda\r\n\t\t\t\tcollection[linda_deep] = t1\r\n\t\t\tend\r\n\t\t\r\n\t\t\tif wakeup_at == nil then\r\n\t\t\t\t-- Clear the timer\r\n\t\t\t\t--\r\n\t\t\t\tt1[key]= nil\r\n\r\n\t\t\t\t-- Remove empty tables from collection; speeds timer checks and\r\n\t\t\t\t-- lets our 'safety reference' proxy be gc:ed as well.\r\n\t\t\t\t--\r\n\t\t\t\tlocal empty = true\r\n\t\t\t\tfor k, _ in pairs( t1) do\r\n\t\t\t\t\tif k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif empty then\r\n\t\t\t\t\tcollection[linda_deep] = nil\r\n\t\t\t\tend\r\n\r\n\t\t\t\t-- Note: any unread timer value is left at 'linda[key]' intensionally;\r\n\t\t\t\t--       clearing a timer just stops it.\r\n\t\t\telse\r\n\t\t\t\t-- New timer or changing the timings\r\n\t\t\t\t--\r\n\t\t\t\tlocal t2 = t1[key]\r\n\t\t\t\tif not t2 then\r\n\t\t\t\t\tt2= {}\r\n\t\t\t\t\tt1[key]= t2\r\n\t\t\t\tend\r\n\t\t\r\n\t\t\t\tt2[1] = wakeup_at\r\n\t\t\t\tt2[2] = period   -- can be 'nil'\r\n\t\t\tend\r\n\t\tend -- set_timer()\r\n\r\n\t\t-----\r\n\t\t-- [next_wakeup_at]= check_timers()\r\n\t\t-- Check timers, and wake up the ones expired (if any)\r\n\t\t-- Returns the closest upcoming (remaining) wakeup time (or 'nil' if none).\r\n\t\tlocal check_timers = function()\r\n\t\t\tlocal now = now_secs()\r\n\t\t\tlocal next_wakeup\r\n\r\n\t\t\tfor linda_deep,t1 in pairs(collection) do\r\n\t\t\t\tfor key,t2 in pairs(t1) do\r\n\t\t\t\t\t--\r\n\t\t\t\t\tif key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend\r\n\t\t\t\tend -- t2 loop\r\n\t\t\tend -- t1 loop\r\n\r\n\t\t\treturn next_wakeup  -- may be 'nil'\r\n\t\tend -- check_timers()\r\n\r\n\t\tlocal timer_gateway_batched = timer_gateway.batched\r\n\t\tset_finalizer( function( err, stk)\r\n\t\t\tif err and type( err) ~= \"userdata\" then\r\n\t\t\t\tWR( \"LanesTimer error: \"..tostring(err))\r\n\t\t\t--elseif type( err) == \"userdata\" then\r\n\t\t\t--\tWR( \"LanesTimer after cancel\" )\r\n\t\t\t--else\r\n\t\t\t--\tWR(\"LanesTimer finalized\")\r\n\t\t\tend\r\n\t\tend)\r\n\t\twhile true do\r\n\t\t\tlocal next_wakeup = check_timers()\r\n\r\n\t\t\t-- Sleep until next timer to wake up, or a set/clear command\r\n\t\t\t--\r\n\t\t\tlocal secs\r\n\t\t\tif next_wakeup then\r\n\t\t\t\tsecs =  next_wakeup - now_secs()\r\n\t\t\t\tif secs < 0 then secs = 0 end\r\n\t\t\tend\r\n\t\t\tlocal key, what = timer_gateway:receive( secs, TGW_KEY, TGW_QUERY)\r\n\r\n\t\t\tif key == TGW_KEY then\r\n\t\t\t\tassert( getmetatable( what) == \"Linda\") -- 'what' should be a linda on which the client sets a timer\r\n\t\t\t\tlocal _, key, wakeup_at, period = timer_gateway:receive( 0, timer_gateway_batched, TGW_KEY, 3)\r\n\t\t\t\tassert( key)\r\n\t\t\t\tset_timer( what, key, wakeup_at, period and period > 0 and period or nil)\r\n\t\t\telseif key == TGW_QUERY then\r\n\t\t\t\tif what == \"get_timers\" then\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, get_timers())\r\n\t\t\t\telse\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, \"unknown query \" .. what)\r\n\t\t\t\tend\r\n\t\t\t--elseif secs == nil then -- got no value while block-waiting?\r\n\t\t\t--\tWR( \"timer lane: no linda, aborted?\")\r\n\t\t\tend\r\n\t\tend\r\n\tend -- timer_body()\r\n\ttimer_lane = gen( \"*\", { package= {}, priority = max_prio}, timer_body)() -- \"*\" instead of \"io,package\" for LuaJIT compatibility...\r\nend",
    "type": "statement:if"
  }, {
    "id": 221,
    "text": "local now_secs = core.now_secs",
    "type": "statement:localassign"
  }, {
    "id": 222,
    "text": "assert( type( now_secs) == \"function\")",
    "type": "statement:functioncall"
  }, {
    "id": 223,
    "text": "local timer_body = function()\r\n\t\tset_debug_threadname( \"LanesTimer\")\r\n\t\t--\r\n\t\t-- { [deep_linda_lightuserdata]= { [deep_linda_lightuserdata]=linda_h, \r\n\t\t--                                 [key]= { wakeup_secs [,period_secs] } [, ...] },\r\n\t\t-- }\r\n\t\t--\r\n\t\t-- Collection of all running timers, indexed with linda's & key.\r\n\t\t--\r\n\t\t-- Note that we need to use the deep lightuserdata identifiers, instead\r\n\t\t-- of 'linda_h' themselves as table indices. Otherwise, we'd get multiple\r\n\t\t-- entries for the same timer.\r\n\t\t--\r\n\t\t-- The 'hidden' reference to Linda proxy is used in 'check_timers()' but\r\n\t\t-- also important to keep the Linda alive, even if all outside world threw\r\n\t\t-- away pointers to it (which would ruin uniqueness of the deep pointer).\r\n\t\t-- Now we're safe.\r\n\t\t--\r\n\t\tlocal collection = {}\r\n\t\tlocal table_insert = assert( table.insert)\r\n\r\n\t\tlocal get_timers = function()\r\n\t\t\tlocal r = {}\r\n\t\t\tfor deep, t in pairs( collection) do\r\n\t\t\t\t-- WR( tostring( deep))\r\n\t\t\t\tlocal l = t[deep]\r\n\t\t\t\tfor key, timer_data in pairs( t) do\r\n\t\t\t\t\tif key ~= deep then\r\n\t\t\t\t\t\ttable_insert( r, {l, key, timer_data})\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn r\r\n\t\tend -- get_timers()\r\n\r\n\t\t--\r\n\t\t-- set_timer( linda_h, key [,wakeup_at_secs [,period_secs]] )\r\n\t\t--\r\n\t\tlocal set_timer = function( linda, key, wakeup_at, period)\r\n\t\t\tassert( wakeup_at == nil or wakeup_at > 0.0)\r\n\t\t\tassert( period == nil or period > 0.0)\r\n\r\n\t\t\tlocal linda_deep = linda:deep()\r\n\t\t\tassert( linda_deep)\r\n\r\n\t\t\t-- Find or make a lookup for this timer\r\n\t\t\t--\r\n\t\t\tlocal t1 = collection[linda_deep]\r\n\t\t\tif not t1 then\r\n\t\t\t\tt1 = { [linda_deep] = linda}     -- proxy to use the Linda\r\n\t\t\t\tcollection[linda_deep] = t1\r\n\t\t\tend\r\n\t\t\r\n\t\t\tif wakeup_at == nil then\r\n\t\t\t\t-- Clear the timer\r\n\t\t\t\t--\r\n\t\t\t\tt1[key]= nil\r\n\r\n\t\t\t\t-- Remove empty tables from collection; speeds timer checks and\r\n\t\t\t\t-- lets our 'safety reference' proxy be gc:ed as well.\r\n\t\t\t\t--\r\n\t\t\t\tlocal empty = true\r\n\t\t\t\tfor k, _ in pairs( t1) do\r\n\t\t\t\t\tif k ~= linda_deep then\r\n\t\t\t\t\t\tempty = false\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif empty then\r\n\t\t\t\t\tcollection[linda_deep] = nil\r\n\t\t\t\tend\r\n\r\n\t\t\t\t-- Note: any unread timer value is left at 'linda[key]' intensionally;\r\n\t\t\t\t--       clearing a timer just stops it.\r\n\t\t\telse\r\n\t\t\t\t-- New timer or changing the timings\r\n\t\t\t\t--\r\n\t\t\t\tlocal t2 = t1[key]\r\n\t\t\t\tif not t2 then\r\n\t\t\t\t\tt2= {}\r\n\t\t\t\t\tt1[key]= t2\r\n\t\t\t\tend\r\n\t\t\r\n\t\t\t\tt2[1] = wakeup_at\r\n\t\t\t\tt2[2] = period   -- can be 'nil'\r\n\t\t\tend\r\n\t\tend -- set_timer()\r\n\r\n\t\t-----\r\n\t\t-- [next_wakeup_at]= check_timers()\r\n\t\t-- Check timers, and wake up the ones expired (if any)\r\n\t\t-- Returns the closest upcoming (remaining) wakeup time (or 'nil' if none).\r\n\t\tlocal check_timers = function()\r\n\t\t\tlocal now = now_secs()\r\n\t\t\tlocal next_wakeup\r\n\r\n\t\t\tfor linda_deep,t1 in pairs(collection) do\r\n\t\t\t\tfor key,t2 in pairs(t1) do\r\n\t\t\t\t\t--\r\n\t\t\t\t\tif key==linda_deep then\r\n\t\t\t\t\t\t-- no 'continue' in Lua :/\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t-- 't2': { wakeup_at_secs [,period_secs] }\r\n\t\t\t\t\t\t--\r\n\t\t\t\t\t\tlocal wakeup_at= t2[1]\r\n\t\t\t\t\t\tlocal period= t2[2]     -- may be 'nil'\r\n\r\n\t\t\t\t\t\tif wakeup_at <= now then    \r\n\t\t\t\t\t\t\tlocal linda= t1[linda_deep]\r\n\t\t\t\t\t\t\tassert(linda)\r\n\t\t\r\n\t\t\t\t\t\t\tlinda:set( key, now )\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t-- 'pairs()' allows the values to be modified (and even\r\n\t\t\t\t\t\t\t-- removed) as far as keys are not touched\r\n\r\n\t\t\t\t\t\t\tif not period then\r\n\t\t\t\t\t\t\t\t-- one-time timer; gone\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\tt1[key]= nil\r\n\t\t\t\t\t\t\t\twakeup_at= nil   -- no 'continue' in Lua :/\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t-- repeating timer; find next wakeup (may jump multiple repeats)\r\n\t\t\t\t\t\t\t\t--\r\n\t\t\t\t\t\t\t\trepeat\r\n\t\t\t\t\t\t\t\t\t\twakeup_at= wakeup_at+period\r\n\t\t\t\t\t\t\t\tuntil wakeup_at > now\r\n\r\n\t\t\t\t\t\t\t\tt2[1]= wakeup_at\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\r\n\t\t\t\t\t\t\tnext_wakeup= wakeup_at\r\n\t\t\t\t\t\tend \r\n\t\t\t\t\tend\r\n\t\t\t\tend -- t2 loop\r\n\t\t\tend -- t1 loop\r\n\r\n\t\t\treturn next_wakeup  -- may be 'nil'\r\n\t\tend -- check_timers()\r\n\r\n\t\tlocal timer_gateway_batched = timer_gateway.batched\r\n\t\tset_finalizer( function( err, stk)\r\n\t\t\tif err and type( err) ~= \"userdata\" then\r\n\t\t\t\tWR( \"LanesTimer error: \"..tostring(err))\r\n\t\t\t--elseif type( err) == \"userdata\" then\r\n\t\t\t--\tWR( \"LanesTimer after cancel\" )\r\n\t\t\t--else\r\n\t\t\t--\tWR(\"LanesTimer finalized\")\r\n\t\t\tend\r\n\t\tend)\r\n\t\twhile true do\r\n\t\t\tlocal next_wakeup = check_timers()\r\n\r\n\t\t\t-- Sleep until next timer to wake up, or a set/clear command\r\n\t\t\t--\r\n\t\t\tlocal secs\r\n\t\t\tif next_wakeup then\r\n\t\t\t\tsecs =  next_wakeup - now_secs()\r\n\t\t\t\tif secs < 0 then secs = 0 end\r\n\t\t\tend\r\n\t\t\tlocal key, what = timer_gateway:receive( secs, TGW_KEY, TGW_QUERY)\r\n\r\n\t\t\tif key == TGW_KEY then\r\n\t\t\t\tassert( getmetatable( what) == \"Linda\") -- 'what' should be a linda on which the client sets a timer\r\n\t\t\t\tlocal _, key, wakeup_at, period = timer_gateway:receive( 0, timer_gateway_batched, TGW_KEY, 3)\r\n\t\t\t\tassert( key)\r\n\t\t\t\tset_timer( what, key, wakeup_at, period and period > 0 and period or nil)\r\n\t\t\telseif key == TGW_QUERY then\r\n\t\t\t\tif what == \"get_timers\" then\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, get_timers())\r\n\t\t\t\telse\r\n\t\t\t\t\ttimer_gateway:send( TGW_REPLY, \"unknown query \" .. what)\r\n\t\t\t\tend\r\n\t\t\t--elseif secs == nil then -- got no value while block-waiting?\r\n\t\t\t--\tWR( \"timer lane: no linda, aborted?\")\r\n\t\t\tend\r\n\t\tend\r\n\tend",
    "type": "statement:localassign"
  }, {
    "id": 224,
    "text": "timer_lane = gen( \"*\", { package= {}, priority = max_prio}, timer_body)()",
    "type": "statement:assign"
  }, {
    "id": 225,
    "text": "timer = function( linda, key, a, period )\r\n    if getmetatable( linda) ~= \"Linda\" then\r\n        error \"expecting a Linda\"\r\n    end\r\n    if a == 0.0 then\r\n        -- Caller expects to get current time stamp in Linda, on return\r\n        -- (like the timer had expired instantly); it would be good to set this\r\n        -- as late as possible (to give most current time) but also we want it\r\n        -- to precede any possible timers that might start striking.\r\n        --\r\n        linda:set( key, core.now_secs())\r\n\r\n        if not period or period==0.0 then\r\n            timer_gateway:send( TGW_KEY, linda, key, nil, nil )   -- clear the timer\r\n            return  -- nothing more to do\r\n        end\r\n        a= period\r\n    end\r\n\r\n    local wakeup_at= type(a)==\"table\" and core.wakeup_conv(a)    -- given point of time\r\n                                       or (a and core.now_secs()+a or nil)\r\n    -- queue to timer\r\n    --\r\n    timer_gateway:send( TGW_KEY, linda, key, wakeup_at, period )\r\nend",
    "type": "statement:assign"
  }, {
    "id": 226,
    "text": "timers = function()\r\n\ttimer_gateway:send( TGW_QUERY, \"get_timers\")\r\n\tlocal _, r = timer_gateway:receive( TGW_REPLY)\r\n\treturn r\r\nend",
    "type": "statement:assign"
  }, {
    "id": 227,
    "text": "local cancel_error = assert( core.cancel_error)",
    "type": "statement:localassign"
  }, {
    "id": 228,
    "text": "local genlock = function( linda, key, N)\r\n\t-- clear existing data and set the limit\r\n\tN = N or 1\r\n\tif linda:set( key) == cancel_error or linda:limit( key, N) == cancel_error then\r\n\t\treturn cancel_error\r\n\tend\r\n\r\n\t-- use an optimized version for case N == 1\r\n\treturn (N == 1) and\r\n\tfunction( M, mode_)\r\n\t\tlocal timeout = (mode_ == \"try\") and 0 or nil\r\n\t\tif M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, true)    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, key)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend\r\n\tend\r\n\tor\r\n\tfunction( M, mode_)\r\n\t\tlocal timeout = (mode_ == \"try\") and 0 or nil\r\n\t\tif M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, trues(M))    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, linda.batched, key, -M)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend\r\n\tend\r\nend",
    "type": "statement:localassign"
  }, {
    "id": 229,
    "text": "local genatomic = function( linda, key, initial_val)\r\n\t\t-- clears existing data (also queue). the slot may contain the stored value, and an additional boolean value\r\n\t\tif linda:limit( key, 2) == cancel_error or linda:set( key, initial_val or 0.0) == cancel_error then\r\n\t\t\treturn cancel_error\r\n\t\tend\r\n\r\n\t\treturn function( diff)\r\n\t\t\t-- 'nil' allows 'key' to be numeric\r\n\t\t\t-- suspends until our 'true' is in\r\n\t\t\tif linda:send( nil, key, true) == cancel_error then\r\n\t\t\t\treturn cancel_error\r\n\t\t\tend\r\n\t\t\tlocal val = linda:get( key)\r\n\t\t\tif val ~= cancel_error then\r\n\t\t\t\tval = val + (diff or 1.0)\r\n\t\t\t\t-- set() releases the lock by emptying queue\r\n\t\t\t\tif linda:set( key, val) == cancel_error then\r\n\t\t\t\t\tval = cancel_error\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn val\r\n\t\tend\r\n\tend",
    "type": "statement:localassign"
  }, {
    "id": 230,
    "text": "lanes.require = core.require",
    "type": "statement:assign"
  }, {
    "id": 231,
    "text": "lanes.gen = gen",
    "type": "statement:assign"
  }, {
    "id": 232,
    "text": "lanes.linda = core.linda",
    "type": "statement:assign"
  }, {
    "id": 233,
    "text": "lanes.cancel_error = core.cancel_error",
    "type": "statement:assign"
  }, {
    "id": 234,
    "text": "lanes.nameof = core.nameof",
    "type": "statement:assign"
  }, {
    "id": 235,
    "text": "lanes.set_singlethreaded = core.set_singlethreaded",
    "type": "statement:assign"
  }, {
    "id": 236,
    "text": "lanes.threads = core.threads or function() error \"lane tracking is not available\" end",
    "type": "statement:assign"
  }, {
    "id": 237,
    "text": "lanes.set_thread_priority = core.set_thread_priority",
    "type": "statement:assign"
  }, {
    "id": 238,
    "text": "lanes.timer = timer",
    "type": "statement:assign"
  }, {
    "id": 239,
    "text": "lanes.timer_lane = timer_lane",
    "type": "statement:assign"
  }, {
    "id": 240,
    "text": "lanes.timers = timers",
    "type": "statement:assign"
  }, {
    "id": 241,
    "text": "lanes.genlock = genlock",
    "type": "statement:assign"
  }, {
    "id": 242,
    "text": "lanes.now_secs = core.now_secs",
    "type": "statement:assign"
  }, {
    "id": 243,
    "text": "lanes.genatomic = genatomic",
    "type": "statement:assign"
  }, {
    "id": 244,
    "text": "lanes.configure = nil",
    "type": "statement:assign"
  }, {
    "id": 245,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 246,
    "text": "function( val_)\r\n\t\t\t-- nb_keepers should be a number > 0\r\n\t\t\treturn type( val_) == \"number\" and val_ > 0\r\n\t\tend",
    "type": "function"
  }, {
    "id": 247,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 248,
    "text": "function( val_)\r\n\t\t\t-- on_state_create may be nil or a function\r\n\t\t\treturn val_ and type( val_) == \"function\" or true\r\n\t\tend",
    "type": "function"
  }, {
    "id": 249,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 250,
    "text": "function( val_)\r\n\t\t\t-- shutdown_timeout should be a number >= 0\r\n\t\t\treturn type( val_) == \"number\" and val_ >= 0\r\n\t\tend",
    "type": "function"
  }, {
    "id": 251,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 252,
    "text": "function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"number\") and v_ or raise_option_error( \"priority\", tv, v_)\r\n\tend",
    "type": "function"
  }, {
    "id": 253,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 254,
    "text": "function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"number\") and v_ or (v_ == true) and 100 or (v_ == false) and 0 or raise_option_error( \"cancelstep\", tv, v_)\r\n\tend",
    "type": "function"
  }, {
    "id": 255,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 256,
    "text": "function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"table\") and v_ or raise_option_error( \"globals\", tv, v_)\r\n\tend",
    "type": "function"
  }, {
    "id": 257,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 258,
    "text": "function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"table\") and v_ or raise_option_error( \"package\", tv, v_)\r\n\tend",
    "type": "function"
  }, {
    "id": 259,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 260,
    "text": "function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"table\") and v_ or raise_option_error( \"required\", tv, v_)\r\n\tend",
    "type": "function"
  }, {
    "id": 261,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 262,
    "text": "function( v_)\r\n\t\tlocal tv = type( v_)\r\n\t\treturn (tv == \"function\") and v_ or raise_option_error( \"gc_cb\", tv, v_)\r\n\tend",
    "type": "function"
  }, {
    "id": 263,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 264,
    "text": "function( ...)\r\n\t\t-- must pass functions args last else they will be truncated to the first one\r\n\t\treturn core_lane_new( func, libs, cancelstep, priority, globals, package, required, gc_cb, ...)\r\n\tend",
    "type": "function"
  }, {
    "id": 265,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 266,
    "text": "function( err, stk)\r\n\t\t\tif err and type( err) ~= \"userdata\" then\r\n\t\t\t\tWR( \"LanesTimer error: \"..tostring(err))\r\n\t\t\t--elseif type( err) == \"userdata\" then\r\n\t\t\t--\tWR( \"LanesTimer after cancel\" )\r\n\t\t\t--else\r\n\t\t\t--\tWR(\"LanesTimer finalized\")\r\n\t\t\tend\r\n\t\tend",
    "type": "function"
  }, {
    "id": 267,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 268,
    "text": "function( M, mode_)\r\n\t\tlocal timeout = (mode_ == \"try\") and 0 or nil\r\n\t\tif M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, true)    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, key)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend\r\n\tend",
    "type": "function"
  }, {
    "id": 269,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 270,
    "text": "function( M, mode_)\r\n\t\tlocal timeout = (mode_ == \"try\") and 0 or nil\r\n\t\tif M > 0 then\r\n\t\t\t-- 'nil' timeout allows 'key' to be numeric\r\n\t\t\treturn linda:send( timeout, key, trues(M))    -- suspends until been able to push them\r\n\t\telse\r\n\t\t\tlocal k = linda:receive( nil, linda.batched, key, -M)\r\n\t\t\t-- propagate cancel_error if we got it, else return true or false\r\n\t\t\treturn k and ((k ~= cancel_error) and true or k) or false\r\n\t\tend\r\n\tend",
    "type": "function"
  }, {
    "id": 271,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 272,
    "text": "function( diff)\r\n\t\t\t-- 'nil' allows 'key' to be numeric\r\n\t\t\t-- suspends until our 'true' is in\r\n\t\t\tif linda:send( nil, key, true) == cancel_error then\r\n\t\t\t\treturn cancel_error\r\n\t\t\tend\r\n\t\t\tlocal val = linda:get( key)\r\n\t\t\tif val ~= cancel_error then\r\n\t\t\t\tval = val + (diff or 1.0)\r\n\t\t\t\t-- set() releases the lock by emptying queue\r\n\t\t\t\tif linda:set( key, val) == cancel_error then\r\n\t\t\t\t\tval = cancel_error\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\treturn val\r\n\t\tend",
    "type": "function"
  }, {
    "id": 273,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 274,
    "text": "",
    "type": "function container"
  }, {
    "id": 275,
    "text": "",
    "type": "function container"
  }, {
    "id": 276,
    "text": "",
    "type": "function container"
  }, {
    "id": 277,
    "text": "",
    "type": "function container"
  }, {
    "id": 278,
    "text": "",
    "type": "function container"
  }, {
    "id": 279,
    "text": "",
    "type": "function container"
  }, {
    "id": 280,
    "text": "",
    "type": "function container"
  }, {
    "id": 281,
    "text": "",
    "type": "function container"
  }, {
    "id": 282,
    "text": "",
    "type": "function container"
  }, {
    "id": 283,
    "text": "local function fib( n )\r\n    set_debug_threadname( \"fib(\" .. n .. \")\")\r\n    local lanes = require\"lanes\"\r\n    --\r\n    local sum\r\n    local floor= assert(math.floor)\r\n\r\n    WR( \"fib(\"..n..\")\" )\r\n\r\n    if n <= #KNOWN then\r\n        sum= KNOWN[n]\r\n    else\r\n        -- Splits into two; this task remains waiting for the results\r\n        --\r\n        local gen_f= lanes.gen( \"*\", fib)\r\n\r\n        local n1=floor(n/2) +1\r\n        local n2=floor(n/2) -1 + n%2\r\n\r\n        WR( \"splitting \"..n..\" -> \"..n1..\" \"..n2 )\r\n\r\n        local a= gen_f( n1 )\r\n        local b= gen_f( n2 )\r\n\r\n        -- children running...\r\n\r\n        local a2= a[1]^2\r\n        local b2= b[1]^2\r\n\r\n        sum = (n%2==1) and a2+b2 or a2-b2\r\n    end\r\n\r\n    io.stderr:write( \"fib(\"..n..\") = \"..sum..\"\\n\" )\r\n\r\n    return sum\r\nend",
    "type": "function"
  }, {
    "id": 284,
    "text": "",
    "type": "function container"
  }, {
    "id": 285,
    "text": "",
    "type": "function container"
  }, {
    "id": 286,
    "text": "",
    "type": "function container"
  }, {
    "id": 287,
    "text": "",
    "type": "function container"
  }, {
    "id": 288,
    "text": "",
    "type": "function container"
  }, {
    "id": 289,
    "text": "local function recurse()\r\n    print(\"level \"..i);\r\n    if i > 10 then return \"finished\" end\r\n\r\n    --local lanes = require \"lanes\"\r\n\r\n    local lane = lanes.gen( \"base,string,lanes.core\", { globals = { [\"i\"]= i + 1 } }, recurse ) ()\r\n    return lane[1]\r\nend",
    "type": "function"
  }, {
    "id": 290,
    "text": "",
    "type": "function container"
  }, {
    "id": 291,
    "text": "",
    "type": "function container"
  }, {
    "id": 292,
    "text": "",
    "type": "function container"
  }, {
    "id": 293,
    "text": "",
    "type": "function container"
  }, {
    "id": 294,
    "text": "",
    "type": "function container"
  }, {
    "id": 295,
    "text": "",
    "type": "function container"
  }, {
    "id": 296,
    "text": "",
    "type": "function container"
  }, {
    "id": 297,
    "text": "",
    "type": "function container"
  }, {
    "id": 298,
    "text": "local function func( depth )\r\n    io.stderr:write(\" \" .. depth)\r\n    if depth > 10 then\r\n        return \"done!\"\r\n    end\r\n\r\n    local lanes = require \"lanes\"\r\n    -- lanes.configure() is available only at the first require()\r\n    if lanes.configure then\r\n\t\t\tlanes = lanes.configure{with_timers = false}\r\n\t\tend\r\n    local lane= lanes.gen(\"*\", func)( depth+1 )\r\n    return lane[1]\r\nend",
    "type": "function"
  }, {
    "id": 299,
    "text": "local function a_lane()\r\n\t\tprint \"IN A LANE\"\r\n    -- To require 'math' we still actually need to have it initialized for\r\n    -- the lane.\r\n    --\r\n    require \"math\"\r\n    assert( math and math.sqrt )\r\n    assert( math.sqrt(4)==2 )\r\n\r\n    assert( lanes==nil )\r\n    local lanes = require \"lanes\".configure{with_timers = false}\r\n    assert( lanes and lanes.gen )\r\n\r\n    local h= lanes.gen( function() return 42 end ) ()\r\n    local v= h[1]\r\n\r\n    return v==42\r\nend",
    "type": "function"
  }, {
    "id": 300,
    "text": "",
    "type": "function container"
  }, {
    "id": 301,
    "text": "",
    "type": "function container"
  }, {
    "id": 302,
    "text": "",
    "type": "function container"
  }, {
    "id": 303,
    "text": "now_secs",
    "type": "global function"
  }, {
    "id": 304,
    "text": "linda",
    "type": "global function"
  }, {
    "id": 305,
    "text": "configure",
    "type": "global function"
  }, {
    "id": 306,
    "text": "set_singlethreaded",
    "type": "global function"
  }, {
    "id": 307,
    "text": "nameof",
    "type": "global function"
  }, {
    "id": 308,
    "text": "wakeup_conv",
    "type": "global function"
  }, {
    "id": 309,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 310,
    "text": "validator",
    "type": "global function"
  }, {
    "id": 311,
    "text": "table_insert",
    "type": "global function"
  }, {
    "id": 312,
    "text": "set_finalizer",
    "type": "global function"
  }, {
    "id": 313,
    "text": "checker",
    "type": "global function"
  }, {
    "id": 314,
    "text": "type",
    "type": "global function"
  }, {
    "id": 315,
    "text": "pairs",
    "type": "global function"
  }, {
    "id": 316,
    "text": "error",
    "type": "global function"
  }, {
    "id": 317,
    "text": "require",
    "type": "global function"
  }, {
    "id": 318,
    "text": "core_lane_new",
    "type": "global function"
  }, {
    "id": 319,
    "text": "now_secs",
    "type": "global function"
  }, {
    "id": 320,
    "text": "set_debug_threadname",
    "type": "global function"
  }, {
    "id": 321,
    "text": "string_format",
    "type": "global function"
  }, {
    "id": 322,
    "text": "string_gmatch",
    "type": "global function"
  }, {
    "id": 323,
    "text": "select",
    "type": "global function"
  }, {
    "id": 324,
    "text": "getmetatable",
    "type": "global function"
  }, {
    "id": 325,
    "text": "tostring",
    "type": "global function"
  }, {
    "id": 326,
    "text": "",
    "type": "variable container"
  }, {
    "id": 327,
    "text": "",
    "type": "require container"
  }, {
    "id": 328,
    "text": "",
    "type": "local variable"
  }, {
    "id": 329,
    "text": "",
    "type": "tableconstructor"
  }, {
    "id": 330,
    "text": "",
    "type": "global variable"
  }, {
    "id": 331,
    "text": "",
    "type": "n/a"
  }, {
    "id": 332,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 333,
    "text": "core",
    "type": "module"
  }, {
    "id": 334,
    "text": "",
    "type": "interface container"
  }, {
    "id": 335,
    "text": "",
    "type": "interface"
  }, {
    "id": 336,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 337,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 338,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 339,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 340,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 341,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 342,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 343,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 344,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 345,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 346,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 347,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 348,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 349,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 350,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 351,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 352,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 353,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 354,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 355,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 356,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 357,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 358,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 359,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 360,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 361,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 362,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 363,
    "text": "",
    "type": "require local variable"
  } ]
}