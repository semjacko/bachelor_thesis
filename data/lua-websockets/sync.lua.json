{
  "_filename": "sync.lua",
  "_isShebang": false,
  "_isSpec": false,
  "_isTest": false,
  "_path": "modules/lua-websockets/src/websocket/sync.lua",
  "edges": [ {
    "from": 0,
    "label": "implements",
    "to": 3
  }, {
    "from": 5,
    "label": "calls",
    "to": 94
  }, {
    "from": 6,
    "label": "calls",
    "to": 94
  }, {
    "from": 14,
    "label": "calls",
    "to": 94
  }, {
    "from": 15,
    "label": "has",
    "to": 16
  }, {
    "from": 15,
    "label": "has",
    "to": 17
  }, {
    "from": 17,
    "label": "has",
    "to": 18
  }, {
    "from": 15,
    "label": "has",
    "to": 19
  }, {
    "from": 15,
    "label": "has",
    "to": 20
  }, {
    "from": 21,
    "label": "has",
    "to": 22
  }, {
    "from": 21,
    "label": "has",
    "to": 19
  }, {
    "from": 21,
    "label": "has",
    "to": 23
  }, {
    "from": 21,
    "label": "has",
    "to": 24
  }, {
    "from": 21,
    "label": "has",
    "to": 25
  }, {
    "from": 21,
    "label": "has",
    "to": 26
  }, {
    "from": 21,
    "label": "has",
    "to": 27
  }, {
    "from": 27,
    "label": "has",
    "to": 16
  }, {
    "from": 27,
    "label": "has",
    "to": 17
  }, {
    "from": 17,
    "label": "has",
    "to": 18
  }, {
    "from": 27,
    "label": "has",
    "to": 19
  }, {
    "from": 21,
    "label": "has",
    "to": 28
  }, {
    "from": 28,
    "label": "has",
    "to": 29
  }, {
    "from": 28,
    "label": "has",
    "to": 30
  }, {
    "from": 28,
    "label": "has",
    "to": 31
  }, {
    "from": 28,
    "label": "has",
    "to": 32
  }, {
    "from": 28,
    "label": "has",
    "to": 33
  }, {
    "from": 28,
    "label": "has",
    "to": 34
  }, {
    "from": 34,
    "label": "has",
    "to": 35
  }, {
    "from": 35,
    "label": "has",
    "to": 36
  }, {
    "from": 36,
    "label": "has",
    "to": 37
  }, {
    "from": 36,
    "label": "has",
    "to": 38
  }, {
    "from": 36,
    "label": "has",
    "to": 39
  }, {
    "from": 34,
    "label": "has",
    "to": 40
  }, {
    "from": 40,
    "label": "has",
    "to": 41
  }, {
    "from": 34,
    "label": "has",
    "to": 42
  }, {
    "from": 42,
    "label": "has",
    "to": 43
  }, {
    "from": 43,
    "label": "has",
    "to": 44
  }, {
    "from": 43,
    "label": "has",
    "to": 45
  }, {
    "from": 42,
    "label": "has",
    "to": 46
  }, {
    "from": 42,
    "label": "has",
    "to": 47
  }, {
    "from": 42,
    "label": "has",
    "to": 45
  }, {
    "from": 42,
    "label": "has",
    "to": 45
  }, {
    "from": 34,
    "label": "has",
    "to": 48
  }, {
    "from": 34,
    "label": "has",
    "to": 49
  }, {
    "from": 21,
    "label": "has",
    "to": 19
  }, {
    "from": 21,
    "label": "has",
    "to": 19
  }, {
    "from": 21,
    "label": "has",
    "to": 19
  }, {
    "from": 21,
    "label": "has",
    "to": 19
  }, {
    "from": 21,
    "label": "has",
    "to": 19
  }, {
    "from": 21,
    "label": "has",
    "to": 19
  }, {
    "from": 21,
    "label": "has",
    "to": 19
  }, {
    "from": 21,
    "label": "has",
    "to": 50
  }, {
    "from": 51,
    "label": "has",
    "to": 52
  }, {
    "from": 51,
    "label": "has",
    "to": 19
  }, {
    "from": 51,
    "label": "has",
    "to": 53
  }, {
    "from": 51,
    "label": "has",
    "to": 54
  }, {
    "from": 51,
    "label": "has",
    "to": 55
  }, {
    "from": 51,
    "label": "has",
    "to": 19
  }, {
    "from": 51,
    "label": "has",
    "to": 19
  }, {
    "from": 51,
    "label": "has",
    "to": 56
  }, {
    "from": 57,
    "label": "has",
    "to": 52
  }, {
    "from": 57,
    "label": "has",
    "to": 19
  }, {
    "from": 57,
    "label": "has",
    "to": 58
  }, {
    "from": 57,
    "label": "has",
    "to": 39
  }, {
    "from": 57,
    "label": "has",
    "to": 59
  }, {
    "from": 57,
    "label": "has",
    "to": 60
  }, {
    "from": 57,
    "label": "has",
    "to": 61
  }, {
    "from": 57,
    "label": "has",
    "to": 62
  }, {
    "from": 57,
    "label": "has",
    "to": 63
  }, {
    "from": 63,
    "label": "has",
    "to": 64
  }, {
    "from": 63,
    "label": "has",
    "to": 65
  }, {
    "from": 63,
    "label": "has",
    "to": 66
  }, {
    "from": 66,
    "label": "has",
    "to": 67
  }, {
    "from": 66,
    "label": "has",
    "to": 68
  }, {
    "from": 57,
    "label": "has",
    "to": 69
  }, {
    "from": 57,
    "label": "has",
    "to": 70
  }, {
    "from": 70,
    "label": "has",
    "to": 18
  }, {
    "from": 57,
    "label": "has",
    "to": 16
  }, {
    "from": 57,
    "label": "has",
    "to": 19
  }, {
    "from": 57,
    "label": "has",
    "to": 71
  }, {
    "from": 72,
    "label": "has",
    "to": 73
  }, {
    "from": 72,
    "label": "has",
    "to": 19
  }, {
    "from": 72,
    "label": "has",
    "to": 74
  }, {
    "from": 72,
    "label": "has",
    "to": 75
  }, {
    "from": 72,
    "label": "has",
    "to": 19
  }, {
    "from": 72,
    "label": "has",
    "to": 76
  }, {
    "from": 72,
    "label": "has",
    "to": 77
  }, {
    "from": 72,
    "label": "has",
    "to": 19
  }, {
    "from": 72,
    "label": "has",
    "to": 78
  }, {
    "from": 72,
    "label": "has",
    "to": 79
  }, {
    "from": 72,
    "label": "has",
    "to": 80
  }, {
    "from": 72,
    "label": "has",
    "to": 81
  }, {
    "from": 72,
    "label": "has",
    "to": 19
  }, {
    "from": 72,
    "label": "has",
    "to": 82
  }, {
    "from": 72,
    "label": "has",
    "to": 83
  }, {
    "from": 83,
    "label": "has",
    "to": 84
  }, {
    "from": 83,
    "label": "has",
    "to": 85
  }, {
    "from": 83,
    "label": "has",
    "to": 86
  }, {
    "from": 72,
    "label": "has",
    "to": 19
  }, {
    "from": 72,
    "label": "has",
    "to": 87
  }, {
    "from": 72,
    "label": "has",
    "to": 88
  }, {
    "from": 72,
    "label": "has",
    "to": 89
  }, {
    "from": 72,
    "label": "has",
    "to": 90
  }, {
    "from": 90,
    "label": "has",
    "to": 91
  }, {
    "from": 72,
    "label": "has",
    "to": 19
  }, {
    "from": 72,
    "label": "has",
    "to": 92
  }, {
    "from": 72,
    "label": "has",
    "to": 19
  }, {
    "from": 72,
    "label": "has",
    "to": 93
  }, {
    "from": 94,
    "label": "has",
    "to": 95
  }, {
    "from": 94,
    "label": "has",
    "to": 96
  }, {
    "from": 94,
    "label": "has",
    "to": 97
  }, {
    "from": 94,
    "label": "has",
    "to": 98
  }, {
    "from": 94,
    "label": "has",
    "to": 99
  }, {
    "from": 94,
    "label": "has",
    "to": 100
  }, {
    "from": 94,
    "label": "has",
    "to": 101
  }, {
    "from": 94,
    "label": "has",
    "to": 19
  }, {
    "from": 94,
    "label": "has",
    "to": 102
  }, {
    "from": 103,
    "label": "calls",
    "to": 10
  }, {
    "from": 103,
    "label": "calls",
    "to": 10
  }, {
    "from": 103,
    "label": "calls",
    "to": 109
  }, {
    "from": 103,
    "label": "calls",
    "to": 106
  }, {
    "from": 103,
    "label": "calls",
    "to": 106
  }, {
    "from": 103,
    "label": "calls",
    "to": 106
  }, {
    "from": 103,
    "label": "calls",
    "to": 106
  }, {
    "from": 103,
    "label": "calls",
    "to": 111
  }, {
    "from": 103,
    "label": "calls",
    "to": 111
  }, {
    "from": 103,
    "label": "calls",
    "to": 104
  }, {
    "from": 103,
    "label": "calls",
    "to": 7
  }, {
    "from": 103,
    "label": "calls",
    "to": 7
  }, {
    "from": 103,
    "label": "calls",
    "to": 7
  }, {
    "from": 103,
    "label": "calls",
    "to": 12
  }, {
    "from": 103,
    "label": "calls",
    "to": 15
  }, {
    "from": 103,
    "label": "calls",
    "to": 15
  }, {
    "from": 103,
    "label": "calls",
    "to": 15
  }, {
    "from": 103,
    "label": "calls",
    "to": 8
  }, {
    "from": 103,
    "label": "calls",
    "to": 107
  }, {
    "from": 103,
    "label": "calls",
    "to": 9
  }, {
    "from": 103,
    "label": "calls",
    "to": 9
  }, {
    "from": 103,
    "label": "calls",
    "to": 13
  }, {
    "from": 103,
    "label": "calls",
    "to": 11
  }, {
    "from": 103,
    "label": "calls",
    "to": 108
  }, {
    "from": 103,
    "label": "calls",
    "to": 110
  }, {
    "from": 103,
    "label": "calls",
    "to": 110
  }, {
    "from": 103,
    "label": "calls",
    "to": 110
  }, {
    "from": 103,
    "label": "calls",
    "to": 112
  }, {
    "from": 103,
    "label": "calls",
    "to": 112
  }, {
    "from": 103,
    "label": "calls",
    "to": 112
  }, {
    "from": 103,
    "label": "calls",
    "to": 105
  }, {
    "from": 3,
    "label": "contains",
    "to": 103
  }, {
    "from": 103,
    "label": "declares",
    "to": 15
  }, {
    "from": 103,
    "label": "declares",
    "to": 21
  }, {
    "from": 103,
    "label": "declares",
    "to": 51
  }, {
    "from": 103,
    "label": "declares",
    "to": 57
  }, {
    "from": 103,
    "label": "declares",
    "to": 72
  }, {
    "from": 103,
    "label": "declares",
    "to": 94
  }, {
    "from": 113,
    "label": "requires",
    "to": 3
  }, {
    "from": 114,
    "label": "requires",
    "to": 3
  }, {
    "from": 115,
    "label": "requires",
    "to": 3
  }, {
    "from": 3,
    "label": "contains",
    "to": 116
  }, {
    "from": 3,
    "label": "contains",
    "to": 117
  }, {
    "from": 116,
    "label": "initializes",
    "to": 118
  }, {
    "from": 118,
    "label": "assigns",
    "to": 119
  }, {
    "from": 116,
    "label": "initializes",
    "to": 120
  }, {
    "from": 120,
    "label": "assigns",
    "to": 121
  }, {
    "from": 116,
    "label": "initializes",
    "to": 122
  }, {
    "from": 122,
    "label": "assigns",
    "to": 123
  }, {
    "from": 116,
    "label": "initializes",
    "to": 124
  }, {
    "from": 124,
    "label": "assigns",
    "to": 125
  }, {
    "from": 116,
    "label": "initializes",
    "to": 126
  }, {
    "from": 126,
    "label": "assigns",
    "to": 127
  }, {
    "from": 116,
    "label": "initializes",
    "to": 128
  }, {
    "from": 128,
    "label": "assigns",
    "to": 129
  }, {
    "from": 116,
    "label": "initializes",
    "to": 130
  }, {
    "from": 130,
    "label": "assigns",
    "to": 131
  }, {
    "from": 117,
    "label": "initializes",
    "to": 132
  }, {
    "from": 132,
    "label": "requires",
    "to": 1
  }, {
    "from": 117,
    "label": "initializes",
    "to": 133
  }, {
    "from": 133,
    "label": "requires",
    "to": 2
  }, {
    "from": 117,
    "label": "initializes",
    "to": 134
  }, {
    "from": 134,
    "label": "requires",
    "to": 4
  }, {
    "from": 3,
    "label": "provides",
    "to": 135
  }, {
    "from": 130,
    "label": "represents",
    "to": 136
  }, {
    "from": 135,
    "label": "provides",
    "to": 136
  } ],
  "nodes": [ {
    "id": 0,
    "text": "",
    "type": "file"
  }, {
    "id": 1,
    "text": "frame",
    "type": "module"
  }, {
    "id": 2,
    "text": "handshake",
    "type": "module"
  }, {
    "id": 3,
    "text": "sync",
    "type": "module"
  }, {
    "id": 4,
    "text": "tools",
    "type": "module"
  }, {
    "id": 5,
    "text": "",
    "type": "function container"
  }, {
    "id": 6,
    "text": "",
    "type": "function container"
  }, {
    "id": 7,
    "text": "function(data,opcode,masked,fin)\r\n  local encoded\r\n  local header = opcode or 1-- TEXT is default opcode\r\n  if fin == nil or fin == true then\r\n    header = bor(header,bit_7)\r\n  end\r\n  local payload = 0\r\n  if masked then\r\n    payload = bor(payload,bit_7)\r\n  end\r\n  local len = #data\r\n  if len < 126 then\r\n    payload = bor(payload,len)\r\n    encoded = spack('bb',header,payload)\r\n  elseif len < 0xffff then\r\n    payload = bor(payload,126)\r\n    encoded = spack('bb>H',header,payload,len)\r\n  elseif len < 2^53 then\r\n    local high = math.floor(len/2^32)\r\n    local low = len - high*2^32\r\n    payload = bor(payload,127)\r\n    encoded = spack('bb>I>I',header,payload,high,low)\r\n  end\r\n  if not masked then\r\n    encoded = encoded..data\r\n  else\r\n    local m1 = math.random(0,0xff)\r\n    local m2 = math.random(0,0xff)\r\n    local m3 = math.random(0,0xff)\r\n    local m4 = math.random(0,0xff)\r\n    local mask = {m1,m2,m3,m4}\r\n    encoded = encoded..spack('bbbb',m1,m2,m3,m4)\r\n    encoded = encoded..xor_mask(data,mask,#data)\r\n  end\r\n  return encoded\r\nend",
    "type": "function"
  }, {
    "id": 8,
    "text": "function(encoded)\r\n  local encoded_bak = encoded\r\n  if #encoded < 2 then\r\n    return nil,2\r\n  end\r\n  local pos,header,payload = sunpack(encoded,'bb')\r\n  encoded = ssub(encoded,pos)\r\n  local bytes = 2\r\n  local fin = band(header,bit_7) > 0\r\n  local opcode = band(header,bit_0_3)\r\n  local mask = band(payload,bit_7) > 0\r\n  payload = band(payload,bit_0_6)\r\n  if payload > 125 then\r\n    if payload == 126 then\r\n      if #encoded < 2 then\r\n        return nil,2\r\n      end\r\n      pos,payload = sunpack(encoded,'>H')\r\n    elseif payload == 127 then\r\n      if #encoded < 8 then\r\n        return nil,8\r\n      end\r\n      pos,high,low = sunpack(encoded,'>I>I')\r\n      payload = high*2^32 + low\r\n      if payload < 0xffff or payload > 2^53 then\r\n        assert(false,'INVALID PAYLOAD '..payload)\r\n      end\r\n    else\r\n      assert(false,'INVALID PAYLOAD '..payload)\r\n    end\r\n    encoded = ssub(encoded,pos)\r\n    bytes = bytes + pos - 1\r\n  end\r\n  local decoded\r\n  if mask then\r\n    local bytes_short = payload + 4 - #encoded\r\n    if bytes_short > 0 then\r\n      return nil,bytes_short\r\n    end\r\n    local pos,m1,m2,m3,m4 = sunpack(encoded,'bbbb')\r\n    encoded = ssub(encoded,pos)\r\n    local mask = {\r\n      m1,m2,m3,m4\r\n    }\r\n    decoded = xor_mask(encoded,mask,payload)\r\n    bytes = bytes + 4 + payload\r\n  else\r\n    local bytes_short = payload - #encoded\r\n    if bytes_short > 0 then\r\n      return nil,bytes_short\r\n    end\r\n    if #encoded > payload then\r\n      decoded = ssub(encoded,1,payload)\r\n    else\r\n      decoded = encoded\r\n    end\r\n    bytes = bytes + payload\r\n  end\r\n  return decoded,fin,opcode,encoded_bak:sub(bytes+1),mask\r\nend",
    "type": "function"
  }, {
    "id": 9,
    "text": "function(code,reason)\r\n  if code then\r\n    data = spack('>H',code)\r\n    if reason then\r\n      data = data..tostring(reason)\r\n    end\r\n    return data\r\n  end\r\n  return ''\r\nend",
    "type": "function"
  }, {
    "id": 10,
    "text": "function(data)\r\n  local _,code,reason\r\n  if data then\r\n    if #data > 1 then\r\n      _,code = sunpack(data,'>H')\r\n    end\r\n    if #data > 2 then\r\n      reason = data:sub(3)\r\n    end\r\n  end\r\n  return code,reason\r\nend",
    "type": "function"
  }, {
    "id": 11,
    "text": "function(sec_websocket_key)\r\n  local a = sec_websocket_key..guid\r\n  local sha1 = sha1(a)\r\n  assert((#sha1 % 2) == 0)\r\n  return base64.encode(sha1)\r\nend",
    "type": "function"
  }, {
    "id": 12,
    "text": "function(request)\r\n  local headers = {}\r\n  if not request:match('.*HTTP/1%.1') then\r\n    return\r\n  end\r\n  request = request:match('[^\\r\\n]+\\r\\n(.*)')\r\n  local empty_line\r\n  for line in request:gmatch('[^\\r\\n]*\\r\\n') do\r\n    local name,val = line:match('([^%s]+)%s*:%s*([^\\r\\n]+)')\r\n    if name and val then\r\n      name = name:lower()\r\n      if not name:match('sec%-websocket') then\r\n        val = val:lower()\r\n      end\r\n      if not headers[name] then\r\n        headers[name] = val\r\n      else\r\n        headers[name] = headers[name]..','..val\r\n      end\r\n    elseif line == '\\r\\n' then\r\n      empty_line = true\r\n    else\r\n      assert(false,line..'('..#line..')')\r\n    end\r\n  end\r\n  return headers,request:match('\\r\\n\\r\\n(.*)')\r\nend",
    "type": "function"
  }, {
    "id": 13,
    "text": "function(req)\r\n  local format = string.format\r\n  local lines = {\r\n    format('GET %s HTTP/1.1',req.uri or ''),\r\n    format('Host: %s',req.host),\r\n    'Upgrade: websocket',\r\n    'Connection: Upgrade',\r\n    format('Sec-WebSocket-Key: %s',req.key),\r\n    format('Sec-WebSocket-Protocol: %s',table.concat(req.protocols,', ')),\r\n    'Sec-WebSocket-Version: 13',\r\n  }\r\n  if req.origin then\r\n    tinsert(lines,string.format('Origin: %s',req.origin))\r\n  end\r\n  if req.port and req.port ~= 80 then\r\n    lines[2] = format('Host: %s:%d',req.host,req.port)\r\n  end\r\n  tinsert(lines,'\\r\\n')\r\n  return table.concat(lines,'\\r\\n')\r\nend",
    "type": "function"
  }, {
    "id": 14,
    "text": "",
    "type": "function container"
  }, {
    "id": 15,
    "text": "function(was_clean,code,reason)\r\n    self.state = 'CLOSED'\r\n    if self.on_close then\r\n      self:on_close()\r\n    end\r\n    return nil,'closed',was_clean,code,reason or ''\r\n  end",
    "type": "function"
  }, {
    "id": 16,
    "text": "self.state = 'CLOSED'",
    "type": "statement:assign"
  }, {
    "id": 17,
    "text": "if self.on_close then\r\n      self:on_close()\r\n    end",
    "type": "statement:if"
  }, {
    "id": 18,
    "text": "self:on_close()",
    "type": "statement:functioncall"
  }, {
    "id": 19,
    "text": "return",
    "type": "statement:keyword"
  }, {
    "id": 20,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 21,
    "text": "function(self)\r\n  if self.state ~= 'OPEN' and not self.is_closing then\r\n    return nil,'wrong state'\r\n  end\r\n  local first_opcode\r\n  local frames\r\n  local bytes = 3\r\n  local encoded = ''\r\n  local clean = function(was_clean,code,reason)\r\n    self.state = 'CLOSED'\r\n    if self.on_close then\r\n      self:on_close()\r\n    end\r\n    return nil,'closed',was_clean,code,reason or ''\r\n  end\r\n  while true do\r\n    local chunk,err = self:sock_receive(bytes)\r\n    if err then\r\n      return clean(err)\r\n    end\r\n    encoded = encoded..chunk\r\n    local decoded,fin,opcode,_,masked = frame.decode(encoded)\r\n    if not self.is_server and masked then\r\n      return clean(false,1006,'Websocket receive failed: frame was not masked')\r\n    end\r\n    if decoded then\r\n      if opcode == frame.CLOSE then\r\n        if not self.is_closing then\r\n          local code,reason = frame.decode_close(decoded)\r\n          -- echo code\r\n          local msg = frame.encode_close(code)\r\n          local encoded = frame.encode(msg,frame.CLOSE,not self.is_server)\r\n          return clean(true,code,reason)\r\n        else\r\n          return decoded,opcode\r\n        end\r\n      end\r\n      if not first_opcode then\r\n        first_opcode = opcode\r\n      end\r\n      if not fin then\r\n        if not frames then\r\n          frames = {}\r\n        elseif opcode ~= frame.CONTINUATION then\r\n          tinsert(frames,decoded)\r\n          return nil,'protocol',tconcat(frames),first_opcode,opcode\r\n        end\r\n        bytes = 3\r\n        encoded = ''\r\n        tinsert(frames,decoded)\r\n      elseif not frames then\r\n        return decoded,first_opcode\r\n      else\r\n        tinsert(frames,decoded)\r\n        return tconcat(frames),first_opcode\r\n      end\r\n    else\r\n      assert(type(fin) == 'number' and fin > 0)\r\n      bytes = fin\r\n    end\r\n  end\r\nend",
    "type": "function"
  }, {
    "id": 22,
    "text": "if self.state ~= 'OPEN' and not self.is_closing then\r\n    return nil,'wrong state'\r\n  end",
    "type": "statement:if"
  }, {
    "id": 23,
    "text": "local first_opcode",
    "type": "statement:localassign"
  }, {
    "id": 24,
    "text": "local frames",
    "type": "statement:localassign"
  }, {
    "id": 25,
    "text": "local bytes = 3",
    "type": "statement:localassign"
  }, {
    "id": 26,
    "text": "local encoded = ''",
    "type": "statement:localassign"
  }, {
    "id": 27,
    "text": "local clean = function(was_clean,code,reason)\r\n    self.state = 'CLOSED'\r\n    if self.on_close then\r\n      self:on_close()\r\n    end\r\n    return nil,'closed',was_clean,code,reason or ''\r\n  end",
    "type": "statement:localassign"
  }, {
    "id": 28,
    "text": "while true do\r\n    local chunk,err = self:sock_receive(bytes)\r\n    if err then\r\n      return clean(err)\r\n    end\r\n    encoded = encoded..chunk\r\n    local decoded,fin,opcode,_,masked = frame.decode(encoded)\r\n    if not self.is_server and masked then\r\n      return clean(false,1006,'Websocket receive failed: frame was not masked')\r\n    end\r\n    if decoded then\r\n      if opcode == frame.CLOSE then\r\n        if not self.is_closing then\r\n          local code,reason = frame.decode_close(decoded)\r\n          -- echo code\r\n          local msg = frame.encode_close(code)\r\n          local encoded = frame.encode(msg,frame.CLOSE,not self.is_server)\r\n          return clean(true,code,reason)\r\n        else\r\n          return decoded,opcode\r\n        end\r\n      end\r\n      if not first_opcode then\r\n        first_opcode = opcode\r\n      end\r\n      if not fin then\r\n        if not frames then\r\n          frames = {}\r\n        elseif opcode ~= frame.CONTINUATION then\r\n          tinsert(frames,decoded)\r\n          return nil,'protocol',tconcat(frames),first_opcode,opcode\r\n        end\r\n        bytes = 3\r\n        encoded = ''\r\n        tinsert(frames,decoded)\r\n      elseif not frames then\r\n        return decoded,first_opcode\r\n      else\r\n        tinsert(frames,decoded)\r\n        return tconcat(frames),first_opcode\r\n      end\r\n    else\r\n      assert(type(fin) == 'number' and fin > 0)\r\n      bytes = fin\r\n    end\r\n  end",
    "type": "statement:while"
  }, {
    "id": 29,
    "text": "local chunk,err = self:sock_receive(bytes)",
    "type": "statement:localassign"
  }, {
    "id": 30,
    "text": "if err then\r\n      return clean(err)\r\n    end",
    "type": "statement:if"
  }, {
    "id": 31,
    "text": "encoded = encoded..chunk",
    "type": "statement:assign"
  }, {
    "id": 32,
    "text": "local decoded,fin,opcode,_,masked = frame.decode(encoded)",
    "type": "statement:localassign"
  }, {
    "id": 33,
    "text": "if not self.is_server and masked then\r\n      return clean(false,1006,'Websocket receive failed: frame was not masked')\r\n    end",
    "type": "statement:if"
  }, {
    "id": 34,
    "text": "if decoded then\r\n      if opcode == frame.CLOSE then\r\n        if not self.is_closing then\r\n          local code,reason = frame.decode_close(decoded)\r\n          -- echo code\r\n          local msg = frame.encode_close(code)\r\n          local encoded = frame.encode(msg,frame.CLOSE,not self.is_server)\r\n          return clean(true,code,reason)\r\n        else\r\n          return decoded,opcode\r\n        end\r\n      end\r\n      if not first_opcode then\r\n        first_opcode = opcode\r\n      end\r\n      if not fin then\r\n        if not frames then\r\n          frames = {}\r\n        elseif opcode ~= frame.CONTINUATION then\r\n          tinsert(frames,decoded)\r\n          return nil,'protocol',tconcat(frames),first_opcode,opcode\r\n        end\r\n        bytes = 3\r\n        encoded = ''\r\n        tinsert(frames,decoded)\r\n      elseif not frames then\r\n        return decoded,first_opcode\r\n      else\r\n        tinsert(frames,decoded)\r\n        return tconcat(frames),first_opcode\r\n      end\r\n    else\r\n      assert(type(fin) == 'number' and fin > 0)\r\n      bytes = fin\r\n    end",
    "type": "statement:if"
  }, {
    "id": 35,
    "text": "if opcode == frame.CLOSE then\r\n        if not self.is_closing then\r\n          local code,reason = frame.decode_close(decoded)\r\n          -- echo code\r\n          local msg = frame.encode_close(code)\r\n          local encoded = frame.encode(msg,frame.CLOSE,not self.is_server)\r\n          return clean(true,code,reason)\r\n        else\r\n          return decoded,opcode\r\n        end\r\n      end",
    "type": "statement:if"
  }, {
    "id": 36,
    "text": "if not self.is_closing then\r\n          local code,reason = frame.decode_close(decoded)\r\n          -- echo code\r\n          local msg = frame.encode_close(code)\r\n          local encoded = frame.encode(msg,frame.CLOSE,not self.is_server)\r\n          return clean(true,code,reason)\r\n        else\r\n          return decoded,opcode\r\n        end",
    "type": "statement:if"
  }, {
    "id": 37,
    "text": "local code,reason = frame.decode_close(decoded)",
    "type": "statement:localassign"
  }, {
    "id": 38,
    "text": "local msg = frame.encode_close(code)",
    "type": "statement:localassign"
  }, {
    "id": 39,
    "text": "local encoded = frame.encode(msg,frame.CLOSE,not self.is_server)",
    "type": "statement:localassign"
  }, {
    "id": 40,
    "text": "if not first_opcode then\r\n        first_opcode = opcode\r\n      end",
    "type": "statement:if"
  }, {
    "id": 41,
    "text": "first_opcode = opcode",
    "type": "statement:assign"
  }, {
    "id": 42,
    "text": "if not fin then\r\n        if not frames then\r\n          frames = {}\r\n        elseif opcode ~= frame.CONTINUATION then\r\n          tinsert(frames,decoded)\r\n          return nil,'protocol',tconcat(frames),first_opcode,opcode\r\n        end\r\n        bytes = 3\r\n        encoded = ''\r\n        tinsert(frames,decoded)\r\n      elseif not frames then\r\n        return decoded,first_opcode\r\n      else\r\n        tinsert(frames,decoded)\r\n        return tconcat(frames),first_opcode\r\n      end",
    "type": "statement:if"
  }, {
    "id": 43,
    "text": "if not frames then\r\n          frames = {}\r\n        elseif opcode ~= frame.CONTINUATION then\r\n          tinsert(frames,decoded)\r\n          return nil,'protocol',tconcat(frames),first_opcode,opcode\r\n        end",
    "type": "statement:if"
  }, {
    "id": 44,
    "text": "frames = {}",
    "type": "statement:assign"
  }, {
    "id": 45,
    "text": "tinsert(frames,decoded)",
    "type": "statement:functioncall"
  }, {
    "id": 46,
    "text": "bytes = 3",
    "type": "statement:assign"
  }, {
    "id": 47,
    "text": "encoded = ''",
    "type": "statement:assign"
  }, {
    "id": 48,
    "text": "assert(type(fin) == 'number' and fin > 0)",
    "type": "statement:functioncall"
  }, {
    "id": 49,
    "text": "bytes = fin",
    "type": "statement:assign"
  }, {
    "id": 50,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 51,
    "text": "function(self,data,opcode)\r\n  if self.state ~= 'OPEN' then\r\n    return nil,'wrong state'\r\n  end\r\n  local encoded = frame.encode(data,opcode or frame.TEXT,not self.is_server)\r\n  local n,err = self:sock_send(encoded)\r\n  if n ~= #encoded then\r\n    return nil,err\r\n  end\r\n  return true\r\nend",
    "type": "function"
  }, {
    "id": 52,
    "text": "if self.state ~= 'OPEN' then\r\n    return nil,'wrong state'\r\n  end",
    "type": "statement:if"
  }, {
    "id": 53,
    "text": "local encoded = frame.encode(data,opcode or frame.TEXT,not self.is_server)",
    "type": "statement:localassign"
  }, {
    "id": 54,
    "text": "local n,err = self:sock_send(encoded)",
    "type": "statement:localassign"
  }, {
    "id": 55,
    "text": "if n ~= #encoded then\r\n    return nil,err\r\n  end",
    "type": "statement:if"
  }, {
    "id": 56,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 57,
    "text": "function(self,code,reason)\r\n  if self.state ~= 'OPEN' then\r\n    return nil,'wrong state'\r\n  end\r\n  local msg = frame.encode_close(code or 1000,reason)\r\n  local encoded = frame.encode(msg,frame.CLOSE,not self.is_server)\r\n  local n = self:sock_send(encoded)\r\n  local was_clean = false\r\n  local code = 1006\r\n  local reason = ''\r\n  if n == #encoded then\r\n    self.is_closing = true\r\n    local ok,rmsg,opcode = pcall(self.receive,self)\r\n    if ok and opcode == frame.CLOSE then\r\n      code,reason = frame.decode_close(rmsg)\r\n      was_clean = true\r\n    end\r\n  end\r\n  self:sock_close()\r\n  if self.on_close then\r\n    self:on_close()\r\n  end\r\n  self.state = 'CLOSED'\r\n  return was_clean,code,reason or ''\r\nend",
    "type": "function"
  }, {
    "id": 58,
    "text": "local msg = frame.encode_close(code or 1000,reason)",
    "type": "statement:localassign"
  }, {
    "id": 59,
    "text": "local n = self:sock_send(encoded)",
    "type": "statement:localassign"
  }, {
    "id": 60,
    "text": "local was_clean = false",
    "type": "statement:localassign"
  }, {
    "id": 61,
    "text": "local code = 1006",
    "type": "statement:localassign"
  }, {
    "id": 62,
    "text": "local reason = ''",
    "type": "statement:localassign"
  }, {
    "id": 63,
    "text": "if n == #encoded then\r\n    self.is_closing = true\r\n    local ok,rmsg,opcode = pcall(self.receive,self)\r\n    if ok and opcode == frame.CLOSE then\r\n      code,reason = frame.decode_close(rmsg)\r\n      was_clean = true\r\n    end\r\n  end",
    "type": "statement:if"
  }, {
    "id": 64,
    "text": "self.is_closing = true",
    "type": "statement:assign"
  }, {
    "id": 65,
    "text": "local ok,rmsg,opcode = pcall(self.receive,self)",
    "type": "statement:localassign"
  }, {
    "id": 66,
    "text": "if ok and opcode == frame.CLOSE then\r\n      code,reason = frame.decode_close(rmsg)\r\n      was_clean = true\r\n    end",
    "type": "statement:if"
  }, {
    "id": 67,
    "text": "code,reason = frame.decode_close(rmsg)",
    "type": "statement:assign"
  }, {
    "id": 68,
    "text": "was_clean = true",
    "type": "statement:assign"
  }, {
    "id": 69,
    "text": "self:sock_close()",
    "type": "statement:functioncall"
  }, {
    "id": 70,
    "text": "if self.on_close then\r\n    self:on_close()\r\n  end",
    "type": "statement:if"
  }, {
    "id": 71,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 72,
    "text": "function(self,ws_url,ws_protocol)\r\n  if self.state ~= 'CLOSED' then\r\n    return nil,'wrong state'\r\n  end\r\n  local protocol,host,port,uri = tools.parse_url(ws_url)\r\n  if protocol ~= 'ws' then\r\n    return nil,'bad protocol'\r\n  end\r\n  local _,err = self:sock_connect(host,port)\r\n  if err then\r\n    return nil,err\r\n  end\r\n  local key = tools.generate_key()\r\n  local req = handshake.upgrade_request\r\n  {\r\n    key = key,\r\n    host = host,\r\n    port = port,\r\n    protocols = {ws_protocol or ''},\r\n    origin = origin,\r\n    uri = uri\r\n  }\r\n  local n,err = self:sock_send(req)\r\n  if n ~= #req then\r\n    return nil,err\r\n  end\r\n  local resp = {}\r\n  repeat\r\n    local line,err = self:sock_receive('*l')\r\n    resp[#resp+1] = line\r\n    if err then\r\n      return nil,err\r\n    end\r\n  until line == ''\r\n  local response = table.concat(resp,'\\r\\n')\r\n  local headers = handshake.http_headers(response)\r\n  local expected_accept = handshake.sec_websocket_accept(key)\r\n  if headers['sec-websocket-accept'] ~= expected_accept then\r\n    local msg = 'Websocket Handshake failed: Invalid Sec-Websocket-Accept (expected %s got %s)'\r\n    return nil,msg:format(expected_accept,headers['sec-websocket-accept'] or 'nil')\r\n  end\r\n  self.state = 'OPEN'\r\n  return true\r\nend",
    "type": "function"
  }, {
    "id": 73,
    "text": "if self.state ~= 'CLOSED' then\r\n    return nil,'wrong state'\r\n  end",
    "type": "statement:if"
  }, {
    "id": 74,
    "text": "local protocol,host,port,uri = tools.parse_url(ws_url)",
    "type": "statement:localassign"
  }, {
    "id": 75,
    "text": "if protocol ~= 'ws' then\r\n    return nil,'bad protocol'\r\n  end",
    "type": "statement:if"
  }, {
    "id": 76,
    "text": "local _,err = self:sock_connect(host,port)",
    "type": "statement:localassign"
  }, {
    "id": 77,
    "text": "if err then\r\n    return nil,err\r\n  end",
    "type": "statement:if"
  }, {
    "id": 78,
    "text": "local key = tools.generate_key()",
    "type": "statement:localassign"
  }, {
    "id": 79,
    "text": "local req = handshake.upgrade_request\r\n  {\r\n    key = key,\r\n    host = host,\r\n    port = port,\r\n    protocols = {ws_protocol or ''},\r\n    origin = origin,\r\n    uri = uri\r\n  }",
    "type": "statement:localassign"
  }, {
    "id": 80,
    "text": "local n,err = self:sock_send(req)",
    "type": "statement:localassign"
  }, {
    "id": 81,
    "text": "if n ~= #req then\r\n    return nil,err\r\n  end",
    "type": "statement:if"
  }, {
    "id": 82,
    "text": "local resp = {}",
    "type": "statement:localassign"
  }, {
    "id": 83,
    "text": "repeat\r\n    local line,err = self:sock_receive('*l')\r\n    resp[#resp+1] = line\r\n    if err then\r\n      return nil,err\r\n    end\r\n  until line == ''",
    "type": "statement:repeat"
  }, {
    "id": 84,
    "text": "local line,err = self:sock_receive('*l')",
    "type": "statement:localassign"
  }, {
    "id": 85,
    "text": "resp[#resp+1] = line",
    "type": "statement:assign"
  }, {
    "id": 86,
    "text": "if err then\r\n      return nil,err\r\n    end",
    "type": "statement:if"
  }, {
    "id": 87,
    "text": "local response = table.concat(resp,'\\r\\n')",
    "type": "statement:localassign"
  }, {
    "id": 88,
    "text": "local headers = handshake.http_headers(response)",
    "type": "statement:localassign"
  }, {
    "id": 89,
    "text": "local expected_accept = handshake.sec_websocket_accept(key)",
    "type": "statement:localassign"
  }, {
    "id": 90,
    "text": "if headers['sec-websocket-accept'] ~= expected_accept then\r\n    local msg = 'Websocket Handshake failed: Invalid Sec-Websocket-Accept (expected %s got %s)'\r\n    return nil,msg:format(expected_accept,headers['sec-websocket-accept'] or 'nil')\r\n  end",
    "type": "statement:if"
  }, {
    "id": 91,
    "text": "local msg = 'Websocket Handshake failed: Invalid Sec-Websocket-Accept (expected %s got %s)'",
    "type": "statement:localassign"
  }, {
    "id": 92,
    "text": "self.state = 'OPEN'",
    "type": "statement:assign"
  }, {
    "id": 93,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 94,
    "text": "function(obj)\r\n  assert(obj.sock_send)\r\n  assert(obj.sock_receive)\r\n  assert(obj.sock_close)\r\n  obj.receive = receive\r\n  obj.send = send\r\n  obj.close = close\r\n  obj.connect = connect\r\n  return obj\r\nend",
    "type": "function"
  }, {
    "id": 95,
    "text": "assert(obj.sock_send)",
    "type": "statement:functioncall"
  }, {
    "id": 96,
    "text": "assert(obj.sock_receive)",
    "type": "statement:functioncall"
  }, {
    "id": 97,
    "text": "assert(obj.sock_close)",
    "type": "statement:functioncall"
  }, {
    "id": 98,
    "text": "obj.receive = receive",
    "type": "statement:assign"
  }, {
    "id": 99,
    "text": "obj.send = send",
    "type": "statement:assign"
  }, {
    "id": 100,
    "text": "obj.close = close",
    "type": "statement:assign"
  }, {
    "id": 101,
    "text": "obj.connect = connect",
    "type": "statement:assign"
  }, {
    "id": 102,
    "text": "",
    "type": "blank lines"
  }, {
    "id": 103,
    "text": "",
    "type": "function container"
  }, {
    "id": 104,
    "text": "function(url)\r\n  local protocol,host = url:match('^(%w+)://([^:/]+)')\r\n  local port,uri = url:match('.+//[^:/]+:?(%d*)(.*)')\r\n  if port and port ~= '' then\r\n    port = tonumber(port)\r\n  elseif protocol == 'ws' then\r\n    port = 80\r\n  end\r\n  if not uri or uri == '' then\r\n    uri = '/'\r\n  end\r\n  if not protocol or not host or not port or not uri then\r\n    error('Invalid URL:'..url)\r\n  end\r\n  return protocol,host,port,uri\r\nend",
    "type": "function"
  }, {
    "id": 105,
    "text": "function()\r\n  local r1 = mrandom(0,0xfffffff)\r\n  local r2 = mrandom(0,0xfffffff)\r\n  local r3 = mrandom(0,0xfffffff)\r\n  local r4 = mrandom(0,0xfffffff)\r\n  local key = spack('IIII',r1,r2,r3,r4)\r\n  assert(#key==16,#key)\r\n  return base64_encode(key)\r\nend",
    "type": "function"
  }, {
    "id": 106,
    "text": "assert",
    "type": "global function"
  }, {
    "id": 107,
    "text": "pcall",
    "type": "global function"
  }, {
    "id": 108,
    "text": "type",
    "type": "global function"
  }, {
    "id": 109,
    "text": "concat",
    "type": "global function"
  }, {
    "id": 110,
    "text": "require",
    "type": "global function"
  }, {
    "id": 111,
    "text": "tconcat",
    "type": "global function"
  }, {
    "id": 112,
    "text": "tinsert",
    "type": "global function"
  }, {
    "id": 113,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 114,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 115,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 116,
    "text": "",
    "type": "variable container"
  }, {
    "id": 117,
    "text": "",
    "type": "require container"
  }, {
    "id": 118,
    "text": "",
    "type": "local variable"
  }, {
    "id": 119,
    "text": "",
    "type": "n/a"
  }, {
    "id": 120,
    "text": "",
    "type": "local variable"
  }, {
    "id": 121,
    "text": "",
    "type": "n/a"
  }, {
    "id": 122,
    "text": "",
    "type": "local variable"
  }, {
    "id": 123,
    "text": "",
    "type": "n/a"
  }, {
    "id": 124,
    "text": "",
    "type": "local variable"
  }, {
    "id": 125,
    "text": "",
    "type": "n/a"
  }, {
    "id": 126,
    "text": "",
    "type": "local variable"
  }, {
    "id": 127,
    "text": "",
    "type": "n/a"
  }, {
    "id": 128,
    "text": "",
    "type": "local variable"
  }, {
    "id": 129,
    "text": "",
    "type": "n/a"
  }, {
    "id": 130,
    "text": "",
    "type": "local variable"
  }, {
    "id": 131,
    "text": "",
    "type": "n/a"
  }, {
    "id": 132,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 133,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 134,
    "text": "",
    "type": "require local variable"
  }, {
    "id": 135,
    "text": "",
    "type": "interface container"
  }, {
    "id": 136,
    "text": "",
    "type": "interface"
  } ]
}